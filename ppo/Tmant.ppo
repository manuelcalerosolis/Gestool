#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 16 ".\Prg\Tmant.prg"
_HB_CLASS TMant ; UTILITY FUNCTION TMant(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TMant" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { nLevel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nLevel" }, .F., .F. ), )

   _HB_MEMBER { cPath} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPath" }, .F., .F. ), )
   _HB_MEMBER { cMru} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cMru" }, .F., .F. ), )

   _HB_MEMBER { aGet} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aGet" }, .F., .F. ), )

   _HB_MEMBER { oDbf} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDbf" }, .F., .F. ), )
   _HB_MEMBER { oDbfDet} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDbfDet" }, .F., .F. ), )

   _HB_MEMBER { oDbfDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDbfDiv" }, .F., .F. ), )

   _HB_MEMBER { oDbfFilter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDbfFilter" }, .F., .F. ), )

   _HB_MEMBER { oBmpDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBmpDiv" }, .F., .F. ), )

   _HB_MEMBER { oBuscar} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBuscar" }, .F., .F. ), )
   _HB_MEMBER { oBandera} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBandera" }, .F., .F. ), )

   _HB_MEMBER { oWndParent} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oWndParent" }, .F., .F. ), )
   _HB_MEMBER { oWndBrw} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oWndBrw" }, .F., .F. ), )

   _HB_MEMBER { oReport} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oReport" }, .F., .F. ), )

   _HB_MEMBER { cFirstKey} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFirstKey" }, .F., .F. ), )
   _HB_MEMBER { bFirstKey} ; IIF( !.F., s_oClass:AddMultiData(, {|| .T. }, nScope + IIF( .F., 32, 0 ), { "bFirstKey" }, .F., .F. ), )

   _HB_MEMBER { cExpresion} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cExpresion" }, .F., .F. ), )

   _HB_MEMBER { lAutoButtons} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lAutoButtons" }, .F., .F. ), )
   _HB_MEMBER { lOpenFiles} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lOpenFiles" }, .F., .F. ), )

   _HB_MEMBER { lCreateShell} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lCreateShell" }, .F., .F. ), )
   _HB_MEMBER { lReport} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lReport" }, .F., .F. ), )

   _HB_MEMBER { cBitmap} ; IIF( !.F., s_oClass:AddMultiData(, "WebTopBlack", nScope + IIF( .F., 32, 0 ), { "cBitmap" }, .F., .F. ), )

   _HB_MEMBER { lAccess} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lAccess" }, .F., .F. ), )

   _HB_MEMBER { lMinimize} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lMinimize" }, .F., .F. ), )

   _HB_MEMBER { bOnPreAppend, bOnPostAppend} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreAppend" , "bOnPostAppend" }, .F., .F. ), )
   _HB_MEMBER { bOnPreEdit, bOnPostEdit} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreEdit" , "bOnPostEdit" }, .F., .F. ), )
   _HB_MEMBER { bOnPreDelete, bOnPostDelete} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreDelete" , "bOnPostDelete" }, .F., .F. ), )
   _HB_MEMBER { bOnPreSave, bOnPostSave} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreSave" , "bOnPostSave" }, .F., .F. ), )
   _HB_MEMBER { bOnPreLoad, bOnPostLoad} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreLoad" , "bOnPostLoad" }, .F., .F. ), )

   _HB_MEMBER { cHtmlHelp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cHtmlHelp" }, .F., .F. ), )

   _HB_MEMBER { cPicUnd} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPicUnd" }, .F., .F. ), )

   _HB_MEMBER { nSeconds} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nSeconds" }, .F., .F. ), )

   _HB_MEMBER { cPinDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPinDiv" }, .F., .F. ), )
   _HB_MEMBER { cPirDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPirDiv" }, .F., .F. ), )
   _HB_MEMBER { cPpvDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPpvDiv" }, .F., .F. ), )
   _HB_MEMBER { cPouDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPouDiv" }, .F., .F. ), )
   _HB_MEMBER { cPorDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPorDiv" }, .F., .F. ), )
   _HB_MEMBER { cPpvDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPpvDiv" }, .F., .F. ), )
   _HB_MEMBER { nDinDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDinDiv" }, .F., .F. ), )
   _HB_MEMBER { nDirDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDirDiv" }, .F., .F. ), )
   _HB_MEMBER { nDouDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDouDiv" }, .F., .F. ), )
   _HB_MEMBER { nDorDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDorDiv" }, .F., .F. ), )
   _HB_MEMBER { nDpvDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDpvDiv" }, .F., .F. ), )
   _HB_MEMBER { nVdvDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nVdvDiv" }, .F., .F. ), )
   _HB_MEMBER { nRouDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nRouDiv" }, .F., .F. ), )

   _HB_MEMBER { cTipoDocumento} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTipoDocumento" }, .F., .F. ), )

   _HB_MEMBER { lAppendBuscar} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lAppendBuscar" }, .F., .F. ), )
   _HB_MEMBER { lModificarBuscar} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lModificarBuscar" }, .F., .F. ), )

   _HB_MEMBER New( cPath, oWndParent, oMenuItem) AS CLASS TMant; IIF( .F., s_oClass:ModMethod( "New", @TMant_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TMant_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Create( cPath) AS CLASS TMant; IIF( .F., s_oClass:ModMethod( "Create", @TMant_Create(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Create", @TMant_Create(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Play( cPath, oWndParent, oMenuItem); IIF( .F., s_oClass:ModMethod( "Play", @TMant_Play(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Play", @TMant_Play(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER OpenFiles( ); IIF( !.F., s_oClass:AddVirtual( "OpenFiles" ), )
   _HB_MEMBER DefineFiles( ); IIF( !.F., s_oClass:AddVirtual( "DefineFiles" ), )
   _HB_MEMBER CheckFiles( cFileAppendFrom); IIF( .F., s_oClass:ModMethod( "CheckFiles", @TMant_CheckFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CheckFiles", @TMant_CheckFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Append(); IIF( .F., s_oClass:ModMethod( "Append", @TMant_Append(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Append", @TMant_Append(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Edit(); IIF( .F., s_oClass:ModMethod( "Edit", @TMant_Edit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Edit", @TMant_Edit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Zoom(); IIF( .F., s_oClass:ModMethod( "Zoom", @TMant_Zoom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Zoom", @TMant_Zoom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Del(); IIF( .F., s_oClass:ModMethod( "Del", @TMant_Del(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Del", @TMant_Del(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Dup(); IIF( .F., s_oClass:ModMethod( "Dup", @TMant_Dup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Dup", @TMant_Dup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Resources( ); IIF( !.F., s_oClass:AddVirtual( "Resources" ), )

   _HB_MEMBER CreateFiles( cPath, lAppend, cPathOld, oMeter); IIF( .F., s_oClass:ModMethod( "CreateFiles", @TMant_CreateFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateFiles", @TMant_CreateFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Reindexa(); IIF( .F., s_oClass:ModMethod( "Reindexa", @TMant_Reindexa(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Reindexa", @TMant_Reindexa(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Reindex( oMeter); IIF( .F., s_oClass:ModMethod( "Reindex", @TMant_Reindex(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Reindex", @TMant_Reindex(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Activate(); IIF( .F., s_oClass:ModMethod( "Activate", @TMant_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Activate", @TMant_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetFocus(); IIF( .F., s_oClass:ModInline( "SetFocus", {|Self | Self, ( if( ::oWndBrw <> nil, ::oWndBrw:SetFocus(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetFocus", {|Self | Self, ( if( ::oWndBrw <> nil, ::oWndBrw:SetFocus(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER CloseFiles(); IIF( .F., s_oClass:ModMethod( "CloseFiles", @TMant_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CloseFiles", @TMant_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CloseService(); IIF( .F., s_oClass:ModMethod( "CloseService", @TMant_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "CloseService", @TMant_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );


   _HB_MEMBER Buscar(); IIF( .F., s_oClass:ModMethod( "Buscar", @TMant_Buscar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Buscar", @TMant_Buscar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Search(); IIF( .F., s_oClass:ModMethod( "Search", @TMant_Buscar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "Search", @TMant_Buscar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );


   _HB_MEMBER Existe( uValue, oGetTxt, uField, lFill, cFillChar); IIF( .F., s_oClass:ModMethod( "Existe", @TMant_Existe(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Existe", @TMant_Existe(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER NotExiste( uValue, oGetTxt, uField, lFill, cFillChar); IIF( .F., s_oClass:ModMethod( "NotExiste", @TMant_NotExiste(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "NotExiste", @TMant_NotExiste(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ReturnField( uValue); IIF( .F., s_oClass:ModMethod( "ReturnField", @TMant_ReturnField(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReturnField", @TMant_ReturnField(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GetAlias(); IIF( .F., s_oClass:ModInline( "GetAlias", {|Self | Self, ( ::oDbf:cAlias ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetAlias", {|Self | Self, ( ::oDbf:cAlias ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Select(); IIF( .F., s_oClass:ModInline( "Select", {|Self | Self, ( ( ::oDbf:cAlias)->( Select() ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Select", {|Self | Self, ( ( ::oDbf:cAlias)->( Select() ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER End(); IIF( .F., s_oClass:ModMethod( "End", @TMant_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @TMant_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AppendFrom( cPath); IIF( .F., s_oClass:ModMethod( "AppendFrom", @TMant_AppendFrom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AppendFrom", @TMant_AppendFrom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SyncAllDbf(); IIF( .F., s_oClass:ModMethod( "SyncAllDbf", @TMant_SyncAllDbf(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SyncAllDbf", @TMant_SyncAllDbf(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER HelpTopic(); IIF( .F., s_oClass:ModMethod( "HelpTopic", @TMant_HelpTopic(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HelpTopic", @TMant_HelpTopic(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER OpenService( lExclusive); IIF( .F., s_oClass:ModMethod( "OpenService", @TMant_OpenService(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "OpenService", @TMant_OpenService(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CloseService(); IIF( .F., s_oClass:ModMethod( "CloseService", @TMant_CloseService(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CloseService", @TMant_CloseService(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lValid( oGet, oSay); IIF( .F., s_oClass:ModMethod( "lValid", @TMant_lValid(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lValid", @TMant_lValid(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER InitSeconds(); IIF( .F., s_oClass:ModInline( "InitSeconds", {|Self | Self, ::nSeconds := Seconds() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "InitSeconds", {|Self | Self, ::nSeconds := Seconds() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER GetSeconds(); IIF( .F., s_oClass:ModInline( "GetSeconds", {|Self | Self, msgInfo( ::nSeconds - Seconds() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetSeconds", {|Self | Self, msgInfo( ::nSeconds - Seconds() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER lLoadDivisa(); IIF( .F., s_oClass:ModMethod( "lLoadDivisa", @TMant_lLoadDivisa(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lLoadDivisa", @TMant_lLoadDivisa(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER Filter(); IIF( .F., s_oClass:ModMethod( "Filter", @TMant_Filter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Filter", @TMant_Filter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER LoadFilter(); IIF( .F., s_oClass:ModMethod( "LoadFilter", @TMant_LoadFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LoadFilter", @TMant_LoadFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Report(); IIF( .F., s_oClass:ModMethod( "Report", @TMant_Report(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Report", @TMant_Report(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CreateShell( nLevel); IIF( .F., s_oClass:ModMethod( "CreateShell", @TMant_CreateShell(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateShell", @TMant_CreateShell(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TMant ;



UTILITY STATIC function TMant_New( cPath, oWndParent, oMenuItem) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   IIF( cPath == nil, cPath := cPatEmp(), ) ;
   IIF( oWndParent == nil, oWndParent := oWnd(), ) ;

   if oMenuItem <> nil
      ::nLevel          := nLevelUsr( oMenuItem )
   end

   ::cPath              := cPath
   ::oWndParent         := oWndParent
   ::oDbf               := nil

   ::lAutoButtons       := .T.
   ::lCreateShell       := .F.

   ::cPicUnd            := MasUnd()

   ::lAppendBuscar      := .F.
   ::lModificarBuscar   := .F.

RETURN ( Self )



UTILITY STATIC function TMant_Create( cPath) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   ::cPath           := cPath
   ::oDbf            := nil

RETURN ( Self )





UTILITY STATIC function TMant_CreateShell( nLevel) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local cIndex
   local oField
   local cTitle
   local lPixel      := .F.
   local nHelpId
   local aFlds       := {}
   local cAlias
   local aIndex      := {}
   local nSizeBtn    := 42

   IIF( nLevel == nil, nLevel := ::nLevel, ) ;





   cAlias            := ::oDbf





   for each cIndex in ::oDbf:aTIndex
      if !Empty( cIndex:cComment )
         aAdd( aIndex, cIndex:cComment )
      end
   next





   cTitle            := ::oDbf:cComment








   ::oWndBrw         := TShell():New(  2, 10, 18, 70, cTitle, nil, ::oWndParent, nil, nil, lPixel, nHelpId, nil, ::oDbf, nil, nil, nil, nil, aIndex, {|| ::Append() }, {|| ::Edit() }, {|| ::Del() }, {|| ::Dup() }, nSizeBtn, nLevel, ::cMru, ::cBitmap, .F., {|| ::Zoom() }, .T. )





   for each oField in ::oDbf:aTField

      if ! oField:lHide

         with object ( ::oWndBrw:AddXCol() )

            :nWidth           := oField:nColSize

            if oField:lColAlign
               :nDataStrAlign := 1
               :nHeadStrAlign := 1
            end

            if oField:lCalculate
               :bEditValue    := oField:bSetGet
            else
               :bEditValue    := oField:bDirect
            end

            if !Empty( oField:aBitmaps )
               :bStrData      := {|| "" }
               :SetCheck( oField:aBitmaps )
            end

            if Valtype( oField:cComment ) == "A"
               :cHeader       := oField:cComment[ 1 ]
               :AddResource( oField:cComment[ 2 ] )
               :nHeadBmpNo    := oField:cComment[ 3 ]
            else
               :cHeader       := oField:cComment
            end

            if aScan( aIndex, {|cIndex| cIndex == :cHeader } ) <> 0
               :cSortOrder    := oField:cName
               :bLClickHeader := {| nMRow, nMCol, nFlags, oCol | ::oWndBrw:ClickOnHeader( oCol ) }
            end

         end

      endif

   next





   ::oWndBrw:CreateXFromCode()

   ::lCreateShell    := .T.

RETURN ( Self )





UTILITY STATIC function TMant_CloseFiles() ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   if !Empty( ::oDbf ) .AND. ::oDbf:Used()
      ::oDbf:End()
   end

    ::oDbf      := nil

RETURN .T.



UTILITY STATIC function TMant_CreateFiles( cPath, lAppend, cPathOld, oMeter) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   IIF( cPath == nil, cPath := ::cPath, ) ;
   IIF( lAppend == nil, lAppend := .F., ) ;

   if oMeter <> NIL
        oMeter:cText    := "Generando Bases"
      SysRefresh()
   end

   if !file( cPath + ::oDbf:cFile )
      ::oDbf:Create()
   end





   if lAppend .AND. lIsDir( cPathOld ) .AND. file( cPathOld + ::oDbf:cFile )
      ( ::oDbf:cAlias )->( __dbApp( cPathOld + ::oDbf:cFile ) )
   end

RETURN NIL



UTILITY STATIC function TMant_Reindexa() ; local Self AS CLASS TMant := QSelf() AS CLASS TMant





   if Empty( ::oDbf )
      ::oDbf   := ::DefineFiles()
   end

   ::oDbf:IdxFDel()

   if ::OpenService( .T. )
      ::oDbf:Pack()
   end

   ::CloseFiles()

RETURN ( Self )



UTILITY STATIC function TMant_Reindex( oMeter) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local bOption     := {|| .T. }

   if oMeter   <> nil
      oMeter:nTotal  := ::oDbf:LastRec() + 1
      bOption        := {|| oMeter:Set( ::oDbf:OrdKeyNo() ), SysRefresh() }
   end

   ::oDbf:Pack()
   ::oDbf:ReindexAll( bOption, 0, "!Deleted()", {|| !Deleted() } )

RETURN ( Self )



UTILITY STATIC function TMant_End() ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   if ::oDbfDiv <> nil .AND. ::oDbfDiv:Used()
      ::oDbfDiv:End()
      ::oDbfDiv   := nil
   end

   if ::oBandera <> nil
      ::oBandera:End()
      ::oBandera  := nil
   end

   if ::oWndBrw <> nil
      ::oWndBrw:End()
      ::oWndBrw   := nil
   end

   ::CloseFiles()

RETURN ( .T. )



UTILITY STATIC function TMant_Activate() ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   if nAnd( ::nLevel, 1 ) <> 0
      msgStop( "Acceso no permitido." )
      Return ( Self )
   end





   if ::oWndParent <> nil
      ::oWndParent:CloseAll()
   end

   if Empty( ::oDbf ) .OR. !::oDbf:Used()
      ::lOpenFiles      := ::OpenFiles()
   end





   if ::lOpenFiles

      if !::lCreateShell
         ::CreateShell( ::nLevel )
      end

      if ::lAutoButtons
         ::oWndBrw:AutoButtons( Self )
      end

      if ::cHtmlHelp <> nil
         ::oWndBrw:cHtmlHelp  := ::cHtmlHelp
      end

      ::oWndBrw:Activate( nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, {|| ::CloseFiles() } )

   end

RETURN ( Self )





UTILITY STATIC function TMant_Report() ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local n
   local aPrompt     := {}
   local aoCols      := {}

   ::oDbf:GetStatus()





   for n := 1 to ::oDbf:fCount()

      if !::oDbf:aTField[ n ]:lCalculate .AND. !Empty( ::oDbf:aTField[ n ]:cComment )









         aAdd( aoCols, {   ::oDbf:aTField[ n ]:cName, ::oDbf:aTField[ n ]:cType, ::oDbf:aTField[ n ]:nLen, ::oDbf:aTField[ n ]:nDec, ::oDbf:aTField[ n ]:cPict, SubStr( ::oDbf:aTField[ n ]:cComment, 1, ::oDbf:aTField[ n ]:nLen + ::oDbf:aTField[ n ]:nDec ), !::oDbf:aTField[ n ]:lHide, ::oDbf:aTField[ n ]:cComment, ::oDbf:aTField[ n ]:nLen + ::oDbf:aTField[ n ]:nDec } )

      endif

   next

   for n := 1 to len( ::oDbf:aTIndex )

      aAdd( aPrompt, { ::oDbf:aTIndex[ n ]:cComment } )

   next

   ::oReport            := TInfGen():New( ::oDbf:cComment, aoCols, aPrompt )

   ::oReport:CreateFilter( nil, ::oDbf )

   ::oReport:lDefDivInf := .F.
   ::oReport:lDefSerInf := .F.
   ::oReport:lDefFecInf := .F.

   ::oReport:oParent    := Self
   ::oReport:oDbfMai    := ::oDbf

   ::oReport:StdResource()
   ::oReport:oDefDesHas()

   ::oReport:Activate()
   ::oReport:End()

   ::oDbf:SetStatus()

RETURN NIL







UTILITY STATIC function TMant_Buscar(oGet, cField, oGetField) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local oDlg
   local nOrd
   local oBrw
   local uVal
   local oField
   local cDlgName
   local cCbxIndex
   local oCbxIndex
   local aCbxIndex
   local oGetSearch
   local cGetSearch
   local nOrdAnt





   if Empty( ::oDbf ) .OR. !::oDbf:Used()
      if !::OpenFiles()
         Return .F.
      end
   end





   IIF( cField == nil, cField := ::oDbf:FieldName( 1 ), ) ;

   cGetSearch     := Space( 100 )

   cDlgName       := "Buscando " + Rtrim( Lower( ::oDbf:cComment ) )
   aCbxIndex      := ::oDbf:aCommentIndex()

   nOrd           := 2
   nOrd           := Min( Max( nOrd, 1 ), len( aCbxIndex ) )
   cCbxIndex      := aCbxIndex[ nOrd ]





   nOrdAnt        := ::oDbf:OrdSetFocus( nOrd )

   ::oDbf:GoTop()





   oDlg                    := TDialog():New( , , , , cDlgName, "HELPENTRY" )

   oGetSearch              := TGet():ReDefine( 104, { | u | if( PCount() == 0, cGetSearch, cGetSearch := u ) }, oDlg, , "@!", , , , , , , .F., , , .F., .F. )
   oGetSearch:bChange      := {|| oGetSearch:Assign(), oBrw:Seek( Alltrim( oGetSearch:VarGet() ) ) }

   oCbxIndex               := TComboBox():ReDefine( 102, { | u | if( PCount() == 0, cCbxIndex, cCbxIndex := u ) }, aCbxIndex, oDlg, , , , , , , .F. )
   oCbxIndex:bChange       := {|| ::oDbf:OrdSetFocus( oCbxIndex:nAt ), oBrw:Refresh(), oGet:SetFocus() }

   oBrw                    := IXBrowse():New( oDlg )

   oBrw:lUpdate            := .T.

   oBrw:bClrSel            := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
   oBrw:bClrSelFocus       := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

   oBrw:nMarqueeStyle      := 5

   oBrw:cName              := cDlgName
   oBrw:bSeek              := {|c| ::oDbf:Seek( c ) }

   oBrw:oSeek              := oGetSearch

   oBrw:bLDblClick         := {|| oDlg:end( 1 ) }
   oBrw:bRClicked          := {| nRow, nCol, nFlags | oBrw:RButtonDown( nRow, nCol, nFlags ) }

   ::oDbf:SetBrowse( oBrw )





   for each oField in ::oDbf:aTField

      if !oField:lHide .AND. !oField:lCalculate

         with object ( oBrw:AddCol() )

            if Valtype( oField:cComment ) == "A"
               :cHeader       := oField:cComment[ 1 ]
               :AddResource( oField:cComment[ 2 ] )
               :nHeadBmpNo    := oField:cComment[ 3 ]
            else
               :cHeader       := oField:cComment
            end
            :nWidth           := oField:nColSize

            if oField:lCalculate
               :bEditValue    := oField:bSetGet
            else
               :bEditValue    := oField:bDirect
            end

            if !Empty( oField:aBitmaps )
               :bStrData      := {|| "" }
               :SetCheck( oField:aBitmaps )
            end

            if oField:lColAlign
               :nDataStrAlign := 1
               :nHeadStrAlign := 1
            end

            if aScan( aCbxIndex, {|cIndex| Valtype( :cHeader ) == "C" .AND. cIndex == :cHeader } ) <> 0
               :cSortOrder    := oField:cName
               :bLClickHeader := {| nMRow, nMCol, nFlags, oCol | oCbxIndex:Set( oCol:cHeader ), oBrw:GoTop() }
            end

         end

      endif

   next

   oBrw:CreateFromResource( 105 )





   TButton():ReDefine( 500, {|| ::Append( oBrw ) }, oDlg, , , .F., {|| ::lAppendBuscar .AND. !IsReport() } )

   TButton():ReDefine( 501, {|| ::Edit( oBrw ) }, oDlg, , , .F., {|| ::lModificarBuscar .AND. !IsReport() } )

   TButton():ReDefine( 1, {|| oDlg:end( 1 ) }, oDlg, , , .F. )

   TButton():ReDefine( 2, {|| oDlg:end() }, oDlg, , , .F. )

   oDlg:bStart             := {|| oBrw:Load(), if( !Empty( oGet ), oGet:SetFocus(), ) }

   if !IsReport()
      oDlg:AddFastKey( 113, {|| ::Append( oBrw ) } )
      oDlg:AddFastKey( 114, {|| ::Edit( oBrw ) } )
   end

   oDlg:AddFastKey( 116, {|| oDlg:end( 1 ) } )

   oDlg:Activate( , , , .T. )





   if oDlg:nResult == 1

      uVal                 := ::oDbf:FieldGetByName( cField )

      if !Empty( oGet ) .AND. !Empty( uVal )

         oGet:cText( uVal )
         oGet:lValid()
         oGet:SetFocus()

      end

   end

   ::oDbf:OrdSetFocus( nOrdAnt )

RETURN ( uVal )







UTILITY STATIC function TMant_Filter( cTipoDocumento, oButton, oDbfFilter) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local oFilter     := TDlgFlt():Create( ::oDbf, oButton, .T., ::oWndBrw )

   if !Empty( oFilter )
      oFilter:Resource( cTipoDocumento, nil, oDbfFilter )
   end

RETURN NIL



UTILITY STATIC function TMant_LoadFilter() ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   if !Empty( ::oWndBrw )
      ::oWndBrw:oActiveFilter:oDbf        := ::oDbf
      ::oWndBrw:oActiveFilter:aTField     := aClone( ::oDbf:aTField )
      ::oWndBrw:oActiveFilter:cDbfFilter  := ::oDbfFilter:nArea
      ::oWndBrw:oActiveFilter:cTipFilter  := ::cTipoDocumento
   end

RETURN ( Self )


Static Function bFiltro( oDbf, oDbfFilter, oButton, oWndBrw )

   local cTip     := by( oDbfFilter:cTipDoc )
   local cTxt     := by( oDbfFilter:cTexFlt )
   local bGen     := {|| TDlgFlt():Create( oDbf, oButton, .T., oWndBrw ):Resource( cTip, cTxt, oDbfFilter ) }

Return ( bGen )





UTILITY STATIC function TMant_Existe( uValue, oGetTxt, uField, lMessage, lFill, cFillChar, uOrder) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local n
   local uFieldGet
   local uValor
   local lValid      := .F.

   IIF( uField == nil, uField := 2, ) ;
   IIF( lFill == nil, lFill := .F., ) ;
   IIF( cFillChar == nil, cFillChar := "0", ) ;
   IIF( lMessage == nil, lMessage := .T., ) ;
   IIF( uOrder == nil, uOrder := 1, ) ;

   if IsObject( uValue )
      uValor         := uValue:VarGet()
   else
      uValor         := uValue
   end

   if Empty( uValor )

      do case
      case IsArray( oGetTxt )

         aEval( oGetTxt, {|o| o:cText( "" ) } )

      case IsObject( oGetTxt )

         oGetTxt:cText( "" )

      end

      return .T.

   else

      uValor         := Upper( uValor )

   end

   if ( Alltrim( uValor ) == Replicate( "Z", len( Alltrim( uValor ) ) ) )
      return .T.
   end

   ::oDbf:GetStatus( .T. )

   if lFill
      uValor         := RJust( uValor, cFillChar )
      if IsObject( uValue )
         uValue:cText( uValor )
      end
   end

   if !Empty( uOrder )
      ::oDbf:OrdSetFocus( uOrder )
   end

   if ::oDbf:Seek( uValor )

      if IsObject( uValue )
         uValue:cText( uValor )
      end

      do case
      case IsArray( oGetTxt ) .AND. IsArray( uField )

         for n := 1 to len( oGetTxt )

            do case
            case IsNum( uField[ n ] )
               uFieldGet   := ::oDbf:FieldGet( uField[ n ] )

            case IsChar( uField[ n ] )
               uFieldGet   := ::oDbf:FieldGet( ::oDbf:FieldPos( uField[ n ] ) )

            case IsBlock( uField[ n ] )
               uFieldGet   := oSend( ::oDbf, Eval( uField[ n ] ) )

            end

            oGetTxt[ n ]:cText( uFieldGet )

         next

      case IsObject( oGetTxt ) .AND. !IsNil( uField )

         do case
         case IsNum( uField )
            uFieldGet      := ::oDbf:FieldGet( uField )

         case IsChar( uField )
            uFieldGet      := ::oDbf:FieldGet( ::oDbf:FieldPos( uField ) )

         case IsBlock( uField )
            uFieldGet      := oSend( ::oDbf, Eval( uField ) )

         end

         oGetTxt:cText( uFieldGet )

      end

      lValid         := .T.

   else

      if lMessage
         msgStop( "Valor no encontrado." )
      end

   end

   ::oDbf:SetStatus()

RETURN lValid



UTILITY STATIC function TMant_NotExiste( uValue, oGetTxt, uField, lMessage, lFill, cFillChar) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local uValor
   local lValid      := .F.
   local nRecno      := ::oDbf:Recno()

   IIF( uField == nil, uField := 2, ) ;
   IIF( lFill == nil, lFill := .F., ) ;
   IIF( cFillChar == nil, cFillChar := "0", ) ;
   IIF( lMessage == nil, lMessage := .T., ) ;

   if ValType( uValue ) == "O"
      uValor   := uValue:VarGet()
   else
      uValor   := uValue
   end

   if Empty( uValor )
      return .T.
   end

   if lFill
      uValor   := RJust( uValor, cFillChar )
   end

   if !::oDbf:Seek( uValor )

      if ValType( uValue ) == "O"
         uValue:cText( uValor )
      end

      lValid   := .T.

   else

      if lMessage
         msgStop( "Valor ya existe." )
      end

   end

   ::oDbf:GoTo( nRecno )

RETURN lValid



UTILITY STATIC function TMant_ReturnField( uValue, uField) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local uReturnField

   if ::oDbf:Seek( uValue )

      if ValType( uField ) == "N"
         uReturnField   := ::oDbf:FieldGet( uField )
      else
         uField         := ::oDbf:FieldPos( uField )
         uReturnField   := ::oDbf:FieldGet( uField )
      end

   else

      uReturnField      := ""

   end

return ( uReturnField )



UTILITY STATIC function TMant_AppendFrom( cFile) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   if !file( cFile )
      MsgStop( "No existe el fichero " + cFile )
   else
      ::oDbf:AppendFrom( cFile )
   end

return ( Self )



UTILITY STATIC function TMant_Append( oBrw) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local lAppend
   local lTrigger

   IIF( oBrw == nil, oBrw := ::oWndBrw, ) ;

   if ::lMinimize
      IIF( oBrw <> nil, oBrw:Minimize(), )
   end

   ::oDbf:Blank()
   ::oDbf:SetDefault()

   if ::bOnPreAppend <> nil
      lTrigger    := Eval( ::bOnPreAppend, Self )
      if Valtype( lTrigger ) == "L" .AND. !lTrigger
         return .F.
      end
   end

   lAppend        := ::Resource( 1 )

   if lAppend
      ::oDbf:Insert()
   else
      ::oDbf:Cancel()
   end

   if ::lMinimize
      IIF( oBrw <> nil, oBrw:Maximize(), )
   end

   if lAppend .AND. !Empty( oBrw )
      oBrw:Refresh()
   end

   if ::bOnPostAppend <> nil
      lTrigger    := Eval( ::bOnPostAppend, Self )
      if Valtype( lTrigger ) == "L" .AND. !lTrigger
         return .F.
      end
   end

return ( lAppend )



UTILITY STATIC function TMant_Dup() ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local lDup
   local lTrigger

   if ::oDbf:OrdKeyCount() == 0
      return .F.
   end

   ::oDbf:Blank()
   ::oDbf:Load()

   if ::bOnPreAppend <> nil
      lTrigger := Eval( ::bOnPreAppend, Self )
      if Valtype( lTrigger ) == "L" .AND. !lTrigger
         return .F.
      end
   end

   lDup        := ::Resource( 1 )

   if lDup
      ::oDbf:Insert()
      if ::oWndBrw <> nil
         ::oWndBrw:Refresh()
      end
   else
      ::oDbf:Cancel()
   end

   if ::bOnPostAppend <> nil
      return Eval( ::bOnPostAppend, Self )
   end

RETURN ( lDup )



UTILITY STATIC function TMant_Edit( oBrw) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local lEdit
   local lTrigger

   IIF( oBrw == nil, oBrw := ::oWndBrw, ) ;

   if ::oDbf:OrdKeyCount() == 0
      return .F.
   end

   if ::lMinimize
      IIF( oBrw <> nil, oBrw:Minimize(), )
   end

   if ::oDbf:RecLock()

      if ::bOnPreEdit <> nil
         lTrigger    := Eval( ::bOnPreEdit, Self )
         if Valtype( lTrigger ) == "L" .AND. !lTrigger
            return .F.
         end
      end

      ::oDbf:Load()

      lEdit          := ::Resource( 2 )

      if lEdit
         ::oDbf:Save()
      else
         ::oDbf:Cancel()
      end

      ::oDbf:UnLock()

   end

   if ::lMinimize
      IIF( oBrw <> nil, oBrw:Maximize(), )
   end

   IIF( oBrw <> nil, oBrw:Refresh(), )

   if ::bOnPostEdit <> nil
      lTrigger    := Eval( ::bOnPostEdit, Self )
      if Valtype( lTrigger ) == "L" .AND. !lTrigger
         return .F.
      end
   end

RETURN ( lEdit )



UTILITY STATIC function TMant_Zoom() ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   if ::oDbf:OrdKeyCount() == 0
      return .F.
   end

   ::oDbf:Load()
   ::Resource( 3 )
   ::oDbf:Cancel()

RETURN ( .T. )



UTILITY STATIC function TMant_Del() ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local lDel
   local lTrigger

   if ::oDbf:OrdKeyCount() == 0
      return .F.
   end

   if ::oDbf:RecLock()

      if ::bOnPreDelete <> nil
         lTrigger := Eval( ::bOnPreDelete, Self )
         if Valtype( lTrigger ) == "L" .AND. !lTrigger
            return .F.
         end
      end

      if oUser():lNotConfirmDelete() .OR. ApoloMsgNoYes("¿Desea eliminar el registro en curso?", "Confirme supresión" )
         CursorWait()
         lDel     := ::oDbf:Delete()
         CursorWE()
      else
         lDel     := .F.
      end

      ::oDbf:UnLock()

   end

   if ::oWndBrw <> nil
      ::oWndBrw:Refresh()
   end

   if ::bOnPostDelete <> nil
      return Eval( ::bOnPostDelete, Self )
   end

RETURN ( lDel )



UTILITY STATIC function TMant_HelpTopic() ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   if !Empty( ::cHtmlHelp )
      HtmlHelp( ::cHtmlHelp )
   end

RETURN ( Self )



UTILITY STATIC function TMant_SyncAllDbf( lInfo) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local oDbfTmp
   local oDbfOld
   local oBlock
   local oError

   IIF( lInfo == nil, lInfo := .F., ) ;

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   oDbfTmp        := ::DefineFiles( cPatEmpTmp() )

   if lInfo
      msginfo( ::cPath, "::cPath" )
      msginfo( "::DefineFiles( " + cEmpTmp() + " )" )
   end

   if !Empty( oDbfTmp )
      oDbfTmp:Activate( .F., .F. )
   end

   if lInfo
      msginfo( "oDbfTmp:Activate( .f., .f. )" )
   end

   oDbfOld        := ::DefineFiles()


   if lInfo
      msginfo( "::DefineFiles()" )
   end

   if !Empty( oDbfOld )
      oDbfOld:Activate( .F., .F., , , , .T. )
   end

   if lInfo
      msginfo( "oDbfOld:Activate( .f., .f., , , , .t. )" )
   end

   while !oDbfOld:Eof()
      dbPass( oDbfOld:cAlias, oDbfTmp:cAlias, .T. )
      oDbfOld:Skip()
   end

   if lInfo
      msginfo( "dbPass( oDbfOld:cAlias, oDbfTmp:cAlias, .t. )" )
   end

   oDbfTmp:Close()
   oDbfOld:Close()

   if lInfo
      msginfo( "oDbfOld:Close()" )
   end

   if dbfErase( oDbfOld:cPath + GetFileNoExt( oDbfOld:cFile ) )
      if dbfRename( oDbfTmp:cPath + GetFileNoExt( oDbfTmp:cFile ), oDbfOld:cPath + GetFileNoExt( oDbfOld:cFile ) )
         dbfErase( oDbfTmp:cPath + GetFileNoExt( oDbfTmp:cFile ) )
      else
         MsgStop( "No se actualizo el fichero " + GetFileNoExt( oDbfOld:cFile ) + ".Dbf" )
      end
   end

   if lInfo
      msginfo( "dbfRename(" + oDbfTmp:cPath + GetFileNoExt( oDbfTmp:cFile ) )
      msginfo( "dbfErase( " + oDbfOld:cPath + GetFileNoExt( oDbfOld:cFile ) )
   end

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Imposible actualizar fichero a nueva estructura" )

   end

   ErrorBlock( oBlock )

   if !Empty( oDbfTmp )
      oDbfTmp:Destroy()
   end

   if !Empty( oDbfOld )
      oDbfOld:Destroy()
   end

RETURN ( Self )



UTILITY STATIC function TMant_OpenService( lExclusive) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local lOpen          := .T.
   local oError
   local oBlock

   IIF( lExclusive == nil, lExclusive := .F., ) ;

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE





      if Empty( ::oDbf )
         ::oDbf         := ::DefineFiles()
      end

      ::oDbf:Activate( .F., !( lExclusive ) )

   RECOVER USING oError

      lOpen             := .F.
      msgStop( "Imposible abrir todas las bases de datos" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

RETURN ( lOpen )



UTILITY STATIC function TMant_CloseService() ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   ::oDbf:End()

   ::oDbf   := nil

RETURN ( .T. )



UTILITY STATIC function TMant_lValid( oGet, oSay) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local lVal  := .F.
   local xVal  := oGet:VarGet()

   ::oDbf:GetStatus( .T. )

   if ::oDbf:Seek( xVal )

      if oSay <> nil
         oSay:cText( ::oDbf:FieldGet( 2 ) )
      end

      lVal     := .T.

   end

   ::oDbf:SetStatus()

RETURN ( lVal )



UTILITY STATIC function TMant_lLoadDivisa( cCodDiv) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   local lRet

   IIF( cCodDiv == nil, cCodDiv := cDivEmp(), ) ;

   if Empty( ::oDbfDiv )
      ::oDbfDiv := DbfServer( "DIVISAS.DBF", ):NewOpen( "DIVISAS.DBF",, ( cDriver() ),, ( cPatDat() ), .F., .T., .F., .F. ) ; ::oDbfDiv:AddBag( "DIVISAS.CDX" ) ; ::oDbfDiv:AddBag( ) ; ::oDbfDiv:AutoIndex()
   end

   if ::oDbfDiv:Seek( cCodDiv )

      ::cPinDiv   := RetPic( ::oDbfDiv:nNinDiv, ::oDbfDiv:nDinDiv )
      ::cPirDiv   := RetPic( ::oDbfDiv:nNinDiv, ::oDbfDiv:nRinDiv )
      ::cPouDiv   := RetPic( ::oDbfDiv:nNouDiv, ::oDbfDiv:nDouDiv )
      ::cPorDiv   := RetPic( ::oDbfDiv:nNouDiv, ::oDbfDiv:nRouDiv )
      ::nDinDiv   := ::oDbfDiv:nDinDiv
      ::nDirDiv   := ::oDbfDiv:nRinDiv
      ::nDouDiv   := ::oDbfDiv:nDouDiv
      ::nDorDiv   := ::oDbfDiv:nRouDiv
      ::nVdvDiv   := nDiv2Div( cCodDiv, cDivEmp(), ::oDbfDiv:cAlias )
      ::nRouDiv   := ::oDbfDiv:nRouDiv

      if ::oBandera <> nil .AND. ::oBmpDiv <> nil
         ::oBmpDiv:Reload( ::oDbfDiv:cBndDiv )
      end

      lRet        := .T.
   else
      MsgStop( "Divisa no encontrada " + cCodDiv  )
      lRet        := .F.
   end

   ::cPicUnd      := MasUnd()

return ( lRet )



UTILITY STATIC function TMant_CheckFiles( cFileAppendFrom) ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   if ::OpenService()
      if !Empty( cFileAppendFrom )
         ::AppendFrom( cFileAppendFrom )
      end
      ::CloseService()
   end

Return ( Self )



UTILITY STATIC function TMant_Play() ; local Self AS CLASS TMant := QSelf() AS CLASS TMant

   if ::OpenFiles()
      ::Activate()
   else
      ::CloseFiles()
   end

Return ( Self )
