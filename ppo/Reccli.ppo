#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 81 ".\Prg\Reccli.prg"
memvar cDbfRec
memvar cDbf
memvar cDbfCol
memvar cCliente
memvar cDbfCli
memvar cFPago
memvar cDbfPgo
memvar cDbfDiv
memvar cDbfAge
memvar cPorDivRec
memvar nPagina
memvar lEnd
memvar nTotFac

static oWndBrw
static dbfDiv
static oBandera
static dbfClient
static dbfCount

static dbfFacCliT
static dbfFacCliL
static dbfFacCliP

static dbfFacRecT
static dbfFacRecL

static dbfAntCliT

static dbfFPago
static dbfIva
static dbfDoc
static dbfFlt
static dbfAgent
static dbfCajT
static oCtaRem
static lPgdOld
static nImpOld
static dbfEmp
static dbfBncCli
static dbfBncEmp
static dbfTurno

static aDbfBmp

static oMenu

static lExternal        := .F.
static lOpenFiles       := .F.
static cFiltroUsuario   := ""

static lOldDevuelto     := .F.


   static bEdit         := { |aTmp, aGet, dbfFacCliP, oBrw, lRectificativa, bValid, nMode, aTmpFac| EdtCob( aTmp, aGet, dbfFacCliP, oBrw, lRectificativa, bValid, nMode, aTmpFac ) }










STATIC FUNCTION OpenFiles( lExt )

   local oError
   local oBlock

   if lOpenFiles
      MsgStop( "Los ficheros de recibos de clientes ya estan abiertos." )
      Return ( .F. )
   end

   IIF( lExt == nil, lExt := .F., ) ;

   lExternal            := lExt

   oBlock               := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      lOpenFiles        := .T.

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACCLIP.DBF" ), ( cCheckArea( "FACCLIP", @dbfFacCliP ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FACCLIP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "DIVISAS.DBF" ), ( cCheckArea( "DIVISAS", @dbfDiv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "DIVISAS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACCLIT.DBF" ), ( cCheckArea( "FACCLIT", @dbfFacCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FACCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACCLIL.DBF" ), ( cCheckArea( "FACCLIL", @dbfFacCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FACCLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacRecT.DBF" ), ( cCheckArea( "FacRecT", @dbfFacRecT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacRecT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacRecL.DBF" ), ( cCheckArea( "FacRecL", @dbfFacRecL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacRecL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatCli() + "CLIENT.DBF" ), ( cCheckArea( "CLIENT", @dbfClient ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatCli() + "CLIENT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatGrp() + "FPAGO.DBF" ), ( cCheckArea( "FPAGO", @dbfFPago ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatGrp() + "FPAGO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIVA.DBF" ), ( cCheckArea( "TIVA", @dbfIva ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TIVA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RDOCUMEN.DBF" ), ( cCheckArea( "RDOCUMEN", @dbfDoc ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RDOCUMEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatCli() + "AGENTES.DBF" ), ( cCheckArea( "AGENTES", @dbfAgent ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatCli() + "AGENTES.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "Cajas.Dbf" ), ( cCheckArea( "CAJAS", @dbfCajT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "Cajas.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "AntCliT.DBF" ), ( cCheckArea( "AntCliT", @dbfAntCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "AntCliT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "CNFFLT.DBF" ), ( cCheckArea( "CNFFLT", @dbfFlt ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "CNFFLT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "EMPRESA.DBF" ), ( cCheckArea( "EMPRESA", @dbfEmp ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "EMPRESA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "NCOUNT.DBF" ), ( cCheckArea( "NCOUNT", @dbfCount ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "NCOUNT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatCli() + "CliBnc.Dbf" ), ( cCheckArea( "CLIBNC", @dbfBncCli ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatCli() + "CliBnc.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cBncDef" )

      dbUseArea( .T., ( cDriver() ), ( cPatGrp() + "EmpBnc.Dbf" ), ( cCheckArea( "EMPBNC", @dbfBncEmp ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatGrp() + "EmpBnc.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cCtaBnc" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "Turno.DBF" ), ( cCheckArea( "Turno", @dbfTurno ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "Turno.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      oBandera             := TBandera():New

      oCtaRem              := TCtaRem():Create( cPatCli() )
      oCtaRem:OpenFiles()





      if oUser():lFiltroVentas()
         cFiltroUsuario    := "Field->cCodUsr == '" + oUser():cCodigo() + "' .and. Field->cCodCaj == '" + oUser():cCaja() + "'"
      end


   RECOVER

      msgStop( "Imposible abrir todas las bases de datos de recibos de clientes" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

      CloseFiles()

   end

   ErrorBlock( oBlock )

RETURN ( lOpenFiles )



STATIC FUNCTION CloseFiles()

   DestroyFastFilter( dbfFacCliP, .T., .T. )

   if dbfFacCliP <> nil
      ( dbfFacCliP )->( dbCloseArea() )
   end
   if dbfDiv <> nil
      ( dbfDiv )->( dbCloseArea() )
   end
   if dbfClient <> nil
      ( dbfClient )->( dbCloseArea() )
   end
   if dbfFacCliT <> nil
      ( dbfFacCliT )->( dbCloseArea() )
    end
   if dbfFacCliL <> nil
      ( dbfFacCliL )->( dbCloseArea() )
   end
   if dbfFacRecT <> nil
      ( dbfFacRecT )->( dbCloseArea() )
    end
   if dbfFacRecL <> nil
      ( dbfFacRecL )->( dbCloseArea() )
   end
   if dbfAntCliT <> nil
      ( dbfAntCliT )->( dbCloseArea() )
   end
   if dbfFPago <> nil
      ( dbfFPago )->( dbCloseArea() )
   end
   if dbfAgent <> nil
      ( dbfAgent )->( dbCloseArea() )
   end
   if dbfIva <> nil
      ( dbfIva )->( dbCloseArea() )
   end
   if dbfDoc <> nil
      ( dbfDoc )->( dbCloseArea() )
   end
   if dbfCajT <> nil
      ( dbfCajT )->( dbCloseArea() )
   end
   if dbfFlt <> nil
      ( dbfFlt )->( dbCloseArea() )
   end
   if dbfEmp <> nil
      ( dbfEmp )->( dbCloseArea() )
   end
   if dbfCount <> nil
      ( dbfCount )->( dbCloseArea() )
   end

   if dbfBncCli <> nil
      ( dbfBncCli )->( dbCloseArea() )
   end

   if dbfBncEmp <> nil
      ( dbfBncEmp )->( dbCloseArea() )
   end

   if dbfTurno <> nil
      ( dbfTurno )->( dbCloseArea() )
   end

   if oCtaRem <> nil
      oCtaRem:CloseFiles()
      oCtaRem:End()
   end

   dbfFacCliP  := nil
   dbfFacCliT  := nil
   dbfFacCliL  := nil
   dbfAntCliT  := nil
   dbfClient   := nil
   oBandera    := nil
   dbfFPago    := nil
   dbfAgent    := nil
   dbfCount    := nil
   dbfEmp      := nil
   dbfDiv      := nil
   dbfDoc      := nil
   dbfFlt      := nil
   dbfBncCli   := nil
   dbfBncEmp   := nil
   dbfTurno    := nil

   oWndBrw     := nil

   lOpenFiles  := .F.

Return .T.



FUNCTION RecCli( oMenuItem, oWnd, aNumRec )

   local oImp
   local oPrv
   local oFlt
   local nLevel
   local oBtnEur
   local lEur           := .F.
   local oPdf
   local oMail
   local oRotor
   local nOrdAnt
   local lFound

   IIF( oMenuItem == nil, oMenuItem := "01059", ) ;
   IIF( oWnd == nil, oWnd := oWnd(), ) ;
   IIF( aNumRec == nil, aNumRec := Array( 1 ), ) ;

   nLevel            := nLevelUsr( oMenuItem )
   if nAnd( nLevel, 1 ) <> 0
      msgStop( "Acceso no permitido." )
      return nil
   end





   if oWnd <> nil
      SysRefresh(); oWnd:CloseAll(); SysRefresh()
   end

   if !OpenFiles()
      Return .F.
   end





   AddMnuNext( "Recibos de facturas de clientes", ProcName() )


















   oWndBrw := TShell():New( 2, 10, 18, 70, "Recibos de facturas de clientes",, oWnd,,, .F.,,, ( dbfFacCliP ),,,,, {"Número", "Código", "Nombre", "Expedición", "Vencimiento", "Cobro", "Importe"},, {||( WinEdtRec( oWndBrw:oBrw, bEdit, dbfFacCliP, , , aNumRec ) )}, {||( DelCobCli( oWndBrw:oBrw, dbfFacCliP ) )},, nil, nLevel, "Briefcase_user1_16", ( 104 + ( 0 * 256 ) + ( 63 * 65536 ) ),, {||( WinZooRec( oWndBrw:oBrw, bEdit, dbfFacCliP ) )}, .T. )

      oWndBrw:lFechado     := .T.

      oWndBrw:bChgIndex    := {|| if( oUser():lFiltroVentas(), CreateFastFilter( cFiltroUsuario, dbfFacCliP, .F., , cFiltroUsuario ), CreateFastFilter( "", dbfFacCliP, .F. ) ) }

      oWndBrw:SetYearComboBoxChange( {|| YearComboBoxChange() } )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Sesión cerrada"
         :nHeadBmpNo       := 3
         :bEditValue       := {|| ( dbfFacCliP )->lCloPgo }
         :nWidth           := 20
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "Zoom16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Cobrado"
         :nHeadBmpNo       := 4
         :bStrData         := {|| "" }
         :bBmpData         := {|| nEstadoRecibo( dbfFacCliP ) }
         :nWidth           := 20
         :AddResource( "Cnt16" )
         :AddResource( "Sel16" )
         :AddResource( "Document_out_16" )
         :AddResource( "ChgPre16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Contabilizado"
         :nHeadBmpNo       := 3
         :bEditValue       := {|| ( dbfFacCliP )->lConPgo }
         :nWidth           := 20
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "BmpConta16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Impreso"
         :nHeadBmpNo       := 3
         :bEditValue       := {|| ( dbfFacCliP )->lRecImp }
         :nWidth           := 20
         :lHide            := .T.
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "IMP16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Espera de documentación"
         :nHeadBmpNo       := 3
         :bEditValue       := {|| ( dbfFacCliP )->lEsperaDoc }
         :nWidth           := 20
         :lHide            := .T.
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "document_time_16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Tipo"
         :bEditValue       := {|| if( !Empty( ( dbfFacCliP )->cTipRec ), "Rectificativa", "" ) }
         :nWidth           := 60
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Número"
         :cSortOrder       := "nNumFac"
         :bEditValue       := {|| ( dbfFacCliP )->cSerie + "/" + AllTrim( Str( ( dbfFacCliP )->nNumFac ) ) + "-" + Str( ( dbfFacCliP )->nNumRec ) }
         :nWidth           := 70
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Delegación"
         :bEditValue       := {|| ( dbfFacCliP )->cSufFac  }
         :nWidth           := 20
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Sesión"
         :bEditValue       := {|| ( dbfFacCliP )->cTurRec }
         :nWidth           := 40
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Caja"
         :bEditValue       := {|| ( dbfFacCliP )->cCodCaj }
         :nWidth           := 40
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Usuario"
         :bEditValue       := {|| ( dbfFacCliP )->cCodUsr }
         :nWidth           := 40
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodCli"
         :bEditValue       := {|| ( dbfFacCliP )->cCodCli }
         :nWidth           := 70
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cNomCli"
         :bEditValue       := {|| ( dbfFacCliP )->cNomCli }
         :nWidth           := 180
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Expedición"
         :cSortOrder       := "dPreCob"
         :bEditValue       := {|| Dtoc( ( dbfFacCliP )->dPreCob ) }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Vencimiento"
         :cSortOrder       := "dFecVto"
         :bEditValue       := {|| Dtoc( ( dbfFacCliP )->dFecVto ) }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Cobro"
         :cSortOrder       := "dEntrada"
         :bEditValue       := {|| Dtoc( ( dbfFacCliP )->dEntrada ) }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Descripción"
         :bEditValue       := {|| ( dbfFacCliP )->cDescrip }
         :nWidth           := 180
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Importe"
         :cSortOrder       := "nImporte"
         :bEditValue       := {|| nTotRecCli( dbfFacCliP, dbfDiv, if( lEur, cDivChg(), cDivEmp() ), .T. ) }
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Cobrado"
         :bEditValue       := {|| nTotCobCli( dbfFacCliP, dbfDiv, if( lEur, cDivChg(), cDivEmp() ), .T. ) }
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Gasto"
         :bEditValue       := {|| nTotGasCli( dbfFacCliP, dbfDiv, if( lEur, cDivChg(), cDivEmp() ), .T. ) }
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Div"
         :bEditValue       := {|| cSimDiv( ( dbfFacCliP )->cDivPgo, dbfDiv ) }
         :nWidth           := 30
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Agente"
         :bEditValue       := {|| ( dbfFacCliP )->cCodAge }
         :lHide            := .T.
         :nWidth           := 40
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Remesa"
         :cSortOrder       := "nNumRem"
         :bEditValue       := {|| Alltrim( Str( ( dbfFacCliP )->nNumRem ) ) + "/" + ( dbfFacCliP )->cSufRem }
         :lHide            := .T.
         :nWidth           := 80
      end

      oWndBrw:CreateXFromCode()





   oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

   oWndBrw:AddSeaBar()







   oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )






   oWndBrw:NewAt( "ZOOM",,, {||( oWndBrw:RecZoom() )}, "(Z)oom", "Z",,, 8,, .F. )






   oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )







   oImp := oWndBrw:NewAt( "IMP",,, {||( ImpPago( nil, 1 ) )}, "(I)mprimir", "I",, {|This|This:Toggle()}, 32,, .F. )


      lGenRecCli( oWndBrw:oBrw, oImp, 1 )





   oWndBrw:NewAt( "SERIE1",,, {||( PrnSerie() )}, "Imp(r)imir series", "R",,, 32,, .F. )







   oPrv := oWndBrw:NewAt( "PREV1",,, {||( ImpPago( nil, 2 ) )}, "(P)revisualizar", "P",, {|This|This:Toggle()}, 32,, .F. )


      lGenRecCli( oWndBrw:oBrw, oPrv, 2 )






   oPdf := oWndBrw:NewAt( "DOCLOCK",,, {||( ImpPago( nil, 3 ) )}, "Pd(f)", "F",, {|This|This:Toggle()}, 32,, .F. )


      lGenRecCli( oWndBrw:oBrw, oPdf, 3 )





   oMail := oWndBrw:NewAt( "Mail",,, {||( ImpPago( nil, 6 ) )}, "Correo electrónico",,, {|This|This:Toggle()}, 32,, .F. )

      lGenRecCli( oWndBrw:oBrw, oMail, 6 )





   oWndBrw:NewAt( "Money2_",,, {||( lLiquida( oWndBrw:oBrw ) )}, "Cobrar",,,, 4,, .F. )








   oWndBrw:NewAt( "PREV1",,, {||( InfPreCli():New( "Previsión de cobros" ):Play() )}, "Pre(v)isión", "V",,, 32,, .F. )








   oWndBrw:NewAt( "BMPCONTA",,, {||( dlgContabilizaReciboCliente( oWndBrw:oBrw ) )}, "(C)ontabilizar", "C",,, 4,, .F. )

   if oUser():lAdministrador()






      oWndBrw:NewAt( "CHGSTATE",,, {||( dlgContabilizaReciboCliente( oWndBrw:oBrw, "Cambiar estado de recibos", "Contabilizado", .T. ) )}, "Cambiar es(t)ado", "T",,, 4,, .F. )

   end






   oBtnEur := oWndBrw:NewAt( "BAL_EURO",,, {||( lEur := !lEur, oWndBrw:Refresh() )}, "M(o)neda", "O",,,,, .F. )





   oWndBrw:NewAt( "Sel",,, {||( FilterRecibos( .T. ) )}, "Solo cob(r)ados", "R",,,,, .F. )





   oWndBrw:NewAt( "Cnt",,, {||( FilterRecibos( .F. ) )}, "Solo (p)endientes", "P",,,,, .F. )





   oWndBrw:NewAt( "Document_out_",,, {||( FilterRecibos() )}, "Solo de(v)ueltos", "V",,,,, .F. )


if oUser():lAdministrador()





   oWndBrw:NewAt( "BMPCHG",,, {||( TDlgFlt():New( aItmRecCli(), dbfFacCliP ):ChgFields(), oWndBrw:Refresh() )}, "Cambiar campos",,,, 2,, .F. )

end






   oRotor := oWndBrw:NewAt( "ROTOR",,, {||( oRotor:Expand() )}, "Rotor",,,,,, .F. )




      oWndBrw:NewAt( "User1_",,, {||( EdtCli( ( dbfFacCliP )->cCodCli ) )}, "Modificar cliente",,,,, oRotor, .F. )




      oWndBrw:NewAt( "Info",,, {||( InfCliente( ( dbfFacCliP )->cCodCli ) )}, "Informe de cliente",,,,, oRotor, .F. )




      oWndBrw:NewAt( "Document_User1_",,, {||( EdtFacCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac ) )}, "Modificar factura",,,,, oRotor, .F. )




   oWndBrw:NewAt( "End",,, {||( oWndBrw:End() )}, "(S)alir", "S",,,,, .F. )

   if !oUser():lFiltroVentas()
      oWndBrw:oActiveFilter:aTField       := aItmrecCli()
      oWndBrw:oActiveFilter:cDbfFilter    := dbfFlt
      oWndBrw:oActiveFilter:cTipFilter    := "18"
   end

   oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp )

   if ValType( aNumRec ) == "A" .AND. !Empty( aNumRec[ 1 ] )

      nOrdAnt  := (dbfFacCliP)->( OrdSetFocus( "nNumFac" ) )
      lFound   := ( dbfFacCliP )->( dbSeek( aNumRec[ 1 ] ) )

      ( dbfFacCliP )->( OrdSetFocus( nOrdAnt ) )

      if lFound
         oWndBrw:Refresh()
         oWndBrw:RecEdit()
      end

      aNumRec  := Array( 1 )

   end

Return .T.



FUNCTION EdtCob( aTmp, aGet, dbfFacCliP, oBrw, lRectificativa, bValid, nMode, aNumRec )

    local oDlg
   local oFld
   local oBmpDiv
   local oGetAge
   local cGetAge           := cNbrAgent( ( dbfFacCliP )->cCodAge, dbfAgent )
   local oGetCaj
   local cGetCaj           := RetFld( ( dbfFacCliP )->cCodCaj, dbfCajT, "cNomCaj" )
   local oGetPgo
   local cGetPgo           := RetFld( ( dbfFacCliP )->cCodPgo, dbfFPago, "cDesPago" )
   local oGetSubCta
   local cGetSubCta
   local oGetCtaRem
   local cGetCtaRem
   local oGetSubGas
   local cGetSubGas
   local cPorDiv           := cPorDiv( ( dbfFacCliP )->cDivPgo, dbfDiv )
   local oBmpGeneral
   local oBmpContabilidad
   local oBmpDevolucion
   local oBmpBancos

   if !IsLogic( lRectificativa )
      lRectificativa       := .F.
   end

   do case
   case nMode == 1

      if lRectificativa
         aTmp[ 5 ]  := "R"
      end

   case nMode == 2

      if aTmp[ 20 ] .AND. !ApoloMsgNoYes( "La modificación de este recibo puede provocar descuadres contables." + Chr(13)+Chr(10) + "¿Desea continuar?", "Recibo ya contabilizado" )
         return .F.
      end

      if aTmp[ 38 ] .AND. !oUser():lAdministrador()
         msgStop( "Solo pueden modificar los recibos cerrados los administradores." )
         return .F.
      end

   end

   if Empty( aTmp[ 7 ] )
      aTmp[ 7 ]     := oUser():cCaja()
   end

   lOldDevuelto            := aTmp[ 46 ]

   lPgdOld                 := ( dbfFacCliP )->lCobrado .OR. ( dbfFacCliP )->lRecDto
   nImpOld                 := ( dbfFacCliP )->nImporte



   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "recibos de clientes", "Recibos",, .F.,,,,,, .F.,,,,,, .F., )











      oFld := TFolder():ReDefine( 500, {"&General", "Bancos", "Devolución", "Contablidad"}, { "Recibos_1","Recibos_6","Recibos_2","Recibos_3" }, oDlg,,,,, .F., )





      oBmpGeneral := TBitmap():ReDefine( 500, "Money_Alpha_48",, oFld:aDialogs[ 1 ],,, .F., .F.,,, .F.,,, .T. )







      aGet[ 14 ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ 14 ], aTmp[ 14 ]:= u ) }, oFld:aDialogs[ 1 ],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,, {|Self|aGet[ 14 ]:cText( Calendario( aTmp[ 14 ] ) )}, nil, "LUPA",, )







      aGet[ 30 ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ 30 ], aTmp[ 30 ]:= u ) }, oFld:aDialogs[ 1 ],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,, {|Self|aGet[ 30 ]:cText( Calendario( aTmp[ 30 ] ) )}, nil, "LUPA",, )




      aGet[ 41 ] := TCheckBox():ReDefine( 200, { | u | If( PCount()==0, aTmp[ 41 ], aTmp[ 41 ]:= u ) }, oFld:aDialogs[ 1 ],,,,,,, .F., {||         ( nMode <> 3 )}, .F. )





      aGet[ 8 ] := TGetHlp():ReDefine( 335, { | u | If( PCount()==0, aTmp[ 8 ], aTmp[ 8 ]:= u ) }, oFld:aDialogs[ 1 ],, "999999",,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )},, .F., .F.,,,,,, nil,,, )




      aGet[ 9 ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ 9 ], aTmp[ 9 ]:= u ) }, oFld:aDialogs[ 1 ],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )




      aGet[ 10 ] := TGetHlp():ReDefine( 121, { | u | If( PCount()==0, aTmp[ 10 ], aTmp[ 10 ]:= u ) }, oFld:aDialogs[ 1 ],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )







      aGet[ 31 ] := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTmp[ 31 ], aTmp[ 31 ]:= u ) }, oFld:aDialogs[ 1 ],,, {||    ( cAgentes( aGet[ 31 ], dbfAgent, oGetAge ) )},,,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwAgentes( aGet[ 31 ], oGetAge ) )}, nil, "LUPA",, )




      oGetAge := TGetHlp():ReDefine( 131, { | u | If( PCount()==0, cGetAge, cGetAge:= u ) }, oFld:aDialogs[ 1 ],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )








      aGet[ 6 ] := TGetHlp():ReDefine( 290, { | u | If( PCount()==0, aTmp[ 6 ], aTmp[ 6 ]:= u ) }, oFld:aDialogs[ 1 ],, "@!", {||    ( cFPago( aGet[ 6 ], dbfFPago, oGetPgo ) )},,,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwFPago( aGet[ 6 ], oGetPgo ) )}, nil, "LUPA",, )




      oGetPgo := TGetHlp():ReDefine( 291, { | u | If( PCount()==0, cGetPgo, cGetPgo:= u ) }, oFld:aDialogs[ 1 ],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )




      aGet[13] := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTmp[13], aTmp[13]:= u ) }, oFld:aDialogs[ 1 ],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )




        aGet[15] := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, aTmp[15], aTmp[15]:= u ) }, oFld:aDialogs[ 1 ],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )




      aGet[16] := TGetHlp():ReDefine( 155, { | u | If( PCount()==0, aTmp[16], aTmp[16]:= u ) }, oFld:aDialogs[ 1 ],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )









      aGet[ 18 ] := TGetHlp():ReDefine( 170, { | u | If( PCount()==0, aTmp[ 18 ], aTmp[ 18 ]:= u ) }, oFld:aDialogs[ 1 ],, "@!", {||    ( cDivOut( aGet[ 18 ], oBmpDiv, aTmp[ 19 ], nil, nil, @cPorDiv, nil, nil, nil, nil, dbfDiv, oBandera ) )}, "N/W*",,,,, .F., {||     ( .F. )},, .F., .F.,,,,, {|Self|BrwDiv( aGet[ 18 ], oBmpDiv, aTmp[ 19 ], dbfDiv, oBandera )}, nil, "LUPA",, )




        oBmpDiv := TBitmap():ReDefine( 171, "BAN_EURO",, oFld:aDialogs[ 1 ],,, .F., .F.,,, .F.,,, .F. )







      aGet[12] := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, aTmp[12], aTmp[12]:= u ) }, oFld:aDialogs[ 1 ],, ( cPorDiv ), {||    ( aGet[ 34 ]:cText( aTmp[ 12 ] ), .T. )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )







      aGet[34] := TGetHlp():ReDefine( 190, { | u | If( PCount()==0, aTmp[34], aTmp[34]:= u ) }, oFld:aDialogs[ 1 ],, ( cPorDiv ), {||    ( ValCobro( aGet, aTmp ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      aGet[35] := TGetHlp():ReDefine( 260, { | u | If( PCount()==0, aTmp[35], aTmp[35]:= u ) }, oFld:aDialogs[ 1 ],, ( cPorDiv ),, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )





      aGet[ 17 ] := TCheckBox():ReDefine( 220, { | u | If( PCount()==0, aTmp[ 17 ], aTmp[ 17 ]:= u ) }, oFld:aDialogs[ 1 ],, {||( ValCheck( aGet, aTmp ) )},,,,, .F., {||         ( nMode <> 3 )}, .F. )







      aGet[ 11 ] := TGetHlp():ReDefine( 230, { | u | If( PCount()==0, aTmp[ 11 ], aTmp[ 11 ]:= u ) }, oFld:aDialogs[ 1 ],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,, {|Self|aGet[ 11 ]:cText( Calendario( aTmp[ 11 ] ) )}, nil, "LUPA",, )









      oBmpDevolucion := TBitmap():ReDefine( 500, "money2_delete_48",, oFld:aDialogs[ 3 ],,, .F., .F.,,, .F.,,, .T. )





      aGet[ 46 ] := TCheckBox():ReDefine( 100, { | u | If( PCount()==0, aTmp[ 46 ], aTmp[ 46 ]:= u ) }, oFld:aDialogs[ 3 ],, {||( lValDevolucion( aGet, aTmp, .F. ) )},,,,, .F., {||     ( aTmp[ 17] .AND. nMode <> 3 )}, .F. )





      aGet[ 47 ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ 47 ], aTmp[ 47 ]:= u ) }, oFld:aDialogs[ 3 ],,,,,,,,, .F., {||     ( aTmp[ 17] .AND. nMode <> 3 )},, .F., .T.,,,,,, nil,,, )




      aGet[ 48 ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ 48 ], aTmp[ 48 ]:= u ) }, oFld:aDialogs[ 3 ],,,,,,,,, .F., {||     ( aTmp[ 17 ] .AND. nMode <> 3 )},, .F., .F.,,,,,, nil,,, )




      aGet[ 49 ] := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTmp[ 49 ], aTmp[ 49 ]:= u ) }, oFld:aDialogs[ 3 ],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )









      oBmpContabilidad := TBitmap():ReDefine( 500, "Folder2_red_Alpha_48",, oFld:aDialogs[ 4 ],,, .F., .F.,,, .F.,,, .T. )




      aGet[ 20 ] := TCheckBox():ReDefine( 230, { | u | If( PCount()==0, aTmp[ 20 ], aTmp[ 20 ]:= u ) }, oFld:aDialogs[ 4 ],,,,,,, .F., {||     ( nMode <> 3 )}, .F. )








      aGet[ 21 ] := TGetHlp():ReDefine( 240, { | u | If( PCount()==0, aTmp[ 21 ], aTmp[ 21 ]:= u ) }, oFld:aDialogs[ 4 ],, ( Replicate( "X", nLenSubcuentaContaplus() ) ), {||    ( MkSubCta( aGet[ 21 ], nil, oGetSubCta ) )},,,,,, .F., {||     ( nLenCuentaContaplus() <> 0 .AND. nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwChkSubCta( aGet[ 21 ], oGetSubCta ) )}, nil, "LUPA",, )




        oGetSubCta := TGetHlp():ReDefine( 241, { | u | If( PCount()==0, cGetSubCta, cGetSubCta:= u ) }, oFld:aDialogs[ 4 ],,,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )








      aGet[ 36 ] := TGetHlp():ReDefine( 270, { | u | If( PCount()==0, aTmp[ 36 ], aTmp[ 36 ]:= u ) }, oFld:aDialogs[ 4 ],, ( Replicate( "X", nLenSubcuentaContaplus() ) ), {||    ( MkSubCta( aGet[ 36 ], nil, oGetSubGas ) )},,,,,, .F., {||     ( nLenCuentaContaplus() <> 0 .AND. nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwChkSubCta( aGet[ 36 ], oGetSubGas ) )}, nil, "LUPA",, )




      oGetSubGas := TGetHlp():ReDefine( 271, { | u | If( PCount()==0, cGetSubGas, cGetSubGas:= u ) }, oFld:aDialogs[ 4 ],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )











      aGet[ 26 ] := TGetHlp():ReDefine( 250, { | u | If( PCount()==0, aTmp[ 26 ], aTmp[ 26 ]:= u ) }, oFld:aDialogs[ 4 ],,, {||    ( oGetCtaRem:cText( oRetFld( aTmp[ 26 ], oCtaRem:oDbf ) ), .T. )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oCtaRem:Buscar( aGet[ 26 ] ) )}, nil, "LUPA",, )





      oGetCtaRem := TGetHlp():ReDefine( 251, { | u | If( PCount()==0, cGetCtaRem, cGetCtaRem:= u ) }, oFld:aDialogs[ 4 ],,,, "N/W*",,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )











      aGet[ 7 ] := TGetHlp():ReDefine( 280, { | u | If( PCount()==0, aTmp[ 7 ], aTmp[ 7 ]:= u ) }, oFld:aDialogs[ 4 ],,, {||    cCajas( aGet[ 7 ], dbfCajT, oGetCaj )},,,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwCajas( aGet[ 7 ], oGetCaj ) )}, nil, "LUPA",, )




      oGetCaj := TGetHlp():ReDefine( 281, { | u | If( PCount()==0, cGetCaj, cGetCaj:= u ) }, oFld:aDialogs[ 4 ],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )




      aGet[27] := TCheckBox():ReDefine( 160, { | u | If( PCount()==0, aTmp[27], aTmp[27]:= u ) }, oFld:aDialogs[ 4 ],,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )}, .F. )




      aGet[ 39 ] := TGetHlp():ReDefine( 161, { | u | If( PCount()==0, aTmp[ 39 ], aTmp[ 39 ]:= u ) }, oFld:aDialogs[ 4 ],,,,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )},, .F., .F.,,,,,, nil,,, )




      aGet[ 40 ] := TGetHlp():ReDefine( 162, { | u | If( PCount()==0, aTmp[ 40 ], aTmp[ 40 ]:= u ) }, oFld:aDialogs[ 4 ],,,,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )},, .F., .F.,,,,,, nil,,, )




      aGet[ 37 ] := TCheckBox():ReDefine( 165, { | u | If( PCount()==0, aTmp[ 37 ], aTmp[ 37 ]:= u ) }, oFld:aDialogs[ 4 ],,,,,,, .F., {||         ( nMode <> 3 )}, .F. )









      oBmpBancos := TBitmap():ReDefine( 500, "office_building_48_alpha",, oFld:aDialogs[ 2 ],,, .F., .F.,,, .F.,,, .T. )






      aGet[ 51 ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ 51 ], aTmp[ 51 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwBncEmp( aGet[ 51 ], aGet[ 53 ], aGet[ 54 ], aGet[ 55 ], aGet[ 56 ] ) )}, nil, "LUPA",, )





      aGet[ 53 ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ 53 ], aTmp[ 53 ]:= u ) }, oFld:aDialogs[2],,, {||    ( lCalcDC( aTmp[ 53 ], aTmp[ 54 ], aTmp[ 55 ], aTmp[ 56 ], aGet[ 55 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 54 ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ 54 ], aTmp[ 54 ]:= u ) }, oFld:aDialogs[2],,, {||    ( lCalcDC( aTmp[ 53 ], aTmp[ 54 ], aTmp[ 55 ], aTmp[ 56], aGet[ 55 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 55 ] := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTmp[ 55 ], aTmp[ 55 ]:= u ) }, oFld:aDialogs[2],,, {||    ( lCalcDC( aTmp[ 53 ], aTmp[ 54 ], aTmp[ 55 ], aTmp[ 56 ], aGet[ 55 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 56 ] := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTmp[ 56 ], aTmp[ 56 ]:= u ) }, oFld:aDialogs[2],,, {||    ( lCalcDC( aTmp[ 53 ], aTmp[ 54 ], aTmp[ 55 ], aTmp[ 56 ], aGet[ 55 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      aGet[ 52 ] := TGetHlp():ReDefine( 200, { | u | If( PCount()==0, aTmp[ 52 ], aTmp[ 52 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwBncCli( aGet[ 52 ], aGet[ 57 ], aGet[ 58 ], aGet[ 59 ], aGet[ 60 ], aTmp[ 9 ] ) )}, nil, "LUPA",, )





      aGet[ 57 ] := TGetHlp():ReDefine( 210, { | u | If( PCount()==0, aTmp[ 57 ], aTmp[ 57 ]:= u ) }, oFld:aDialogs[2],,, {||    ( lCalcDC( aTmp[ 57 ], aTmp[ 58 ], aTmp[ 59 ], aTmp[ 60 ], aGet[ 59 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 58 ] := TGetHlp():ReDefine( 220, { | u | If( PCount()==0, aTmp[ 58 ], aTmp[ 58 ]:= u ) }, oFld:aDialogs[2],,, {||    ( lCalcDC( aTmp[ 57 ], aTmp[ 58 ], aTmp[ 59 ], aTmp[ 60], aGet[ 59 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 59 ] := TGetHlp():ReDefine( 230, { | u | If( PCount()==0, aTmp[ 59 ], aTmp[ 59 ]:= u ) }, oFld:aDialogs[2],,, {||    ( lCalcDC( aTmp[ 57 ], aTmp[ 58 ], aTmp[ 59 ], aTmp[ 60 ], aGet[ 59 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 60 ] := TGetHlp():ReDefine( 240, { | u | If( PCount()==0, aTmp[ 60 ], aTmp[ 60 ]:= u ) }, oFld:aDialogs[2],,, {||    ( lCalcDC( aTmp[ 57 ], aTmp[ 58 ], aTmp[ 59 ], aTmp[ 60 ], aGet[ 59 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )




      aGet[ 61 ] := TCheckBox():ReDefine( 300, { | u | If( PCount()==0, aTmp[ 61 ], aTmp[ 61 ]:= u ) }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )}, .F. )




      aGet[ 24 ] := TGetHlp():ReDefine( 310, { | u | If( PCount()==0, aTmp[ 24 ], aTmp[ 24 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )},, .F., .F.,,,,,, nil,,, )




      aGet[ 25 ] := TGetHlp():ReDefine( 320, { | u | If( PCount()==0, aTmp[ 25 ], aTmp[ 25 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )},, .F., .F.,,,,,, nil,,, )









      TButton():ReDefine( 1, {||( EndTrans( aTmp, aGet, dbfFacCliP, oBrw, oDlg, nMode ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( KillTrans( dbfFacCliP, oDlg ) )}, oDlg,,, .F.,,,, .T. )




      TButton():ReDefine( 998, {||( ChmHelp ("Recibos") )}, oDlg,,, .F.,,,, .F. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| EndTrans( aTmp, aGet, dbfFacCliP, oBrw, oDlg, nMode ) } )
   end

   oDlg:AddFastKey ( 112, {|| ChmHelp ("Recibos") } )

   oDlg:bStart := {|| lValDevolucion( aGet, aTmp, .T. ) }







   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|(  aGet[ 18 ]:lValid(), aGet[ 21 ]:lValid(), aGet[ 36 ]:lValid(), aGet[ 26 ]:lValid(), aGet[ 14 ]:SetFocus(), EdtRecMenu( aTmp, oDlg ) )}, oDlg:bRClicked,,, )

   EndEdtRecMenu()

   if !Empty( oBmpDiv )
      oBmpDiv:End()
   end

   if !Empty( oBmpGeneral )
      oBmpGeneral:End()
   end

   if !Empty( oBmpDevolucion )
      oBmpDevolucion:End()
   end

   if !Empty( oBmpContabilidad )
      oBmpContabilidad:End()
   end

   if !Empty( oBmpBancos )
      oBmpBancos:End()
   end

RETURN ( oDlg:nResult == 1 )



Static Function KillTrans( dbfFacCliP, oDlg )

   oDlg:End()

Return .T.






STATIC FUNCTION ChgState( lState )

   IIF( lState == nil, lState := !( dbfFacCliP )->lConPgo, ) ;

   if ( dbfFacCliP )->lConPgo <> lState .AND. dbLock( dbfFacCliP )
      ( dbfFacCliP )->lConPgo := lState
      ( dbfFacCliP )->( dbUnLock() )
   end

RETURN NIL







Static Function dlgContabilizaReciboCliente( oBrw, cTitle, cOption, lChgState )

    local oDlg
   local oBrwCon
   local cSerIni
   local cSerFin
   local oDocIni
   local oDocFin
   local nDocIni
   local nDocFin
   local cSufIni
   local cSufFin
   local nNumIni
   local nNumFin
   local oMtrInf
   local nMtrInf
   local oSerIni
   local oSerFin
   local oBtnCancel
   local nRad        := 2
   local oSimula
   local lSimula     := .T.
   local nRecFac     := ( dbfFacCliT )->( Recno() )
   local nOrdFac     := ( dbfFacCliT )->( OrdSetFocus( 1 ) )
   local nRecRec     := ( dbfFacCliP )->( Recno() )
   local nOrdRec     := ( dbfFacCliP )->( OrdSetFocus( 1 ) )
   local cTipo       := "Todas"
   local oTree
   local oImageList

   IIF( cTitle == nil, cTitle := "Contabilizar recibos", ) ;
   IIF( cOption == nil, cOption := "Simular resultados", ) ;
   IIF( lChgState == nil, lChgState := .F., ) ;

   oImageList        := TImageList():New( 16, 16 )
   oImageList:AddMasked( TBitmap():Define( "bRed" ),     ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )
   oImageList:AddMasked( TBitmap():Define( "bGreen" ),   ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )

   cSerIni           := ( dbfFacCliP )->cSerie
   cSerFin           := ( dbfFacCliP )->cSerie
   nDocIni           := ( dbfFacCliP )->nNumFac
   nDocFin           := ( dbfFacCliP )->nNumFac
   cSufIni           := ( dbfFacCliP )->cSufFac
   cSufFin           := ( dbfFacCliP )->cSufFac
   nNumIni           := ( dbfFacCliP )->nNumRec
   nNumFin           := ( dbfFacCliP )->nNumRec

   oDlg = TDialog():New(,,,, ( cTitle ), "ConSerRec",, .F.,,,,,, .F.,,,,,, .F., )



   TRadMenu():Redefine( { | u | If( PCount()==0, nRad, nRad:= u ) }, oDlg,, { 90, 91 },,,,, .F.,, )




   TComboBox():ReDefine( 80, { | u | If( PCount()==0, cTipo, cTipo:= u ) }, { "Todas", "Facturas", "Rectificativas" }, oDlg,,,,,,, .F.,,,,,, )










   oSerIni := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, cSerIni, cSerIni:= u ) }, oDlg,, "@!", {||    ( cSerIni >= "A" .AND. cSerIni <= "Z" )},,,,,, .T., {||     ( nRad == 2 )},, .F., .T., {||    ( UpSerie( oSerIni ) )}, {||  ( DwSerie( oSerIni ) )},,,, nil,,, )






   TBtnBmp():ReDefine( 101, "Up16",,,,, {|Self|( dbFirst( dbfFacCliP, "nNumFac", oDocIni, cSerIni, "nNumFac" ) )}, oDlg, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F. )










   oSerFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cSerFin, cSerFin:= u ) }, oDlg,, "@!", {||    ( cSerFin >= "A" .AND. cSerFin <= "Z" )},,,,,, .T., {||     ( nRad == 2 )},, .F., .T., {||    ( UpSerie( oSerFin ) )}, {||  ( DwSerie( oSerFin ) )},,,, nil,,, )






   TBtnBmp():ReDefine( 111, "Down16",,,,, {|Self|( dbLast( dbfFacCliP, "nNumFac", oDocFin, cSerFin, "nNumFac" ) )}, oDlg, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F. )






   oDocIni := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, nDocIni, nDocIni:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( nRad == 2 )},, .F., .T.,,,,,, nil,,, )






   oDocFin := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, nDocFin, nDocFin:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( nRad == 2 )},, .F., .T.,,,,,, nil,,, )





   TGetHlp():ReDefine( 140, { | u | If( PCount()==0, cSufIni, cSufIni:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )





   TGetHlp():ReDefine( 150, { | u | If( PCount()==0, cSufFin, cSufFin:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )





   TGetHlp():ReDefine( 160, { | u | If( PCount()==0, nNumIni, nNumIni:= u ) }, oDlg,, "99",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )





   TGetHlp():ReDefine( 170, { | u | If( PCount()==0, nNumFin, nNumFin:= u ) }, oDlg,, "99",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )



   oSimula := TCheckBox():ReDefine( 190, { | u | If( PCount()==0, lSimula, lSimula:= u ) }, oDlg,,,,,,, .F.,, .F. )

   oTree             := TTreeView():Redefine( 180, oDlg )
   oTree:bLDblClick  := {|| TreeChanged( oTree ) }





   oMtrInf := TMeter():ReDefine( 200, { | u | If( PCount()==0, nMtrInf, nMtrInf:= u ) },, oDlg, .F.,,, .T.,,,, )

   oMtrInf:SetTotal( ( dbfFacCliP )->( OrdKeyCount() ) )




   TButton():ReDefine( 1, {||( PasRec( cSerIni + Str( nDocIni, 9 ) + cSufIni + Str( nNumIni ), cSerFin + Str( nDocFin, 9 ) + cSufFin + Str( nNumFin ), nRad, cTipo, lSimula, lChgState, oBrw, oBtnCancel, oDlg, oTree, oMtrInf ) )}, oDlg,,, .F.,,,, .F. )





   oBtnCancel := TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   oDlg:AddFastKey( 116, {|| PasRec( cSerIni + Str( nDocIni, 9 ) + cSufIni + Str( nNumIni ), cSerFin + Str( nDocFin, 9 ) + cSufFin + Str( nNumFin ), nRad, cTipo, lSimula, lChgState, oBrw, oBtnCancel, oDlg, oTree, oMtrInf ) } )

   oDlg:bStart := {|| oSerIni:SetFocus(), SetWindowText( oSimula:hWnd, cOption ), oSimula:Refresh() }



   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( oTree:SetImageList( oImageList ) )}, oDlg:bRClicked,,, )

   ( dbfFacCliT )->( dbGoTo( nRecFac ) )
   ( dbfFacCliT )->( OrdSetFocus( nOrdFac ) )
   ( dbfFacCliP )->( dbGoTo( nRecRec ) )
   ( dbfFacCliP )->( OrdSetFocus( nOrdRec ) )

   oImageList:End()

   oTree:Destroy()

   if oBrw <> nil
      oBrw:Refresh()
   end

RETURN NIL



Static Function TreeChanged( oTree )

   local oItemTree   := oTree:GetItem()

   if !Empty( oItemTree ) .AND. !Empty( oItemTree:bAction )
      Eval( oItemTree:bAction )
   end

RETURN NIL



STATIC FUNCTION PasRec( cDocIni, cDocFin, nRad, cTipo, lSimula, lChgState, oBrw, oBtnCancel, oDlg, oTree, oMtrInf )

   local aPos
   local bWhile
   local lWhile         := .T.
   local aSimula        := {}
   local nRecno         := ( dbfFacCliP )->( Recno() )
   local nOrden         := ( dbfFacCliP )->( OrdSetFocus( "nNumFac" ) )
   local lErrorFound    := .F.
   local lReturn





   if lSimula
      aPos              := { 0, 0 }
      ClientToScreen( oDlg:hWnd, aPos )
      oDlg:Move( aPos[ 1 ] - 22, aPos[ 2 ] - 510 )
   end





   oDlg:Disable()

   oBtnCancel:bAction   := {|| lWhile := .F. }
   oBtnCancel:Enable()

   oTree:Enable()
   oTree:DeleteAll()

   if ( nRad == 1 )

      ( dbfFacCliP )->( dbGoTop() )

      bWhile            := {|| !( dbfFacCliP )->( eof() ) }

   else

      ( dbfFacCliP )->( dbSeek( cDocIni, .T. ) )



      bWhile            := {||   ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ) >= cDocIni .AND.  ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ) <= cDocFin .AND.  !( dbfFacCliP )->( eof() ) }

   end

   oMtrInf:Set( ( dbfFacCliP )->( OrdKeyNo() ) )

   while ( lWhile .AND. Eval( bWhile ) )





      do case
         case ( cTipo == "Facturas" .OR. cTipo == "Todas" )       .AND. Empty( ( dbfFacCliP )->cTipRec )

            if lChgState
               lReturn  := ChgState( lSimula )
            else
               lReturn  := ContabilizaReciboCliente( nil, oTree, lSimula, aSimula, dbfFacCliT, dbfFacCliP, dbfDiv )
            end

         case ( cTipo == "Rectificativas" .OR. cTipo == "Todas" ) .AND. !Empty( ( dbfFacCliP )->cTipRec )

            if lChgState
               lReturn  := ChgState( lSimula )
            else
               lReturn  := ContabilizaReciboCliente( nil, oTree, lSimula, aSimula, dbfFacRecT, dbfFacCliP, dbfDiv )
            end

      end

      if IsFalse( lReturn )
         exit
      end

      ( dbfFacCliP )->( dbSkip() )

      oMtrInf:Set( ( dbfFacCliP )->( OrdKeyNo() ) )

      sysrefresh()

   end

   oMtrInf:Set( ( dbfFacCliP )->( OrdKeyCount() ) )





   ( dbfFacCliP )->( OrdSetFocus( nOrden ) )
   ( dbfFacCliP )->( dbGoTo( nRecno ) )

   oBtnCancel:bAction   := {|| oDlg:End() }

   if lSimula
      WndCenter( oDlg:hWnd )
   end

   oDlg:Enable()

   if oBrw <> nil
      oBrw:Refresh()
   end

RETURN NIL



FUNCTION ContabilizaReciboCliente( oBrw, oTree, lSimula, aSimula, dbfFacCliT, dbfFacCliP, dbfDiv, lFromFactura, nAsiento )

   local cCodEmp
   local cRuta
   local dFecha
   local cConcepto
   local cCtaGas
   local cCtaPgo
   local cCtaCli
   local nDpvDiv
   local nRecCliT       := ( dbfFacCliT )->( Recno() )
   local nRecCliP       := ( dbfFacCliP )->( Recno() )
   local cCodDiv        := if( ( dbfFacCliP )->lImpEur, "EUR", ( dbfFacCliP )->cDivPgo )
   local nImpRec        := nTotRecCli( dbfFacCliP, dbfDiv )
   local nImpCob        := nTotCobCli( dbfFacCliP, dbfDiv )
   local nImpGas        := nTotGasCli( dbfFacCliP, dbfDiv )
   local lConFac        := lConFacCli( ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC, dbfFacCliT )
   local cCodCli        := cCliFacCli( ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC, dbfFacCliT )
   local cCodPgo        := cPgoFacCli( ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC, dbfFacCliT )
   local cCodPro        := cProFacCli( ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC, dbfFacCliT )
   local nRecibo        := ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC + Str( ( dbfFacCliP )->NNUMREC )
   local cRecibo        := ( dbfFacCliP )->cSerie + "/" + Ltrim( Str( ( dbfFacCliP )->NNUMFAC, 9 ) ) + "/" + ( dbfFacCliP )->CSUFFAC + "-" + Str( ( dbfFacCliP )->NNUMREC )
   local cTerNif        := RetFld( ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC, dbfFacCliT, "CDNICLI" )
   local cTerNom        := ( dbfFacCliP )->cNomCli
   local lErrorFound    := .F.
   local lRectif        := !Empty( ( dbfFacCliP )->cTipRec )
   local cProyecto      := Left( cCodPro, 3 )
   local cClave         := Right( cCodPro, 6 )
   local lReturn        := .T.

   nDpvDiv              := nDpvDiv( cCodDiv, dbfDiv )

   IIF( lSimula == nil, lSimula := .F., ) ;
   IIF( lFromFactura == nil, lFromFactura := .F., ) ;
   IIF( nAsiento == nil, nAsiento := 0, ) ;

   cRuta                := cRutCnt()
   cCodEmp              := cCodEmpCnt( ( dbfFacCliP )->cSerie )

   if !lFromFactura

      if OpenDiario( , cCodEmp )
         nAsiento          := RetLastAsi()
      else
         oTree:Select( oTree:Add( "Recibo : " + Rtrim( cRecibo ) + " imposible abrir ficheros de contaplus.", 0 ) )
         Return .F.
      end

   end






   if ( dbfFacCliP )->lConPgo
      oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " ya contabilizado.", 0, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
      lErrorFound       := .T.
   end

   if !( ( dbfFacCliP )->lCobrado .OR. ( dbfFacCliP )->lDevuelto )
      oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " no cobrado o no devuelto.", 0, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
      lErrorFound       := .T.
   end

   if ( dbfFacCliP )->lCobrado .AND. !ChkFecha( , , ( dbfFacCliP )->dEntrada, .F. )
      oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " de " + dtoc( ( dbfFacCliP )->dEntrada ) + " asiento fuera de fechas", 0, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
      lErrorFound       := .T.
   end

   if !Empty( ( dbfFacCliP )->nNumRem ) .AND. !( dbfFacCliP )->lDevuelto
      oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " pertenece a remesa.", 0, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
      lErrorFound       := .T.
   end

   if !lConFac .AND. !lFromFactura
      oTree:Select( oTree:Add( "Factura de recibo : " + rtrim( cRecibo ) + " no contabilizada.", 0, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
      lErrorFound       := .T.
   end

   if !ChkRuta( cRutCnt() )
      oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " ruta no valida.", 0, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
      lErrorFound       := .T.
   end







   if Empty( cCodEmp )
      oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " no se definieron empresas asociadas.", 0, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
      lErrorFound       := .T.
   end






   if Empty( cCodCli )
      cCodCli           := cCliFacCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac, dbfFacCliT )
   end

   cCtaCli              := cCliCta( cCodCli, dbfClient )

   if Empty( cCtaCli )
      cCtaCli           := cCtaSin()
   end

   if !ChkSubCta( cRuta, cCodEmp, cCtaCli, , .F., .F. )
      oTree:Select( oTree:Add( "Recibo : " + Rtrim( cRecibo ) + " subcuenta de cliente " + cCtaCli + " no encontada.", 0, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
      lErrorFound       := .T.
   end






   if ( dbfFacCliP )->( dbSeek( nRecibo ) )





      cCtaPgo        := ( dbfFacCliP )->cCtaRec

      if Empty( cCtaPgo )
         cCtaPgo     := cCtaFPago( cCodPgo, dbfFPago )
      end

      if Empty( cCtaPgo )
         cCtaPgo     := cCtaCob()
      end

      if Empty( cCtaPgo )
         oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " no existe cuenta de pago.", 0, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
         lErrorFound := .T.
      end

      if !ChkSubCta( cRuta, cCodEmp, cCtaPgo, , .F., .F. )
         oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " subcuenta " + rtrim( cCtaPgo ) + " no encontada.", 0, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
         lErrorFound := .T.
      end





      if nImpGas <> 0

         if Empty( ( dbfFacCliP )->cCtaGas )
            cCtaGas  := cCtaFGas( cCodPgo, dbfFPago )
         else
            cCtaGas  := ( dbfFacCliP )->cCtaGas
         end

         if Empty( cCtaGas )
            oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " no existe cuenta de gastos.", 0, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
            lErrorFound := .T.
         end

         if !ChkSubCta( cRuta, cCodEmp, cCtaGas, , .F., .F. )
            oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " subcuenta " + rtrim( cCtaGas ) + " no encontada.", 0, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
            lErrorFound := .T.
         end

      end

   else

      msginfo( "No encuentro el recibo " + nRecibo )

   end






   if ( !lErrorFound )

      if Empty( ( dbfFacCliP )->dPreCob )

         if dbDialogLock( dbfFacCliP )
            ( dbfFacCliP )->dPreCob := date()
            ( dbfFacCliP )->( dbUnLock() )
         end

      end

   end






   if ( lSimula .OR. !lErrorFound )

      if ( dbfFacCliP )->lDevuelto
         cConcepto      := "Dev./Recibo. " + cRecibo
         dFecha         := ( dbfFacCliP )->dFecDev
      else
         cConcepto      := "C/Recibo. " + cRecibo
         dFecha         := ( dbfFacCliP )->dEntrada
      end

   end






   if ( lSimula .OR. !lErrorFound )





      if nImpRec <> 0





















          aadd( aSimula, MkAsiento( nAsiento, cCodDiv, dFecha,  cCtaCli, , if( ( dbfFacCliP )->lDevuelto, nImpRec, 0 ), cConcepto, if( ( dbfFacCliP )->lDevuelto, 0, nImpRec ), , , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end





      if nImpCob <> 0





















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha,  cCtaPgo, , if( ( dbfFacCliP )->lDevuelto, 0, nImpCob ), cConcepto, if( ( dbfFacCliP )->lDevuelto, nImpCob, 0 ), , , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end





      if nImpGas <> 0





















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha,  cCtaGas, , if( ( dbfFacCliP )->lDevuelto, 0, nImpGas ), cConcepto, if( ( dbfFacCliP )->lDevuelto, nImpGas, 0 ), , , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end

      if ( !lSimula .AND. !lErrorFound )
         lReturn     := lContabilizaReciboCliente( cRecibo, nAsiento, lFromFactura, oTree, dbfFacCliP )
      end

      if ( lSimula .AND. !lFromFactura )
         lReturn     := msgTblCon( aSimula, cCodDiv, dbfDiv, !lErrorFound, cRecibo, {|| aWriteAsiento( aSimula, cCodDiv, .T., oTree, cRecibo, nAsiento ), lContabilizaReciboCliente( cRecibo, nAsiento, lFromFactura, oTree, dbfFacCliP ) } )
      end

   end

   if !lFromFactura
      CloseDiario()
   end

   if !Empty( oBrw )
      oBrw:Refresh()
   end

   ( dbfFacCliP )->( dbGoTo( nRecCliP ) )
   ( dbfFacCliT )->( dbGoTo( nRecCliT ) )

RETURN ( lReturn )



Function lContabilizaReciboCliente( cRecibo, nAsiento, lFromFactura, oTree, dbfFacCliP )

   if dbLock( dbfFacCliP )
      ( dbfFacCliP )->lConPgo  := .T.
      ( dbfFacCliP )->( dbUnLock() )
   end

   if !lFromFactura
      oTree:Select( oTree:Add( "Recibo : " + Rtrim( cRecibo ) + " asiento generado num. " + Alltrim( Str( nAsiento ) ), 1, bGenEdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ), lFromFactura ) ) )
   end

RETURN ( .T. )



Function nTotRecCli( uFacCliP, cDbfDiv, cDivRet, lPic )

   local cDivPgo
   local nRouDiv
   local cPorDiv
   local nTotRec

   IIF( uFacCliP == nil, uFacCliP := dbfFacCliP, ) ;
   IIF( cDbfDiv == nil, cDbfDiv := dbfDiv, ) ;
   IIF( cDivRet == nil, cDivRet := cDivEmp(), ) ;
   IIF( lPic == nil, lPic := .F., ) ;

   if ValType( uFacCliP ) == "O"
      cDivPgo        := uFacCliP:cDivPgo
      nTotRec        := uFacCliP:nImporte
   else
      cDivPgo        := ( uFacCliP )->cDivPgo
      nTotRec        := ( uFacCliP )->nImporte
   end

   nRouDiv           := nRouDiv( cDivPgo, cDbfDiv )
   cPorDiv           := cPorDiv( cDivPgo, cDbfDiv )

   nTotRec           := Round( nTotRec, nRouDiv )

   if cDivRet <> cDivPgo
      nRouDiv        := nRouDiv( cDivRet, cDbfDiv )
      cPorDiv        := cPorDiv( cDivRet, cDbfDiv )
      nTotRec        := nCnv2Div( nTotRec, cDivPgo, cDivRet, cDbfDiv )
   end

RETURN if( lPic, Trans( nTotRec, cPorDiv ), nTotRec )



function nTotCobCli( uFacCliP, uDiv, cDivRet, lPic )

   local cDivPgo
   local nRouDiv
   local cPorDiv
   local nTotRec
   local nTotCob
   local lRecCob
   local cDbfDiv

   IIF( cDivRet == nil, cDivRet := cDivEmp(), ) ;
   IIF( lPic == nil, lPic := .F., ) ;

   if ValType( uFacCliP ) == "O"
      cDivPgo        := uFacCliP:cDivPgo
      nTotRec        := uFacCliP:nImporte
      nTotCob        := uFacCliP:nImpCob
      lRecCob        := uFacCliP:lCobrado
   else
      cDivPgo        := ( uFacCliP )->cDivPgo
      nTotRec        := ( uFacCliP )->nImporte
      nTotCob        := ( uFacCliP )->nImpCob
      lRecCob        := ( uFacCliP )->lCobrado
   end

   if ValType( uDiv ) == "O"
      cDbfDiv        := uDiv:cAlias
   else
      cDbfDiv        := uDiv
   end

   nRouDiv           := nRouDiv( cDivPgo, cDbfDiv )
   cPorDiv           := cPorDiv( cDivPgo, cDbfDiv )

   if lRecCob

      if nTotCob == 0
         nTotCob     := Round( nTotRec, nRouDiv )
      else
         nTotCob     := Round( nTotCob, nRouDiv )
      end

   else

      nTotCob        := 0

   end

   if cDivRet <> cDivPgo
      nRouDiv        := nRouDiv( cDivRet, cDbfDiv )
      cPorDiv        := cPorDiv( cDivRet, cDbfDiv )
      nTotCob        := nCnv2Div( nTotRec, cDivPgo, cDivRet, cDbfDiv )
   end

RETURN if( lPic, Trans( nTotCob, cPorDiv ), nTotCob )



function nTotGasCli( uFacCliP, uDiv, cDivRet, lPic )

   local cDivPgo
   local nRouDiv
   local cPorDiv
   local nTotRec
   local nTotCob
   local lRecCob
   local cDbfDiv

   IIF( cDivRet == nil, cDivRet := cDivEmp(), ) ;
   IIF( lPic == nil, lPic := .F., ) ;

   if ValType( uFacCliP ) == "O"
      cDivPgo        := uFacCliP:cDivPgo
      nTotRec        := uFacCliP:nImporte
      nTotCob        := uFacCliP:nImpCob
      lRecCob        := uFacCliP:lCobrado
   else
      cDivPgo        := ( uFacCliP )->cDivPgo
      nTotRec        := ( uFacCliP )->nImporte
      nTotCob        := ( uFacCliP )->nImpCob
      lRecCob        := ( uFacCliP )->lCobrado
   end

   if ValType( uDiv ) == "O"
      cDbfDiv        := uDiv:cAlias
   else
      cDbfDiv        := uDiv
   end

   nRouDiv           := nRouDiv( cDivPgo, cDbfDiv )
   cPorDiv           := cPorDiv( cDivPgo, cDbfDiv )

   if lRecCob

      if nTotCob <> 0
         nTotRec     -= nTotCob
         nTotRec     := Round( nTotRec, nRouDiv )
      else
         nTotRec     := 0
      end

   else

      nTotRec        := 0

   end

   if cDivRet <> cDivPgo
      nRouDiv        := nRouDiv( cDivRet, cDbfDiv )
      cPorDiv        := cPorDiv( cDivRet, cDbfDiv )
      nTotRec        := nCnv2Div( nTotRec, cDivPgo, cDivRet, cDbfDiv )
   end

RETURN if( lPic, Trans( nTotRec, cPorDiv ), nTotRec )



function nImpRecCli( cFacCliP, cDbfDiv )

   local cImp

   IIF( cFacCliP == nil, cFacCliP := dbfFacCliP, ) ;
   IIF( cDbfDiv == nil, cDbfDiv := dbfDiv, ) ;

   if ( cFacCliP )->lImpEur
      cImp           := nTotRecCli( cFacCliP, cDbfDiv, "EUR", .T. )
   else
      cImp           := nTotRecCli( cFacCliP, cDbfDiv, cDivEmp(), .T. )
   end

RETURN ( cImp )



function cTxtRecCli( cFacCliP, cDbfDiv )

   local cImp
   local lMas        := .T.

   IIF( cFacCliP == nil, cFacCliP := dbfFacCliP, ) ;
   IIF( cDbfDiv == nil, cDbfDiv := dbfDiv, ) ;

   if ( cFacCliP )->lImpEur
      lMas           := lMasDiv( "EUR", dbfDiv )
      cImp           := Num2Text( nTotRecCli( cFacCliP, cDbfDiv, "EUR", .F. ), lMas )
   else
      lMas           := lMasDiv( ( cFacCliP )->cDivPgo, cDbfDiv )
      cImp           := Num2Text( nTotRecCli( cFacCliP, cDbfDiv, ( cFacCliP )->cDivPgo, .F. ), lMas )
   end

RETURN ( cImp )



Function cCtaRecCli( cFacCliP, cBncCli )

   IIF( cFacCliP == nil, cFacCliP := dbfFacCliP, ) ;
   IIF( cBncCli == nil, cBncCli := dbfBncCli, ) ;

Return ( cClientCuenta( ( cFacCliP )->cCodCli, cBncCli ) )






function SynRecCli( cPath )

   local oBlock
   local oError
   local nTotFac
   local nTotRec
   local dbfFacCliT
   local dbfFacCliP
   local dbfFacCliL
   local dbfAntCliT
   local dbfFacRecT
   local dbfFacRecL
   local dbfDiv
   local dbfIva
   local dbfClient
   local dbfFPago

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPath + "FACCLIT.DBF" ), ( cCheckArea( "FacCliT", @dbfFacCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   ( dbfFacCliT )->( ordListAdd( ( cPath + "FACCLIT.CDX" ) ) )

   dbUseArea( .T., ( cDriver() ), ( cPath + "FACCLIL.DBF" ), ( cCheckArea( "FacCliL", @dbfFacCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   ( dbfFacCliL )->( ordListAdd( ( cPath + "FACCLIL.CDX" ) ) )

   dbUseArea( .T., ( cDriver() ), ( cPath + "FACCLIP.DBF" ), ( cCheckArea( "FacCliP", @dbfFacCliP ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   ( dbfFacCliP )->( ordListAdd( ( cPath + "FACCLIP.CDX" ) ) )

   dbUseArea( .T., ( cDriver() ), ( cPath + "AntCliT.DBF" ), ( cCheckArea( "AntCliT", @dbfAntCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   ( dbfAntCliT )->( ordListAdd( ( cPath + "AntCliT.CDX" ) ) )

   dbUseArea( .T., ( cDriver() ), ( cPath + "FACRECT.DBF" ), ( cCheckArea( "FacRecT", @dbfFacRecT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   ( dbfFacRecT )->( ordListAdd( ( cPath + "FacRecT.CDX" ) ) )

   dbUseArea( .T., ( cDriver() ), ( cPath + "FACRECL.DBF" ), ( cCheckArea( "FacRecL", @dbfFacRecL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   ( dbfFacRecL )->( ordListAdd( ( cPath + "FacRecL.CDX" ) ) )

   dbUseArea( .T., ( cDriver() ), ( cPatCli() + "CLIENT.DBF" ), ( cCheckArea( "Client", @dbfClient ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   ( dbfClient )->( ordListAdd( ( cPatCli() + "CLIENT.CDX" ) ) )

   dbUseArea( .T., ( cDriver() ), ( cPatGrp() + "FPAGO.DBF" ), ( cCheckArea( "FPagO", @dbfFPago ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   ( dbfFPago )->( ordListAdd( ( cPatGrp() + "FPAGO.CDX" ) ) )

   dbUseArea( .T., ( cDriver() ), ( cPatDat() + "DIVISAS.DBF" ), ( cCheckArea( "Divisas", @dbfDiv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   ( dbfDiv )->( ordListAdd( ( cPatDat() + "DIVISAS.CDX" ) ) )

   dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIVA.DBF" ), ( cCheckArea( "TIva", @dbfIva ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   ( dbfIva )->( ordListAdd( ( cPatDat() + "TIVA.CDX" ) ) )

   ( dbfFacCliP )->( dbGoTop() )
   while !( dbfFacCliP )->( eof() )



      if ( dbfFacCliP )->nImpCob == 0 .AND. ( dbfFacCliP )->lCobrado
         if dbLock( dbfFacCliP )
            ( dbfFacCliP )->nImpCob := ( dbfFacCliP )->nImporte
            ( dbfFacCliP )->( dbUnLock() )
         end
      end

      if Empty( ( dbfFacCliP )->cTurRec )
         if dbLock( dbfFacCliP )
            ( dbfFacCliP )->cTurRec := RetFld( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac, dbfFacCliT, "cTurFac" )
            ( dbfFacCliP )->( dbUnLock() )
         end
      end

      if !( ( dbfFacCliP )->cSerie >= "A" .AND. ( dbfFacCliP )->cSerie <= "Z" )
         if dbLock( dbfFacCliP )
            ( dbfFacCliP )->( dbDelete() )
            ( dbfFacCliP )->( dbUnLock() )
         end
      end

      if Empty( ( dbfFacCliP )->cNomCli )
         if dbLock( dbfFacCliP )
            ( dbfFacCliP )->cNomCli := retClient( ( dbfFacCliP )->cCodCli, dbfClient )
            ( dbfFacCliP )->( dbUnLock() )
         end
      end

      if Empty( ( dbfFacCliP )->cCodCaj )

         if dbLock( dbfFacCliP )

            if ( dbfFacCliP )->cTipRec == "R"
               ( dbfFacCliP )->cCodCaj := RetFld( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac, dbfFacRecT, "CCODCAJ" )
            else
               ( dbfFacCliP )->cCodCaj := RetFld( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac, dbfFacCliT, "CCODCAJ" )
            end

            ( dbfFacCliP )->( dbUnLock() )

         end

      end

      if Empty( ( dbfFacCliP )->cCodUsr )

         if dbLock( dbfFacCliP )

            if ( dbfFacCliP )->cTipRec == "R"
               ( dbfFacCliP )->cCodUsr := RetFld( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac, dbfFacRecT, "CCODUSR" )
            else
               ( dbfFacCliP )->cCodUsr := RetFld( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac, dbfFacCliT, "CCODUSR" )
            end

            ( dbfFacCliP )->( dbUnLock() )

         end

      end

      ( dbfFacCliP )->( dbSkip() )

   end

   ( dbfFacCliT )->( dbGoTop() )
   while !( dbfFacCliT )->( eof() )



      nTotFac  := nTotFacCli( ( dbfFacCliT )->cSerie + Str( ( dbfFacCliT )->nNumFac ) + ( dbfFacCliT )->cSufFac, dbfFacCliT, dbfFacCliL, dbfIva, dbfDiv, dbfFacCliP, dbfAntCliT, nil, nil, .F. )
      nTotRec  := nPagFacCli( ( dbfFacCliT )->cSerie + Str( ( dbfFacCliT )->nNumFac ) + ( dbfFacCliT )->cSufFac, dbfFacCliT, dbfFacCliP, dbfIva, dbfDiv, nil, .F. )



      if abs( nTotFac ) > abs( nTotRec )
         GenPgoFacCli( ( dbfFacCliT )->cSerie + Str( ( dbfFacCliT )->nNumFac ) + ( dbfFacCliT )->cSufFac, dbfFacCliT, dbfFacCliL, dbfFacCliP, dbfAntCliT, dbfClient, dbfFPago, dbfDiv, dbfIva, 1, .F. )
      end

      ChkLqdFacCli( nil, dbfFacCliT, dbfFacCliL, dbfFacCliP, dbfAntCliT, dbfIva, dbfDiv )

      ( dbfFacCliT )->( dbSkip() )

      SysRefresh()

   end





   ( dbfFacRecT )->( dbGoTop() )

   while !( dbfFacRecT )->( eof() )



      nTotFac  := nTotFacRec( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, dbfFacRecT, dbfFacRecL, dbfIva, dbfDiv )
      nTotRec  := nPagFacRec( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfIva, dbfDiv )



      if abs( nTotFac ) > abs( nTotRec )
         GenPgoFacRec( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfClient, dbfFPago, dbfDiv, dbfIva, 1, .F. )
      end

      ChkLqdFacRec( nil, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfIva, dbfDiv )

      ( dbfFacRecT )->( dbSkip() )

      SysRefresh()

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfFacCliT )->( dbCloseArea() )
   ( dbfFacCliL )->( dbCloseArea() )
   ( dbfFacCliP )->( dbCloseArea() )
   ( dbfAntCliT )->( dbCloseArea() )
   ( dbfFacRecT )->( dbCloseArea() )
   ( dbfFacRecL )->( dbCloseArea() )
   ( dbfDiv     )->( dbCloseArea() )
   ( dbfIva     )->( dbCloseArea() )
   ( dbfClient  )->( dbCloseArea() )
   ( dbfFPago   )->( dbCloseArea() )

return nil























FUNCTION EdmRecCli( cCodRut, cPathTo, oStru )

   local oBlock
   local oError
   local n           := 0
   local cChr
   local cCod
   local fTar
   local cFilEdm
   local cFilOdb
   local nWrote
   local nRead
   local dbfFacCliP
   local dbfFacCliT

   IIF( cCodRut == nil, cCodRut := "001", ) ;
   IIF( cPathTo == nil, cPathTo := "C:\INTERS~1\", ) ;

   cCodRut           := SubStr( cCodRut, -3 )

   cFilEdm           := cPathTo + "EPEND" + cCodRut + ".TXT"
   cFilOdb           := cPathTo + "EPEND" + cCodRut + ".ODB"





   if file( cFilEdm )
      fErase( cFilEdm )
   end

   fTar              := fCreate( cFilEdm )





   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACCLIP.DBF" ), ( cCheckArea( "FACCLIP", @dbfFacCliP ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "FACCLIP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACCLIT.DBF" ), ( cCheckArea( "FACCLIT", @dbfFacCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "FACCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   oStru:oMetUno:cText   := "Pendientes de cobro"
   oStru:oMetUno:SetTotal( ( dbfFacCliP )->( LastRec() ) )

   WHILE !(dbfFacCliP)->( eof() )

      if !( dbfFacCliP )->lCobrado .AND. (dbfFacCliP)->nImporte <> 0

         cChr  := "+"
         cCod  := cCliFacCli( (dbfFacCliP)->CSERIE + Str( (dbfFacCliP)->NNUMFAC ) + (dbfFacCliP)->CSUFFAC, dbfFacCliT )
         cChr  += EdmRjust( cCod, "0", 7 )
         cChr  += EdmSubStr( (dbfFacCliP)->DPRECOB, 1, 10 )
         cCod  := cAgeFacCli( (dbfFacCliP)->CSERIE + Str( (dbfFacCliP)->NNUMFAC ) + (dbfFacCliP)->CSUFFAC, dbfFacCliT )
         cChr  += EdmRjust( Right( cCod, 3 ) + "/" + AllTrim( Str( (dbfFacCliP)->nNumFac ) ), 1, 10 )
         cChr  += EdmSubStr( Trans( (dbfFacCliP)->nImporte / (dbfFacCliP)->nVdvPgo, "99999999" ) )
         cChr  += "1"
         cChr  += Chr(13)+Chr(10)

      end

      nWrote:= fwrite( fTar, cChr, nRead )

      oStru:oMetUno:Set( ++n )







      (dbfFacCliP)->( dbSkip() )

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfFacCliP )->( dbCloseArea() )
   ( dbfFacCliT )->( dbCloseArea() )
   fClose( fTar )

   if file( FullCurDir() + "CONVER.EXE" )
      WinExec( FullCurDir() + "CONVER.EXE " + cFilEdm + " " + cFilOdb + " 44 -x", 6 )
   end

RETURN NIL

































FUNCTION EdmCobCli( cCodRut, cPathTo, oStru, aSucces )

   local oBlock
   local oError
   local cLine
   local cFilEdm
   local oFilEdm
   local dFecDoc
   local cCodCli
   local nImpDoc
   local cNumDoc
   local nNumDoc
   local nNewCon
   local cNumFac
   local cTipDoc
   local cCodPgo     := ""
   local cCtaRec     := ""
   local dbfAlbCliT

   IIF( cCodRut == nil, cCodRut := "001", ) ;
   IIF( cPathTo == nil, cPathTo := "C:\INTERS~1\", ) ;

   cCodRut           := SubStr( cCodRut, -3 )

   cFilEdm           := cPathTo + "COBRO" + cCodRut + ".PSI"

   if !file( cFilEdm )
      msgWait( "No existe el fichero " + Rtrim( cFilEdm ), "Atención", 1 )
      return nil
   end

   oFilEdm           := TTxtFile():New( cFilEdm )

   OpenFiles()

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBCLIT.DBF" ), ( cCheckArea( "ALBCLIT", @dbfAlbCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   oStru:oMetDos:cText   := "Gestión de cobros"
   oStru:oMetDos:SetTotal( oFilEdm:nTLines )

   cLine             := oFilEdm:cLine

   while ! oFilEdm:lEoF()

      cCodCli        := SubStr( cLine,  1,  7 )
      cNumDoc        := SubStr( cLine,  8, 10 )
      nNumDoc        := Val( StrTran( cNumDoc, "/", "" ) )
      nImpDoc        := Val( SubStr( cLine, 29, 10 ) )
      dFecDoc        := Ctod( SubStr( cLine, 39, 10 ) )
      cTipDoc        := SubStr( cLine, 49,  1 )





      if ( dbfClient )->( dbSeek( cCodCli  ) )

         cNumFac     := RetFld( ( dbfClient )->Serie + Str( nNumDoc, 9 ) + RetSufEmp(), dbfAlbCliT, "cNumFac" )
         if !Empty( cNumFac )

            if cTipDoc $ "TM"

               if nChkPagFacCli( cNumFac, dbfFacCliT, dbfFacCliP ) <> 1

                  if ( dbfFacCliT )->( dbSeek( cNumFac ) )

                     cCodPgo     := RetFld( ( dbfFacCliT )->cCodCli, dbfClient, "CODPAGO" )
                     if !Empty( cCodPgo )
                        cCtaRec  := RetFld( cCodPgo, dbfFPago, "CCTACOBRO" )
                     end

                     nNewCon                    := nNewReciboCliente( ( dbfFacCliT )->cSerie + Str( ( dbfFacCliT )->nNumFac ) + ( dbfFacCliT )->cSufFac, Space( 1 ), dbfFacCliP )

                     ( dbfFacCliP )->( dbAppend() )
                     ( dbfFacCliP )->cSerie     := ( dbfFacCliT )->cSerie
                     ( dbfFacCliP )->nNumFac    := ( dbfFacCliT )->nNumFac
                     ( dbfFacCliP )->cSufFac    := ( dbfFacCliT )->cSufFac
                     ( dbfFacCliP )->nNumRec    := nNewCon
                     ( dbfFacCliP )->cCodCli    := ( dbfFacCliT )->cCodCli
                     ( dbfFacCliP )->cNomCli    := ( dbfFacCliT )->cNomCli
                     ( dbfFacCliP )->dEntrada   := dFecDoc
                     ( dbfFacCliP )->nImporte   := nImpDoc
                     ( dbfFacCliP )->cDescrip   := "Recibo nº" + Str( nNewCon, 2 ) + " de factura  " + ( dbfFacCliP )->cSerie + "/" + Alltrim( Str( ( dbfFacCliP )->nNumFac ) ) + "/" + ( dbfFacCliP )->cSufFac + "-" + Str( ( dbfFacCliP )->nNumRec )
                     ( dbfFacCliP )->dPreCob    := dFecDoc
                     ( dbfFacCliP )->lCobrado   := .T.
                     ( dbfFacCliP )->cTurRec    := cCurSesion()
                     ( dbfFacCliP )->cDivPgo    := cDivEmp()
                     ( dbfFacCliP )->nVdvPgo    := 1
                     ( dbfFacCliP )->cCtaRec    := cCtaRec
                     ( dbfFacCliP )->cCtaRem    := RetFld( ( dbfFacCliT )->cCodCli, dbfClient, "cCodRem" )
                     ( dbfFacCliP )->lRecImp    := .F.
                     ( dbfFacCliP )->dFecCre     := GetSysDate()
                     ( dbfFacCliP )->cHorCre     := SubStr( Time(), 1, 5 )

                     ChkLqdFacCli( nil, dbfFacCliT, dbfFacCliL, dbfFacCliP, dbfAntCliT, dbfIva, dbfDiv, .F. )

                     aAdd( aSucces, { .F., "Nuevo recibo de clientes " + ( dbfFacCliP )->cSerie + "/" + Str( ( dbfFacCliP )->nNumFac ) + "/" + ( dbfFacCliP )->cSufFac + "/" + Str( ( dbfFacCliP )->nNumRec ) } )

                  else

                     aAdd( aSucces, { .F., "Factura de clientes no existe " + ( dbfClient )->Serie + "/" + Str( nNumDoc, 9 ) + "/" + RetSufEmp() + " en recibo " + cNumDoc } )

                  end

               else

                  aAdd( aSucces, { .F., "Factura ya liquidada " + ( dbfFacCliT )->cSerie + Str( ( dbfFacCliT )->nNumFac ) + ( dbfFacCliT )->cSufFac + " en recibo " + cNumDoc } )

               end

            end

         else

            aAdd( aSucces, { .F., "Albarán " + ( dbfClient )->Serie + Str( nNumDoc, 9 ) + RetSufEmp() + "no facturado" } )

         end

      else

         aAdd( aSucces, { .F., "No existe cliente " + cCodCli + " en recibo " + cNumDoc } )

      end

      oFilEdm:Skip()

      oStru:oMetDos:SetTotal( oFilEdm:nLine )

      cLine    := oFilEdm:cLine

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   CloseFiles()
   ( dbfAlbCliT )->( dbCloseArea() )

   oFilEdm:Close()

RETURN ( aSucces )



static function lGenRecCli( oBrw, oBtn, nDevice )

   local bAction
   local nOrdAnt     := ( dbfDoc )->( OrdSetFocus( "cTipo" ) )

   IIF( nDevice == nil, nDevice := 1, ) ;

   IF !( dbfDoc )->( dbSeek( "RF" ) )








      oWndBrw:NewAt( "DOCUMENT",,, {||( msgStop( "No hay recibos de clientes predefinidos" ) )}, "No hay documentos", "N",,, 4, oBtn, .F. )

   ELSE

      WHILE ( dbfDoc )->CTIPO == "RF" .AND. !( dbfDoc )->( eof() )

         bAction  := bGenRecCli( nDevice, ( dbfDoc )->CODIGO, "Imprimiendo recibos de clientes" )

         oWndBrw:NewAt( "Document", , , bAction, Rtrim( ( dbfDoc )->cDescrip ) , , , , , oBtn )

         ( dbfDoc )->( dbSkip() )

      end

   end

   ( dbfDoc )->( OrdSetFocus( nOrdAnt ) )

return nil



static function bGenRecCli( nDevice, cCodDoc, cTitle )

   local nDev  := by( nDevice )
   local cCod  := by( cCodDoc   )
   local cTit  := by( cTitle    )

return {|| ImpPago( nil, nDev, cCod, cTit ) }



FUNCTION BrwRecCli( uGet, dbfFacCliP, dbfClient, dbfDiv, oBandera )

    local oDlg
    local oBrw
    local aGet1
    local cGet1
   local nOrd        := GetBrwOpt( "BrwRecCli" )
    local nOrdAnt
    local oCbxOrd
   local cCbxOrd






   local aCbxOrd     := {  "Número", "Código cliente", "Nombre cliente", "Fecha expedición", "Fecha vencimiento", "Fecha cobro", "Importe" }

   nOrd              := Min( Max( nOrd, 1 ), len( aCbxOrd ) )
   cCbxOrd           := aCbxOrd[ nOrd ]

   nOrdAnt           := ( dbfFacCliP )->( OrdSetFocus( nOrd ) )

   ( dbfFacCliP )->( dbSetFilter( {|| !Field->lCobrado }, "!lCobrado" ) )
   ( dbfFacCliP )->( dbGoTop() )

   oDlg = TDialog():New(,,,, "Recibos de clientes", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F., )







        aGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,, "@!", {||    ( OrdClearScope( oBrw, dbfFacCliP ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfFacCliP, .F. ) ) }, .F., .F.,,,,,, nil, "FIND",, )






        oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( dbfFacCliP )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:Refresh(), aGet1:SetFocus() )},,,, .F.,,,,,, )

      oBrw                    := IXBrowse():New( oDlg )

      oBrw:bClrSel            := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus       := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias             := dbfFacCliP
      oBrw:cName              := "Browse de recibos de cliente"
      oBrw:bLDblClick         := {|| oDlg:end( 1 ) }

      oBrw:nMarqueeStyle      := 5

      oBrw:CreateFromResource( 105 )

      with object ( oBrw:AddCol() )
         :cHeader             := "Cn. Contabilizado"
         :bStrData            := {|| "" }
         :bEditValue          := {|| ( dbfFacCliP )->lConPgo }
         :nWidth              := 20
         :SetCheck( { "Sel16", "Nil16" } )
      end

      with object ( oBrw:AddCol() )
         :cHeader             := "Co. Cobrado"
         :bStrData            := {|| "" }
         :bEditValue          := {|| ( dbfFacCliP )->lCobrado }
         :nWidth              := 20
         :SetCheck( { "Sel16", "Cnt16" } )
      end

      with object ( oBrw:AddCol() )
         :cHeader             := "Número"
         :bEditValue          := {|| ( dbfFacCliP )->cSerie + "/" + AllTrim( Str( ( dbfFacCliP )->nNumFac ) ) + "/" + ( dbfFacCliP )->cSufFac + "-" + Str( ( dbfFacCliP )->nNumRec ) }
         :nWidth              := 95
      end

      with object ( oBrw:AddCol() )
         :cHeader             := "Código cliente"
         :bEditValue          := {|| ( dbfFacCliP )->cCodCli }
         :nWidth              := 80
      end

      with object ( oBrw:AddCol() )
         :cHeader             := "Nombre cliente"
         :bEditValue          := {|| ( dbfFacCliP )->cNomCli }
         :nWidth              := 170
      end

      with object ( oBrw:AddCol() )
         :cHeader             := "Importe " + cDivEmp()
         :bEditValue          := {|| nTotRecCli( dbfFacCliP, dbfDiv, cDivEmp(), .T. ) }
         :nWidth              := 85
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
      end

      with object ( oBrw:AddCol() )
         :cHeader             := "Div."
         :bEditValue          := {|| cSimDiv( ( dbfFacCliP )->cDivPgo, dbfDiv ) }
         :nWidth              := 30
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
      end

      with object ( oBrw:AddCol() )
         :cHeader             := "Descripción"
         :bEditValue          := {|| ( dbfFacCliP )->cDescrip }
         :nWidth              := 150
         :lHide               := .T.
      end

      with object ( oBrw:AddCol() )
         :cHeader             := "Fecha expedición"
         :bEditValue          := {|| Dtoc( ( dbfFacCliP )->dPreCob ) }
         :nWidth              := 80
         :lHide               := .T.
      end

      with object ( oBrw:AddCol() )
         :cHeader             := "Fecha vencimiento"
         :bEditValue          := {|| Dtoc( ( dbfFacCliP )->dFecVto ) }
         :nWidth              := 80
         :lHide               := .T.
      end

      with object ( oBrw:AddCol() )
         :cHeader             := "Fecha cobro"
         :bEditValue          := {|| Dtoc( ( dbfFacCliP )->dEntrada ) }
         :nWidth              := 80
         :lHide               := .T.
      end




        TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )





      TButton():ReDefine( 500,, oDlg,,, .F., {||     ( .F. )},,, .F. )




        TButton():ReDefine( 501,, oDlg,,, .F., {||     ( .F. )},,, .F. )
   oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
   oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|oBrw:Load()}, oDlg:bRClicked,,, )

   SetBrwOpt( "BrwRecCli", ( dbfFacCliP )->( OrdNumber() ) )

   if oDlg:nResult == 1

      if ValType( uGet ) == "O"
         uGet:cText( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ) )
         uGet:lValid()
         uGet:SetFocus()
      elseif ValType( uGet ) == "C"
         uGet     := ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec )
      end

   end





   OrdClearScope( nil, dbfFacCliP )

   ( dbfFacCliP )->( dbClearFilter() )

   ( dbfFacCliP )->( OrdSetFocus( nOrdAnt ) )





   oBrw:CloseData()

RETURN ( oDlg:nResult == 1 )



FUNCTION aCalRecCli()

   local aCalRecCli  := {}

   aAdd( aCalRecCli, {"nImpRecCli( cDbfRec, cDbfDiv )", "N", 16, 6, "Importe del recibo", "cPorDivRec",  "", "" } )
   aAdd( aCalRecCli, {"cTxtRecCli( cDbfRec, cDbfDiv )", "C",100, 0, "Importe en letras",  "",            "", "" } )
   aAdd( aCalRecCli, {"nTotFac",                        "N", 16, 6, "Total factura",      "cPorDivRec",  "", "" } )

return ( aCalRecCli )



FUNCTION aDocRecCli()

   local aDoc  := {}





   aAdd( aDoc, { "Empresa",         "EM" } )
   aAdd( aDoc, { "Recibo",          "RF" } )
   aAdd( aDoc, { "Factura",         "FC" } )
   aAdd( aDoc, { "Cliente",         "CL" } )
   aAdd( aDoc, { "Formas de pago",  "PG" } )

RETURN ( aDoc )



static function lLiquida( oBrw )

   if !( dbfFacCliP )->lCobrado
      if ( dbfFacCliP )->( dbRLock() )
         ( dbfFacCliP )->lCobrado   := .T.
         ( dbfFacCliP )->dEntrada   := GetSysDate()
         ( dbfFacCliP )->cTurRec    := cCurSesion()
         ( dbfFacCliP )->( dbUnLock() )
      end
   else
      msgStop( "Recibo ya pagado" )
   end

   if oBrw <> nil
      oBrw:Refresh()
   end

return nil







FUNCTION GenPgoFacRec( cNumFac, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfCli, dbfFPago, dbfDiv, dbfIva, nMode, lMessage )

   local cCodPgo
   local cSerFac
   local nNumFac
   local cSufFac
   local cDivFac
   local nVdvFac
   local dFecFac
   local cCodCli
   local cNomCli
   local cCodAge
   local cCodCaj
   local cCodUsr
   local cCtaRem     := ""
   local nCobro      := 0
   local nTotal      := 0
   local nTotCob     := 0
   local nDec        := 0
   local nInc        := 0
   local nTotAcu     := 0
   local n           := 0
   local nPlazos     := 0
   local nRecCli
   local cBanco
   local cEntidad
   local cSucursal
   local cControl
   local cCuenta

   IIF( nMode == nil, nMode := 1, ) ;
   IIF( lMessage == nil, lMessage := .T., ) ;

   cSerFac           := ( dbfFacRecT )->cSerie
   nNumFac           := ( dbfFacRecT )->nNumFac
   cSufFac           := ( dbfFacRecT )->cSufFac
   cDivFac           := ( dbfFacRecT )->cDivFac
   nVdvFac           := ( dbfFacRecT )->nVdvFac
   dFecFac           := ( dbfFacRecT )->dFecFac
   cCodPgo           := ( dbfFacRecT )->cCodPago
   cCodCli           := ( dbfFacRecT )->cCodCli
   cNomCli           := ( dbfFacRecT )->cNomCli
   cCodAge           := ( dbfFacRecT )->cCodAge
   cCodCaj           := ( dbfFacRecT )->cCodCaj
   cCodUsr           := ( dbfFacRecT )->cCodUsr
   cBanco            := ( dbfFacRecT )->cBanco
   cEntidad          := ( dbfFacRecT )->cEntBnc
   cSucursal         := ( dbfFacRecT )->cSucBnc
   cControl          := ( dbfFacRecT )->cDigBnc
   cCuenta           := ( dbfFacRecT )->cCtaBnc





   nRecCli           := ( dbfCli )->( Recno() )

   if ( dbfCli )->( dbSeek( cCodCli ) )
      cCtaRem        := ( dbfCli )->cCodRem
   end





   nDec              := nRouDiv( cDivFac, dbfDiv )





   nTotal            := nTotFacRec( cNumFac, dbfFacRecT, dbfFacRecL, dbfIva, dbfDiv, nil, nil, .F. )
   nTotCob           := nPagFacRec( cNumFac, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfIva, dbfDiv, nil, .F. )

   if nTotal <> nTotCob





      if ( dbfFacCliP )->( dbSeek( cSerFac + Str( nNumFac ) + cSufFac ) )

         while cSerFac + Str( nNumFac ) + cSufFac == ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac .AND. !( dbfFacCliP )->( eof() )

            if !Empty( ( dbfFacCliP )->cTipRec )

               if !( dbfFacCliP )->lCobrado .AND. dbLock( dbfFacCliP )
                  ( dbfFacCliP )->( dbDelete() )
                  ( dbfFacCliP )->( dbUnLock() )
               else
                  nInc  := ( dbfFacCliP )->nNumRec
               end

            end

            ( dbfFacCliP )->( dbSkip() )

         end

      end





      nTotal         -= nPagFacRec( cSerFac + Str( nNumFac ) + cSufFac, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfIva, dbfDiv, nil, .T. )





      if ( dbfFPago )->( dbSeek( cCodPgo ) )

         nTotAcu        := nTotal
         nPlazos        := Max( ( dbfFPago )->nPlazos, 1 )

         for n := 1 to nPlazos

            if n <> nPlazos
               nTotAcu  -= Round( nTotal / nPlazos, nDec )
            end

            ( dbfFacCliP )->( dbAppend() )

            ( dbfFacCliP )->cSerie        := cSerFac
            ( dbfFacCliP )->nNumFac       := nNumFac
            ( dbfFacCliP )->cSufFac       := cSufFac
            ( dbfFacCliP )->nNumRec       := ++nInc
            ( dbfFacCliP )->cTipRec       := "R"
            ( dbfFacCliP )->cCodCaj       := cCodCaj
            ( dbfFacCliP )->cCodUsr       := cCodUsr
            ( dbfFacCliP )->cTurRec       := cCurSesion()
            ( dbfFacCliP )->cCodCli       := cCodCli
            ( dbfFacCliP )->cNomCli       := cNomCli

            if ( dbfFPago )->lUtlBnc
               ( dbfFacCliP )->cBncEmp    := ( dbfFPago )->cBanco
               ( dbfFacCliP )->cEntEmp    := ( dbfFPago )->cEntBnc
               ( dbfFacCliP )->cSucEmp    := ( dbfFPago )->cSucBnc
               ( dbfFacCliP )->cDigEmp    := ( dbfFPago )->cDigBnc
               ( dbfFacCliP )->cCtaEmp    := ( dbfFPago )->cCtaBnc
            end

            ( dbfFacCliP )->cBncCli       := cBanco
            ( dbfFacCliP )->cEntCli       := cEntidad
            ( dbfFacCliP )->cSucCli       := cSucursal
            ( dbfFacCliP )->cDigCli       := cControl
            ( dbfFacCliP )->cCtaCli       := cCuenta

            ( dbfFacCliP )->nImporte      := if( n <> nPlazos, Round( nTotal / nPlazos, nDec ), Round( nTotAcu, nDec ) )
            ( dbfFacCliP )->nImpCob       := if( n <> nPlazos, Round( nTotal / nPlazos, nDec ), Round( nTotAcu, nDec ) )
            ( dbfFacCliP )->cDescrip      := "Recibo nº" + AllTrim( Str( nInc ) ) + " de factura rectificativa " + cSerFac  + "/" + allTrim( Str( nNumFac )  ) + "/" + cSufFac
            ( dbfFacCliP )->cDivPgo       := cDivFac
            ( dbfFacCliP )->nVdvPgo       := nVdvFac
            ( dbfFacCliP )->dPreCob       := dFecFac
            ( dbfFacCliP )->dFecVto       := dNexDay( dFecFac + ( dbfFPago )->nPlaUno + ( ( dbfFPago )->nDiaPla * ( n - 1 ) ), dbfCli )
            ( dbfFacCliP )->cCtaRec       := ( dbfFPago )->cCtaCobro
            ( dbfFacCliP )->cCtaGas       := ( dbfFPago )->cCtaGas
            ( dbfFacCliP )->cCtaRem       := cCtaRem
            ( dbfFacCliP )->cCodAge       := cCodAge
            ( dbfFacCliP )->lEsperaDoc    := ( dbfFPago )->lEsperaDoc

            if ( dbfFPago )->nCobRec == 1 .AND. nMode == 1
               ( dbfFacCliP )->lCobrado   := .T.
               ( dbfFacCliP )->cTurRec    := cCurSesion()
               ( dbfFacCliP )->dEntrada   := dNexDay( dFecFac + ( dbfFPago )->nPlaUno + ( ( dbfFPago )->nDiaPla * ( n - 1 ) ), dbfCli )
            end

            ( dbfFacCliP )->dFecCre       := GetSysDate()
            ( dbfFacCliP )->cHorCre       := SubStr( Time(), 1, 5 )

            ( dbfFacCliP )->( dbUnLock() )





            if ( dbfFacCliP )->lCobrado
               DelRiesgo( ( dbfFacCliP )->nImporte, ( dbfFacCliP )->cCodCli, dbfCli )
            end

         next

      else

         if lMessage
            MsgStop( "Forma de pago no encontrada" )
         end

      end

   end

   ( dbfCli )->( dbGoTo( nRecCli ) )

RETURN NIL



Static Function EdtRecMenu( aTmp, oDlg )

   oMenu := MenuBegin( .F.,,, .F., .F. )

      MenuAddItem( "&1. Rotor",, .F.,,,,,,,,, .F.,,, .F. )

         MenuBegin( .F.,,, .F., .F. )




            MenuAddItem( "&1. Modificar factura", "Modificar la factura que creó el recibo", .F.,, {|oMenuItem|( EdtFacCli( aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ] ) )},, "Document_user1_16",,,,, .F.,,, .F. )

            MenuAddItem()




            MenuAddItem( "&2. Modificar cliente", "Modifica la ficha del cliente", .F.,, {|oMenuItem|( if( !Empty( aTmp[ 9 ] ), EdtCli( aTmp[ 9 ] ), MsgStop( "Código de cliente vacío" ) ) )},, "User1_16",,,,, .F.,,, .F. )





            MenuAddItem( "&3. Informe de cliente", "Informe de cliente", .F.,, {|oMenuItem|( if( !Empty( aTmp[ 9 ] ), InfCliente( aTmp[ 9 ] ), MsgStop( "Código de cliente vacío" ) ) )},, "Info16",,,,, .F.,,, .F. )
         MenuEnd()

   MenuEnd()

   oDlg:SetMenu( oMenu )

RETURN ( oMenu )



Static Function EndEdtRecMenu()

Return( oMenu:End() )



Function EdtRecCli( cNumFac, lOpenBrowse, lRectificativa )

   local nLevel            := nLevelUsr( "01059" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;
   IIF( lRectificativa == nil, lRectificativa := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 4 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if RecCli()
         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacCliP )
            oWndBrw:RecEdit()
         else
            MsgStop( "No se encuentra recibo" )
         end
      end

   else

      if OpenFiles( .T. )

         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacCliP )
            WinEdtRec( nil, bEdit, dbfFacCliP, lRectificativa )
         else
            MsgStop( "No se encuentra recibo" + str( len( cNumFac ) ) )
         end

         CloseFiles()

      end

   end

Return .T.



FUNCTION ZooRecCli( cNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01059" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 8 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if RecCli()
         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacCliP )
            oWndBrw:RecZoom()
         else
            MsgStop( "No se encuentra recibo" )
         end
      end

   else

      if OpenFiles( .T. )
         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacCliP )
            WinZooRec( nil, bEdit, dbfFacCliP )
         end
         CloseFiles()
      end

   end

Return .T.



FUNCTION DelRecCli( cNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01059" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 16 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if RecCli()
         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacCliP )
            oWndBrw:RecDel()
         else
            MsgStop( "No se encuentra factura" )
         end
      end

   else

      if OpenFiles( .T. )

         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacCliP )
            DelCobCli( nil, dbfFacCliP )
         end

         CloseFiles()

      end

   end

Return .T.



FUNCTION PrnRecCli( cNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01059" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 32 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if RecCli()
         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacCliP )
            ImpPago( nil, 1 )
         else
            MsgStop( "No se encuentra recibo" )
         end
      end

   else

      if OpenFiles( .T. )

         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacCliP )
            ImpPago( nil, 1 )
         end

         CloseFiles()

      end

   end

Return .T.



FUNCTION VisRecCli( cNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01059" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 32 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if RecCli()
         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacCliP )
            ImpPago( nil, 2 )
         else
            MsgStop( "No se encuentra recibo" )
         end
      end

   else

      if OpenFiles( .T. )

         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacCliP )
            ImpPago( nil, 2 )
         end

         CloseFiles()

      end

   end

Return .T.



FUNCTION IntEdtRecCli( cNumFac )

   local nLevel         := nLevelUsr( "01059" )

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 8 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if dbSeekInOrd( cNumFac, "nNumFac", dbfFacCliP )
      WinEdtRec( nil, bEdit, dbfFacCliP )
   else
      MsgStop( "No se encuentra recibo" )
   end

Return .T.



FUNCTION ExtEdtRecCli( cFacCliP, cFacCliT, cFacCliL, cAntCliT, cPgo, cAge, cCaj, cIva, cDiv, oCta, oBcn, lRectificativa )

   local nLevel            := nLevelUsr( "01059" )

   IIF( lRectificativa == nil, lRectificativa := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 4 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   dbfFacCliP              := cFacCliP
   dbfFacCliT              := cFacCliT
   dbfFacCliL              := cFacCliL
   dbfAntCliT              := cAntCliT
   dbfFPago                := cPgo
   dbfAgent                := cAge
   dbfCajT                 := cCaj
   dbfIva                  := cIva
   dbfDiv                  := cDiv

   oCtaRem                 := oCta

   WinEdtRec( nil, bEdit, cFacCliP, lRectificativa )

Return .T.



FUNCTION ExtDelRecCli( cFacCliP )

   local nLevel         := nLevelUsr( "01059" )

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 16 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   DelCobCli( nil, cFacCliP )

Return .T.



STATIC FUNCTION PrnSerie()

    local oDlg
   local oRad
   local nRad        := 1
   local nCopPrn     := 1
   local oSerIni
   local oSerFin
   local oFmtRec
   local cFmtRec     := cSelPrimerDoc( "RF" )
   local oSayRec
   local cSayRec
   local lNotRem     := .F.
   local lNotImp     := .F.
   local lNotCob     := .F.
   local oCodPgo
   local cCodPgo     := Space( 3 )
   local oTxtPgo
   local cTxtPgo     := ""
   local nRecno      := ( dbfFacCliP )->( recno() )
   local nOrdAnt     := ( dbfFacCliP )->( OrdSetFocus( 1 ) )
   local dFecIni     := CtoD( "01/" + Str( Month( GetSysDate() ), 2 ) + "/" + Str( Year( Date() ) ) )
   local dFecFin     := GetSysDate()
   local cSerIni     := ( dbfFacCliP )->CSERIE
   local cSerFin     := ( dbfFacCliP )->CSERIE
   local nDocIni     := ( dbfFacCliP )->NNUMFAC
   local nDocFin     := ( dbfFacCliP )->NNUMFAC
   local cSufIni     := ( dbfFacCliP )->CSUFFAC
   local cSufFin     := ( dbfFacCliP )->CSUFFAC
   local nNumIni     := ( dbfFacCliP )->NNUMREC
   local nNumFin     := ( dbfFacCliP )->NNUMREC
   local oPrinter
   local cPrinter    := PrnGetName()

   cSayRec           := cNombreDoc( cFmtRec )

   oDlg = TDialog():New(,,,,, "IMPSERREC",, .F.,,,,,, .F.,,,,,, .F., )



   oRad := TRadMenu():Redefine( { | u | If( PCount()==0, nRad, nRad:= u ) }, oDlg,, { 90, 91 },,,,, .F.,, )






   oFmtRec := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, cFmtRec, cFmtRec:= u ) }, oDlg,,, {||    ( cDocumento( oFmtRec, oSayRec, dbfDoc ) )},,,,,, .F.,,, .F., .F.,,,,, {|Self|( BrwDocumento( oFmtRec, oSayRec, "RF" ) )}, nil, "LUPA",, )




   oSayRec := TGetHlp():ReDefine( 101, { | u | If( PCount()==0, cSayRec, cSayRec:= u ) }, oDlg,,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )

   TBtnBmp():ReDefine( 92, "Printer_pencil_16",,,,,{|| EdtDocumento( cFmtRec ) }, oDlg, .F., , .F.,  )





   TGetHlp():ReDefine( 110, { | u | If( PCount()==0, dFecIni, dFecIni:= u ) }, oDlg,,,,,,,,, .F., {||     ( nRad == 1 )},, .F., .T.,,,,,, nil,,, )





   TGetHlp():ReDefine( 120, { | u | If( PCount()==0, dFecFin, dFecFin:= u ) }, oDlg,,,,,,,,, .F., {||     ( nRad == 1 )},, .F., .T.,,,,,, nil,,, )










   oSerIni := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, cSerIni, cSerIni:= u ) }, oDlg,, "@!", {||    ( cSerIni >= "A" .AND. cSerIni <= "Z"  )},,,,,, .T., {||     ( nRad == 2 )},, .F., .T., {||    ( UpSerie( oSerIni ) )}, {||  ( DwSerie( oSerIni ) )},,,, nil,,, )










   oSerFin := TGetHlp():ReDefine( 170, { | u | If( PCount()==0, cSerFin, cSerFin:= u ) }, oDlg,, "@!", {||    ( cSerFin >= "A" .AND. cSerFin <= "Z"  )},,,,,, .T., {||     ( nRad == 2 )},, .F., .T., {||    ( UpSerie( oSerFin ) )}, {||  ( DwSerie( oSerFin ) )},,,, nil,,, )






   TGetHlp():ReDefine( 140, { | u | If( PCount()==0, nDocIni, nDocIni:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( nRad == 2 )},, .F., .T.,,,,,, nil,,, )






   TGetHlp():ReDefine( 180, { | u | If( PCount()==0, nDocFin, nDocFin:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( nRad == 2 )},, .F., .T.,,,,,, nil,,, )





   TGetHlp():ReDefine( 150, { | u | If( PCount()==0, cSufIni, cSufIni:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )





   TGetHlp():ReDefine( 190, { | u | If( PCount()==0, cSufFin, cSufFin:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )





   TGetHlp():ReDefine( 160, { | u | If( PCount()==0, nNumIni, nNumIni:= u ) }, oDlg,, "99",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )





   TGetHlp():ReDefine( 200, { | u | If( PCount()==0, nNumFin, nNumFin:= u ) }, oDlg,, "99",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )




   oPrinter := TGetHlp():ReDefine( 320, { | u | If( PCount()==0, cPrinter, cPrinter:= u ) }, oDlg,,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )

   TBtnBmp():ReDefine( 321, "Printer_preferences_16",,,,,{|| PrinterPreferences( oPrinter ) }, oDlg, .F., , .F.,  )









   oCodPgo := TGetHlp():ReDefine( 210, { | u | If( PCount()==0, cCodPgo, cCodPgo:= u ) }, oDlg,, "@!", {||    ( cFPago( oCodPgo, dbfFPago, oTxtPgo ) )},,,,,, .F.,,, .F., .F.,,,,, {|Self|( BrwFPago( oCodPgo, oTxtPgo ) )}, nil, "LUPA",, )




   oTxtPgo := TGetHlp():ReDefine( 220, { | u | If( PCount()==0, cTxtPgo, cTxtPgo:= u ) }, oDlg,,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )



   TCheckBox():ReDefine( 230, { | u | If( PCount()==0, lNotRem, lNotRem:= u ) }, oDlg,,,,,,, .F.,, .F. )



   TCheckBox():ReDefine( 240, { | u | If( PCount()==0, lNotImp, lNotImp:= u ) }, oDlg,,,,,,, .F.,, .F. )



   TCheckBox():ReDefine( 250, { | u | If( PCount()==0, lNotCob, lNotCob:= u ) }, oDlg,,,,,,, .F.,, .F. )








   TGetHlp():ReDefine( 260, { | u | If( PCount()==0, nCopPrn, nCopPrn:= u ) }, oDlg,, "999999999", {||    nCopPrn > 0},,,,,, .F.,,, .F., .T.,,, {||      1}, {||      99999},, nil,,, )





   TButton():ReDefine( 1, {||(  StartPrint( SubStr( cFmtRec, 1, 3 ), nRad, dFecIni, dFecFin, cSerIni + Str( nDocIni, 9 ) + cSufIni + Str( nNumIni, 2 ), cSerFin + Str( nDocFin, 9 ) + cSufFin + Str( nNumFin, 2 ), cCodPgo, lNotRem, lNotImp, lNotCob, nCopPrn, cPrinter, oDlg ), oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )





   TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   oDlg:AddFastKey( 116, {|| StartPrint( SubStr( cFmtRec, 1, 3 ), nRad, dFecIni, dFecFin, cSerIni + Str( nDocIni, 9 ) + cSufIni + Str( nNumIni, 2 ), cSerFin + Str( nDocFin, 9 ) + cSufFin + Str( nNumFin, 2 ), cCodPgo, lNotRem, lNotImp, lNotCob, nCopPrn, cPrinter, oDlg ), oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   ( dbfFacCliP )->( dbGoTo( nRecNo ) )
   ( dbfFacCliP )->( ordSetFocus( nOrdAnt ) )

    oWndBrw:oBrw:refresh()

RETURN NIL



STATIC FUNCTION StartPrint( cCodDoc, nRad, dFecIni, dFecFin, cDocIni, cDocFin, cCodPgo, lNotRem, lNotImp, lNotCob, nCopPrn, cPrinter, oDlg )

   local oInf
   local nOrd
   local oDevice
   local cCaption       := "Imprimiendo recibos"

   if Empty( cCodDoc )
      return nil
   end

   private cDbfRec      := dbfFacCliP
   private cDbf         := dbfFacCliT
   private cCliente     := dbfClient
   private cDbfCli      := dbfClient
   private cFPago       := dbfFPago
   private cDbfPgo      := dbfFPago
   private cDbfAge      := dbfAgent
   private cDbfDiv      := dbfDiv
   private cPorDivRec   := cPorDiv( ( dbfFacCliP )->cDivPgo, dbfDiv )

   oDlg:Disable()

   if lVisualDocumento( cCodDoc, dbfDoc )

      if nRad == 1
         nOrd           := ( dbfFacCliP )->( OrdSetFocus( "dPreCob" ) )
         ( dbfFacCliP )->( dbSeek( dFecIni, .T. ) )
      else
         nOrd           := ( dbfFacCliP )->( OrdSetFocus( "nNumFac" ) )
         ( dbfFacCliP )->( dbSeek( cDocIni, .T. ) )
      end

      while !( dbfFacCliP )->( eof() )







         if (  if( nRad == 1, ( ( dbfFacCliP )->dPreCob >= dFecIni .AND. ( dbfFacCliP )->dPreCob <= dFecFin ), .T. )                 .AND.  if( nRad == 2, ( ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC ) + ( dbfFacCliP )->CSUFFAC + Str( ( dbfFacCliP )->nNumRec ) >= cDocIni .AND.  ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC ) + ( dbfFacCliP )->CSUFFAC + Str( ( dbfFacCliP )->nNumRec ) <= cDocFin ), .T. )  .AND.  if( !Empty( cCodPgo ), cCodPgo == cPgoFacCli( ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC, dbfFacCliT ), .T. ) .AND. if( lNotRem, ( dbfFacCliP )->nNumRem == 0 .AND. Empty( ( dbfFacCliP )->cSufRem ), .T. )                                 .AND.  if( lNotImp, !( dbfFacCliP )->lRecImp, .T. )                                                                            .AND.  if( lNotCob, !( dbfFacCliP )->lCobrado, .T. ) )



            if dbLock( dbfFacCliP )
               ( dbfFacCliP )->lRecImp    := .T.
               ( dbfFacCliP )->dFecImp    := GetSysDate()
               ( dbfFacCliP )->cHorImp    := SubStr( Time(), 1, 5 )
               ( dbfFacCliP )->( dbUnLock() )
            end

            ( dbfFacCliT)->( dbSeek( ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC ) + ( dbfFacCliP )->CSUFFAC ) )
            ( dbfClient )->( dbSeek( ( dbfFacCliT )->CCODCLI ) )
            ( dbfFPago  )->( dbSeek( ( dbfFacCliT )->CCODPAGO ) )



            PrintReportRecCli( 1, nCopPrn, nil, dbfDoc )

         end

         ( dbfFacCliP )->( dbSkip() )

      end

   else

      if !Empty( cPrinter )
         oDevice           := TPrinter():New( cCaption, .F., .T., cPrinter )
         oInf := RptBegin({}, {}, {}, {}, {}, .F.,,,, .F.,, oDevice, cCaption,,, )
      else
         oInf := RptBegin({}, {}, {}, {}, {}, .F.,,,, .T.,,, cCaption,,, )
      end



      if !Empty( oInf ) .AND. oInf:lCreated
         oInf:lFinish      := .F.
         oInf:lAutoland    := .T.
         oInf:lNoCancel    := .T.
         oInf:bSkip        := {|| Skipping( nRad, dFecIni, dFecFin, cDocIni, cDocFin, cCodDoc, cCodPgo, lNotRem, lNotImp, lNotCob, nCopPrn, oInf ) }

         oInf:oDevice:lPrvModal  := .T.

         oInf:bPreview     := {| oDevice | PrintPreview( oDevice ) }

      end

      SetMargin(  cCodDoc, oInf )
      PrintColum( cCodDoc, oInf )

      RptEnd()

      if !Empty( oInf )

         oInf:Activate(, {|| ( !( dbfFacCliP )->( eof() ) )},,,,,,,,,,,, )

         oInf:oDevice:end()

      end

      oInf                          := nil

   end

   oDlg:Enable()

RETURN NIL



Static Function Skipping( nRad, dFecIni, dFecFin, cDocIni, cDocFin, cCodDoc, cCodPgo, lNotRem, lNotImp, lNotCob, nCopPrn, oInf )

   local nOrd
   local nCopYet  := 0
   local nImpYet  := 0
   local nDocPag  := 0
   local nLenPag  := 0
   local nLenDoc  := 0
   local nOffset  := 0

   if ( dbfDoc )->( dbSeek( cCodDoc ) )
      nLenPag     := ( dbfDoc )->nLenPag
      nLenDoc     := ( dbfDoc )->nLenDoc
      if nLenPag <> 0 .AND. nLenDoc <> 0
         nDocPag  := Int( nLenPag / nLenDoc )
      end
   end

   if nRad == 1
      nOrd        := ( dbfFacCliP )->( OrdSetFocus( "dPreCob" ) )
      ( dbfFacCliP )->( dbSeek( dFecIni, .T. ) )
   else
      nOrd        := ( dbfFacCliP )->( OrdSetFocus( "nNumFac" ) )
      ( dbfFacCliP )->( dbSeek( cDocIni, .T. ) )
   end

   while !( dbfFacCliP )->( eof() )







      if (  if( nRad == 1, ( ( dbfFacCliP )->dPreCob >= dFecIni .AND. ( dbfFacCliP )->dPreCob <= dFecFin ), .T. )                 .AND.  if( nRad == 2, ( ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC ) + ( dbfFacCliP )->CSUFFAC + Str( ( dbfFacCliP )->nNumRec ) >= cDocIni .AND.  ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC ) + ( dbfFacCliP )->CSUFFAC + Str( ( dbfFacCliP )->nNumRec ) <= cDocFin ), .T. )  .AND.  if( !Empty( cCodPgo ), cCodPgo == cPgoFacCli( ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC, dbfFacCliT ), .T. ) .AND. if( lNotRem, ( dbfFacCliP )->nNumRem == 0 .AND. Empty( ( dbfFacCliP )->cSufRem ), .T. )                                 .AND.  if( lNotImp, !( dbfFacCliP )->lRecImp, .T. )                                                                            .AND.  if( lNotCob, !( dbfFacCliP )->lCobrado, .T. ) )



         if dbLock( dbfFacCliP )
            ( dbfFacCliP )->lRecImp    := .T.
            ( dbfFacCliP )->dFecImp    := GetSysDate()
            ( dbfFacCliP )->cHorImp    := SubStr( Time(), 1, 5 )
            ( dbfFacCliP )->( dbUnLock() )
         end

         ( dbfFacCliT)->( dbSeek( ( dbfFacCliP )->CSERIE + Str( ( dbfFacCliP )->NNUMFAC ) + ( dbfFacCliP )->CSUFFAC ) )
         ( dbfClient )->( dbSeek( ( dbfFacCliT )->CCODCLI ) )
         ( dbfFPago  )->( dbSeek( ( dbfFacCliT )->CCODPAGO ) )

         nImpYet++
         if nImpYet > nDocPag
            oInf:EndPage()
            nImpYet  := 1
         end

         nOffSet     := ( nImpYet - 1 ) * nLenDoc

         PrintItems( cCodDoc, oInf, nil, nOffSet )

      end

      nCopYet++

      if nCopYet >= nCopPrn
         ( dbfFacCliP )->( dbSkip() )
         nCopYet     := 0
      end

   end

RETURN NIL




STATIC FUNCTION ImpPago( cNumRec, nDevice, cCodDoc, cCaption, nCopies )

   local oInf
   local cPrinter

   IIF( cNumRec == nil, cNumRec := ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac, ) ;
   IIF( nDevice == nil, nDevice := 1, ) ;
   IIF( cCaption == nil, cCaption := "Imprimiendo recibos", ) ;
   IIF( nCopies == nil, nCopies := 1, ) ;
   IIF( cCodDoc == nil, cCodDoc := cFormatoDocumento( ( dbfFacCliP )->cSerie, "nRecCli", dbfCount ), ) ;

   if Empty( cCodDoc )
      cCodDoc           := cFirstDoc( "RF", dbfDoc )
   end

   if !lExisteDocumento( cCodDoc, dbfDoc )
      return nil
   end





   if lVisualDocumento( cCodDoc, dbfDoc )

      PrintReportRecCli( nDevice, nCopies, cPrinter, dbfDoc )

   else

      private cDbfRec      := dbfFacCliP
      private cDbf         := dbfFacCliT
      private cCliente     := dbfClient
      private cDbfCli      := dbfClient
      private cFPago       := dbfFPago
      private cDbfPgo      := dbfFPago
      private cDbfDiv      := dbfDiv
      private cDbfAge      := dbfAgent
      private cPorDivRec   := cPorDiv( ( dbfFacCliP )->cDivPgo, dbfDiv )
      private nTotFac      := nTotFacCli( cNumRec, dbfFacCliT, dbfFacCliL, dbfIva, dbfDiv, dbfFacCliP, dbfAntCliT, , , .F. )



      if Empty( ( dbfFacCliP )->cTipRec )
         ( dbfFacCliT)->( dbSeek( cNumRec ) )
         ( dbfClient )->( dbSeek( ( dbfFacCliP )->cCodCli ) )
         ( dbfFPago  )->( dbSeek( ( dbfFacCliT )->cCodPago ) )
      else
         ( dbfFacRecT)->( dbSeek( cNumRec ) )
         ( dbfClient )->( dbSeek( ( dbfFacCliP )->cCodCli ) )
         ( dbfFPago  )->( dbSeek( ( dbfFacRecT )->cCodPago ) )
      end

      if Empty( cPrinter )
         oInf := RptBegin({}, {}, {}, {}, {}, .F.,,,, .T.,,, cCaption,,, )
      else
         oInf := RptBegin({}, {}, {}, {}, {}, .F.,, cPrinter,, .T.,,, cCaption,,, )
      end



      if oInf:lCreated
         oInf:lFinish      := .F.
         oInf:lAutoland    := .T.
         oInf:bSkip        := {|| ( dbfFacCliP )->( dbSkip() ) }

         do case
            case nDevice == 1
               oInf:bPreview  := {| oDevice | PrintPreview( oDevice ) }

            case nDevice == 3
               oInf:bPreview  := {| oDevice | PrintPdf( oDevice ) }

         end

         SetMargin(  cCodDoc, oInf )
         PrintColum( cCodDoc, oInf )
      end

      RptEnd()

      oInf:Activate(, {|| ( .F. )},,,, {|| ( eItems( cCodDoc, oInf ) )},,,,,,,, )



      if nDevice == 1
         oInf:oDevice:end()
      end

      oInf                 := nil

   end



   if dbLock( dbfFacCliP )
      ( dbfFacCliP )->lRecImp    := .T.
      ( dbfFacCliP )->dFecImp    := GetSysDate()
      ( dbfFacCliP )->cHorImp    := SubStr( Time(), 1, 5 )
      ( dbfFacCliP )->( dbUnLock() )
   end





   if !Empty( oWndBrw )
      oWndBrw:Refresh()
   end

RETURN NIL



STATIC FUNCTION eItems( cCodDoc, oInf )

   private nPagina      := oInf:nPage
    private lEnd            := oInf:lFinish



   PrintItems( cCodDoc, oInf )

RETURN NIL



Static Function bGenEdtRecCli( cDocumento, lFromFactura )

   local bGen
   local cDoc           := by( cDocumento )

   IIF( lFromFactura == nil, lFromFactura := .F., ) ;

   if lFromFactura
      bGen              := {|| EdtRecCli( cDoc, .F. ) }
   else
      bGen              := {|| IntEdtRecCli( cDoc ) }
   end

return ( bGen )
#line 3997 ".\Prg\Reccli.prg"
Static Function DataReport( oFr )





   oFr:ClearDataSets()

   oFr:SetWorkArea(     "Recibos", ( dbfFacCliP )->( Select() ), .F., { 1, 1, 0 } )
   oFr:SetFieldAliases( "Recibos", cItemsToReport( aItmRecCli() ) )

   oFr:SetWorkArea(     "Facturas", ( dbfFacCliT )->( Select() ) )
   oFr:SetFieldAliases( "Facturas", cItemsToReport( aItmFacCli() ) )

   oFr:SetWorkArea(     "Facturas rectificativas", ( dbfFacRecT )->( Select() ) )
   oFr:SetFieldAliases( "Facturas rectificativas", cItemsToReport( aItmFacRec() ) )

   oFr:SetWorkArea(     "Empresa", ( dbfEmp )->( Select() ) )
   oFr:SetFieldAliases( "Empresa", cItemsToReport( aItmEmp() ) )

   oFr:SetWorkArea(     "Clientes", ( dbfClient )->( Select() ) )
   oFr:SetFieldAliases( "Clientes", cItemsToReport( aItmCli() ) )

   oFr:SetWorkArea(     "Formas de pago", ( dbfFpago )->( Select() ) )
   oFr:SetFieldAliases( "Formas de pago", cItemsToReport( aItmFPago() ) )

   oFr:SetWorkArea(     "Agentes", ( dbfAgent )->( Select() ) )
   oFr:SetFieldAliases( "Agentes", cItemsToReport( aItmAge() ) )

   oFr:SetWorkArea(     "Bancos", ( dbfBncCli )->( Select() ) )
   oFr:SetFieldAliases( "Bancos", cItemsToReport( aCliBnc() ) )

   oFr:SetMasterDetail( "Recibos", "Facturas",                 {|| ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac } )
   oFr:SetMasterDetail( "Recibos", "Facturas rectificativas",  {|| ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac } )
   oFr:SetMasterDetail( "Recibos", "Empresa",                  {|| cCodigoEmpresaEnUso() } )
   oFr:SetMasterDetail( "Recibos", "Clientes",                 {|| ( dbfFacCliP )->cCodCli } )
   oFr:SetMasterDetail( "Recibos", "Formas de pago",           {|| ( dbfFacCliP )->cCodPgo } )
   oFr:SetMasterDetail( "Recibos", "Agentes",                  {|| ( dbfFacCliP )->cCodAge } )
   oFr:SetMasterDetail( "Recibos", "Bancos",                   {|| ( dbfFacCliP )->cCodCli } )

   oFr:SetResyncPair(   "Recibos", "Facturas" )
   oFr:SetResyncPair(   "Recibos", "Facturas rectificativas" )
   oFr:SetResyncPair(   "Recibos", "Empresa" )
   oFr:SetResyncPair(   "Recibos", "Clientes" )
   oFr:SetResyncPair(   "Recibos", "Formas de pago" )
   oFr:SetResyncPair(   "Recibos", "Agentes" )
   oFr:SetResyncPair(   "Recibos", "Bancos" )

Return nil



Static Function VariableReport( oFr )

   oFr:DeleteCategory(  "Recibos" )





   oFr:AddVariable(     "Recibos", "Importe del recibo",       "CallHbFunc('nImpRecCli')" )
   oFr:AddVariable(     "Recibos", "Importe formato texto",    "CallHbFunc('cTxtRecCli')" )
   oFr:AddVariable(     "Recibos", "Total factura",            "CallHbFunc('nTotFactura')" )
   oFr:AddVariable(     "Recibos", "Total rectificativa",      "CallHbFunc('nTotRectificativa')" )
   oFr:AddVariable(     "Recibos", "Cuenta bancaria cliente",  "CallHbFunc('cCtaRecCli')" )

Return nil



Function DesignReportRecCli( oFr, dbfDoc )

   local lOpen    := .F.
   local lFlag    := .F.





   if lOpenFiles
      lFlag       := .T.
   else
      if Openfiles()
         lFlag    := .T.
         lOpen    := .T.
      else
         lFlag    := .F.
      end
   end

   if lFlag





      DataReport( oFr )





      if !Empty( ( dbfDoc )->mReport )

         oFr:LoadFromBlob( ( dbfDoc )->( Select() ), "mReport")

      else

         oFr:SetProperty(     "Report",            "ScriptLanguage", "PascalScript" )







         oFr:SetProperty(     "Report.ScriptText", "Text", +  "procedure DetalleOnMasterDetail(Sender: TfrxComponent);"   + Chr(13) + Chr(10) +  "begin"                                                     + Chr(13) + Chr(10) +  "CallHbFunc('nTotRecCli');"                                 + Chr(13) + Chr(10) +  "end;"                                                      + Chr(13) + Chr(10) +  "begin"                                                     + Chr(13) + Chr(10) +  "end." )

         oFr:AddPage(         "MainPage" )

         oFr:AddBand(         "CuerpoDocumento",   "MainPage", 2 )
         oFr:SetProperty(     "CuerpoDocumento",   "Top", 0 )
         oFr:SetProperty(     "CuerpoDocumento",   "Height", 300 )

         oFr:AddBand(         "CabeceraColumnas",  "MainPage", 6 )
         oFr:SetProperty(     "CabeceraColumnas",  "Top", 300 )
         oFr:SetProperty(     "CabeceraColumnas",  "Height", 0 )
         oFr:SetProperty(     "CabeceraColumnas",  "StartNewPage", .T. )
         oFr:SetObjProperty(  "CabeceraColumnas",  "DataSet", "Recibos" )

      end





      VariableReport( oFr )





      oFr:DesignReport()





      oFr:DestroyFr()





      if lOpen
         CloseFiles()
      end

   else

      Return .F.

   end

Return .T.



Function PrintReportRecCli( nDevice, nCopies, cPrinter, dbfDoc )

   local oFr
   local cFilePdf       := cPatTmp() + "RecibosCliente" + StrTran( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac, " ", "" ) + ".Pdf"

   IIF( nDevice == nil, nDevice := 2, ) ;
   IIF( nCopies == nil, nCopies := 1, ) ;
   IIF( cPrinter == nil, cPrinter := PrnGetName(), ) ;

   SysRefresh()

   oFr                  := frReportManager():New()

   oFr:LoadLangRes(     "Spanish.Xml" )

   oFr:SetIcon( 1 )

   oFr:SetTitle(        "Diseñador de documentos" )





   oFr:SetEventHandler( "Designer", "OnSaveReport", {|| oFr:SaveToBlob( ( dbfDoc )->( Select() ), "mReport" ) } )





   DataReport( oFr )





   if !Empty( ( dbfDoc )->mReport )

      oFr:LoadFromBlob( ( dbfDoc )->( Select() ), "mReport")





      VariableReport( oFr )





      oFr:PrepareReport()





      do case
         case nDevice == 2

            oFr:ShowPreparedReport()

         case nDevice == 1

            oFr:PrintOptions:SetPrinter( cPrinter )
            oFr:PrintOptions:SetCopies( nCopies )
            oFr:PrintOptions:SetShowDialog( .F. )
            oFr:Print()

         case nDevice == 3

            oFr:SetProperty(  "PDFExport", "ShowDialog",       .F. )
            oFr:SetProperty(  "PDFExport", "DefaultPath",      cPatTmp() )
            oFr:SetProperty(  "PDFExport", "FileName",         cFilePdf )
            oFr:SetProperty(  "PDFExport", "EmbeddedFonts",    .T. )
            oFr:SetProperty(  "PDFExport", "PrintOptimized",   .T. )
            oFr:SetProperty(  "PDFExport", "Outline",          .T. )
            oFr:SetProperty(  "PDFExport", "OpenAfterExport",  .T. )
            oFr:DoExport(     "PDFExport" )

         case nDevice == 6

            oFr:SetProperty(  "PDFExport", "ShowDialog",       .F. )
            oFr:SetProperty(  "PDFExport", "DefaultPath",      cPatTmp() )
            oFr:SetProperty(  "PDFExport", "FileName",         cFilePdf )
            oFr:SetProperty(  "PDFExport", "EmbeddedFonts",    .T. )
            oFr:SetProperty(  "PDFExport", "PrintOptimized",   .T. )
            oFr:SetProperty(  "PDFExport", "Outline",          .T. )
            oFr:SetProperty(  "PDFExport", "OpenAfterExport",  .F. )
            oFr:DoExport(     "PDFExport" )

            if file( cFilePdf )

               with object ( TGenMailing():New() )

                  :SetTypeDocument( "nRecCli" )
                  :SetDe(           uFieldEmpresa( "cNombre" ) )
                  :SetCopia(        uFieldEmpresa( "cCcpMai" ) )
                  :SetAdjunto(      cFilePdf )
                  :SetPara(         RetFld( ( dbfFacCliP )->cCodCli, dbfClient, "cMeiInt" ) )
                  :SetAsunto(       "Envio de recibo de cliente número " + StrTran( ( dbfFacCliP )->cSerie + "/" + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac + "-" + Str( ( dbfFacCliP )->nNumRec ), " ", "" ) )
                  :SetMensaje(      "Adjunto le remito nuestra factura de anticipo de cliente " + StrTran( ( dbfFacCliP )->cSerie + "/" + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac + "-" + Str( ( dbfFacCliP )->nNumRec ), " ", "" ) + Space( 1 ) )
                  :SetMensaje(      "de fecha " + Dtoc( ( dbfFacCliP )->dPreCob ) + Space( 1 ) )
                  :SetMensaje(      Chr(13)+Chr(10) )
                  :SetMensaje(      Chr(13)+Chr(10) )
                  :SetMensaje(      "Reciba un cordial saludo." )

                  :GeneralResource( dbfFacCliP, aItmRecCli() )

               end

            end

      end

   end





   oFr:DestroyFr()

Return .T.



function nTotFactura( cNumRec, cFacCliT, cFacCliL, cDbfIva, cDbfDiv, cFacCliP, cAntCliT )

   IIF( cNumRec == nil, cNumRec := ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac, ) ;
   IIF( cFacCliT == nil, cFacCliT := dbfFacCliT, ) ;
   IIF( cFacCliL == nil, cFacCliL := dbfFacCliL, ) ;
   IIF( cDbfIva == nil, cDbfIva := dbfIva, ) ;
   IIF( cDbfDiv == nil, cDbfDiv := dbfDiv, ) ;
   IIF( cFacCliP == nil, cFacCliP := dbfFacCliP, ) ;
   IIF( cAntCliT == nil, cAntCliT := dbfAntCliT, ) ;

Return ( nTotFacCli( cNumRec, cFacCliT, cFacCliL, cDbfIva, cDbfDiv, cFacCliP, cAntCliT, , , .F. ) )



function nTotRectificativa( cNumRec, cFacRecT, cFacRecL, cDbfIva, cDbfDiv )

   IIF( cNumRec == nil, cNumRec := ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac, ) ;
   IIF( cFacRecT == nil, cFacRecT := dbfFacRecT, ) ;
   IIF( cFacRecL == nil, cFacRecL := dbfFacRecL, ) ;
   IIF( cDbfIva == nil, cDbfIva := dbfIva, ) ;
   IIF( cDbfDiv == nil, cDbfDiv := dbfDiv, ) ;

Return ( nTotFacRec( cNumRec, cFacRecT, cFacRecL, cDbfIva, cDbfDiv, nil, nil, .F. ) )

















































































































































































































































































































































































































Function rxRecCli( cPath, oMeter )

   local dbfFacCliT

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "FACCLIP.DBF" )
      mkRecCli( cPath, oMeter, .F. )
   end

   fEraseIndex( cPath + "FACCLIP.CDX" )

   dbUseArea( .T., cDriver(), cPath + "FACCLIP.DBF", cCheckArea( "FACCLIP", @dbfFacCliT ), .F. )

   if !( dbfFacCliT )->( neterr() )

      ( dbfFacCliT )->( __dbPack() )



      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "nNumFac", "cSerie + Str( nNumFac ) + cSufFac + Str( nNumRec ) + cTipRec", {|| Field->CSERIE + Str( Field->NNUMFAC ) + Field->CSUFFAC + Str( Field->NNUMREC ) + Field->cTipRec } ) )



      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "cCodCli", "cCodCli", {|| Field->CCODCLI } ) )



      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "cNomCli", "cNomCli", {|| Field->cNomCli } ) )



      ( dbfFacCliT )->( ordCondSet("!Deleted() .and. !Field->lCobrado", {|| !Deleted() .AND. !Field->lCobrado } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "lCodCli", "cCodCli", {|| Field->cCodCli } ) )



      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "dPreCob", "dPreCob", {|| Field->dPreCob } ) )



      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "dFecVto", "dFecVto", {|| Field->dFecVto } ) )



      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "dEntrada", "dEntrada", {|| Field->dEntrada } ) )



      ( dbfFacCliT )->( ordCondSet( "!Deleted()", {|| !Deleted() }, , , , , , , , , , , .T. ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "nImporte", "nImporte", {|| Field->nImporte }, ) )



      ( dbfFacCliT )->( ordCondSet("!Deleted() .and. !lCobrado", {|| !Deleted() .AND. !Field->lCobrado } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "pNumFac", "cSerie + Str( nNumFac ) + cSufFac + Str( nNumRec ) + cTipRec", {|| Field->CSERIE + Str( Field->NNUMFAC ) + Field->CSUFFAC + Str( Field->NNUMREC ) + Field->cTipRec } ) )



      ( dbfFacCliT )->( ordCondSet("!Deleted() .and. lCobrado", {|| !Deleted() .AND. Field->lCobrado } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "tNumFac", "cSerie + Str( nNumFac ) + cSufFac + Str( nNumRec ) + cTipRec", {|| Field->CSERIE + Str( Field->NNUMFAC ) + Field->CSUFFAC + Str( Field->NNUMREC ) + Field->cTipRec } ) )



      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "nNumRem", "Str( nNumRem ) + cSufRem", {|| Str( Field->nNumRem ) + Field->cSufRem } ) )



      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "nNumCli", "Str( nNumRem ) + cSufRem + cCodCli", {|| Str( Field->nNumRem ) + Field->cSufRem + Field->cCodCli } ) )



      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "cCtaRem", "cCtaRem", {|| Field->CCTAREM }, ) )

      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "cCodAge", "cCodAge", {|| Field->CCODAGE } ) )

      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "nNumCob", "Str( nNumCob ) + cSufCob", {|| Str( Field->NNUMCOB ) + Field->CSUFCOB } ) )

      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "cTurRec", "cTurRec + cSufFac + cCodCaj", {|| Field->CTURREC + Field->CSUFFAC + Field->cCodCaj } ) )

      ( dbfFacCliT )->( ordCondSet("!Deleted() .and. Empty( cTipRec )", {|| !Deleted() .AND.  Empty( Field->cTipRec ) } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "fNumFac", "cSerie + Str( nNumFac ) + cSufFac + Str( nNumRec )", {|| Field->CSERIE + Str( Field->NNUMFAC ) + Field->CSUFFAC + Str( Field->NNUMREC ) } ) )

      ( dbfFacCliT )->( ordCondSet("!Deleted() .and. !Empty( cTipRec )", {|| !Deleted() .AND.  !Empty( Field->cTipRec ) } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "rNumFac", "cSerie + Str( nNumFac ) + cSufFac + Str( nNumRec )", {|| Field->CSERIE + Str( Field->NNUMFAC ) + Field->CSUFFAC + Str( Field->NNUMREC ) } ) )

      ( dbfFacCliT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "cRecDev", "cRecDev", {|| Field->CRECDEV } ) )

      ( dbfFacCliT )->( ordCondSet("!Deleted() .and. Field->lCobrado", {|| !Deleted() .AND. Field->lCobrado } ) )
      ( dbfFacCliT )->( ordCreate( cPath + "FACCLIP.CDX", "lCtaBnc", "Field->cEntEmp + Field->cSucEmp + Field->cDigEmp + Field->cCtaEmp", {|| Field->cEntEmp + Field->cSucEmp + Field->cDigEmp + Field->cCtaEmp } ) )

      ( dbfFacCliT )->( dbCloseArea() )

   else

      msgStop( "Imposible abrir en modo exclusivo la tabla de recibos de clientes" )

   end

RETURN NIL






FUNCTION mkRecCli( cPath, oMeter, lReindex )

   IIF( lReindex == nil, lReindex := .T., ) ;

   if oMeter <> NIL
        oMeter:cText    := "Generando Bases"
        sysrefresh()
   end

   dbCreate( cPath + "FACCLIP.DBF", aSqlStruct( aItmRecCli() ), cDriver() )

   if lReindex
      rxRecCli( cPath )
   end

RETURN NIL



FUNCTION aItmRecCli()

   local aBasRecCli  := {}

   aAdd( aBasRecCli, {"cSerie"      ,"C",  1, 0, "Serie de factura",            "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"nNumFac"     ,"N",  9, 0, "Número de factura",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cSufFac"     ,"C",  2, 0, "Sufijo de factura",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"nNumRec"     ,"N",  2, 0, "Número del recibo",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cTipRec"     ,"C",  1, 0, "Tipo de recibo",              "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cCodPgo"     ,"C",  2, 0, "Código de forma de pago",     "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cCodCaj"     ,"C",  3, 0, "Código de caja",              "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cTurRec"     ,"C",  6, 0, "Sesión del recibo",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cCodCli"     ,"C", 12, 0, "Código de cliente",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cNomCli"     ,"C", 80, 0, "Nombre de cliente",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"dEntrada"    ,"D",  8, 0, "Fecha de cobro",              "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"nImporte"    ,"N", 16, 6, "Importe",                     "cPorDivRec",         "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cDesCriP"    ,"C",100, 0, "Concepto del pago",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"dPreCob"     ,"D",  8, 0, "Fecha de previsión de cobro", "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cPgdoPor"    ,"C", 50, 0, "Pagado por",                  "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cDocPgo"     ,"C", 50, 0, "Documento de pago",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"lCobrado"    ,"L",  1, 0, "Lógico de cobrado",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cDivPgo"     ,"C",  3, 0, "Código de la divisa",         "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"nVdvPgo"     ,"N", 10, 6, "Cambio de la divisa",         "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"lConPgo"     ,"L",  1, 0, "Lógico de contabilizado",     "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cCtaRec"     ,"C", 12, 0, "Cuenta de contabilidad",      "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"nImpEur"     ,"N", 16, 6, "Importe del pago en Euros",   "cPorDivRec",         "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"lImpEur"     ,"L",  1, 0, "Lógico cobrar en Euros",      "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"nNumRem"     ,"N",  9, 0, "Número de la remesas",        "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cSufRem"     ,"C",  2, 0, "Sufijo de remesas",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cCtaRem"     ,"C",  3, 0, "Cuenta de remesa",            "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"lRecImp"     ,"L",  1, 0, "Lógico ya impreso",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"lRecDto"     ,"L",  1, 0, "Lógico descontado",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"dFecDto"     ,"D",  8, 0, "Fecha del descuento",         "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"dFecVto"     ,"D",  8, 0, "Fecha de vencimiento",        "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cCodAge"     ,"C",  3, 0, "Código del agente",           "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"nNumCob"     ,"N",  9, 0, "Número de cobro",             "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cSufCob"     ,"C",  2, 0, "Sufijo del cobro",            "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"nImpCob"     ,"N", 16, 6, "Importe del cobro",           "cPorDivRec",         "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"nImpGas"     ,"N", 16, 6, "Importe de gastos",           "cPorDivRec",         "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cCtaGas"     ,"C", 12, 0, "Subcuenta de gastos",         "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"lEsperaDoc"  ,"L",  1, 0, "Lógico a la espera de documentación","",            "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"lCloPgo"     ,"L",  1, 0, "Lógico de turno cerrado",     "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"dFecImp"     ,"D",  8, 0, "Última fecha de impresión" ,  "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cHorImp"     ,"C",  5, 0, "Hora de la última impresión" ,"",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"lNotArqueo"  ,"L",  1, 0, "Lógico de no incluir en arqueo","",                 "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cCodBnc"     ,"C",  4, 0, "Código del banco",            "",                   "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"dFecCre"     ,"D",  8, 0, "Fecha de creación del registro" ,  "",              "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cHorCre"     ,"C",  5, 0, "Hora de creación del registro" ,"",                 "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cCodUsr"     ,"C",  3, 0, "Código del usuario" ,"",                            "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"lDevuelto"   ,"L",  1, 0, "Lógico recibo devuelto" ,"",                        "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"dFecDev"     ,"D",  8, 0, "Fecha devolución" ,"",                              "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cMotDev"     ,"C",250, 0, "Motivo devolución" ,"",                             "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cRecDev"     ,"C", 14, 0, "Recibo de procedencia" ,"",                         "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"lSndDoc"     ,"L",  1, 0, "Lógico para envio" ,"",                             "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cBncEmp"     ,"C", 50, 0, "Banco de la empresa para el recibo" ,"",            "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cBncCli"     ,"C", 50, 0, "Banco del cliente para el recibo" ,"",              "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cEntEmp"     ,"C",  4, 0, "Entidad de la cuenta de la empresa",  "",           "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cSucEmp"     ,"C",  4, 0, "Sucursal de la cuenta de la empresa",  "",          "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cDigEmp"     ,"C",  2, 0, "Dígito de control de la cuenta de la empresa", "",  "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cCtaEmp"     ,"C", 10, 0, "Cuenta bancaria de la empresa",  "",                "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cEntCli"     ,"C",  4, 0, "Entidad de la cuenta del cliente",  "",             "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cSucCli"     ,"C",  4, 0, "Sucursal de la cuenta del cliente",  "",            "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cDigCli"     ,"C",  2, 0, "Dígito de control de la cuenta del cliente", "",    "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"cCtaCli"     ,"C", 10, 0, "Cuenta bancaria del cliente",  "",                  "", "( cDbfRec )" } )
   aAdd( aBasRecCli, {"lRemesa"     ,"L",  1, 0, "Lógico de incluido en una remesa",  "",             "", "( cDbfRec )" } )

return ( aBasRecCli )






FUNCTION GenPgoFacCli( cNumFac, dbfFacCliT, dbfFacCliL, dbfFacCliP, dbfAntCliT, dbfCli, dbfFPago, dbfDiv, dbfIva, nMode, lMessage )

   local cCodPgo
   local cSerFac
   local nNumFac
   local cSufFac
   local cDivFac
   local nVdvFac
   local dFecFac
   local cCodCli
   local cNomCli
   local cCodAge
   local cCodCaj
   local cCodUsr
   local cCtaRem     := ""
   local nCobro      := 0
   local nTotal      := 0
   local nTotCob     := 0
   local nDec        := 0
   local nInc        := 0
   local n           := 0
   local nTotAcu     := 0
   local nPlazos     := 1
   local nRecCli
   local cEntidad
   local cSucursal
   local cControl
   local cCuenta
   local cBanco
   local lAlert

   IIF( nMode == nil, nMode := 1, ) ;
   IIF( lMessage == nil, lMessage := .T., ) ;

   lAlert            := ( nMode == 1 )

   cSerFac           := ( dbfFacCliT )->cSerie
   nNumFac           := ( dbfFacCliT )->nNumFac
   cSufFac           := ( dbfFacCliT )->cSufFac
   cDivFac           := ( dbfFacCliT )->cDivFac
   nVdvFac           := ( dbfFacCliT )->nVdvFac
   dFecFac           := ( dbfFacCliT )->dFecFac
   cCodPgo           := ( dbfFacCliT )->cCodPago
   cCodCli           := ( dbfFacCliT )->cCodCli
   cNomCli           := ( dbfFacCliT )->cNomCli
   cCodAge           := ( dbfFacCliT )->cCodAge
   cCodCaj           := ( dbfFacCliT )->cCodCaj
   cCodUsr           := ( dbfFacCliT )->cCodUsr
   cBanco            := ( dbfFacCliT )->cBanco
   cEntidad          := ( dbfFacCliT )->cEntBnc
   cSucursal         := ( dbfFacCliT )->cSucBnc
   cControl          := ( dbfFacCliT )->cDigBnc
   cCuenta           := ( dbfFacCliT )->cCtaBnc





   nRecCli           := ( dbfCli )->( Recno() )

   if ( dbfCli )->( dbSeek( cCodCli ) )
      cCtaRem        := ( dbfCli )->cCodRem
   end





   nDec              := nRouDiv( cDivFac, dbfDiv )





   nTotal            := nTotFacCli( cNumFac, dbfFacCliT, dbfFacCliL, dbfIva, dbfDiv, dbfFacCliP, dbfAntCliT, nil, nil, .F. )

   nTotCob           := nPagFacCli( cNumFac, dbfFacCliT, dbfFacCliP, dbfIva, dbfDiv, nil, .F. )





   if lDiferencia( nTotal, nTotCob, 0.1 )





      if ( dbfFacCliP )->( dbSeek( cSerFac + Str( nNumFac ) + cSufFac ) )

         while cSerFac + Str( nNumFac ) + cSufFac == ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac

            if !( dbfFacCliP )->lCobrado .AND. dbLock( dbfFacCliP )
               ( dbfFacCliP )->( dbDelete() )
               ( dbfFacCliP )->( dbUnLock() )
            else
               nInc  := ( dbfFacCliP )->nNumRec
            end

            ( dbfFacCliP )->( dbSkip() )

         end

      end





      nTotal         -= nPagFacCli( cSerFac + Str( nNumFac ) + cSufFac, dbfFacCliT, dbfFacCliP, dbfIva, dbfDiv, nil, .T. )





      if ( dbfFPago )->( dbSeek( cCodPgo ) )

         nTotAcu        := nTotal
         nPlazos        := Max( ( dbfFPago )->nPlazos, 1 )

         for n := 1 to nPlazos

            if n <> nPlazos
               nTotAcu  -= Round( nTotal / nPlazos, nDec )
            end

            ( dbfFacCliP )->( dbAppend() )

            ( dbfFacCliP )->cTurRec       := cCurSesion()
            ( dbfFacCliP )->cSerie        := cSerFac
            ( dbfFacCliP )->nNumFac       := nNumFac
            ( dbfFacCliP )->cSufFac       := cSufFac
            ( dbfFacCliP )->nNumRec       := ++nInc
            ( dbfFacCliP )->cCodCaj       := cCodCaj
            ( dbfFacCliP )->cCodUsr       := cCodUsr
            ( dbfFacCliP )->cCodPgo       := cCodPgo
            ( dbfFacCliP )->cCodCli       := cCodCli
            ( dbfFacCliP )->cNomCli       := cNomCli

            if ( dbfFPago )->lUtlBnc
               ( dbfFacCliP )->cBncEmp    := ( dbfFPago )->cBanco
               ( dbfFacCliP )->cEntEmp    := ( dbfFPago )->cEntBnc
               ( dbfFacCliP )->cSucEmp    := ( dbfFPago )->cSucBnc
               ( dbfFacCliP )->cDigEmp    := ( dbfFPago )->cDigBnc
               ( dbfFacCliP )->cCtaEmp    := ( dbfFPago )->cCtaBnc
            end

            ( dbfFacCliP )->cBncCli       := cBanco
            ( dbfFacCliP )->cEntCli       := cEntidad
            ( dbfFacCliP )->cSucCli       := cSucursal
            ( dbfFacCliP )->cDigCli       := cControl
            ( dbfFacCliP )->cCtaCli       := cCuenta

            ( dbfFacCliP )->nImporte      := if( n <> nPlazos, Round( nTotal / nPlazos, nDec ), Round( nTotAcu, nDec ) )
            ( dbfFacCliP )->nImpCob       := if( n <> nPlazos, Round( nTotal / nPlazos, nDec ), Round( nTotAcu, nDec ) )
            ( dbfFacCliP )->cDescrip      := "Recibo nº" + AllTrim( Str( nInc ) ) + " de factura " + cSerFac  + "/" + allTrim( Str( nNumFac ) ) + "/" + cSufFac

            ( dbfFacCliP )->cDivPgo       := cDivFac
            ( dbfFacCliP )->nVdvPgo       := nVdvFac
            ( dbfFacCliP )->dPreCob       := dFecFac
            ( dbfFacCliP )->dFecVto       := dNexDay( dFecFac + ( dbfFPago )->nPlaUno + ( ( dbfFPago )->nDiaPla * ( n - 1 ) ), dbfCli )

            ( dbfFacCliP )->cCtaRec       := ( dbfFPago )->cCtaCobro
            ( dbfFacCliP )->cCtaGas       := ( dbfFPago )->cCtaGas

            ( dbfFacCliP )->cCtaRem       := cCtaRem
            ( dbfFacCliP )->cCodAge       := cCodAge
            ( dbfFacCliP )->lEsperaDoc    := ( dbfFPago )->lEsperaDoc

            if ( dbfFPago )->nCobRec == 1 .AND. nMode == 1
               ( dbfFacCliP )->cTurRec    := cCurSesion()
               ( dbfFacCliP )->lCobrado   := .T.
               ( dbfFacCliP )->dEntrada   := dNexDay( dFecFac + ( dbfFPago )->nPlaUno + ( ( dbfFPago )->nDiaPla * ( n - 1 ) ), dbfCli )
            end

            ( dbfFacCliP )->dFecCre       := GetSysDate()
            ( dbfFacCliP )->cHorCre       := SubStr( Time(), 1, 5 )

            lAlert                        := .F.

            ( dbfFacCliP )->( dbUnLock() )

         next

      else

         if lMessage
            MsgStop( "Forma de pago " + cCodPgo + " no encontrada, generando recibos" )
         end

      end

   end

   ( dbfCli )->( dbGoTo( nRecCli ) )

   if ( lAlert .AND. lMessage )
      msgWait( "Factura " + cSerFac  + "/" + allTrim( Str( nNumFac ) ) + "/" + cSufFac + " no se generaron recibos.", "Atención", 1 )
   end

RETURN NIL



FUNCTION dNexDay( dFecPgo, dbfCli )

   local nDay
   local nMon
   local nYea

   if Empty( dbfCli )
      Return ( dFecPgo )
   end

   nDay        := Day( dFecPgo )
   nYea        := Year( dFecPgo )
   nMon        := Month( dFecPgo )

   if ( dbfCli )->DiaPago <> 0





      if nDay > ( dbfCli )->DiaPago

         if nDay > ( dbfCli )->DiaPago2

            if nMon == 12
               nMon := 1
               nYea++
            else
               nMon++
            end

            nDay := ( dbfCli )->DiaPago

         else

            nDay := ( dbfCli )->DiaPago2

         end

      else

         nDay := ( dbfCli )->DiaPago

      end

   end





   if ( ( dbfCli )->nMesVac - 1 ) == nMon

      if nMon == 12
         nMon := 1
         nYea++
      else
         nMon++
      end

   end

RETURN ( Ctod( Str( nDay, 2 ) + "/" + Str( nMon, 2 ) + "/" + Str( nYea, 4 ) ) )



Function ValCobro( aGet, aTmp )

   if aTmp[ 34 ] <= aTmp[ 12 ]

      if ( aTmp[ 34 ] <> 0 ) .AND. ( aTmp[ 12 ] <> aTmp[ 34 ] )
         aGet[ 35 ]:cText( aTmp[ 12 ] - aTmp[ 34 ] )
      end

      Return .T.

   else

      msgAlert( "El importe del cobro excede al importe del recibo" )

   end

Return .F.



Function ValCheck( aGet, aTmp )

   if aTmp[ 17 ]

      aGet[ 11 ]:cText( GetSysDate() )
      aGet[ 8  ]:cText( cCurSesion( nil, .F. ) )

      if aTmp[ 34 ] == 0
         aGet[ 34 ]:cText( aTmp[ 12 ] )
      end

   else

      aGet[ 11 ]:cText( Ctod( "" ) )

   end

Return .T.



Function lValDevolucion( aGet, aTmp, lIntro )

   IIF( lIntro == nil, lIntro := .F., ) ;

   if aTmp[ 46 ]

      if !lIntro
         aGet[ 47 ]:cText( GetSysDate() )
      end

      aGet[ 14    ]:HardDisable()
      aGet[ 30    ]:HardDisable()
      aGet[ 12   ]:HardDisable()
      aGet[ 34    ]:HardDisable()
      aGet[ 17   ]:HardDisable()
      aGet[ 11   ]:HardDisable()
      aGet[ 31    ]:HardDisable()
      aGet[ 6    ]:HardDisable()
      aGet[ 13   ]:HardDisable()
      aGet[ 15   ]:HardDisable()
      aGet[ 16    ]:HardDisable()
      aGet[ 35    ]:HardDisable()
      aGet[ 21    ]:HardDisable()
      aGet[ 26    ]:HardDisable()
      aGet[ 7    ]:HardDisable()
      aGet[ 41 ]:HardDisable()
      aGet[ 27    ]:HardDisable()
      aGet[ 39    ]:HardDisable()
      aGet[ 40    ]:HardDisable()
      aGet[ 37 ]:HardDisable()
      aGet[ 8    ]:HardDisable()
      aGet[ 51    ]:HardDisable()
      aGet[ 52    ]:HardDisable()
      aGet[ 53    ]:HardDisable()
      aGet[ 54    ]:HardDisable()
      aGet[ 55    ]:HardDisable()
      aGet[ 56    ]:HardDisable()
      aGet[ 57    ]:HardDisable()
      aGet[ 58    ]:HardDisable()
      aGet[ 59    ]:HardDisable()
      aGet[ 60    ]:HardDisable()

   else

      if !lIntro
         aGet[ 47 ]:cText( Ctod( "" ) )
         aGet[ 48 ]:cText( Space( 250 ) )
      end

      aGet[ 14    ]:HardEnable()
      aGet[ 30    ]:HardEnable()
      aGet[ 12   ]:HardEnable()
      aGet[ 34    ]:HardEnable()
      aGet[ 17   ]:HardEnable()
      aGet[ 11   ]:HardEnable()
      aGet[ 31    ]:HardEnable()
      aGet[ 6    ]:HardEnable()
      aGet[ 13   ]:HardEnable()
      aGet[ 15   ]:HardEnable()
      aGet[ 16    ]:HardEnable()
      aGet[ 35    ]:HardEnable()
      aGet[ 21    ]:HardEnable()
      aGet[ 26    ]:HardEnable()
      aGet[ 7    ]:HardEnable()
      aGet[ 41 ]:HardEnable()
      aGet[ 27    ]:HardEnable()
      aGet[ 39    ]:HardEnable()
      aGet[ 40    ]:HardEnable()
      aGet[ 37 ]:HardEnable()
      aGet[ 8    ]:HardEnable()
      aGet[ 51    ]:HardEnable()
      aGet[ 52    ]:HardEnable()
      aGet[ 53    ]:HardEnable()
      aGet[ 54    ]:HardEnable()
      aGet[ 55    ]:HardEnable()
      aGet[ 56    ]:HardEnable()
      aGet[ 57    ]:HardEnable()
      aGet[ 58    ]:HardEnable()
      aGet[ 59    ]:HardEnable()
      aGet[ 60    ]:HardEnable()

   end

   if Empty( aTmp[ 49 ] )
      aGet[ 49 ]:Disable()
   else
      aGet[ 49 ]:Enable()
   end

return .T.



Function DelCobCli( oBrw, dbfFacCliP )

   if ( dbfFacCliP )->lCloPgo .AND. !oUser():lAdministrador()
      MsgStop( "Solo pueden eliminar los recibos cerrados los administradores." )
      return .F.
   end

   if !Empty( ( dbfFacCliP )->nNumRem ) .AND. !oUser():lAdministrador()
      msgStop( "Este tiket pertenece a una remesa de clientes.", "Imposible eliminar" )
      return .F.
   end

   if !Empty( ( dbfFacCliP )->nNumCob ) .AND. !oUser():lAdministrador()
      msgStop( "Este tiket pertenece a una remesa de cobros.", "Imposible eliminar" )
      return .F.
   end

   if ( dbfFacCliP )->lCobrado .AND. !oUser():lAdministrador()
      msgStop( "Este tiket esta cobrado.", "Imposible eliminar" )
      return .F.
   end

   if ( dbfFacCliP )->lRecDto .AND. !oUser():lAdministrador()
      msgStop( "Este tiket esta descontado.", "Imposible eliminar" )
      return .F.
   end

   WinDelRec( oBrw, dbfFacCliP )

return .T.



function nNewReciboCliente( cNumFac, cTipRec, dbfFacCliP )

   local nCon
   local nRec
   local nOrd

   IIF( cTipRec == nil, cTipRec := Space( 1 ), ) ;

   nCon              := 1
   nRec              := ( dbfFacCliP )->( Recno() )
   nOrd              := ( dbfFacCliP )->( OrdSetFocus( "nNumFac" ) )

   if ( dbfFacCliP )->( dbSeek( cNumFac ) )

      while ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == cNumFac .AND. !( dbfFacCliP )->( eof() )

         if ( dbfFacCliP )->cTipRec == cTipRec
            ++nCon
         end

         ( dbfFacCliP )->( dbSkip() )

      end

   end

   ( dbfFacCliP )->( OrdSetFocus( nOrd ) )
   ( dbfFacCliP )->( dbGoTo( nRec ) )

return ( nCon )



Function SetHeadEuro()

Return nil



Static Function YearComboBoxChange()

   if oWndBrw:oWndBar:lAllYearComboBox()
      DestroyFastFilter( dbfFacCliP )
      CreateUserFilter( "", dbfFacCliP, .F., , , "all" )
   else
      DestroyFastFilter( dbfFacCliP )
      CreateUserFilter( "Year( Field->dPreCob ) == " + oWndBrw:oWndBar:cYearComboBox(), dbfFacCliP, .F., , , "Year( Field->dPreCob ) == " + oWndBrw:oWndBar:cYearComboBox() )
   end

   ( dbfFacCliP )->( dbGoTop() )

   oWndBrw:Refresh()

Return nil



Static Function EndTrans( aTmp, aGet, dbfFacCliP, oBrw, oDlg, nMode )

   local nImp
   local nCon
   local nRec        := ( dbfFacCliP )->( Recno() )
   local lImpNeg     := ( dbfFacCliP )->nImporte < 0
   local nImpFld     := abs( ( dbfFacCliP )->nImporte )
   local nImpTmp     := abs( aTmp[ 12 ] )
   local cNumFac     := aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ]
   local cNumRec     := aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ] + Str( aTmp[ 4 ] )
   local lDevuelto   := aTmp[ 46 ]
   local aTabla
   local nOrdAnt

   if !aGet[ 34 ]:lValid()
      return .F.
   end





   if nImpTmp > nImpFld
      msgStop( "El importe no puede ser superior al actual." )
      return nil
   end

   if !lExisteTurno( aGet[ 8 ]:VarGet(), dbfTurno )

      msgStop( "La sesión introducida no existe." )

      aGet[ 8 ]:SetFocus()

      return nil

   end

   oDlg:Disable()





   if !Empty( dbfClient )

      if lPgdOld
         AddRiesgo( nImpOld, aTmp[ 9 ], dbfClient )
      end

      if ( aTmp[ 17 ] .OR. aTmp[ 28 ] )
         DelRiesgo( aTmp[ 12 ], aTmp[ 9 ], dbfClient )
      end

   end





   if nImpFld <> nImpTmp





      nImp                       := ( nImpFld - nImpTmp ) * if( lImpNeg, - 1 , 1 )





      nCon                       := nNewReciboCliente( aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ], aTmp[ 5 ], dbfFacCliP )





      ( dbfFacCliP )->( dbAppend() )


      ( dbfFacCliP )->cTurRec    := cCurSesion()

      ( dbfFacCliP )->cSerie     := aTmp[ 1  ]
      ( dbfFacCliP )->nNumFac    := aTmp[ 2 ]
      ( dbfFacCliP )->cSufFac    := aTmp[ 3 ]
      ( dbfFacCliP )->cCodCaj    := aTmp[ 7 ]
      ( dbfFacCliP )->cCodCli    := aTmp[ 9 ]
      ( dbfFacCliP )->cNomCli    := aTmp[ 10 ]
      ( dbfFacCliP )->dEntrada   := Ctod( "" )
      ( dbfFacCliP )->nImporte   := nImp
      ( dbfFacCliP )->nImpCob    := nImp
      ( dbfFacCliP )->cDescrip   := "Recibo nº" + AllTrim( Str( nCon ) ) + " de factura " + if( !Empty( aTmp[ 5 ] ), "rectificativa ", "" ) + aTmp[ 1 ] + "/" + AllTrim( Str( aTmp[ 2 ] ) ) + "/" + aTmp[ 3 ]
      ( dbfFacCliP )->dPreCob    := dFecFacCli( aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ], dbfFacCliT )
      ( dbfFacCliP )->cPgdoPor   := ""
      ( dbfFacCliP )->lCobrado   := .F.
      ( dbfFacCliP )->nNumRec    := nCon
      ( dbfFacCliP )->cDivPgo    := aTmp[ 18 ]
      ( dbfFacCliP )->nVdvPgo    := aTmp[ 19 ]
      ( dbfFacCliP )->lConPgo    := .F.
      ( dbfFacCliP )->dFecCre    := GetSysDate()
      ( dbfFacCliP )->cHorCre    := SubStr( Time(), 1, 5 )

      ( dbfFacCliP )->( dbUnLock() )

   end

   ( dbfFacCliP )->( dbGoTo( nRec ) )





   if ( lOldDevuelto <> lDevuelto )
      aTmp[ 20 ]              := .F.
   end





   WinGather( aTmp, aGet, dbfFacCliP, oBrw, nMode )





   nRec     := ( dbfFacCliP )->( Recno() )

   if lOldDevuelto <> lDevuelto

      if lDevuelto

         nOrdAnt                       := ( dbfFacCliP )->( OrdSetFocus( "nNumFac" ) )

         if ( dbfFacCliP )->( dbSeek( cNumRec ) )
            aTabla                     := dbScatter( dbfFacCliP )
         end

         nCon                          := nNewReciboCliente( aTabla[ 1 ] + Str( aTabla[ 2 ] ) + aTabla[ 3 ], aTabla[ 5 ], dbfFacCliP )

         if aTabla <> nil

            ( dbfFacCliP )->( dbAppend() )
            ( dbfFacCliP )->cSerie     := aTabla[ 1  ]
            ( dbfFacCliP )->nNumFac    := aTabla[ 2 ]
            ( dbfFacCliP )->cSufFac    := aTabla[ 3 ]
            ( dbfFacCliP )->nNumRec    := nCon
            ( dbfFacCliP )->cTipRec    := aTabla[ 5 ]
            ( dbfFacCliP )->cCodPgo    := aTabla[ 6 ]
            ( dbfFacCliP )->cCodCaj    := aTabla[ 7 ]
            ( dbfFacCliP )->cTurRec    := cCurSesion()
            ( dbfFacCliP )->cCodCli    := aTabla[ 9 ]
            ( dbfFacCliP )->cNomCli    := aTabla[ 10 ]
            ( dbfFacCliP )->dEntrada   := Ctod( "" )
            ( dbfFacCliP )->nImporte   := aTabla[ 12 ]
            ( dbfFacCliP )->cDesCriP   := "Recibo Nº" + AllTrim( Str( nCon ) ) + " generado de la devolución del recibo " + aTabla[ 1 ] + "/" + AllTrim( Str( aTabla[ 2 ] ) ) + "/" + aTabla[ 3 ] + " - " + AllTrim( Str( aTabla[ 4 ] ) )
            ( dbfFacCliP )->dPreCob    := GetSysDate()
            ( dbfFacCliP )->lCobrado   := .F.
            ( dbfFacCliP )->cDivPgo    := aTabla[ 18 ]
            ( dbfFacCliP )->nVdvPgo    := aTabla[ 19 ]
            ( dbfFacCliP )->lConPgo    := .F.
            ( dbfFacCliP )->dFecVto    := GetSysDate()
            ( dbfFacCliP )->cCodAge    := aTabla[ 31 ]
            ( dbfFacCliP )->nImpGas    := aTabla[ 35 ]
            ( dbfFacCliP )->dFecCre    := GetSysDate()
            ( dbfFacCliP )->cHorCre    := Time()
            ( dbfFacCliP )->cCodUsr    := oUser():cCodigo()
            ( dbfFacCliP )->cRecDev    := cNumRec
            ( dbfFacCliP )->( dbUnLock() )

         end

         ( dbfFacCliP )->( OrdSetFocus( nOrdAnt ) )

      else

         nOrdAnt                       := ( dbfFacCliP )->( OrdSetFocus( "cRecDev" ) )

         if ( dbfFacCliP )->( dbSeek( cNumRec ) ) .AND. dbDialogLock( dbfFacCliP )
            ( dbfFacCliP )->( dbDelete() )
            ( dbfFacCliP )->( dbUnLock() )
         end

         ( dbfFacCliP )->( OrdSetFocus( nOrdAnt ) )

      end

   end

   ( dbfFacCliP )->( dbGoTo( nRec ) )









   if dbfFacCliT <> nil          .AND. dbfFacCliL <> nil          .AND. dbfIva     <> nil          .AND. dbfDiv     <> nil          .AND. dbfClient  <> nil

      if ( dbfFacCliT )->( dbSeek( cNumFac ) )
         ChkLqdFacCli( nil, dbfFacCliT, dbfFacCliL, dbfFacCliP, dbfAntCliT, dbfIva, dbfDiv, .F. )
      end

   end





   dbCommitAll()

   oDlg:Enable()

   oDlg:End( 1 )

return .T.



_HB_CLASS pdaRecCliSenderReciver ; UTILITY FUNCTION pdaRecCliSenderReciver(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "pdaRecCliSenderReciver" , { HBObject():Classh } ) ) ;

   _HB_MEMBER CreateDataPcToPda( oPgrActual, oSayStatus); IIF( .F., s_oClass:ModMethod( "CreateDataPcToPda", @pdaRecCliSenderReciver_CreateDataPcToPda(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateDataPcToPda", @pdaRecCliSenderReciver_CreateDataPcToPda(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CreateDataPdaToPc( oPgrActual, oSayStatus); IIF( .F., s_oClass:ModMethod( "CreateDataPdaToPc", @pdaRecCliSenderReciver_CreateDataPdaToPc(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateDataPdaToPc", @pdaRecCliSenderReciver_CreateDataPdaToPc(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS pdaRecCliSenderReciver ;



UTILITY STATIC function pdaRecCliSenderReciver_CreateDataPdaToPc( oPgrActual, oSayStatus, cPatPreVenta) ; local Self AS CLASS pdaRecCliSenderReciver := QSelf() AS CLASS pdaRecCliSenderReciver

   local pdaFacCliT
   local pdaFacCliP
   local dbfFacCliP
   local cPatPc      := if( Empty( cPatPreVenta ), cPatPc(), cPatPreVenta )

   dbUseArea( .T., cDriver(), cPatEmp() + "FacCliT.Dbf", cCheckArea( "FacCliT", @pdaFacCliT ), .T. )
   ( pdaFacCliT )->( ordListAdd( cPatEmp() + "FacCliT.Cdx" ) )

   dbUseArea( .T., cDriver(), cPatEmp() + "FacCliP.Dbf", cCheckArea( "FacCliP", @pdaFacCliP ), .T. )
   ( pdaFacCliP )->( ordListAdd( cPatEmp() + "FacCliP.Cdx" ) )

   dbUseArea( .T., ( cDriver() ), ( cPatPc + "FacCliP.DBF" ), ( cCheckArea( "FacCliP", @dbfFacCliP ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatPc + "FacCliP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if !Empty( oPgrActual )
      oPgrActual:SetRange( 0, ( pdaFacCliP )->( OrdKeyCount() ) )
   end

   ( pdaFacCliP )->( dbGoTop() )

   while !( pdaFacCliP )->( eof() )

      if !( dbfFacCliP )->( dbSeek( ( pdaFacCliP )->cSerie + Str( ( pdaFacCliP )->nNumFac ) + ( pdaFacCliP )->cSufFac + Str( ( pdaFacCliP )->nNumRec ) ) )

         dbPass( pdaFacCliP, dbfFacCliP, .T. )

      else

         do case
            case !( pdaFacCliP )->lCobrado .AND. ( dbfFacCliP )->lCobrado
               dbPass( dbfFacCliP, pdaFacCliP, .F. )

            case ( pdaFacCliP )->lCobrado .AND. !( dbfFacCliP )->lCobrado
               dbPass( pdaFacCliP, dbfFacCliP, .F. )

         end

      end

      ( pdaFacCliP )->( dbSkip() )

      if !Empty( oSayStatus )
         oSayStatus:SetText( "Sincronizando Recibos " + Alltrim( Str( ( pdaFacCliP )->( OrdKeyNo() ) ) ) + " de " + Alltrim( Str( ( pdaFacCliP )->( OrdKeyCount() ) ) ) )
      end

      SysRefresh()

      if !Empty( oPgrActual )
         oPgrActual:SetPos( ( pdaFacCliP )->( OrdKeyNo() ) )
      end

      SysRefresh()

   end





   if !Empty( oPgrActual )
      oPgrActual:SetRange( 0, ( pdaFacCliP )->( OrdKeyCount() ) )
   end

   if !Empty( oSayStatus )
      oSayStatus:SetText( "Sincronizando recibos" )
   end

   SysRefresh()

   ( pdaFacCliP )->( dbGoTop() )

   while !( pdaFacCliP )->( eof() )



      if ( pdaFacCliP )->lCobrado                                                                                         .AND. !( pdaFacCliT )->( dbSeek( ( pdaFacCliP )->cSerie + Str( ( pdaFacCliP )->nNumFac ) + ( pdaFacCliP )->cSufFac ) ) .AND. dbDialogLock( pdaFacCliP )

         ( pdaFacCliP )->( dbDelete() )
         ( pdaFacCliP )->( dbUnLock() )

      end

      ( pdaFacCliP )->( dbSkip() )

      if !Empty( oPgrActual )
         oPgrActual:SetPos( ( pdaFacCliP )->( OrdKeyNo() ) )
      end

      SysRefresh()

   end

   ( pdaFacCliT )->( dbCloseArea() )
   ( pdaFacCliP )->( dbCloseArea() )
   ( dbfFacCliP )->( dbCloseArea() )

Return ( Self )



UTILITY STATIC function pdaRecCliSenderReciver_CreateDataPcToPda( oPgrActual, oSayStatus, cPatPreVenta) ; local Self AS CLASS pdaRecCliSenderReciver := QSelf() AS CLASS pdaRecCliSenderReciver

   local pdaFacCliP
   local dbfFacCliP
   local cPatPc      := if( Empty( cPatPreVenta ), cPatPc(), cPatPreVenta )

   dbUseArea( .T., cDriver(), cPatEmp() + "FacCliP.Dbf", cCheckArea( "FacCliP", @pdaFacCliP ), .T. )
   ( pdaFacCliP )->( ordListAdd( cPatEmp() + "FacCliP.Cdx" ) )

   dbUseArea( .T., ( cDriver() ), ( cPatPc + "FacCliP.DBF" ), ( cCheckArea( "FacCliP", @dbfFacCliP ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatPc + "FacCliP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   ( dbfFacCliP )->( dbGoTop() )

   while !( dbfFacCliP )->( Eof() )


      if !( pdaFacCliP )->( dbSeek( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ) ) ) .AND. !( dbfFacCliP )->lCobrado

         dbPass( dbfFacCliP, pdaFacCliP, .T. )

      end

      ( dbfFacCliP )->( dbSkip() )

      if !Empty( oSayStatus )
         oSayStatus:SetText( "Sincronizando Recibos " + Alltrim( Str( ( dbfFacCliP )->( OrdKeyNo() ) ) ) + " de " + Alltrim( Str( ( dbfFacCliP )->( OrdKeyCount() ) ) ) )
      end

      SysRefresh()

      if !Empty( oPgrActual )
         oPgrActual:SetPos( ( dbfFacCliP )->( OrdKeyNo() ) )
      end

      SysRefresh()

   end

   ( pdaFacCliP )->( dbCloseArea() )
   ( dbfFacCliP )->( dbCloseArea() )

Return ( Self )



function nEstadoRecibo( dbfFacCliP )

   local nEstado  := 1

   if !Empty( dbfFacCliP )

      if !( dbfFacCliP )->lCobrado
         nEstado     := 1
      else
         if !( dbfFacCliP )->lDevuelto
            nEstado  := 2
         else
            nEstado  := 3
         end
      end

   end

return ( nEstado )





Static Function FilterRecibos( lCobrado )

   with object ( TDlgFlt():Init( oWndBrw ) )

      do case
         case IsTrue( lCobrado )
            :cExpFilter    := "lCobrado .and. !lDevuelto"
         case IsFalse( lCobrado )
            :cExpFilter    := "!lCobrado .and. !lDevuelto"
         case IsNil( lCobrado )
            :cExpFilter    := "lDevuelto"
      end

      :AplyFilter()

   end

return ( nil )





Function cCuentaEmpresaRecibo( uFacCliP )

   local cCuentaEmpresaRecibo := ""

   do case
   case IsObject( uFacCliP )
      cCuentaEmpresaRecibo    += uFacCliP:cEntEmp
      cCuentaEmpresaRecibo    += uFacCliP:cSucEmp
      cCuentaEmpresaRecibo    += uFacCliP:cDigEmp
      cCuentaEmpresaRecibo    += uFacCliP:cCtaEmp

   case IsChar( uFacCliP )
      cCuentaEmpresaRecibo    += ( uFacCliP )->cEntEmp
      cCuentaEmpresaRecibo    += ( uFacCliP )->cSucEmp
      cCuentaEmpresaRecibo    += ( uFacCliP )->cDigEmp
      cCuentaEmpresaRecibo    += ( uFacCliP )->cCtaEmp

   end

return ( cCuentaEmpresaRecibo )
