#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 7 ".\Prg\Stock.prg"
_HB_CLASS TStock ; UTILITY FUNCTION TStock(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TStock" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { dbfDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "dbfDiv" }, .F., .F. ), )

   _HB_MEMBER { cPath} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPath" }, .F., .F. ), )

   _HB_MEMBER { lExclusive} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lExclusive" }, .F., .F. ), )

   _HB_MEMBER { cAlm} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAlm" }, .F., .F. ), )
   _HB_MEMBER { cArt} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cArt" }, .F., .F. ), )

   _HB_MEMBER { cPedCliT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPedCliT" }, .F., .F. ), )
   _HB_MEMBER { cPedCliL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPedCliL" }, .F., .F. ), )
   _HB_MEMBER { cPedCliR} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPedCliR" }, .F., .F. ), )

   _HB_MEMBER { cAlbCliT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAlbCliT" }, .F., .F. ), )
   _HB_MEMBER { cAlbCliL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAlbCliL" }, .F., .F. ), )
   _HB_MEMBER { cAlbCliS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAlbCliS" }, .F., .F. ), )

   _HB_MEMBER { cAlqCliT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAlqCliT" }, .F., .F. ), )
   _HB_MEMBER { cAlqCliL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAlqCliL" }, .F., .F. ), )

   _HB_MEMBER { cFacCliT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFacCliT" }, .F., .F. ), )
   _HB_MEMBER { cFacCliL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFacCliL" }, .F., .F. ), )
   _HB_MEMBER { cFacCliP} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFacCliP" }, .F., .F. ), )
   _HB_MEMBER { cFacCliS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFacCliS" }, .F., .F. ), )

   _HB_MEMBER { cFacRecT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFacRecT" }, .F., .F. ), )
   _HB_MEMBER { cFacRecL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFacRecL" }, .F., .F. ), )
   _HB_MEMBER { cFacRecS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFacRecS" }, .F., .F. ), )

   _HB_MEMBER { cAntCliT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAntCliT" }, .F., .F. ), )

   _HB_MEMBER { cPedPrvT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPedPrvT" }, .F., .F. ), )
   _HB_MEMBER { cPedPrvL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPedPrvL" }, .F., .F. ), )

   _HB_MEMBER { cAlbPrvT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAlbPrvT" }, .F., .F. ), )
   _HB_MEMBER { cAlbPrvL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAlbPrvL" }, .F., .F. ), )
   _HB_MEMBER { cAlbPrvS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAlbPrvS" }, .F., .F. ), )

   _HB_MEMBER { cFacPrvT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFacPrvT" }, .F., .F. ), )
   _HB_MEMBER { cFacPrvL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFacPrvL" }, .F., .F. ), )
   _HB_MEMBER { cFacPrvS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFacPrvS" }, .F., .F. ), )

   _HB_MEMBER { cRctPrvT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cRctPrvT" }, .F., .F. ), )
   _HB_MEMBER { cRctPrvL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cRctPrvL" }, .F., .F. ), )
   _HB_MEMBER { cRctPrvS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cRctPrvS" }, .F., .F. ), )

   _HB_MEMBER { cDepAgeT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cDepAgeT" }, .F., .F. ), )
   _HB_MEMBER { cDepAgeL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cDepAgeL" }, .F., .F. ), )

   _HB_MEMBER { cExtAgeT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cExtAgeT" }, .F., .F. ), )
   _HB_MEMBER { cExtAgeL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cExtAgeL" }, .F., .F. ), )

   _HB_MEMBER { cProducT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cProducT" }, .F., .F. ), )
   _HB_MEMBER { cProducL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cProducL" }, .F., .F. ), )
   _HB_MEMBER { cProducM} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cProducM" }, .F., .F. ), )
   _HB_MEMBER { cProducS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cProducS" }, .F., .F. ), )
   _HB_MEMBER { cProducP} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cProducP" }, .F., .F. ), )

   _HB_MEMBER { nDouDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDouDiv" }, .F., .F. ), )
   _HB_MEMBER { nDorDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDorDiv" }, .F., .F. ), )
   _HB_MEMBER { nDinDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDinDiv" }, .F., .F. ), )
   _HB_MEMBER { nDirDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDirDiv" }, .F., .F. ), )
   _HB_MEMBER { cPicUnd} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPicUnd" }, .F., .F. ), )
   _HB_MEMBER { nVdvDiv} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nVdvDiv" }, .F., .F. ), )
   _HB_MEMBER { nDecIn} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDecIn" }, .F., .F. ), )
   _HB_MEMBER { nDerIn} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDerIn" }, .F., .F. ), )

   _HB_MEMBER { cKit} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cKit" }, .F., .F. ), )

   _HB_MEMBER { cTikT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTikT" }, .F., .F. ), )
   _HB_MEMBER { cTikL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTikL" }, .F., .F. ), )
   _HB_MEMBER { cTikP} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTikP" }, .F., .F. ), )
   _HB_MEMBER { cTikS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTikS" }, .F., .F. ), )

   _HB_MEMBER { cHisMov} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cHisMov" }, .F., .F. ), )
   _HB_MEMBER { cHisMovS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cHisMovS" }, .F., .F. ), )

   _HB_MEMBER { tmpAlbCliL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "tmpAlbCliL" }, .F., .F. ), )
   _HB_MEMBER { tmpAlbCliS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "tmpAlbCliS" }, .F., .F. ), )
   _HB_MEMBER { tmpFacCliL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "tmpFacCliL" }, .F., .F. ), )
   _HB_MEMBER { tmpFacCliS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "tmpFacCliS" }, .F., .F. ), )
   _HB_MEMBER { tmpFacRecL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "tmpFacRecL" }, .F., .F. ), )
   _HB_MEMBER { tmpFacRecS} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "tmpFacRecS" }, .F., .F. ), )

   _HB_MEMBER {AS ARRAY aSeries} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aSeries" }, .F., .F. ), )

   _HB_MEMBER {AS ARRAY aMovAlm} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aMovAlm" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aStocks} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aStocks" }, .F., .F. ), )

   _HB_MEMBER { dConsolidacion} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "dConsolidacion" }, .F., .F. ), )

   _HB_MEMBER {AS LOGIC lAlbPrv} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .T., nScope + IIF( .F., 32, 0 ), { "lAlbPrv" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lAlbCli} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .T., nScope + IIF( .F., 32, 0 ), { "lAlbCli" }, .F., .F. ), )

   _HB_MEMBER New( cPath, lExclusive); IIF( .F., s_oClass:ModMethod( "New", @TStock_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TStock_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Create( cPath, lExclusive); IIF( .F., s_oClass:ModMethod( "Create", @TStock_Create(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Create", @TStock_Create(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER End(); IIF( .F., s_oClass:ModInline( "End", {|Self | Self, ( ::CloseFiles() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "End", {|Self | Self, ( ::CloseFiles() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER lOpenFiles( lExclusive); IIF( .F., s_oClass:ModMethod( "lOpenFiles", @TStock_lOpenFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lOpenFiles", @TStock_lOpenFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CloseFiles(); IIF( .F., s_oClass:ModMethod( "CloseFiles", @TStock_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CloseFiles", @TStock_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CreateFiles( cPath); IIF( .F., s_oClass:ModMethod( "CreateFiles", @TStock_CreateFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateFiles", @TStock_CreateFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DeleteFiles( cPath); IIF( .F., s_oClass:ModMethod( "DeleteFiles", @TStock_DeleteFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DeleteFiles", @TStock_DeleteFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Zap(); IIF( .F., s_oClass:ModMethod( "Zap", @TStock_Zap(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Zap", @TStock_Zap(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ReindexFiles( cPath); IIF( .F., s_oClass:ModMethod( "ReindexFiles", @TStock_ReindexFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReindexFiles", @TStock_ReindexFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER PedPrv( cNumPed, cCodAlm, lDelete, lIncremento); IIF( .F., s_oClass:ModMethod( "PedPrv", @TStock_PedPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PedPrv", @TStock_PedPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AlbPrv( cNumAlb, cCodAlm, cNumPed, lDelete, lIncremento, lIgnEstado); IIF( .F., s_oClass:ModMethod( "AlbPrv", @TStock_AlbPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AlbPrv", @TStock_AlbPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER FacPrv( cNumFac, cCodAlm, lDelete, lIncremento); IIF( .F., s_oClass:ModMethod( "FacPrv", @TStock_FacPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FacPrv", @TStock_FacPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ChkFacPrv( cNumFac); IIF( .F., s_oClass:ModMethod( "ChkFacPrv", @TStock_ChkFacPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ChkFacPrv", @TStock_ChkFacPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER RctPrv( cNumFac, cCodAlm, lDelete, lIncremento); IIF( .F., s_oClass:ModMethod( "RctPrv", @TStock_RctPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RctPrv", @TStock_RctPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ChkRctPrv( cNumFac); IIF( .F., s_oClass:ModMethod( "ChkRctPrv", @TStock_ChkRctPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ChkRctPrv", @TStock_ChkRctPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER PedCli( cNumPed, cCodAlm, lDelete, lIncremento); IIF( .F., s_oClass:ModMethod( "PedCli", @TStock_PedCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PedCli", @TStock_PedCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AlbCli( cNumAlb, cCodAlm, lDelete, lIncremento, lIgnEstado, lChequea); IIF( .F., s_oClass:ModMethod( "AlbCli", @TStock_AlbCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AlbCli", @TStock_AlbCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ChkAlbCli( cNumAlb); IIF( .F., s_oClass:ModMethod( "ChkAlbCli", @TStock_ChkAlbCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ChkAlbCli", @TStock_ChkAlbCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AlqCli( cNumAlq, cCodAlm, lDelete, lIncremento, lIgnEstado, lChequea); IIF( .F., s_oClass:ModMethod( "AlqCli", @TStock_AlqCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AlqCli", @TStock_AlqCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER FacCli( cNumFac, cCodAlm, lDelete, lIncremento); IIF( .F., s_oClass:ModMethod( "FacCli", @TStock_FacCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FacCli", @TStock_FacCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ChkFacCli( cNumFac); IIF( .F., s_oClass:ModMethod( "ChkFacCli", @TStock_ChkFacCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ChkFacCli", @TStock_ChkFacCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER FacRec( cNumFac, cCodAlm, lDelete, lIncremento); IIF( .F., s_oClass:ModMethod( "FacRec", @TStock_FacRec(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FacRec", @TStock_FacRec(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DepAge( cNumDep, cCodAlmEntrda, cCodAlmSalida, lDelete, lIncremento); IIF( .F., s_oClass:ModMethod( "DepAge", @TStock_DepAge(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DepAge", @TStock_DepAge(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ExtAge( cNumDep, cCodAlm, lDelete, lIncremento); IIF( .F., s_oClass:ModMethod( "ExtAge", @TStock_ExtAge(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ExtAge", @TStock_ExtAge(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER TpvCli( cNumFac, cCodAlm, lIncremento); IIF( .F., s_oClass:ModMethod( "TpvCli", @TStock_TpvCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "TpvCli", @TStock_TpvCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ChkTikCli( cNumTik); IIF( .F., s_oClass:ModMethod( "ChkTikCli", @TStock_ChkTikCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ChkTikCli", @TStock_ChkTikCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER nStockActual( cCodArt, cCodAlm, cValPr1, cValPr2); IIF( .F., s_oClass:ModMethod( "nStockActual", @TStock_nStockActual(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nStockActual", @TStock_nStockActual(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nTotStockAct( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, lKitArt, nKitStk); IIF( .F., s_oClass:ModMethod( "nTotStockAct", @TStock_nTotStockAct(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nTotStockAct", @TStock_nTotStockAct(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nPutStockActual( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, lKitAct, nKitStk, oSay); IIF( .F., s_oClass:ModMethod( "nPutStockActual", @TStock_nPutStockActual(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nPutStockActual", @TStock_nPutStockActual(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lPutStockActual( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, lKitAct, nKitStk, oSay); IIF( .F., s_oClass:ModMethod( "lPutStockActual", @TStock_lPutStockActual(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lPutStockActual", @TStock_lPutStockActual(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Recalcula( oMeter, cPath); IIF( .F., s_oClass:ModMethod( "Recalcula", @TStock_Recalcula(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Recalcula", @TStock_Recalcula(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER Duplicados( oMeter, aMsg, cPath); IIF( .F., s_oClass:ModMethod( "Duplicados", @TStock_Duplicados(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Duplicados", @TStock_Duplicados(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER StockInit( cPath, cPathOld, oMsg, lAlbPrv, lAlbCli, lGrupo); IIF( .F., s_oClass:ModMethod( "StockInit", @TStock_StockInit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "StockInit", @TStock_StockInit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nGetUndRes(); IIF( .F., s_oClass:ModMethod( "nGetUndRes", @TStock_nGetUndRes(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nGetUndRes", @TStock_nGetUndRes(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetEstadoPedCli( cNumPed); IIF( .F., s_oClass:ModMethod( "SetEstadoPedCli", @TStock_SetEstadoPedCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetEstadoPedCli", @TStock_SetEstadoPedCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetRecibidoPedCli( cNumPed); IIF( .F., s_oClass:ModMethod( "SetRecibidoPedCli", @TStock_SetRecibidoPedCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetRecibidoPedCli", @TStock_SetRecibidoPedCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetGeneradoPedCli( cNumPed); IIF( .F., s_oClass:ModMethod( "SetGeneradoPedCli", @TStock_SetGeneradoPedCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetGeneradoPedCli", @TStock_SetGeneradoPedCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetPedPrv( cNumPed); IIF( .F., s_oClass:ModMethod( "SetPedPrv", @TStock_SetPedPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetPedPrv", @TStock_SetPedPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AppMovAlm( cRefMov, cValPr1, cValPr2, cCodAlm, cValPr1, cValPr2, nCajMov, nUndMov, lApp, cLote); IIF( .F., s_oClass:ModMethod( "AppMovAlm", @TStock_AppMovAlm(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AppMovAlm", @TStock_AppMovAlm(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nTotAlbPrv( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha); IIF( .F., s_oClass:ModMethod( "nTotAlbPrv", @TStock_nTotAlbPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nTotAlbPrv", @TStock_nTotAlbPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nTotFacPrv( cCodArt); IIF( .F., s_oClass:ModMethod( "nTotFacPrv", @TStock_nTotFacPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nTotFacPrv", @TStock_nTotFacPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nTotRctPrv( cCodArt); IIF( .F., s_oClass:ModMethod( "nTotRctPrv", @TStock_nTotRctPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nTotRctPrv", @TStock_nTotRctPrv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nTotAlbCli( cCodArt); IIF( .F., s_oClass:ModMethod( "nTotAlbCli", @TStock_nTotAlbCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nTotAlbCli", @TStock_nTotAlbCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nTotFacCli( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha); IIF( .F., s_oClass:ModMethod( "nTotFacCli", @TStock_nTotFacCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nTotFacCli", @TStock_nTotFacCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nTotFacRec( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha); IIF( .F., s_oClass:ModMethod( "nTotFacRec", @TStock_nTotFacRec(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nTotFacRec", @TStock_nTotFacRec(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nTotTikCli( cCodArt); IIF( .F., s_oClass:ModMethod( "nTotTikCli", @TStock_nTotTikCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nTotTikCli", @TStock_nTotTikCli(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nTotMovAlm( cCodArt); IIF( .F., s_oClass:ModMethod( "nTotMovAlm", @TStock_nTotMovAlm(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nTotMovAlm", @TStock_nTotMovAlm(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nStockActualCalculado( cCodArt, cCodAlm, cValPr1, cValPr2, cLote); IIF( .F., s_oClass:ModMethod( "nStockActualCalculado", @TStock_nStockActualCalculado(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nStockActualCalculado", @TStock_nStockActualCalculado(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nStockAlmacen( cCodArt, cCodAlm, cValPr1, cValPr2, cLote); IIF( .F., s_oClass:ModMethod( "nStockAlmacen", @TStock_nStockAlmacen(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nStockAlmacen", @TStock_nStockAlmacen(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nTotalSaldo( cCodArt, cCodCli); IIF( .F., s_oClass:ModMethod( "nTotalSaldo", @TStock_nTotalSaldo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nTotalSaldo", @TStock_nTotalSaldo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nSaldoDocumento( cCodArt, cNumDoc); IIF( .F., s_oClass:ModMethod( "nSaldoDocumento", @TStock_nSaldoDocumento(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nSaldoDocumento", @TStock_nSaldoDocumento(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nSaldoAnterior( cCodArt, cCodCli, cNumDoc); IIF( .F., s_oClass:ModMethod( "nSaldoAnterior", @TStock_nSaldoAnterior(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nSaldoAnterior", @TStock_nSaldoAnterior(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nSaldoAntAlb( cCodArt, cNumDoc); IIF( .F., s_oClass:ModMethod( "nSaldoAntAlb", @TStock_nSaldoAntAlb(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nSaldoAntAlb", @TStock_nSaldoAntAlb(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nSaldoDocAlb( cCodArt, cNumDoc); IIF( .F., s_oClass:ModMethod( "nSaldoDocAlb", @TStock_nSaldoDocAlb(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nSaldoDocAlb", @TStock_nSaldoDocAlb(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nPrecioMedioCompra( cCodArt, cCodAlm, dFecIni, dFecFin, lSerie, lExcCero, lExcImp); IIF( .F., s_oClass:ModMethod( "nPrecioMedioCompra", @TStock_nPrecioMedioCompra(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nPrecioMedioCompra", @TStock_nPrecioMedioCompra(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER aStockArticulo( cCodArt); IIF( .F., s_oClass:ModMethod( "aStockArticulo", @TStock_aStockArticulo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "aStockArticulo", @TStock_aStockArticulo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nStockArticulo( cCodArt); IIF( .F., s_oClass:ModMethod( "nStockArticulo", @TStock_nStockArticulo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nStockArticulo", @TStock_nStockArticulo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nStockSerie( cCodArt, cCodAlm, uNumeroSerie); IIF( .F., s_oClass:ModMethod( "nStockSerie", @TStock_nStockSerie(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nStockSerie", @TStock_nStockSerie(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER aStockAlmacen( oRemMov); IIF( .F., s_oClass:ModMethod( "aStockAlmacen", @TStock_aStockAlmacen(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "aStockAlmacen", @TStock_aStockAlmacen(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Integra( sStock); IIF( .F., s_oClass:ModMethod( "Integra", @TStock_Integra(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Integra", @TStock_Integra(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lValidNumeroSerie( cCodArt, cCodAlm, nNumSer, lMessage); IIF( .F., s_oClass:ModMethod( "lValidNumeroSerie", @TStock_lValidNumeroSerie(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lValidNumeroSerie", @TStock_lValidNumeroSerie(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER BrowseNumeroSerie( cCodArt, cCodAlm); IIF( .F., s_oClass:ModMethod( "BrowseNumeroSerie", @TStock_BrowseNumeroSerie(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "BrowseNumeroSerie", @TStock_BrowseNumeroSerie(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetTmpAlbCliL(tmpAlbCliL); IIF( .F., s_oClass:ModInline( "SetTmpAlbCliL", {|Self,tmpAlbCliL | Self, ( ::tmpAlbCliL := tmpAlbCliL ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetTmpAlbCliL", {|Self,tmpAlbCliL | Self, ( ::tmpAlbCliL := tmpAlbCliL ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER SetTmpAlbCliS(tmpAlbCliS); IIF( .F., s_oClass:ModInline( "SetTmpAlbCliS", {|Self,tmpAlbCliS | Self, ( ::tmpAlbCliS := tmpAlbCliS ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetTmpAlbCliS", {|Self,tmpAlbCliS | Self, ( ::tmpAlbCliS := tmpAlbCliS ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetTmpFacCliL(tmpFacCliL); IIF( .F., s_oClass:ModInline( "SetTmpFacCliL", {|Self,tmpFacCliL | Self, ( ::tmpFacCliL := tmpFacCliL ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetTmpFacCliL", {|Self,tmpFacCliL | Self, ( ::tmpFacCliL := tmpFacCliL ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER SetTmpFacCliS(tmpFacCliS); IIF( .F., s_oClass:ModInline( "SetTmpFacCliS", {|Self,tmpFacCliS | Self, ( ::tmpFacCliS := tmpFacCliS ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetTmpFacCliS", {|Self,tmpFacCliS | Self, ( ::tmpFacCliS := tmpFacCliS ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetTmpFacRecL(tmpFacRecL); IIF( .F., s_oClass:ModInline( "SetTmpFacRecL", {|Self,tmpFacRecL | Self, ( ::tmpFacRecL := tmpFacRecL ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetTmpFacRecL", {|Self,tmpFacRecL | Self, ( ::tmpFacRecL := tmpFacRecL ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER SetTmpFacRecS(tmpFacRecS); IIF( .F., s_oClass:ModInline( "SetTmpFacRecS", {|Self,tmpFacRecS | Self, ( ::tmpFacRecS := tmpFacRecS ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetTmpFacRecS", {|Self,tmpFacRecS | Self, ( ::tmpFacRecS := tmpFacRecS ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER nRiesgo( cCodigoCliente); IIF( .F., s_oClass:ModMethod( "nRiesgo", @TStock_nRiesgo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nRiesgo", @TStock_nRiesgo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetRiesgo( cCodigoCliente, oGetRiesgo, nRiesgoCliente); IIF( .F., s_oClass:ModMethod( "SetRiesgo", @TStock_SetRiesgo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetRiesgo", @TStock_SetRiesgo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nCostoMedio( cCodArt, cCodAlm, cCodPr1, cCodPr2, cValPr1, cValPr2); IIF( .F., s_oClass:ModMethod( "nCostoMedio", @TStock_nCostoMedio(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nCostoMedio", @TStock_nCostoMedio(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GetConsolidacion(); IIF( .F., s_oClass:ModMethod( "GetConsolidacion", @TStock_GetConsolidacion(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetConsolidacion", @TStock_GetConsolidacion(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lValoracionCostoMedio( nTipMov); IIF( .F., s_oClass:ModMethod( "lValoracionCostoMedio", @TStock_lValoracionCostoMedio(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lValoracionCostoMedio", @TStock_lValoracionCostoMedio(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TStock ;



UTILITY STATIC function TStock_New( cPath, lExclusive) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   IIF( cPath == nil, cPath := cPatGrp(), ) ;
   IIF( lExclusive == nil, lExclusive := .F., ) ;

   ::cPath              := cPath
   ::lExclusive         := lExclusive

   ::aStocks            := { sStock():New() }

   ::lOpenFiles( cPath, lExclusive )

Return Self



UTILITY STATIC function TStock_Create( cPath, lExclusive) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   IIF( cPath == nil, cPath := cPatGrp(), ) ;
   IIF( lExclusive == nil, lExclusive := .F., ) ;

   ::cPath              := cPath
   ::lExclusive         := lExclusive

   ::aStocks            := { sStock():New() }

Return Self



UTILITY STATIC function TStock_CreateFiles( cPath) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   IIF( cPath == nil, cPath := ::cPath, ) ;

   aAdd( ::aMovAlm, { "cCodArt", "C", 18, 0, ""                                           } )
   aAdd( ::aMovAlm, { "cCodAlm", "C",  3, 0, ""                                           } )
   aAdd( ::aMovAlm, { "cCodPr1", "C", 10, 0, ""                                           } )
   aAdd( ::aMovAlm, { "cCodPr2", "C", 10, 0, ""                                           } )
   aAdd( ::aMovAlm, { "cValPr1", "C", 10, 0, ""                                           } )
   aAdd( ::aMovAlm, { "cValPr2", "C", 10, 0, ""                                           } )
   aAdd( ::aMovAlm, { "nStkAct", "N", 19, 6, "Stock actual"                               } )
   aAdd( ::aMovAlm, { "nStkIn",  "N", 19, 6, "Stock entrada"                              } )
   aAdd( ::aMovAlm, { "nStkPdr", "N", 19, 6, "Stock pendiente de recibir"                 } )
   aAdd( ::aMovAlm, { "nStkPde", "N", 19, 6, "Stock pendiente de entregar"                } )
   aAdd( ::aMovAlm, { "nStkPdc", "N", 19, 6, "Stock pendiente de entregar comprometido"   } )
   aAdd( ::aMovAlm, { "nStkEnt", "N", 19, 6, "Total de stock comprado"                    } )
   aAdd( ::aMovAlm, { "nStkSal", "N", 19, 6, "Total de stock vendido"                     } )
   aAdd( ::aMovAlm, { "nImpStk", "N", 19, 6, "Importe de stock"                           } )
   aAdd( ::aMovAlm, { "nLote"  , "N",  9, 0, "Número de lote"                             } )
   aAdd( ::aMovAlm, { "cLote"  , "C", 12, 0, "Número de lote"                             } )

   if !lExistTable( cPath + "MovAlm.Dbf" )
      dbCreate( cPath + "MovAlm.Dbf", aSqlStruct( ::aMovAlm ), cDriver() )
   end

   ::ReindexFiles( cPath )

RETURN ( Self )



UTILITY STATIC function TStock_DeleteFiles( cPath) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   IIF( cPath == nil, cPath := ::cPath, ) ;

   dbfErase( cPath + "MovAlm" )

RETURN ( Self )



UTILITY STATIC function TStock_ReindexFiles( cPath, oMeter) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local dbfMovAlm

   IIF( cPath == nil, cPath := ::cPath, ) ;

   if !lExistTable( cPath + "MovAlm.Dbf" )
      ::CreateFiles( cPath )
   end

   fEraseIndex( cPath + "MovAlm.Cdx" )

   dbUseArea( .T., cDriver(), cPath + "MovAlm.Dbf", cCheckArea( "MovAlm", @dbfMovAlm ), .F. )
   if !( dbfMovAlm )->( netErr() )
      ( dbfMovAlm )->( ordCondSet( "!Deleted()", {||!Deleted()}  ) )
      ( dbfMovAlm )->( ordCreate( cPath + "MovAlm.Cdx", "Codigo", "cCodArt + cValPr1 + cValPr2 + cCodAlm + cLote", {|| Field->cCodArt + Field->cValPr1 + Field->cValPr2 + Field->cCodAlm + Field->cLote } ) )

      ( dbfMovAlm )->( dbCloseArea() )
   end


RETURN ( Self )



UTILITY STATIC function TStock_lOpenFiles( cPath, lExclusive) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local lOpen          := .T.
   local oError
   local oBlock

   IIF( cPath == nil, cPath := ::cPath, ) ;
   IIF( lExclusive == nil, lExclusive := ::lExclusive, ) ;

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "Divisas.Dbf" ), ( ::dbfDiv := cCheckArea( "Divisas" ) ), .T. )
      IIF( !lAIS(), ( ::dbfDiv )->( OrdListAdd( cPatDat() + "Divisas.Cdx" ) ), ( ::dbfDiv )->( OrdSetFocus( 1 ) ) )

      ::nDouDiv         := nDouDiv( cDivEmp(), ::dbfDiv )
      ::nDorDiv         := nRouDiv( cDivEmp(), ::dbfDiv )
      ::nDinDiv         := nDinDiv( cDivEmp(), ::dbfDiv )
      ::nDirDiv         := nRinDiv( cDivEmp(), ::dbfDiv )
      ::nVdvDiv         := nChgDiv( cDivEmp(), ::dbfDiv )
      ::nDecIn          := nDinDiv( cDivEmp(), ::dbfDiv )
      ::nDerIn          := nRinDiv( cDivEmp(), ::dbfDiv )

   RECOVER USING oError

      lOpen             := .F.

      MsgStop( ErrorMessage( oError ), "Imposible abrir las bases de datos de stocks" )

   end

   ErrorBlock( oBlock )

   if !lOpen
      ::CloseFiles()
   end

RETURN ( lOpen )






UTILITY STATIC function TStock_PedPrv( cNumPed, cCodAlm, lDelete, lIncremento) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nUnits

   IIF( cCodAlm == nil, cCodAlm := oUser():cAlmacen(), ) ;
   IIF( lDelete == nil, lDelete := .T., ) ;
   IIF( lIncremento == nil, lIncremento := .T., ) ;





   if ::cPedPrvL == nil .OR. cNumPed == nil
      msgAlert( "Imposible realizar la actualización de stocks.", "Atención" )
      return self
   end

   if ( ::cPedPrvL )->( dbSeek( cNumPed ) )



      while ( ::cPedPrvL )->cSerPed + Str( ( ::cPedPrvL )->nNumPed ) + ( ::cPedPrvL )->cSufPed == cNumPed .AND.  !( ::cPedPrvL )->( eof() )
         if !Empty( Rtrim( ( ::cPedPrvL )->cRef ) )

            nUnits      := nTotNPedPrv( ::cPedPrvL ) - ( ::cPedPrvL )->nUniEnt





            if ( ::cPedPrvL )->nFacCnv <> 0
               nUnits   := nUnits * ( ::cPedPrvL )->nFacCnv
            end

         end





         if lDelete .AND. dbLock( ::cPedPrvL )
            ( ::cPedPrvL )->( dbDelete() )
            ( ::cPedPrvL )->( dbUnLock() )
         end

         ( ::cPedPrvL )->( dbSkip() )

      end

   end

return self



UTILITY STATIC function TStock_AlbPrv( cNumAlb, cCodAlm, cNumPed, lDelete, lIncremento, lIgnEstado, lActPendientes) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

































































Return Self




UTILITY STATIC function TStock_SetPedPrv( cNumPed) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nTotPedPrv     := 0
   local nRecPedPrv     := 0
   local nTotLineaAct   := 0
   local nEstPed
   local nRegAnt        := ( ::cPedPrvT )->( RecNo() )
   local nOrdAnt        := ( ::cPedPrvT )->( OrdSetFocus( "nNumPed" ) )

   if Empty( ::cPedPrvT ) .OR. Empty( ::cPedPrvL )
      return .F.
   end





   if !Empty( cNumPed )                            .AND. ( ::cPedPrvT )->( dbSeek( cNumPed ) )        .AND. ( ::cPedPrvL )->( dbSeek( cNumPed ) )

      while ( ::cPedPrvL )->cSerPed + Str( ( ::cPedPrvL )->nNumPed ) + ( ::cPedPrvL )->cSufPed == cNumPed .AND. !( ::cPedPrvL )->( eof() )

         if !( ::cPedPrvL )->lAnulado




            nTotLineaAct:= nTotNPedPrv( ::cPedPrvL )
            nTotPedPrv  += nTotLineaAct
            nRecPedPrv  += Min( nUnidadesRecibidasPedPrv( cNumPed, ( ::cPedPrvL )->cRef, ( ::cPedPrvL )->cValPr1, ( ::cPedPrvL )->cValPr2, ( ::cPedPrvL )->cRefPrv, ( ::cPedPrvL )->cDetalle, ::cAlbPrvL ), nTotLineaAct )

         end

         ( ::cPedPrvL )->( dbSkip() )

      end

      do case
         case nRecPedPrv == 0
            nEstPed  := 1

         case nTotPedPrv > nRecPedPrv
            nEstPed  := 2

         case nRecPedPrv >= nTotPedPrv
            nEstPed  := 3

      end

      if dbLock( ::cPedPrvT )
         ( ::cPedPrvT )->nEstado := nEstPed
         ( ::cPedPrvT )->( dbUnLock() )
      end

   end

   ( ::cPedPrvT )->( OrdSetFocus( nOrdAnt ) )
   ( ::cPedPrvT )->( DbGoTo( nRegAnt ) )

Return ( Self )



UTILITY STATIC function TStock_FacPrv( cNumFac, cCodAlm, lDelete, lIncremento) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nUnits

   IIF( cCodAlm == nil, cCodAlm := oUser():cAlmacen(), ) ;
   IIF( lDelete == nil, lDelete := .T., ) ;
   IIF( lIncremento == nil, lIncremento := .T., ) ;





   if ::cFacPrvL == nil .OR. cNumFac == nil
      msgAlert( "Imposible realizar la actualización de stocks.", "Atención" )
      return self
   end

   if ( ::cFacPrvL )->( dbSeek( cNumFac ) )



      while ( ::cFacPrvL )->cSerFac + Str( ( ::cFacPrvL )->nNumFac ) + ( ::cFacPrvL )->cSufFac == cNumFac .AND.  !( ::cFacPrvL )->( eof() )
         if !empty( rtrim( ( ::cFacPrvL )->cRef ) )

            nUnits      := nTotNFacPrv( ::cFacPrvL )





            if ( ::cFacPrvL )->nFacCnv <> 0
               nUnits   := nUnits * ( ::cFacPrvL )->nFacCnv
            end



            if Empty( ( ::cFacPrvL )->cAlmLin ) .AND. dbLock( ::cFacPrvL )
               ( ::cFacPrvL )->cAlmLin    := ( ::cFacPrvT )->cCodAlm
               ( ::cFacPrvL )->( dbUnLock() )
            end

         end



         if lDelete .AND. dbLock( ::cFacPrvL )
            ( ::cFacPrvL )->( dbDelete() )
            ( ::cFacPrvL )->( dbUnLock() )
         end

         ( ::cFacPrvL )->( dbSkip() )

      end

   end



Return ( Self )



UTILITY STATIC function TStock_ChkFacPrv( cNumFac) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nTotStock
   local nTotStockCalculado
   local aFacPrvL       := aGetStatus( ::cFacPrvL, .T. )





      if ( ::cFacPrvL )->( dbSeek( cNumFac ) )


         while ( ::cFacPrvL )->cSerFac + Str( ( ::cFacPrvL )->nNumFac ) + ( ::cFacPrvL )->cSufFac == cNumFac .AND.  !( ::cFacCliL )->( eof() )

            if !Empty( Rtrim( ( ::cFacPrvL )->cRef ) )

            nTotStock            := ::nTotStockAct( ( ::cFacPrvL )->cRef )
            nTotStockCalculado   := nStockCalculado( ( ::cFacPrvL )->cRef )

               if nTotStock <> nTotStockCalculado


                  MsgStop( "DECUADRE EN STOCK FACTURAS DE PROVEEDOR " + ( ::cFacPrvL )->cRef + Chr(13)+Chr(10) +  "Actual" + Trans( nTotStock, "@E 9999999.999999" )                + Chr(13)+Chr(10) +  "Calculado" + Trans( nTotStockCalculado, "@E 9999999.999999" ) )
               end

            end

            ( ::cFacPrvL )->( dbSkip() )

         end

      end

   SetStatus( ::cFacPrvL, aFacPrvL )

return self



UTILITY STATIC function TStock_RctPrv( cNumFac, cCodAlm, lDelete, lIncremento) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nUnits

   IIF( cCodAlm == nil, cCodAlm := oUser():cAlmacen(), ) ;
   IIF( lDelete == nil, lDelete := .T., ) ;
   IIF( lIncremento == nil, lIncremento := .T., ) ;





   if ::cRctPrvL == nil .OR. cNumFac == nil
      msgAlert( "Imposible realizar la actualización de stocks.", "Atención" )
      return self
   end

   if ( ::cRctPrvL )->( dbSeek( cNumFac ) )



      while ( ::cRctPrvL )->cSerFac + Str( ( ::cRctPrvL )->nNumFac ) + ( ::cRctPrvL )->cSufFac == cNumFac .AND.  !( ::cRctPrvL )->( eof() )
         if !empty( rtrim( ( ::cRctPrvL )->cRef ) )

            nUnits      := nTotNRctPrv( ::cRctPrvL )





            if ( ::cRctPrvL )->nFacCnv <> 0
               nUnits   := nUnits * ( ::cRctPrvL )->nFacCnv
            end



            if Empty( ( ::cRctPrvL )->cAlmLin ) .AND. dbLock( ::cRctPrvL )
               ( ::cRctPrvL )->cAlmLin    := ( ::cRctPrvT )->cCodAlm
               ( ::cRctPrvL )->( dbUnLock() )
            end

         end



         if lDelete .AND. dbLock( ::cRctPrvL )
            ( ::cRctPrvL )->( dbDelete() )
            ( ::cRctPrvL )->( dbUnLock() )
         end

         ( ::cRctPrvL )->( dbSkip() )

      end

   end



Return ( Self )



UTILITY STATIC function TStock_ChkRctPrv( cNumFac) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nTotStock
   local nTotStockCalculado
   local aRctPrvL       := aGetStatus( ::cRctPrvL, .T. )





      if ( ::cRctPrvL )->( dbSeek( cNumFac ) )


         while ( ::cRctPrvL )->cSerFac + Str( ( ::cRctPrvL )->nNumFac ) + ( ::cRctPrvL )->cSufFac == cNumFac .AND.  !( ::cFacCliL )->( eof() )

            if !Empty( Rtrim( ( ::cRctPrvL )->cRef ) )

            nTotStock            := ::nTotStockAct( ( ::cRctPrvL )->cRef )
            nTotStockCalculado   := nStockCalculado( ( ::cRctPrvL )->cRef )

               if nTotStock <> nTotStockCalculado


                  MsgStop( "DECUADRE EN STOCK FACTURAS DE PROVEEDOR " + ( ::cRctPrvL )->cRef + Chr(13)+Chr(10) +  "Actual" + Trans( nTotStock, "@E 9999999.999999" )                + Chr(13)+Chr(10) +  "Calculado" + Trans( nTotStockCalculado, "@E 9999999.999999" ) )
               end

            end

            ( ::cRctPrvL )->( dbSkip() )

         end

      end

   SetStatus( ::cRctPrvL, aRctPrvL )

return self



UTILITY STATIC function TStock_PedCli( cNumPed, cCodAlm, lDelete, lIncremento) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nUndPed
   local nUndRes

   IIF( cCodAlm == nil, cCodAlm := oUser():cAlmacen(), ) ;
   IIF( lDelete == nil, lDelete := .T., ) ;
   IIF( lIncremento == nil, lIncremento := .T., ) ;





   if Empty( cNumPed ) .OR. Empty( ::cPedCliL ) .OR. Empty( ::cAlbCliT ) .OR. Empty( ::cAlbCliL ) .OR. Empty( ::cAlbPrvL )
      msgAlert( "Imposible realizar la actualización de stocks.", "Atención" )
      return self
   end

   if ( ::cPedCliL )->( dbSeek( cNumPed ) )


      while ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed == cNumPed .AND.  !( ::cPedCliL )->( eof() )

         if !Empty( Rtrim( ( ::cPedCliL )->cRef ) )

            nUndPed     := nTotNPedCli( ::cPedCliL )
            nUndRes     := nTotRPedCli( ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed, ( ::cPedCliL )->cRef, ( ::cPedCliL )->cValPr1, ( ::cPedCliL )->cValPr2, ::cPedCliR )





            if Empty( ( ::cPedCliL )->cAlmLin )
               if dbLock( ::cPedCliL )
                  ( ::cPedCliL )->cAlmLin    := ( ::cPedCliT )->cCodAlm
                  ( ::cPedCliL )->( dbUnLock() )
               end
            end

         end





         if lDelete .AND. dbLock( ::cPedCliL )
            ( ::cPedCliL )->( dbDelete() )
            ( ::cPedCliL )->( dbUnLock() )
         end

         ( ::cPedCliL )->( dbSkip() )

      end

   end





   if ::cPedCliR <> nil .AND. lDelete .AND. ( ::cPedCliR )->( dbSeek( cNumPed ) )


      while ( ::cPedCliR )->cSerPed + Str( ( ::cPedCliR )->nNumPed ) + ( ::cPedCliR )->cSufPed == cNumPed .AND.  !( ::cPedCliR )->( eof() )

         if dbLock( ::cPedCliR )
            ( ::cPedCliR )->( dbDelete() )
            ( ::cPedCliR )->( dbUnLock() )
         end

         ( ::cPedCliR )->( dbSkip() )

      end

   end

return self



UTILITY STATIC function TStock_SetEstadoPedCli( cNumPed, lFactura, cNumFac) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nEstPed        := 1
   local nTotPed        := 0
   local nTotSer        := 0
   local nTotLineaAct   := 0

   IIF( lFactura == nil, lFactura := .F., ) ;

   if Empty( ::cPedCliT ) .OR. Empty( ::cPedCliL )
      return .F.
   end






   if ( ::cPedCliT )->( dbSeek( cNumPed ) )  .AND. ( ::cPedCliL )->( dbSeek( cNumPed ) )


      while ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed == cNumPed .AND. !( ::cPedCliL )->( eof() )

         if !( ::cPedCliL )->lAnulado




            nTotLineaAct:= nTotNPedCli( ::cPedCliL )

            nTotPed     += nTotLineaAct

            nTotSer     += Min( nUnidadesRecibidasAlbCli( ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed, ( ::cPedCliL )->cRef, ( ::cPedCliL )->cCodPr1, ( ::cPedCliL )->cCodPr2, ( ::cPedCliL )->cRefPrv, ( ::cPedCliL )->cDetalle, ::cAlbCliL ), nTotLineaAct )
            nTotSer     += Min( nUnidadesRecibidasFacCli( ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed, ( ::cPedCliL )->cRef, ( ::cPedCliL )->cValPr1, ( ::cPedCliL )->cValPr2, ::cFacCliL ), nTotLineaAct )


         end

         ( ::cPedCliL )->( dbSkip() )

      end





      do case
         case nTotSer == 0
            nEstPed     := 1
         case nTotPed > nTotSer
            nEstPed     := 2
         case nTotSer >= nTotPed
            nEstPed     := 3
      end

      if dbLock( ::cPedCliT )
         ( ::cPedCliT )->nEstado := nEstPed
         ( ::cPedCliT )->( dbUnlock() )
      end

   end

Return .T.



UTILITY STATIC function TStock_SetRecibidoPedCli( cNumPed) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nUndPed
   local nEstPed        := 0
   local nTotRec        := 0
   local nTotPed        := 0





   if Empty( cNumPed ) .OR. Empty( ::cPedCliT ) .OR. Empty( ::cPedCliL ) .OR. Empty( ::cAlbPrvL )

      return self
   end


   if ( ::cPedCliT )->( dbSeek( cNumPed ) )  .AND. ( ::cPedCliL )->( dbSeek( cNumPed ) )


      while ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed == cNumPed .AND.  !( ::cPedCliL )->( eof() )

         if !Empty( ( ::cPedCliL )->cRef )

            nUndPed     := nTotNPedCli( ::cPedCliL )
            nTotPed     += nUndPed
            nTotRec     += Min( nUnidadesRecibidasPedCli( ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed, ( ::cPedCliL )->cRef, ( ::cPedCliL )->cValPr1, ( ::cPedCliL )->cValPr2,  ( ::cPedCliL )->cRefPrv, ( ::cPedCliL )->cDetalle, ::cAlbPrvL ), nUndPed )

         end

         ( ::cPedCliL )->( dbSkip() )

      end





      do case
         case nTotRec == 0
            nEstPed  := 1
         case nTotRec < nTotPed
            nEstPed  := 2
         case nTotRec >= nTotPed
            nEstPed  := 3
      end

      if dbLock( ::cPedCliT )
         ( ::cPedCliT )->nRecibido  := Max( nEstPed, 1 )
         ( ::cPedCliT )->( dbUnLock() )
      end

   end

Return ( Self )



UTILITY STATIC function TStock_SetGeneradoPedCli( cNumPed) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nEstado  := 0
   local nRecCliT := ( ::cPedCliT )->( Recno() )
   local nRecCliL := ( ::cPedCliL )->( Recno() )
   local nOrdCliT := ( ::cPedCliT )->( OrdSetFocus( "nNumPed" ) )
   local nOrdCliL := ( ::cPedCliL )->( OrdSetFocus( "nNumPed" ) )





   if Empty( cNumPed ) .OR. Empty( ::cPedCliT ) .OR. Empty( ::cPedCliL ) .OR. Empty( ::cPedPrvL )
      msgAlert( "Imposible actualizar el estado del pedido.", "Atención" )
      return self
   end


   if ( ::cPedCliT )->( dbSeek( cNumPed ) )  .AND.  ( ::cPedCliL )->( dbSeek( cNumPed ) )


      while ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed == cNumPed .AND.  !( ::cPedCliL )->( eof() )

         if nTotNPedCli( ::cPedCliL ) <> 0

            if IsMuebles()

               if dbSeekInOrd( cNumPed + ( ::cPedCliL )->cRef + ( ::cPedCliL )->cValPr1 + ( ::cPedCliL )->cValPr2 + ( ::cPedCliL )->cRefPrv + ( ::cPedCliL )->cDetalle, "cPedCliDet", ::cPedPrvL )

                  do case
                     case nEstado == 0 .OR. nEstado == 3
                        nEstado := 3
                     case nEstado == 1
                        nEstado := 2
                  end

               else

                  do case
                     case nEstado == 0
                        nEstado := 1
                     case nEstado == 3
                        nEstado := 2
                  end
               end

            else

               if dbSeekInOrd( cNumPed + ( ::cPedCliL )->cRef + ( ::cPedCliL )->cValPr1 + ( ::cPedCliL )->cValPr2, "cPedCliRef", ::cPedPrvL )

                  do case
                     case nEstado == 0 .OR. nEstado == 3
                        nEstado := 3
                     case nEstado == 1
                        nEstado := 2
                  end

               else

                  do case
                     case nEstado == 0
                        nEstado := 1
                     case nEstado == 3
                        nEstado := 2
                  end

               end

            end

         end

         ( ::cPedCliL )->( dbSkip() )

      end

      if dbLock( ::cPedCliT )
         ( ::cPedCliT )->nGenerado  := Max( nEstado, 1 )
         ( ::cPedCliT )->( dbUnLock() )
      end

   end

   ( ::cPedCliT )->( OrdSetFocus( nOrdCliT ) )
   ( ::cPedCliL )->( OrdSetFocus( nOrdCliL ) )
   ( ::cPedCliT )->( dbGoTo( nRecCliT ) )
   ( ::cPedCliL )->( dbGoTo( nRecCliL ) )

Return ( Self )






UTILITY STATIC function TStock_nGetUndRes() ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nUndRes  := nTotRPedCli( ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed, ( ::cPedCliL )->cRef, ( ::cPedCliL )->cValPr1, ( ::cPedCliL )->cValPr2, ::cPedCliR )

   if nUndRes <> 0

      nUndRes     -= nUnidadesRecibidasAlbCli( ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed, ( ::cPedCliL )->cRef, ( ::cPedCliL )->cValPr1, ( ::cPedCliL )->cValPr2, ( ::cPedCliL )->cRefPrv, ( ::cPedCliL )->cDetalle, ::cAlbCliL )





      if nUndRes < 0
         nUndRes  := 0
      end

   end

return ( nUndRes )



UTILITY STATIC function TStock_AlbCli( cNumAlb, cCodAlm, lDelete, lIncremento, lIgnEstado, lChequea, lActPendientes) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock





















































































return self



UTILITY STATIC function TStock_ChkAlbCli( cNumAlb) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nTotStock
   local nTotStockCalculado
   local aAlbCliT       := aGetStatus( ::cAlbCliT, .T. )
   local aAlbCliL       := aGetStatus( ::cAlbCliL, .T. )





   if ( ::cAlbCliT )->( dbSeek( cNumAlb ) )

      if ( ::cAlbCliL )->( dbSeek( cNumAlb ) )



         while ( ::cAlbCliL )->cSerAlb + Str( ( ::cAlbCliL )->nNumAlb ) + ( ::cAlbCliL )->cSufAlb == cNumAlb .AND.  !( ::cAlbCliL )->( eof() )
            if !Empty( Rtrim( ( ::cAlbCliL )->cRef ) )

            nTotStock            := ::nTotStockAct( ( ::cAlbCliL )->cRef )
            nTotStockCalculado   := nStockCalculado( ( ::cAlbCliL )->cRef )

               if nTotStock <> nTotStockCalculado


                  MsgStop( "DECUADRE EN STOCK ALBARANES DE CLIENTES " + ( ::cAlbCliL )->cRef + Chr(13)+Chr(10) +  "Actual" + Trans( nTotStock, "@E 9999999.999999" )                + Chr(13)+Chr(10) +  "Calculado" + Trans( nTotStockCalculado, "@E 9999999.999999" ) )
               end

            end

            ( ::cAlbCliL )->( dbSkip() )

         end

      end

   end

   SetStatus( ::cAlbCliT, aAlbCliT )
   SetStatus( ::cAlbCliL, aAlbCliL )

return self



UTILITY STATIC function TStock_AlqCli( cNumAlq, cCodAlm, lDelete, lIncremento, lIgnEstado, lChequea) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

Return ( Self )



UTILITY STATIC function TStock_FacCli( cNumFac, cCodAlm, lDelete, lIncremento, lActPendientes) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock



























































return self



UTILITY STATIC function TStock_ChkFacCli( cNumFac) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nTotStock
   local nTotStockCalculado
   local aFacCliL       := aGetStatus( ::cFacCliL, .T. )





   if ( ::cFacCliL )->( dbSeek( cNumFac ) )


      while ( ::cFacCliL )->cSerie + Str( ( ::cFacCliL )->nNumFac ) + ( ::cFacCliL )->cSufFac == cNumFac .AND.  !( ::cFacCliL )->( eof() )

         if !Empty( Rtrim( ( ::cFacCliL )->cRef ) )

         nTotStock            := ::nTotStockAct( ( ::cFacCliL )->cRef )
         nTotStockCalculado   := nStockCalculado( ( ::cFacCliL )->cRef )

            if nTotStock <> nTotStockCalculado


               MsgStop( "DECUADRE EN STOCK FACTURAS DE CLIENTES " + ( ::cFacCliL )->cRef + Chr(13)+Chr(10) +  "Actual" + Trans( nTotStock, "@E 9999999.999999" )                + Chr(13)+Chr(10) +  "Calculado" + Trans( nTotStockCalculado, "@E 9999999.999999" ) )
            end

         end

         ( ::cFacCliL )->( dbSkip() )

      end

   end

   SetStatus( ::cFacCliL, aFacCliL )

return self



UTILITY STATIC function TStock_FacRec( cNumFac, cCodAlm, lDelete, lIncremento, lActPendientes) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nUnits
   local nPendEnt          := 0

   IIF( cCodAlm == nil, cCodAlm := oUser():cAlmacen(), ) ;
   IIF( lDelete == nil, lDelete := .T., ) ;
   IIF( lIncremento == nil, lIncremento := .T., ) ;
   IIF( lActPendientes == nil, lActPendientes := .F., ) ;





   if ::cFacRecL == nil .OR. cNumFac == nil
      msgAlert( "Imposible realizar la actualización de stocks.", "Atención" )
      return self
   end

   if ( ::cFacRecL )->( dbSeek( cNumFac ) )


      while ( ::cFacRecL )->cSerie + Str( ( ::cFacRecL )->nNumFac ) + ( ::cFacRecL )->cSufFac == cNumFac .AND. !( ::cFacRecL )->( eof() )

         if !empty( rtrim( ( ::cFacRecL )->cRef ) )

            nUnits      := nTotNFacRec( ::cFacRecL )





            if ( ::cFacRecL )->nFacCnv <> 0
               nUnits   := nUnits * ( ::cFacRecL )->nFacCnv
            end





            if Empty( ( ::cFacRecL )->cAlmLin )
               if dbLock( ::cFacRecL )
                  ( ::cFacRecL )->cAlmLin    := ( ::cFacRecT )->cCodAlm
                  ( ::cFacRecL )->( dbUnLock() )
               end
            end

         end





         if lDelete .AND. dbLock( ::cFacRecL )
            ( ::cFacRecL )->( dbDelete() )
            ( ::cFacRecL )->( dbUnLock() )
         end

         ( ::cFacRecL )->( dbSkip() )

      end

   end


return self



UTILITY STATIC function TStock_TpvCli( cNumTik, cCodAlm, lIncremento, lDevolucion, lChequea) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nRec
   local nUnits

   IIF( cCodAlm == nil, cCodAlm := oUser():cAlmacen(), ) ;
   IIF( lIncremento == nil, lIncremento := .T., ) ;
   IIF( lDevolucion == nil, lDevolucion := ( ( ::cTikT )->cTipTik == "4" .OR. ( ::cTikT )->cTipTik == "6" ), ) ;
   IIF( lChequea == nil, lChequea := .T., ) ;





   if ::cTikL == nil .OR. cNumTik == nil
      return self
   end

   if lDevolucion
      lIncremento       := !lIncremento
   end

   nRec                 := ( ::cTikL )->( Recno() )





   if ( ::cTikL )->( dbSeek( cNumTik ) )



      while ( ::cTikL )->cSerTil + ( ::cTikL )->cNumTil + ( ::cTikL )->cSufTil == cNumTik .AND.  !( ::cTikL )->( eof() )
         if !Empty( Rtrim( ( ::cTikL )->cCbaTil ) )

            nUnits      := ( ::cTikL )->nUntTil





            if ( ::cTikL )->nFacCnv <> 0
               nUnits   := ( ::cTikL )->nUntTil * ( ::cTikL )->nFacCnv
            end





            if Empty( ( ::cTikL )->cAlmLin ) .AND. dbLock( ::cTikL )
               ( ::cTikL )->cAlmLin    := cCodAlm
               ( ::cTikL )->( dbUnLock() )
            end





            if lDevolucion
               nUnits   := Abs( nUnits )
            end

         end

         ( ::cTikL )->( dbSkip() )

      end

   end

   ( ::cTikL )->( dbGoTo( nRec ) )





return self



UTILITY STATIC function TStock_ChkTikCli( cNumTik) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nTotStock
   local nTotStockCalculado
   local aTikCliL       := aGetStatus( ::cTikL, .T. )





   if ( ::cTikL )->( dbSeek( cNumTik ) )

      while ( ::cTikL )->cSerTil + ( ::cTikL )->cNumTil + ( ::cTikL )->cSufTil == cNumTik .AND. !( ::cTikL )->( eof() )

         if !Empty( rtrim( ( ::cTikL )->cCbaTil ) )

         nTotStock            := ::nTotStockAct( ( ::cTikL )->cCbaTil )
         nTotStockCalculado   := nStockCalculado( ( ::cTikL )->cCbaTil )

            if nTotStock <> nTotStockCalculado


               MsgStop( "DECUADRE EN STOCK TIKET DE CLIENTES " + ( ::cTikL )->cCbaTil     + Chr(13)+Chr(10) +  "Actual" + Trans( nTotStock, "@E 9999999.999999" )                + Chr(13)+Chr(10) +  "Calculado" + Trans( nTotStockCalculado, "@E 9999999.999999" ) )
            end

         end

         ( ::cTikL )->( dbSkip() )

      end

   end

   SetStatus( ::cTikL, aTikCliL )

return self



UTILITY STATIC function TStock_DepAge( nNumDep, cCodAlmEntrada, cCodAlmSalida, lDelete, lIncremento) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nUnits

   IIF( lDelete == nil, lDelete := .T., ) ;
   IIF( lIncremento == nil, lIncremento := .T., ) ;





   if ::cDepAgeL == nil .OR. nNumDep == nil

      msgAlert( "Imposible realizar la actualización de stocks.", "Atención" )
      return self

   end

   if ( ::cDepAgeL )->( dbSeek( nNumDep ) )


      while ( ::cDepAgeL )->CSERDEP + Str( ( ::cDepAgeL )->NNUMDEP ) + ( ::cDepAgeL )->CSUFDEP  == nNumDep .AND. !( ::cDepAgeL )->( eof() )
         if !empty( rtrim( ( ::cDepAgeL )->cRef ) )

            nUnits      := ( NotCaja( ( ::cDepAgeL )->nCanEnt ) * ( ::cDepAgeL )->nUniCaja )

            if lIncremento
               nUnits   := - nUnits
            end





            if ( ::cDepAgeL )->nFacCnv <> 0
               nUnits   *= ( ::cDepAgeL )->nFacCnv
            end

         end





         if lDelete .AND. dbLock( ::cDepAgeL )
            ( ::cDepAgeL )->( dbDelete() )
            ( ::cDepAgeL )->( dbUnLock() )
         end

         ( ::cDepAgeL )->( dbSkip() )

      end

   end

return self



UTILITY STATIC function TStock_ExtAge( nNumExt, cCodAlm, lDelete, lIncremento) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nUnits

   IIF( cCodAlm == nil, cCodAlm := oUser():cAlmacen(), ) ;
   IIF( lDelete == nil, lDelete := .T., ) ;
   IIF( lIncremento == nil, lIncremento := .T., ) ;





   if ::cExtAgeL == nil .OR. nNumExt == nil
      msgAlert( "Imposible realizar la actualización de stocks.", "Atención" )
      return self
   end

   if ( ::cExtAgeL )->( dbSeek( nNumExt ) )


      while ( ::cExtAgeL )->CSEREXT + Str( ( ::cExtAgeL )->NNUMEXT ) + ( ::cExtAgeL )->CSUFEXT  == nNumExt .AND. !( ::cExtAgeL )->( eof() )
         if !empty( rtrim( ( ::cExtAgeL )->cRef ) )

            nUnits      := ( NotCaja( ( ::cExtAgeL )->nCanEnt ) * ( ::cExtAgeL )->nUniCaja )





            if ( ::cExtAgeL )->nFacCnv <> 0
               nUnits   *= ( ::cExtAgeL )->nFacCnv
            end











         end





         if lDelete .AND. dbLock( ::cExtAgeL )
            ( ::cExtAgeL )->( dbDelete() )
            ( ::cExtAgeL )->( dbUnLock() )
         end

         ( ::cExtAgeL )->( dbSkip() )

      end

   end

return self

























































UTILITY STATIC function TStock_nStockActual( cCodArt, cCodAlm, cValPr1, cValPr2, cLote) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local aSta
   local nUnits   := 0

RETURN ( nUnits )






UTILITY STATIC function TStock_nTotStockAct( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, lKitArt, nKitStk, nCtlStk) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local aSta
   local nUnits         := 0

   IIF( lKitArt == nil, lKitArt := .T., ) ;
   IIF( nKitStk == nil, nKitStk := 0, ) ;
   IIF( nCtlStk == nil, nCtlStk := 1, ) ;

   if nCtlStk <= 1

      if lKitArt .AND. nKitStk == 3

         if ( ::cKit )->( dbSeek( cCodArt ) )

            while ( ::cKit )->cCodKit == cCodArt .AND. !( ::cKit )->( eof() )

               if nUnits == nil
                  nUnits   := Int( ::nStockAlmacen( ( ::cKit )->cRefKit, cCodAlm, cValPr1, cValPr2, cLote ) / ( ::cKit )->nUndKit )
               else
                  nUnits   := Min( nUnits, Int( ::nStockAlmacen( ( ::cKit )->cRefKit, cCodAlm, cValPr1, cValPr2, cLote ) / ( ::cKit )->nUndKit ) )
               end

               ( ::cKit )->( dbSkip() )

            end

         end

      else

         nUnits            := ::nStockAlmacen( cCodArt, cCodAlm, cValPr1, cValPr2, cLote )

      end

   end

RETURN ( nUnits )



UTILITY STATIC function TStock_nPutStockActual( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, lKitArt, nKitStk, oSay) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local cClass   := oSay:ClassName()
   local nStock   := ::nTotStockAct( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, lKitArt, nKitStk, nKitStk )

   do case
      case cClass == "TGET" .OR. cClass == "TGETHLP"
         oSay:cText( nStock )
      case cClass == "TSAY"
         oSay:SetText( nStock )
   end









return ( nStock )



UTILITY STATIC function TStock_lPutStockActual( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, lKitArt, nKitStk, oSay) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local cClass   := oSay:ClassName()
   local nStock   := ::nTotStockAct( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, lKitArt, nKitStk )

   do case
      case cClass == "TGET" .OR. cClass == "TGETHLP"
         oSay:cText( nStock )
      case cClass == "TSAY"
         oSay:SetText( nStock )
   end

return ( .T. )



UTILITY STATIC function TStock_Recalcula( oMeter, cNewEmp, cPatEmp) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock






































































































































































































































































































































































































































































































RETURN ( Self )



























UTILITY STATIC function TStock_Duplicados( oMeter, aMsg, cPath) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local lDup           := .F.
   local dbf
   local cCodAnt

   IIF( cPath == nil, cPath := ::cPath, ) ;
   IIF( aMsg == nil, aMsg := {}, ) ;

   dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ARTICULO.DBF" ), ( cCheckArea( "ARTICULO", @dbf ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatArt() + "ARTICULO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if oMeter <> NIL
      oMeter:nTotal := ( dbf )->( LastRec() )
      oMeter:cText  := "Artículos"
   end

   while !( dbf )->( eof() )

      cCodAnt  := ( dbf )->Codigo
      ( dbf )->( dbSkip() )
      if cCodAnt == ( dbf )->Codigo .AND. !(dbf)->(eof())
         aAdd( aMsg, { .T., "Artículo duplicado : " + cCodAnt } )
         lDup  := .T.
      end

      if oMeter <> NIL .AND. Mod( ( dbf )->( OrdKeyNo() ), int( oMeter:nTotal / 10 ) ) == 0
         oMeter:Set( ( dbf )->( OrdKeyNo() ) )
      else
         SysRefresh()
      end

   end

   ( dbf )->( dbCloseArea() )





   dbUseArea( .T., ( cDriver() ), ( cPath + "PEDPROVT.DBF" ), ( cCheckArea( "PEDPROVT", @dbf ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPath + "PEDPROVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if oMeter <> NIL
      oMeter:nTotal := ( dbf )->( LastRec() )
      oMeter:cText  := "Ped. Prv."
   end

   while !( dbf )->( eof() )

      cCodAnt  := ( dbf )->CSERPED + Str( ( dbf )->NNUMPED ) + ( dbf )->CSUFPED
      ( dbf )->( dbSkip() )
      if cCodAnt  == ( dbf )->CSERPED + Str( ( dbf )->NNUMPED ) + ( dbf )->CSUFPED .AND. !(dbf)->(eof())
         aAdd( aMsg, { .T., "Pedido a proveedor duplicado : " + cCodAnt } )
         lDup  := .T.
      end

      if oMeter <> NIL .AND. Mod( ( dbf )->( OrdKeyNo() ), int( oMeter:nTotal / 10 ) ) == 0
         oMeter:Set( ( dbf )->( OrdKeyNo() ) )
      end

   end

   ( dbf )->( dbCloseArea() )


































   dbUseArea( .T., ( cDriver() ), ( cPath + "FACPRVT.DBF" ), ( cCheckArea( "FACPROVT", @dbf ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPath + "FACPRVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if oMeter <> NIL
      oMeter:nTotal := ( dbf )->( LastRec() )
      oMeter:cText  := "Fac. Prv."
   end

   while !( dbf )->( eof() )

      cCodAnt  := (dbf)->CSERFAC + Str( (dbf)->NNUMFAC ) + (dbf)->CSUFFAC
      ( dbf )->( dbSkip() )
      if cCodAnt  == (dbf)->CSERFAC + Str( (dbf)->NNUMFAC ) + (dbf)->CSUFFAC .AND. !(dbf)->(eof())
         aAdd( aMsg, { .T., "Factura de proveedor duplicado : " + cCodAnt } )
         lDup  := .T.
      end

      if oMeter <> NIL .AND. Mod( ( dbf )->( OrdKeyNo() ), int( oMeter:nTotal / 10 ) ) == 0
         oMeter:Set( ( dbf )->( OrdKeyNo() ) )
      end

   end

   ( dbf )->( dbCloseArea() )





   dbUseArea( .T., ( cDriver() ), ( cPath + "RctPrvT.DBF" ), ( cCheckArea( "RctPrvT", @dbf ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPath + "RctPrvT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if oMeter <> NIL
      oMeter:nTotal  := ( dbf )->( LastRec() )
      oMeter:cText   := "Rct. Prv."
   end

   while !( dbf )->( eof() )

      cCodAnt        := ( dbf )->cSerFac + Str( ( dbf )->nNumFac ) + ( dbf )->cSufFac
      ( dbf )->( dbSkip() )

      if cCodAnt  == ( dbf )->cSerFac + Str( ( dbf )->nNumFac ) + ( dbf )->cSufFac .AND. !( dbf )->( eof() )
         aAdd( aMsg, { .T., "Factura rectificativa de proveedor duplicado : " + cCodAnt } )
         lDup  := .T.
      end

      if oMeter <> NIL .AND. Mod( ( dbf )->( OrdKeyNo() ), int( oMeter:nTotal / 10 ) ) == 0
         oMeter:Set( ( dbf )->( OrdKeyNo() ) )
      end

   end

   ( dbf )->( dbCloseArea() )





   dbUseArea( .T., ( cDriver() ), ( cPath + "PEDCLIT.DBF" ), ( cCheckArea( "PEDCLIT", @dbf ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPath + "PEDCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if oMeter <> NIL
      oMeter:nTotal := ( dbf )->( LastRec() )
      oMeter:cText  := "Ped. Prv."
   end

   while !( dbf )->( eof() )

      cCodAnt  := (dbf)->CSERPED + Str( (dbf)->NNUMPED ) + (dbf)->CSUFPED
      ( dbf )->( dbSkip() )
      if cCodAnt  == (dbf)->CSERPED + Str( (dbf)->NNUMPED ) + (dbf)->CSUFPED .AND. !(dbf)->(eof())
         aAdd( aMsg, { .T., "Pedido de cliente duplicado : " + cCodAnt } )
         lDup  := .T.
      end

      if oMeter <> NIL .AND. Mod( ( dbf )->( OrdKeyNo() ), int( oMeter:nTotal / 10 ) ) == 0
         oMeter:Set( ( dbf )->( OrdKeyNo() ) )
      else
         SysRefresh()
      end

   end

   ( dbf )->( dbCloseArea() )





   dbUseArea( .T., ( cDriver() ), ( cPath + "ALBCLIT.DBF" ), ( cCheckArea( "ALBCLIT", @dbf ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPath + "ALBCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if oMeter <> NIL
      oMeter:nTotal := ( dbf )->( LastRec() )
      oMeter:cText  := "Alb. Cli."
   end

   while !( dbf )->( eof() )

      cCodAnt  := (dbf)->CSERALB + Str( (dbf)->NNUMALB ) + (dbf)->CSUFALB
      ( dbf )->( dbSkip() )
      if cCodAnt  == (dbf)->CSERALB + Str( (dbf)->NNUMALB ) + (dbf)->CSUFALB .AND. !(dbf)->(eof())
         aAdd( aMsg, { .T., "Albaran de cliente duplicado : " + cCodAnt } )
         lDup  := .T.
      end

      if oMeter <> NIL .AND. Mod( ( dbf )->( OrdKeyNo() ), int( oMeter:nTotal / 10 ) ) == 0
         oMeter:Set( ( dbf )->( OrdKeyNo() ) )
      end

   end

   ( dbf )->( dbCloseArea() )





   dbUseArea( .T., ( cDriver() ), ( cPath + "FACCLIT.DBF" ), ( cCheckArea( "FACCLIT", @dbf ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPath + "FACCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if oMeter <> NIL
      oMeter:nTotal := ( dbf )->( LastRec() )
      oMeter:cText  := "Fac. Cli."
   end

   while !( dbf )->( eof() )

      cCodAnt  := ( dbf )->cSerie + Str( ( dbf )->nNumFac ) + ( dbf )->cSufFac
      ( dbf )->( dbSkip() )
      if cCodAnt  == ( dbf )->cSerie + Str( ( dbf )->nNumFac ) + ( dbf )->cSufFac .AND. !(dbf)->(eof())
         aAdd( aMsg, { .T., "Factura de cliente duplicado : " + cCodAnt } )
         lDup  := .T.
      end

      if oMeter <> NIL .AND. Mod( ( dbf )->( OrdKeyNo() ), int( oMeter:nTotal / 10 ) ) == 0
         oMeter:Set( ( dbf )->( OrdKeyNo() ) )
      end

   end

   ( dbf )->( dbCloseArea() )





   dbUseArea( .T., ( cDriver() ), ( cPath + "TIKET.DBF" ), ( cCheckArea( "TIKET", @dbf ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPath + "TIKET.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if oMeter <> NIL
      oMeter:nTotal := ( dbf )->( LastRec() )
      oMeter:cText  := "Tik. Cli."
   end

   while !( dbf )->( eof() )

      cCodAnt  := (dbf)->CSERTIK + (dbf)->CNUMTIK + (dbf)->CSUFTIK
      ( dbf )->( dbSkip() )

      if cCodAnt == (dbf)->CSERTIK + (dbf)->CNUMTIK + (dbf)->CSUFTIK .AND. !(dbf)->(eof())
         aAdd( aMsg, { .T., "Ticket de cliente duplicado : " + cCodAnt } )
         lDup  := .T.
      end

      if oMeter <> NIL .AND. Mod( ( dbf )->( OrdKeyNo() ), int( oMeter:nTotal / 10 ) ) == 0
         oMeter:Set( ( dbf )->( OrdKeyNo() ) )
      end

   end

   ( dbf )->( dbCloseArea() )

RETURN ( lDup )








UTILITY STATIC function TStock_StockInit( cPath, cPathOld, oMsg, lAlbPrv, lAlbCli, nCalcCosto) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local aAlm
   local sStk
   local aStk
   local dbfAlm
   local dbfCnt
   local oldArt
   local oldTikL
   local nNumDoc
   local dbfHisMov
   local dbfRemMov
   local oldHisMov
   local oldProLin
   local oldProMat
   local oldPedPrvL
   local oldAlbPrvL
   local oldFacPrvL
   local oldRctPrvL
   local oldPedCliL
   local oldAlbCliL
   local oldFacCliL
   local oldFacRecL

   IIF( lAlbPrv == nil, lAlbPrv := .T., ) ;
   IIF( lAlbCli == nil, lAlbCli := .T., ) ;

   if Empty( cPathOld )
      Return nil
   end

   aAlm              := {}
   aStk              := {}

   if ::lOpenFiles( cPath, .T. )

      ::lAlbPrv      := lAlbPrv
      ::lAlbCli      := lAlbCli

      dbUseArea( .T., ( cDriver() ), ( cPath + "HisMov.Dbf" ), ( cCheckArea( "HISMOV", @dbfHisMov ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPath + "HisMov.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPath + "RemMovT.Dbf" ), ( cCheckArea( "REMMOVT", @dbfRemMov ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPath + "RemMovT.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPath + "NCount.Dbf" ), ( cCheckArea( "NCount", @dbfCnt ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPath + "NCount.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatAlm() + "Almacen.Dbf" ), ( cCheckArea( "ALMACEN", @dbfAlm ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatAlm() + "Almacen.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "HisMov.Dbf" ), ( cCheckArea( "HISMOV", @oldHisMov ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "HisMov.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "Articulo.Dbf" ), ( cCheckArea( "ARTICULO", @oldArt ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "ARTICULO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "PEDPROVL.DBF" ), ( cCheckArea( "PedPrvL", @oldPedPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "PEDPROVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "ALBPROVL.Dbf" ), ( cCheckArea( "ALBPRVL", @oldAlbPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "ALBPROVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "FACPRVL.Dbf" ), ( cCheckArea( "FACPRVL", @oldFacPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "FACPRVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "RctPrvL.Dbf" ), ( cCheckArea( "RctPrvL", @oldRctPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "RctPrvL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "PEDCLIL.DBF" ), ( cCheckArea( "PedCliL", @oldPedCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "PEDCLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "ALBCLIL.Dbf" ), ( cCheckArea( "ALBCLIL", @oldAlbCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "ALBCLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "FACCLIL.Dbf" ), ( cCheckArea( "FACCliL", @oldFacCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "FACCliL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "FACRECL.Dbf" ), ( cCheckArea( "FACRECL", @oldFacRecL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "FACRECL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "TIKEL.Dbf" ), ( cCheckArea( "TIKEL", @oldTikL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "TIKEL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "PROLIN.DBF" ), ( cCheckArea( "PROLIN", @oldProLin ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "PROLIN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPathOld + "PROMAT.DBF" ), ( cCheckArea( "PROMAT", @oldProMat ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPathOld + "PROMAT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      ::cPedPrvL                             := oldPedPrvL
      ::cAlbPrvL                             := oldAlbPrvL
      ::cFacPrvL                             := oldFacPrvL
      ::cRctPrvL                             := oldRctPrvL
      ::cPedCliL                             := oldPedCliL
      ::cAlbCliL                             := oldAlbCliL
      ::cFacCliL                             := oldFacCliL
      ::cFacRecL                             := oldFacRecL
      ::cTikL                                := oldTikL
      ::cHisMov                              := oldHisMov
      ::cProducL                             := oldProLin
      ::cProducM                             := oldProMat





      ( oldArt )->( dbGoTop() )
      while !( oldArt )->( eof() )
         aEval( ::aStockArticulo( ( oldArt )->Codigo ), {|s| aAdd( aStk, s ) } )
         sysrefresh()
         ( oldArt )->( dbSkip() )
      end





      ( dbfAlm )->( dbGoTop() )
      while !( dbfAlm )->( eof() )

         if aScan( aAlm, ( dbfAlm )->cCodAlm ) == 0

            aAdd( aAlm, ( dbfAlm )->cCodAlm )

            if dbAppe( dbfRemMov )

               nNumDoc                          := nNewDoc( nil, dbfHisMov, "nMovAlm", nil, dbfCnt )
               ( dbfRemMov )->nNumRem           := nNumDoc
               ( dbfRemMov )->cSufRem           := RetSufEmp()
               ( dbfRemMov )->nTipMov           := 4
               ( dbfRemMov )->cCodUsr           := cCurUsr()
               ( dbfRemMov )->cCodDlg           := ""
               ( dbfRemMov )->cCodAge           := ""
               ( dbfRemMov )->cCodMov           := "EI"
               ( dbfRemMov )->dFecRem           := Date()
               ( dbfRemMov )->cTimRem           := Time()
               ( dbfRemMov )->cAlmOrg           := ( dbfAlm )->cCodAlm
               ( dbfRemMov )->cAlmDes           := ( dbfAlm )->cCodAlm
               ( dbfRemMov )->cCodDiv           := cDivEmp()
               ( dbfRemMov )->nVdvDiv           := nChgDiv( cDivEmp(), ::dbfDiv )
               ( dbfRemMov )->nTotRem           := 0
               ( dbfRemMov )->( dbUnLock() )

               for each sStk in aStk




                  if !Empty( sStk:cCodigo )                          .AND.  !Empty( sStk:nUnidades )                        .AND.  ( sStk:cCodigoAlmacen == ( dbfAlm )->cCodAlm )  .AND.  dbAppe( dbfHisMov )

                     ( dbfHisMov )->nNumRem  := nNumDoc
                     ( dbfHisMov )->cSufRem  := RetSufEmp()
                     ( dbfHisMov )->nNumLin  := nLastNum( dbfHisMov )
                     ( dbfHisMov )->dFecMov  := Date()
                     ( dbfHisMov )->nTipMov  := 4
                     ( dbfHisMov )->cCodMov  := "EI"
                     ( dbfHisMov )->cRefMov  := sStk:cCodigo
                     ( dbfHisMov )->cAliMov  := sStk:cCodigoAlmacen
                     ( dbfHisMov )->cValPr1  := sStk:cValorPropiedad1
                     ( dbfHisMov )->cValPr2  := sStk:cValorPropiedad2
                     ( dbfHisMov )->cLote    := sStk:cLote
                     ( dbfHisMov )->nUndMov  := sStk:nUnidades
                     if nCalcCosto <= 1
                        ( dbfHisMov )->nPreDiv  := RetFld( sStk:cCodigo, oldArt, "pCosto", "Codigo" )
                     else
                        ( dbfHisMov )->nPreDiv  := ::nPrecioMedioCompra( sStk:cCodigo, sStk:cCodigoAlmacen )
                     end

                     ( dbfHisMov )->( dbUnLock() )

                  end

                  sysrefresh()

               next

            end

         end

         ( dbfAlm )->( dbSkip() )

      end

      ( dbfHisMov  )->( dbCloseArea() )
      ( dbfRemMov  )->( dbCloseArea() )
      ( dbfAlm     )->( dbCloseArea() )
      ( dbfCnt     )->( dbCloseArea() )

      ( oldArt     )->( dbCloseArea() )
      ( oldHisMov  )->( dbCloseArea() )
      ( oldPedCliL )->( dbCloseArea() )
      ( oldAlbCliL )->( dbCloseArea() )
      ( oldFacCliL )->( dbCloseArea() )
      ( oldFacRecL )->( dbCloseArea() )
      ( oldTikL    )->( dbCloseArea() )
      ( oldPedPrvL )->( dbCloseArea() )
      ( oldAlbPrvL )->( dbCloseArea() )
      ( oldFacPrvL )->( dbCloseArea() )
      ( oldRctPrvL )->( dbCloseArea() )
      ( oldProLin  )->( dbCloseArea() )
      ( oldProMat  )->( dbCloseArea() )

      ::CloseFiles()

   end

RETURN ( Self )



UTILITY STATIC function TStock_AppMovAlm( cRefMov, cValPr1, cValPr2, cCodAlm, nCajMov, nUndMov, dbfHisMov, lApp, cLote) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nTotMov

   IIF( lApp == nil, lApp := .T., ) ;
   IIF( cLote == nil, cLote := "", ) ;

   if !Empty( nCajMov )
      nTotMov        := NotCaja( nCajMov ) * nUndMov
   else
      nTotMov        := nUndMov
   end

   if nTotMov == 0
      Return ( Self )
   end

   if !lApp
      nTotMov        := - nTotMov
   end

   if !( dbfHisMov )->( dbSeek( cRefMov + cValPr1 + cValPr2 + cCodAlm + cLote ) )

      if dbAppe( dbfHisMov )
         ( dbfHisMov )->dFecMov  := Date()
         ( dbfHisMov )->nTipMov  := 2
         ( dbfHisMov )->cCodMov  := "EI"
         ( dbfHisMov )->cAliMov  := cCodAlm
         ( dbfHisMov )->cRefMov  := cRefMov
         ( dbfHisMov )->cValPr1  := cValPr1
         ( dbfHisMov )->cValPr2  := cValPr2
         ( dbfHisMov )->cLote    := cLote
         ( dbfHisMov )->nUndMov  := nTotMov
         ( dbfHisMov )->( dbUnLock() )
      end

   else

      if dbLock( dbfHisMov )
         ( dbfHisMov )->nUndMov  += nTotMov
         ( dbfHisMov )->( dbUnLock() )
      end

   end

RETURN ( Self )



UTILITY STATIC function TStock_nTotAlbPrv( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nOrd
   local nTotal
   local cCodEmp
   local cAlbEmpT
   local cAlbEmpL

   IIF( cValPr1 == nil, cValPr1 := Space( 10 ), ) ;
   IIF( cValPr2 == nil, cValPr2 := Space( 10 ), ) ;
   IIF( cLote == nil, cLote := Space( 12 ), ) ;

   nTotal            := 0

   if Len( aEmpGrp() ) <> 0

      for each cCodEmp in aEmpGrp()

         if cCodEmp == cCodEmp()

            nOrd     := ( ::cAlbPrvL )->( OrdSetFocus( "cRef" ) )
            if ( ::cAlbPrvL )->( dbSeek( cCodArt ) )

               while ( ::cAlbPrvL )->cRef == cCodArt .AND. !( ::cAlbPrvL )->( Eof() )



                  if ( ::cAlbPrvT )->( dbSeek( ( ::cAlbPrvL )->cSerAlb + Str( ( ::cAlbPrvL )->nNumAlb ) + ( ::cAlbPrvL )->cSufAlb ) )  .AND. ( Empty( dFecha ) .OR. ( ::cAlbPrvT )->dFecAlb <= dFecha )                                                        .AND. !( ::cAlbPrvT )->lFacturado




                     if ( cCodAlm == ( ::cAlbPrvL )->cAlmLin )     .AND. ( cValPr1 == ( ::cAlbPrvL )->cValPr1 )     .AND. ( cValPr2 == ( ::cAlbPrvL )->cValPr2 )     .AND. ( cLote   == ( ::cAlbPrvL )->cLote   )

                        nTotal += nTotNAlbPrv( ::cAlbPrvL )

                     end


                  end

                  ( ::cAlbPrvL )->( dbSkip() )

               end

            end
            ( ::cAlbPrvL )->( OrdSetFocus( nOrd ) )

         else

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "ALBPROVT.DBF" ), ( cCheckArea( "ALBPROVT", @cAlbEmpT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "ALBPROVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "ALBPROVL.DBF" ), ( cCheckArea( "ALBPROVL", @cAlbEmpL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "ALBPROVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
            ( cAlbEmpL )->( ordSetFocus( "cRef" ) )

            if ( cAlbEmpL )->( dbSeek( cCodArt ) )

               while ( cAlbEmpL )->cRef == cCodArt .AND. !( cAlbEmpL )->( Eof() )



                  if ( cAlbEmpT )->( dbSeek( ( cAlbEmpL )->cSerAlb + Str( ( cAlbEmpL )->nNumAlb ) + ( cAlbEmpL )->cSufAlb ) )  .AND. ( Empty( dFecha ) .OR. ( cAlbEmpT )->dFecAlb <= dFecha )                                                  .AND. !( cAlbEmpT )->lFacturado




                     if ( cCodAlm == ( cAlbEmpL )->cAlmLin )     .AND. ( cValPr1 == ( cAlbEmpL )->cValPr1 )     .AND. ( cValPr2 == ( cAlbEmpL )->cValPr2 )     .AND. ( cLote   == ( cAlbEmpL )->cLote   )

                        nTotal += nTotNAlbPrv( cAlbEmpL )

                     end


                  end

                  ( cAlbEmpL )->( dbSkip() )

               end

            end

            ( cAlbEmpT )->( dbCloseArea() )
            ( cAlbEmpL )->( dbCloseArea() )

         end

      next

   end

RETURN ( nTotal )



UTILITY STATIC function TStock_nTotFacPrv( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nOrd
   local nTotal
   local cCodEmp
   local cFacEmpT
   local cFacEmpL

   IIF( cValPr1 == nil, cValPr1 := Space( 10 ), ) ;
   IIF( cValPr2 == nil, cValPr2 := Space( 10 ), ) ;
   IIF( cLote == nil, cLote := Space( 12 ), ) ;

   nTotal            := 0

   if Len( aEmpGrp() ) <> 0

      for each cCodEmp in aEmpGrp()

         if cCodEmp == cCodEmp()

            nOrd     := ( ::cFacPrvL )->( ordSetFocus( "cRef" ) )
            if ( ::cFacPrvL )->( dbSeek( cCodArt ) )

               while ( ::cFacPrvL )->cRef == cCodArt .AND. !( ::cFacPrvL )->( Eof() )


                  if ( ::cFacPrvT )->( dbSeek( ( ::cFacPrvL )->cSerFac + Str( ( ::cFacPrvL )->nNumFac ) + ( ::cFacPrvL )->cSufFac ) )  .AND. ( Empty( dFecha ) .OR. ( ::cFacPrvT )->dFecFac <= dFecha )




                     if ( cCodAlm == ( ::cFacPrvL )->cAlmLin )     .AND. ( cValPr1 == ( ::cFacPrvL )->cValPr1 )     .AND. ( cValPr2 == ( ::cFacPrvL )->cValPr2 )     .AND. ( cLote   == ( ::cFacPrvL )->cLote   )

                        nTotal += nTotNFacPrv( ::cFacPrvL )

                     end

                  end

               ( ::cFacPrvL )->( dbSkip() )

               end

            end
            ( ::cFacPrvL )->( ordSetFocus( nOrd ) )

         else

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "FACPRVT.DBF" ), ( cCheckArea( "FACPRVT", @cFacEmpT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "FACPRVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "FACPRVL.DBF" ), ( cCheckArea( "FACPRVL", @cFacEmpL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "FACPRVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
            ( cFacEmpL )->( ordSetFocus( "cRef" ) )

            if ( cFacEmpL )->( dbSeek( cCodArt ) )

               while ( cFacEmpL )->cRef == cCodArt .AND. !( cFacEmpL )->( Eof() )


                  if ( cFacEmpT )->( dbSeek( ( cFacEmpL )->cSerFac + Str( ( cFacEmpL )->nNumFac ) + ( cFacEmpL )->cSufFac ) )  .AND. ( Empty( dFecha ) .OR. ( cFacEmpT )->dFecFac <= dFecha )




                     if ( cCodAlm == ( cFacEmpL )->cAlmLin )     .AND. ( cValPr1 == ( cFacEmpL )->cValPr1 )     .AND. ( cValPr2 == ( cFacEmpL )->cValPr2 )     .AND. ( cLote   == ( cFacEmpL )->cLote   )

                        nTotal += nTotNFacPrv( cFacEmpL )

                     end

                  end

               ( cFacEmpL )->( dbSkip() )

               end

            end

            ( cFacEmpT )->( dbCloseArea() )
            ( cFacEmpL )->( dbCloseArea() )

         end

      next

   end

RETURN ( nTotal )



UTILITY STATIC function TStock_nTotRctPrv( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nOrd
   local nTotal
   local cCodEmp
   local cFacEmpT
   local cFacEmpL

   IIF( cValPr1 == nil, cValPr1 := Space( 10 ), ) ;
   IIF( cValPr2 == nil, cValPr2 := Space( 10 ), ) ;
   IIF( cLote == nil, cLote := Space( 12 ), ) ;

   nTotal            := 0

   if Len( aEmpGrp() ) <> 0

      for each cCodEmp in aEmpGrp()

         if cCodEmp == cCodEmp()

            nOrd     := ( ::cRctPrvL )->( ordSetFocus( "cRef" ) )
            if ( ::cRctPrvL )->( dbSeek( cCodArt ) )

               while ( ::cRctPrvL )->cRef == cCodArt .AND. !( ::cRctPrvL )->( Eof() )


                  if ( ::cRctPrvT )->( dbSeek( ( ::cRctPrvL )->cSerFac + Str( ( ::cRctPrvL )->nNumFac ) + ( ::cRctPrvL )->cSufFac ) )  .AND. ( Empty( dFecha ) .OR. ( ::cRctPrvT )->dFecFac <= dFecha )




                     if ( cCodAlm == ( ::cRctPrvL )->cAlmLin )     .AND. ( cValPr1 == ( ::cRctPrvL )->cValPr1 )     .AND. ( cValPr2 == ( ::cRctPrvL )->cValPr2 )     .AND. ( cLote   == ( ::cRctPrvL )->cLote   )

                        nTotal += nTotNRctPrv( ::cRctPrvL )

                     end

                  end

               ( ::cRctPrvL )->( dbSkip() )

               end

            end

            ( ::cRctPrvL )->( ordSetFocus( nOrd ) )

         else

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "RctPrvT.DBF" ), ( cCheckArea( "RctPrvT", @cFacEmpT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "RctPrvT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "RctPrvL.DBF" ), ( cCheckArea( "RctPrvL", @cFacEmpL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "RctPrvL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
            ( cFacEmpL )->( ordSetFocus( "cRef" ) )

            if ( cFacEmpL )->( dbSeek( cCodArt ) )

               while ( cFacEmpL )->cRef == cCodArt .AND. !( cFacEmpL )->( Eof() )


                  if ( cFacEmpT )->( dbSeek( ( cFacEmpL )->cSerFac + Str( ( cFacEmpL )->nNumFac ) + ( cFacEmpL )->cSufFac ) )  .AND. ( Empty( dFecha ) .OR. ( cFacEmpT )->dFecFac <= dFecha )




                     if ( cCodAlm == ( cFacEmpL )->cAlmLin )     .AND. ( cValPr1 == ( cFacEmpL )->cValPr1 )     .AND. ( cValPr2 == ( cFacEmpL )->cValPr2 )     .AND. ( cLote   == ( cFacEmpL )->cLote   )

                        nTotal += nTotNRctPrv( cFacEmpL )

                     end

                  end

               ( cFacEmpL )->( dbSkip() )

               end

            end

            ( cFacEmpT )->( dbCloseArea() )
            ( cFacEmpL )->( dbCloseArea() )

         end

      next

   end

RETURN ( nTotal )



UTILITY STATIC function TStock_nTotAlbCli( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nOrd
   local nTotal      := 0
   local cAlbEmpT
   local cAlbEmpL
   local cCodEmp

   IIF( cValPr1 == nil, cValPr1 := Space( 10 ), ) ;
   IIF( cValPr2 == nil, cValPr2 := Space( 10 ), ) ;
   IIF( cLote == nil, cLote := Space( 12 ), ) ;

   if Len( aEmpGrp() ) <> 0

      for each cCodEmp in aEmpGrp()

         if cCodEmp == cCodEmp()

            nOrd     := ( ::cAlbCliL )->( ordSetFocus( "cRef" ) )
            if ( ::cAlbCliL )->( dbSeek( cCodArt ) )

               while ( ::cAlbCliL )->cRef == cCodArt .AND. !( ::cAlbCliL )->( Eof() )



                  if ( ::cAlbCliT )->( dbSeek( ( ::cAlbCliL )->cSerAlb + Str( ( ::cAlbCliL )->nNumAlb ) + ( ::cAlbCliL )->cSufAlb ) )  .AND. ( Empty( dFecha ) .OR. ( ::cAlbCliT )->dFecAlb <= dFecha )                                                        .AND. !( ::cAlbCliT )->lFacturado




                     if ( cCodAlm == ( ::cAlbCliL )->cAlmLin )     .AND. ( cValPr1 == ( ::cAlbCliL )->cValPr1 )     .AND. ( cValPr2 == ( ::cAlbCliL )->cValPr2 )     .AND. ( cLote   == ( ::cAlbCliL )->cLote   )

                        nTotal += nTotNAlbCli( ::cAlbCliL )

                     end

                  end

                  ( ::cAlbCliL )->( dbSkip() )

               end

            end
            ( ::cAlbCliL )->( ordSetFocus( nOrd ) )

         else

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "ALBCLIT.DBF" ), ( cCheckArea( "ALBCLIT", @cAlbEmpT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "ALBCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "ALBCLIL.DBF" ), ( cCheckArea( "ALBCLIL", @cAlbEmpL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "ALBCLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
            ( cAlbEmpL )->( ordSetFocus( "cRef" ) )

            if ( cAlbEmpL )->( dbSeek( cCodArt ) )

               while ( cAlbEmpL )->cRef == cCodArt .AND. !( cAlbEmpL )->( Eof() )



                  if ( cAlbEmpT )->( dbSeek( ( cAlbEmpL )->cSerAlb + Str( ( cAlbEmpL )->nNumAlb ) + ( cAlbEmpL )->cSufAlb ) )  .AND. ( Empty( dFecha ) .OR. ( cAlbEmpT )->dFecAlb <= dFecha )                                                        .AND. !( cAlbEmpT )->lFacturado




                     if ( cCodAlm == ( cAlbEmpL )->cAlmLin )     .AND. ( cValPr1 == ( cAlbEmpL )->cValPr1 )     .AND. ( cValPr2 == ( cAlbEmpL )->cValPr2 )     .AND. ( cLote   == ( cAlbEmpL )->cLote   )

                        nTotal += nTotNAlbCli( cAlbEmpL )

                     end

                  end

                  ( cAlbEmpL )->( dbSkip() )

               end

            end

            ( cAlbEmpT )->( dbCloseArea() )
            ( cAlbEmpL )->( dbCloseArea() )

         end

      next

   end

RETURN ( nTotal )



UTILITY STATIC function TStock_nTotFacCli( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nOrd
   local nTotal      := 0
   local cCodEmp
   local cFacEmpT
   local cFacEmpL

   IIF( cValPr1 == nil, cValPr1 := Space( 10 ), ) ;
   IIF( cValPr2 == nil, cValPr2 := Space( 10 ), ) ;
   IIF( cLote == nil, cLote := Space( 12 ), ) ;

   if Len( aEmpGrp() ) <> 0

      for each cCodEmp in aEmpGrp()

         if cCodEmp == cCodEmp()

            nOrd     := ( ::cFacCliL )->( ordSetFocus( "cRef" ) )

            if ( ::cFacCliL )->( dbSeek( cCodArt ) )

               while ( ::cFacCliL )->cRef == cCodArt .AND. !( ::cFacCliL )->( Eof() )


                  if ( ::cFacCliT )->( dbSeek( ( ::cFacCliL )->cSerie + Str( ( ::cFacCliL )->nNumFac ) + ( ::cFacCliL )->cSufFac ) )   .AND. ( Empty( dFecha ) .OR. ( ::cFacCliT )->dFecFac <= dFecha )




                     if ( cCodAlm == ( ::cFacCliL )->cAlmLin )   .AND. ( cValPr1 == ( ::cFacCliL )->cValPr1 )   .AND. ( cValPr2 == ( ::cFacCliL )->cValPr2 )   .AND. ( cLote   == ( ::cFacCliL )->cLote   )

                        nTotal += nTotNFacCli( ::cFacCliL )

                     end

                  end

                  ( ::cFacCliL )->( dbSkip() )

               end

            end

            ( ::cFacCliL )->( ordSetFocus( nOrd ) )

         else

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "FACCLIT.DBF" ), ( cCheckArea( "FACCLIT", @cFacEmpT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "FACCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "FACCLIL.DBF" ), ( cCheckArea( "FACCLIL", @cFacEmpL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "FACCLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
            ( cFacEmpL )->( ordSetFocus( "cRef" ) )

            if ( cFacEmpL )->( dbSeek( cCodArt ) )

               while ( cFacEmpL )->cRef == cCodArt .AND. !( cFacEmpL )->( Eof() )


                  if ( cFacEmpT )->( dbSeek( ( cFacEmpL )->cSerie + Str( ( cFacEmpL )->nNumFac ) + ( cFacEmpL )->cSufFac ) )   .AND. ( Empty( dFecha ) .OR. ( cFacEmpT )->dFecFac <= dFecha )




                     if ( cCodAlm == ( cFacEmpL )->cAlmLin )   .AND. ( cValPr1 == ( cFacEmpL )->cValPr1 )   .AND. ( cValPr2 == ( cFacEmpL )->cValPr2 )   .AND. ( cLote   == ( cFacEmpL )->cLote   )

                        nTotal += nTotNFacCli( cFacEmpL )

                     end

                  end

                  ( cFacEmpL )->( dbSkip() )

               end

            end

            ( cFacEmpT )->( dbCloseArea() )
            ( cFacEmpL )->( dbCloseArea() )

         end

      next

   end

RETURN ( nTotal )



UTILITY STATIC function TStock_nTotFacRec( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nOrd
   local nTotal      := 0
   local cCodEmp
   local cFacRecEmpT
   local cFacRecEmpL

   IIF( cValPr1 == nil, cValPr1 := Space( 10 ), ) ;
   IIF( cValPr2 == nil, cValPr2 := Space( 10 ), ) ;
   IIF( cLote == nil, cLote := Space( 12 ), ) ;

   if Len( aEmpGrp() ) <> 0

      for each cCodEmp in aEmpGrp()

         if cCodEmp == cCodEmp()

            nOrd     := ( ::cFacRecL )->( ordSetFocus( "cRef" ) )
            if ( ::cFacRecL )->( dbSeek( cCodArt ) )

               while ( ::cFacRecL )->cRef == cCodArt .AND. !( ::cFacCliL )->( Eof() )


                  if ( ::cFacRecT )->( dbSeek( ( ::cFacRecL )->cSerie + Str( ( ::cFacRecL )->nNumFac ) + ( ::cFacRecL )->cSufFac ) )   .AND. ( Empty( dFecha ) .OR. ( ::cFacRecT )->dFecFac <= dFecha )




                     if ( cCodAlm == ( ::cFacRecL )->cAlmLin )   .AND. ( cValPr1 == ( ::cFacRecL )->cValPr1 )   .AND. ( cValPr2 == ( ::cFacRecL )->cValPr2 )   .AND. ( cLote   == ( ::cFacRecL )->cLote   )

                         nTotal += nTotNFacRec( ::cFacRecL )

                     end

                  end

                  ( ::cFacRecL )->( dbSkip() )

               end

            end

            ( ::cFacRecL )->( ordSetFocus( nOrd ) )

         else

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "FACRECT.DBF" ), ( cCheckArea( "FACRECT", @cFacRecEmpT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "FACRECT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "FACRECL.DBF" ), ( cCheckArea( "FACRECL", @cFacRecEmpL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "FACRECL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
            ( cFacRecEmpL )->( ordSetFocus( "cRef" ) )

            if ( cFacRecEmpL )->( dbSeek( cCodArt ) )

               while ( cFacRecEmpL )->cRef == cCodArt .AND. !( cFacRecEmpL )->( Eof() )


                  if ( cFacRecEmpT )->( dbSeek( ( cFacRecEmpL )->cSerie + Str( ( cFacRecEmpL )->nNumFac ) + ( cFacRecEmpL )->cSufFac ) )   .AND. ( Empty( dFecha ) .OR. ( cFacRecEmpT )->dFecFac <= dFecha )




                     if ( cCodAlm == ( cFacRecEmpL )->cAlmLin )   .AND. ( cValPr1 == ( cFacRecEmpL )->cValPr1 )   .AND. ( cValPr2 == ( cFacRecEmpL )->cValPr2 )   .AND. ( cLote   == ( cFacRecEmpL )->cLote   )

                         nTotal += nTotNFacRec( cFacRecEmpL )

                     end

                  end

                  ( cFacRecEmpL )->( dbSkip() )

               end

            end

            ( cFacRecEmpT )->( dbCloseArea() )
            ( cFacRecEmpL )->( dbCloseArea() )

         end

      next

   end

RETURN ( nTotal )



UTILITY STATIC function TStock_nTotTikCli( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nOrd
   local cCodEmp
   local cTikEmpT
   local cTikEmpL
   local nTotal      := 0

   IIF( cValPr1 == nil, cValPr1 := Space( 10 ), ) ;
   IIF( cValPr2 == nil, cValPr2 := Space( 10 ), ) ;
   IIF( cLote == nil, cLote := Space( 12 ), ) ;

   if Len( aEmpGrp() ) <> 0

      for each cCodEmp in aEmpGrp()

         if cCodEmp == cCodEmp()

            nOrd     := ( ::cTikL )->( OrdSetFocus( "cCbaTil" ) )

            if ( ::cTikL )->( dbSeek( cCodArt ) )

               while ( ::cTikL )->cCbaTil == cCodArt .AND. !( ::cTikL )->( Eof() )


                  if ( ::cTikT )->( dbSeek( ( ::cTikL )->cSerTil + ( ::cTikL )->cNumTil + ( ::cTikL )->cSufTil ) )   .AND. ( Empty( dFecha ) .OR. ( ::cTikT )->dFecTik <= dFecha )




                     if ( cCodAlm == ( ::cTikL )->cAlmLin )   .AND. ( cValPr1 == ( ::cTikL )->cValPr1 )   .AND. ( cValPr2 == ( ::cTikL )->cValPr2 )   .AND. ( cLote   == ( ::cTikL )->cLote   )

                        nTotal += ( ::cTikL )->nUntTil

                     end

                  end

                  ( ::cTikL )->( dbSkip() )

               end

            end

            ( ::cTikL )->( OrdSetFocus( "cComTil" ) )

            if ( ::cTikL )->( dbSeek( cCodArt ) )

               while ( ::cTikL )->cComTil == cCodArt .AND. !( ::cTikL )->( Eof() )

                  if ( ::cTikT )->( dbSeek( ( ::cTikL )->cSerTil + ( ::cTikL )->cNumTil + ( ::cTikL )->cSufTil ) )




                     if ( cCodAlm == ( ::cTikL )->cAlmLin )   .AND. ( cValPr1 == ( ::cTikL )->cValPr1 )   .AND. ( cValPr2 == ( ::cTikL )->cValPr2 )   .AND. ( cLote   == ( ::cTikL )->cLote   )

                        nTotal += ( ::cTikL )->nUntTil

                     end

                  end

                  ( ::cTikL )->( dbSkip() )

               end

            end

            ( ::cTikL )->( OrdSetFocus( nOrd ) )

         else

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "TIKET.DBF" ), ( cCheckArea( "TIKET", @cTikEmpT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "TIKET.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cDriver() ), ( cPatStk( cCodEmp ) + "TIKEL.DBF" ), ( cCheckArea( "TIKEL", @cTikEmpL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatStk( cCodEmp ) + "TIKEL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
            ( cTikEmpL )->( ordSetFocus( "cCbaTil" ) )

            if ( cTikEmpL )->( dbSeek( cCodArt ) )
               while ( cTikEmpL )->cCbaTil == cCodArt .AND. !( cTikEmpL )->( Eof() )


                  if ( cTikEmpT )->( dbSeek( ( cTikEmpL )->cSerTil + ( cTikEmpL )->cNumTil + ( cTikEmpL )->cSufTil ) )   .AND. ( Empty( dFecha ) .OR. ( cTikEmpT )->dFecTik <= dFecha )




                     if ( cCodAlm == ( cTikEmpL )->cAlmLin )   .AND. ( cValPr1 == ( cTikEmpL )->cValPr1 )   .AND. ( cValPr2 == ( cTikEmpL )->cValPr2 )   .AND. ( cLote   == ( cTikEmpL )->cLote   )

                        nTotal += ( cTikEmpL )->nUntTil

                     end

                  end

                  ( cTikEmpL )->( dbSkip() )

               end

            end

            ( cTikEmpL )->( OrdSetFocus( "cComTil" ) )

            if ( cTikEmpL )->( dbSeek( cCodArt ) )

               while ( cTikEmpL )->cComTil == cCodArt .AND. !( cTikEmpL )->( Eof() )

                  if ( cTikEmpT )->( dbSeek( ( cTikEmpL )->cSerTil + ( cTikEmpL )->cNumTil + ( cTikEmpL )->cSufTil ) )




                     if ( cCodAlm == ( cTikEmpL )->cAlmLin )   .AND. ( cValPr1 == ( cTikEmpL )->cValPr1 )   .AND. ( cValPr2 == ( cTikEmpL )->cValPr2 )   .AND. ( cLote   == ( cTikEmpL )->cLote   )

                        nTotal += ( cTikEmpL )->nUntTil

                     end

                  end

                  ( cTikEmpL )->( dbSkip() )

               end

            end

            ( cTikEmpL )->( OrdSetFocus( "cCbaTil" ) )

            ( cTikEmpT )->( dbCloseArea() )
            ( cTikEmpL )->( dbCloseArea() )

         end

      next

   end

RETURN ( nTotal )



UTILITY STATIC function TStock_nTotMovAlm( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nOrd
   local nTotal      := 0

   IIF( cValPr1 == nil, cValPr1 := Space( 10 ), ) ;
   IIF( cValPr2 == nil, cValPr2 := Space( 10 ), ) ;
   IIF( cLote == nil, cLote := Space( 12 ), ) ;

   nOrd              := ( ::cHisMov )->( OrdSetFocus( "cRefMov" ) )
   if ( ::cHisMov )->( dbSeek( cCodArt ) )

      while ( ::cHisMov )->cRefMov == cCodArt .AND. !( ::cHisMov )->( Eof() )




         if ( Empty( dFecha ) .OR. ( ::cHisMov )->dFecMov <= dFecha )   .AND. ( cValPr1 == ( ::cHisMov )->cValPr1 )                       .AND. ( cValPr2 == ( ::cHisMov )->cValPr2 )                       .AND. ( cLote   == ( ::cHisMov )->cLote   )

            if !( ::cHisMov )->lNoStk

               if ( ::cHisMov )->cAliMov == cCodAlm
                  nTotal   += nTotNMovAlm( ::cHisMov )
               end

               if ( ::cHisMov )->cAloMov == cCodAlm
                  nTotal   -= nTotNMovAlm( ::cHisMov )
               end

            end

         end

         ( ::cHisMov )->( dbSkip() )

      end

   end

   ( ::cHisMov )->( OrdSetFocus( nOrd ) )

RETURN ( nTotal )



UTILITY STATIC function TStock_nStockActualCalculado( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nStkTotal   := 0

   nStkTotal         += ::nTotAlbPrv( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha )

   nStkTotal         += ::nTotFacPrv( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha )
   nStkTotal         += ::nTotRctPrv( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha )

   nStkTotal         -= ::nTotAlbCli( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha )
   nStkTotal         -= ::nTotFacCli( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha )
   nStkTotal         -= ::nTotFacRec( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha )
   nStkTotal         -= ::nTotTikCli( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha )

   nStkTotal         += ::nTotMovAlm( cCodArt, cCodAlm, cValPr1, cValPr2, cLote, dFecha )

RETURN ( nStkTotal )



UTILITY STATIC function TStock_CloseFiles() ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   if !Empty( ::dbfDiv )
      ( ::dbfDiv )->( dbCloseArea() )
   end

Return ( Self )



UTILITY STATIC function TStock_nTotalSaldo( cCodArt, cCodCli, dFecha) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nTotal   := 0
   local nOrdLin
   local nRecCab
   local nRecLin





   nRecCab        := ( ::cAlbCliT )->( RecNo() )
   nRecLin        := ( ::cAlbCliL )->( Recno() )
   nOrdLin        := ( ::cAlbCliL )->( OrdSetFocus( "cRef" ) )

   if ( ::cAlbCliL )->( dbSeek( cCodArt ) )

      while ( ::cAlbCliL )->cRef == cCodArt .AND. !( ::cAlbCliL )->( Eof() )




         if dbSeekInOrd( ( ::cAlbCliL )->cSerAlb + Str( ( ::cAlbCliL )->nNumAlb ) + ( ::cAlbCliL )->cSufAlb, "nNumAlb", ::cAlbCliT )  .AND. ( ::cAlbCliT )->cCodCli == cCodCli .AND. ( ::cAlbCliT )->dFecAlb <= dFecha .AND. !( ::cAlbCliT )->lFacturado

            nTotal   += nTotNAlbCli( ::cAlbCliL )

         end

         ( ::cAlbCliL )->( dbSkip() )

      end

   end

   ( ::cAlbCliL )->( OrdSetFocus( nOrdLin ) )
   ( ::cAlbCliL )->( dbGoTo( nRecLin ) )
   ( ::cAlbCliT )->( dbGoTo( nRecCab ) )





   nRecCab        := ( ::cFacCliT )->( RecNo() )
   nRecLin        := ( ::cFacCliL )->( Recno() )
   nOrdLin        := ( ::cFacCliL )->( OrdSetFocus( "cRef" ) )

   if ( ::cFacCliL )->( dbSeek( cCodArt ) )

      while ( ::cFacCliL )->cRef == cCodArt .AND. !( ::cFacCliL )->( Eof() )



         if dbSeekInOrd( ( ::cFacCliL )->cSerie + Str( ( ::cFacCliL )->nNumFac ) + ( ::cFacCliL )->cSufFac, "NNUMFAC", ::cFacCliT ) .AND. ( ::cFacCliT )->cCodCli == cCodCli .AND. ( ::cFacCliT )->dFecFac <= dFecha

            nTotal   += nTotNFacCli( ::cFacCliL )

         end

         ( ::cFacCliL )->( dbSkip() )

      end

   end

   ( ::cFacCliL )->( OrdSetFocus( nOrdLin ) )
   ( ::cFacCliL )->( dbGoTo( nRecLin ) )
   ( ::cFacCliT )->( dbGoTo( nRecCab ) )





   nRecCab        := ( ::cFacRecT )->( RecNo() )
   nRecLin        := ( ::cFacRecL )->( Recno() )
   nOrdLin        := ( ::cFacRecL )->( OrdSetFocus( "cRef" ) )

   if ( ::cFacRecL )->( dbSeek( cCodArt ) )

      while ( ::cFacRecL )->cRef == cCodArt .AND. !( ::cFacRecL )->( Eof() )



         if dbSeekInOrd( ( ::cFacRecL )->cSerie + Str( ( ::cFacRecL )->nNumFac ) + ( ::cFacRecL )->cSufFac, "NNUMFAC", ::cFacRecT ) .AND. ( ::cFacRecT )->cCodCli == cCodCli .AND. ( ::cFacRecT )->dFecFac <= dFecha

            nTotal   += nTotNFacRec( ::cFacRecL )

         end

         ( ::cFacRecL )->( dbSkip() )

      end

   end

   ( ::cFacRecL )->( OrdSetFocus( nOrdLin ) )
   ( ::cFacRecL )->( dbGoTo( nRecLin ) )
   ( ::cFacRecT )->( dbGoTo( nRecCab ) )





   nRecCab        := ( ::cTikT )->( RecNo() )
   nRecLin        := ( ::cTikL )->( Recno() )
   nOrdLin        := ( ::cTikL )->( OrdSetFocus( "CCBATIL" ) )

   if ( ::cTikL )->( dbSeek( cCodArt ) )

      while ( ::cTikL )->cCbaTil == cCodArt .AND. !( ::cTikL )->( Eof() )



         if dbSeekInOrd( ( ::cTikL )->cSerTil + ( ::cTikL )->cNumTil + ( ::cTikL )->cSufTil, "CNUMTIK", ::cTikT ) .AND. ( ::cTikT )->cCliTik == cCodCli .AND. ( ::cTikT )->dFecTik <= dFecha

            nTotal   += ( ::cTikL )->nUntTil

         end

         ( ::cTikL )->( dbSkip() )

      end

   end

   ( ::cTikL )->( OrdSetFocus( nOrdLin ) )
   ( ::cTikL )->( dbGoTo( nRecLin ) )
   ( ::cTikT )->( dbGoTo( nRecCab ) )





   nRecCab        := ( ::cTikT )->( RecNo() )
   nRecLin        := ( ::cTikL )->( Recno() )
   nOrdLin        := ( ::cTikL )->( OrdSetFocus( "CCOMTIL" ) )

   if ( ::cTikL )->( dbSeek( cCodArt ) )

      while ( ::cTikL )->cComTil == cCodArt .AND. !( ::cTikL )->( Eof() )



         if dbSeekInOrd( ( ::cTikL )->cSerTil + ( ::cTikL )->cNumTil + ( ::cTikL )->cSufTil, "CNUMTIK", ::cTikT ) .AND. ( ::cTikT )->cCliTik == cCodCli .AND. ( ::cTikT )->dFecTik <= dFecha

            nTotal   += ( ::cTikL )->nUntTil

         end

         ( ::cTikL )->( dbSkip() )

      end

   end

   ( ::cTikL )->( OrdSetFocus( nOrdLin ) )
   ( ::cTikL )->( dbGoTo( nRecLin ) )
   ( ::cTikT )->( dbGoTo( nRecCab ) )

RETURN ( nTotal)



UTILITY STATIC function TStock_nSaldoDocumento( cCodArt, cNumDoc) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nTotal   := 0
   local nRecLin  := ( ::cFacCliL )->( Recno() )
   local nOrdAnt  := ( ::cFacCliL )->( OrdSetFocus( "nNumFac" ) )

   if ( ::cFacCliL )->( dbSeek( cNumDoc ) )

      while ( ::cFacCliL )->cSerie + Str( ( ::cFacCliL )->nNumFac ) + ( ::cFacCliL )->cSufFac == cNumDoc .AND. !( ::cFacCliL )->( Eof())

         if ( ::cFacCliL )->cRef == cCodArt

            nTotal   += nTotNFacCli( ::cFacCliL )

         end

         ( ::cFacCliL )->( dbSkip() )

      end

   end

   ( ::cFacCliL )->( OrdSetFocus( nOrdAnt ) )
   ( ::cFacCliL )->( dbGoTo( nRecLin ) )

RETURN ( nTotal )



UTILITY STATIC function TStock_nSaldoAnterior( cCodArt, cNumDoc) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local cCodCli
   local dFecha
   local nRec     := ( ::cFacCliT )->( Recno() )
   local nOrdAnt  := ( ::cFacCliT )->( OrdSetFocus( "NNUMFAC" ) )

   if ( ::cFacCliT )->( dbSeek( cNumDoc ) )
      cCodCli     := ( ::cFacCliT )->cCodCli
      dFecha      := ( ::cFacCliT )->dFecFac
   end

   ( ::cFacCliT )->( OrdSetFocus( nOrdAnt ) )
   ( ::cFacCliT )->( dbGoTo( nRec ) )

RETURN ( ::nTotalSaldo( cCodArt, cCodCli, dFecha ) - ::nSaldoDocumento( cCodArt, cNumDoc ) )



UTILITY STATIC function TStock_nSaldoDocAlb( cCodArt, cNumDoc) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nTotal   := 0
   local nRecLin  := ( ::cAlbCliL )->( Recno() )
   local nOrdAnt  := ( ::cAlbCliL )->( OrdSetFocus( "nNumAlb" ) )

   if ( ::cAlbCliL )->( dbSeek( cNumDoc ) )

      while ( ::cAlbCliL )->cSerAlb + Str( ( ::cAlbCliL )->nNumAlb ) + ( ::cAlbCliL )->cSufAlb == cNumDoc .AND. !( ::cAlbCliL )->( Eof())

         if ( ::cAlbCliL )->cRef == cCodArt

            nTotal   += nTotNAlbCli( ::cAlbCliL )

         end

         ( ::cAlbCliL )->( dbSkip() )

      end

   end

   ( ::cAlbCliL )->( OrdSetFocus( nOrdAnt ) )
   ( ::cAlbCliL )->( dbGoTo( nRecLin ) )

RETURN ( nTotal )



UTILITY STATIC function TStock_nSaldoAntAlb( cCodArt, cNumDoc) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local cCodCli
   local dFecha
   local nRec     := ( ::cAlbCliT )->( Recno() )
   local nOrdAnt  := ( ::cAlbCliT )->( OrdSetFocus( "NNUMALB" ) )

   if ( ::cAlbCliT )->( dbSeek( cNumDoc ) )
      cCodCli     := ( ::cAlbCliT )->cCodCli
      dFecha      := ( ::cAlbCliT )->dFecAlb
   end

   ( ::cAlbCliT )->( OrdSetFocus( nOrdAnt ) )
   ( ::cAlbCliT )->( dbGoTo( nRec ) )

RETURN ( ::nTotalSaldo( cCodArt, cCodCli, dFecha ) - ::nSaldoDocAlb( cCodArt, cNumDoc ) )



UTILITY STATIC function TStock_nPrecioMedioCompra( cCodArt, cCodAlm, dFecIni, dFecFin, lSerie, lExcCero, lExcImp, aSer, oMtr) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nPreMed        := 0
   local aMovimientos   := {}
   local nSalAnt        := 0
   local nImpAnt        := 0
   local aMov           := {}
   local nOrdAlbPrvL    := ( ::cAlbPrvL )->( OrdSetFocus( "cStkFast") )
   local nOrdFacPrvL    := ( ::cFacPrvL )->( OrdSetFocus( "cRef"    ) )
   local nOrdRctPrvL    := ( ::cRctPrvL )->( OrdSetFocus( "cRef"    ) )
   local cHisMov        := ( ::cHisMov  )->( OrdSetFocus( "cRefMov" ) )

   IIF( lExcCero == nil, lExcCero := .F., ) ;
   IIF( lExcImp == nil, lExcImp := .F., ) ;
   IIF( lSerie == nil, lSerie := .F., ) ;

   if oMtr <> nil
      oMtr:SetTotal( 8 )
   end



   if ( ::cAlbPrvL )->( dbSeek( cCodArt ) )

      while ( ::cAlbPrvL )->cRef == cCodArt .AND. !( ::cAlbPrvL )->( eof() )






         if ( Empty( cCodAlm ) .OR. ( ( ::cAlbPrvL )->cAlmLin == cCodAlm ) )           .AND. !( lExcCero .AND. nTotNAlbPrv( ::cAlbPrvL ) == 0 )                         .AND. !( lExcImp .AND. nTotLAlbPrv( ::cAlbPrvL, ::nDecIn, ::nDerIn ) == 0 )      .AND. ( Empty( dFecIni ) .OR. ( ::cAlbPrvL )->dFecAlb >= dFecIni )               .AND. ( Empty( dFecFin ) .OR. ( ::cAlbPrvL )->dFecAlb <= dFecFin )               .AND. ( !lSerie .OR. lChkSer( ( ::cAlbPrvL )->cSerAlb, aSer ) )

            aAdd( aMovimientos, STemporal():New( ( ::cAlbPrvL )->dFecAlb, nil, nTotNAlbPrv( ::cAlbPrvL ), 0, nTotLAlbPrv( ::cAlbPrvL, ::nDecIn, ::nDerIn ), "alb prv", ( ::cAlbPrvL )->cSerAlb + Str( ( ::cAlbPrvL )->nNumAlb ) + ( ::cAlbPrvL )->cSufAlb ) )

         end

         ( ::cAlbPrvL )->( dbSkip() )

      end

   end

   if oMtr <> nil
      oMtr:AutoInc()
   end



   if ( ::cFacPrvL )->( dbSeek( cCodArt ) )

      while ( ::cFacPrvL )->cRef == cCodArt .AND. !( ::cFacPrvL )->( eof() )






         if ( Empty( cCodAlm ) .OR. ( ( ::cFacPrvL )->cAlmLin == cCodAlm ) )           .AND. !( lExcCero .AND. nTotNFacPrv( ::cFacPrvL ) == 0 )                         .AND. !( lExcImp .AND. nTotLFacPrv( ::cFacPrvL, ::nDecIn, ::nDerIn ) == 0 )      .AND. ( Empty( dFecIni ) .OR. ( ::cFacPrvL )->dFecFac >= dFecIni )               .AND. ( Empty( dFecFin ) .OR. ( ::cFacPrvL )->dFecFac <= dFecFin )               .AND. ( !lSerie .OR. lChkSer( ( ::cFacPrvL )->cSerFac, aSer ) )

            aAdd( aMovimientos, STemporal():New( ( ::cFacPrvL )->dFecFac, nil, nTotNFacPrv( ::cFacPrvL ), 0, nTotLFacPrv( ::cFacPrvL, ::nDecIn, ::nDerIn ), "fac prv", ( ::cFacPrvL )->cSerFac + Str( ( ::cFacPrvL )->nNumFac ) + ( ::cFacPrvL )->cSufFac ) )

         end

         ( ::cFacPrvL )->( dbSkip() )

      end

   end

   if oMtr <> nil
      oMtr:AutoInc()
   end



   if ( ::cRctPrvL )->( dbSeek( cCodArt ) )

      while ( ::cRctPrvL )->cRef == cCodArt .AND. !( ::cRctPrvL )->( eof() )






         if ( Empty( cCodAlm ) .OR. ( ( ::cRctPrvL )->cAlmLin == cCodAlm ) )           .AND. !( lExcCero .AND. nTotNRctPrv( ::cRctPrvL ) == 0 )                         .AND. !( lExcImp .AND. nTotLRctPrv( ::cRctPrvL, ::nDecIn, ::nDerIn ) == 0 )      .AND. ( Empty( dFecIni ) .OR. ( ::cRctPrvL )->dFecFac >= dFecIni )               .AND. ( Empty( dFecFin ) .OR. ( ::cRctPrvL )->dFecFac <= dFecFin )               .AND. ( !lSerie .OR. lChkSer( ( ::cRctPrvL )->cSerFac, aSer ) )

            aAdd( aMovimientos, STemporal():New( ( ::cRctPrvL )->dFecFac, nil, nTotNRctPrv( ::cRctPrvL ), 0, nTotLRctPrv( ::cRctPrvL, ::nDecIn, ::nDerIn ), "fac prv", ( ::cRctPrvL )->cSerFac + Str( ( ::cRctPrvL )->nNumFac ) + ( ::cRctPrvL )->cSufFac ) )

         end

         ( ::cRctPrvL )->( dbSkip() )

      end

   end

   if oMtr <> nil
      oMtr:AutoInc()
   end



   if ( ::cHisMov )->( dbSeek( cCodArt ) )

      while ( ::cHisMov )->cRefMov == cCodArt .AND. !( ::cHisMov )->( Eof() )




         if ( Empty( dFecIni ) .OR. ( ::cHisMov )->dFecMov >= dFecIni )                   .AND. ( Empty( dFecFin ) .OR. ( ::cHisMov )->dFecMov <= dFecFin )                   .AND. !( lExcCero .AND. nTotNMovAlm( ::cHisMov ) == 0 )                             .AND. !( lExcImp  .AND. nTotLMovAlm( ::cHisMov ) == 0 )




            if !Empty( ( ::cHisMov )->cAliMov )                                           .AND. ( Empty( cCodAlm ) .OR. ( ::cHisMov )->cAliMov == cCodAlm )

               aAdd( aMovimientos, STemporal():New( ( ::cHisMov )->dFecMov, nil, nTotNMovAlm( ::cHisMov ), 0, nTotLMovAlm( ::cHisMov ), "mov alm", dtos( ( ::cHisMov )->dFecMov ) ) )

            end

         end

         ( ::cHisMov )->( dbSkip() )

      end

   end

   if oMtr <> nil
      oMtr:AutoInc()
   end



   aMovimientos            := aSort( aMovimientos,,, {|x,y| ( Dtos( x:dFecMov ) ) < ( Dtos( y:dFecMov ) ) } )



   for each aMov in aMovimientos



      if aMov:nTotEnt <> 0
         nSalAnt           += aMov:nTotEnt
         nImpAnt           += aMov:nImpEnt
         nPreMed           := nImpAnt / nSalAnt
      end

   next





   ( ::cAlbPrvL )->( OrdSetFocus( nOrdAlbPrvL ) )
   ( ::cFacPrvL )->( OrdSetFocus( nOrdFacPrvL ) )
   ( ::cRctPrvL )->( OrdSetFocus( nOrdRctPrvL ) )
   ( ::cHisMov  )->( OrdSetFocus( cHisMov     ) )

RETURN ( nPreMed )



UTILITY STATIC function TStock_nCostoMedio( cCodArt, cCodAlm, cCodPr1, cCodPr2, cValPr1, cValPr2) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nUnidades      := 0
   local nImporte       := 0
   local nCostoMedio    := 0
   local nOrdAlbPrvL    := ( ::cAlbPrvL )->( OrdSetFocus( "cStkRef" ) )
   local nOrdFacPrvL    := ( ::cFacPrvL )->( OrdSetFocus( "cRef" ) )
   local nOrdRctPrvL    := ( ::cRctPrvL )->( OrdSetFocus( "cRef" ) )
   local nOrdMovAlm     := ( ::cHisMov  )->( OrdSetFocus( "cRefMov" ) )





   ::GetConsolidacion( cCodArt )





   if ( ::cHisMov )->( dbSeek( cCodArt + cValPr1 + cValPr2 ) )

      while ( ::cHisMov )->cRefMov == cCodArt .AND. ( ::cHisMov )->cValPr1 == cValPr1 .AND. ( ::cHisMov )->cValPr2 == cValPr2 .AND. !( ::cHisMov )->( Eof() )


         if ::lValoracionCostoMedio( ( ::cHisMov )->nTipMov ) .AND. ( Empty( ::dConsolidacion ) .OR. ( ::cHisMov )->dFecMov >= ::dConsolidacion )

            if !Empty( ( ::cHisMov )->cAloMov ) .AND. ( Empty( cCodAlm ) .OR. ( ::cHisMov )->cAliMov == cCodAlm )

               nUnidades   += nTotNMovAlm( ::cHisMov )
               nImporte    += nTotLMovAlm( ::cHisMov )

            end

            if !Empty( ( ::cHisMov )->cAliMov ) .AND. ( Empty( cCodAlm ) .OR. ( ::cHisMov )->cAliMov == cCodAlm )

               nUnidades   += nTotNMovAlm( ::cHisMov )
               nImporte    += nTotLMovAlm( ::cHisMov )

            end

         end

         ( ::cHisMov )->( dbSkip() )

      end

   end





   if ( ::cAlbPrvL )->( dbSeek( cCodArt + cValPr1 + cValPr2 ) )

      while ( ::cAlbPrvL )->cRef == cCodArt .AND. ( ::cAlbPrvL )->cValPr1 == cValPr1 .AND. ( ::cAlbPrvL )->cValPr2 == cValPr2 .AND. !( ::cAlbPrvL )->( eof() )


         if ( Empty( ::dConsolidacion ) .OR. ( ::cAlbPrvL )->dFecAlb >= ::dConsolidacion )   .AND. Empty( cCodAlm ) .OR. ( ( ::cAlbPrvL )->cAlmLin == cCodAlm )

            nUnidades   += nTotNAlbPrv( ::cAlbPrvL )
            nImporte    += nTotLAlbPrv( ::cAlbPrvL, ::nDecIn, ::nDerIn )

         end

         ( ::cAlbPrvL )->( dbSkip() )

      end

   end





   if ( ::cFacPrvL )->( dbSeek( cCodArt + cValPr1 + cValPr2 ) )

      while ( ::cFacPrvL )->cRef == cCodArt .AND. ( ::cFacPrvL )->cValPr1 == cValPr1 .AND. ( ::cFacPrvL )->cValPr2 == cValPr2 .AND. !( ::cFacPrvL )->( eof() )


         if ( Empty( ::dConsolidacion ) .OR. ( ::cFacPrvL )->dFecFac >= ::dConsolidacion )   .AND. Empty( cCodAlm ) .OR. ( ( ::cFacPrvL )->cAlmLin == cCodAlm )

            nUnidades   += nTotNFacPrv( ::cFacPrvL )
            nImporte    += nTotLFacPrv( ::cFacPrvL, ::nDecIn, ::nDerIn )

         end

         ( ::cFacPrvL )->( dbSkip() )

      end

   end





   if ( ::cRctPrvL )->( dbSeek( cCodArt + cValPr1 + cValPr2 ) )

      while ( ::cRctPrvL )->cRef == cCodArt .AND. ( ::cRctPrvL )->cValPr1 == cValPr1 .AND. ( ::cRctPrvL )->cValPr2 == cValPr2 .AND. !( ::cRctPrvL )->( eof() )


         if ( Empty( ::dConsolidacion ) .OR. ( ::cRctPrvL )->dFecFac >= ::dConsolidacion )   .AND. Empty( cCodAlm ) .OR. ( ( ::cRctPrvL )->cAlmLin == cCodAlm )

            nUnidades   += nTotNRctPrv( ::cRctPrvL )
            nImporte    += nTotLRctPrv( ::cRctPrvL, ::nDecIn, ::nDerIn )

         end

         ( ::cRctPrvL )->( dbSkip() )

      end

   end





   if nImporte <> 0 .AND. nUnidades <> 0
      nCostoMedio       := ( nImporte / nUnidades )
   end





   if nCostoMedio == 0 .AND. !Empty( ::cArt ) .AND. !Empty( ::cKit )
      nCostoMedio       := nCosto( cCodArt, ::cArt, ::cKit )
   end





   ( ::cAlbPrvL )->( OrdSetFocus( nOrdAlbPrvL ) )
   ( ::cFacPrvL )->( OrdSetFocus( nOrdFacPrvL ) )
   ( ::cRctPrvL )->( OrdSetFocus( nOrdRctPrvL ) )
   ( ::cHisMov  )->( OrdSetFocus( nOrdMovAlm  ) )

RETURN ( nCostoMedio )



UTILITY STATIC function TStock_lValoracionCostoMedio( nTipMov) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

RETURN ( !uFieldEmpresa( "lMovCos" ) .AND. ( nTipMov == 2 .OR. nTipMov == 4 ) )



UTILITY STATIC function TStock_Zap() ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   if ( ::oDbf )->( Used() )

      if !( ::oDbf )->( IsShared() )

         ( ::oDbf )->( __dbZap() )

      else

         ( ::oDbf )->( dbGoTop() )
         while !( ::oDbf )->( eof() )

            if dbLock( ::oDbf )
               ( ::oDbf )->( dbDelete() )
               ( ::oDbf )->( dbUnLock() )
            end

            ( ::oDbf )->( dbSkip( 0 ) )

         end

      end

   end

RETURN ( Self )



UTILITY STATIC function TStock_nStockAlmacen( cCodArt, cCodAlm, cValPr1, cValPr2, cLote) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local oBlock
   local oError
   local nOrdAnt
   local nStkTotal      := 0
   local nOrdHisMov
   local nOrdPedPrvL
   local nOrdAlbPrvL
   local nOrdFacPrvL
   local nOrdRctPrvL
   local nOrdPedCliL
   local nOrdAlbCliL
   local nOrdFacCliL
   local nOrdFacRecL
   local nOrdTikCliL
   local nOrdProducL
   local nOrdProducM

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   nOrdPedPrvL          := if( !Empty( ::cPedPrvL ), ( ::cPedPrvL )->( OrdSetFocus( "cRef" ) )     , "" )
   nOrdAlbPrvL          := if( !Empty( ::cAlbPrvL ), ( ::cAlbPrvL )->( OrdSetFocus( "cStkFast" ) ) , "" )
   nOrdFacPrvL          := if( !Empty( ::cFacPrvL ), ( ::cFacPrvL )->( OrdSetFocus( "cRef" ) )     , "" )
   nOrdRctPrvL          := if( !Empty( ::cRctPrvL ), ( ::cRctPrvL )->( OrdSetFocus( "cRef" ) )     , "" )
   nOrdPedCliL          := if( !Empty( ::cPedCliL ), ( ::cPedCliL )->( OrdSetFocus( "cRef" ) )     , "" )
   nOrdAlbCliL          := if( !Empty( ::cAlbCliL ), ( ::cAlbCliL )->( OrdSetFocus( "cStkFast" ) ) , "" )
   nOrdFacCliL          := if( !Empty( ::cFacCliL ), ( ::cFacCliL )->( OrdSetFocus( "cRef" ) )     , "" )
   nOrdFacRecL          := if( !Empty( ::cFacRecL ), ( ::cFacRecL )->( OrdSetFocus( "cRef" ) )     , "" )
   nOrdTikCliL          := if( !Empty( ::cTikL    ), ( ::cTikL    )->( OrdSetFocus( "cStkFast" ) ) , "" )
   nOrdProducL          := if( !Empty( ::cProducL ), ( ::cProducL )->( OrdSetFocus( "cCodArt" ) )  , "" )
   nOrdProducM          := if( !Empty( ::cProducM ), ( ::cProducM )->( OrdSetFocus( "cCodArt" ) )  , "" )
   nOrdHisMov           := if( !Empty( ::cHisMov  ), ( ::cHisMov  )->( OrdSetFocus( "cRefMov" ) )  , "" )

   if !Empty( cCodArt )

      CursorWait()





      SysRefresh()

      if !Empty( ::cHisMov )

         ::GetConsolidacion( cCodArt )

         if ( ::cHisMov )->( dbSeek( cCodArt ) )

            while ( ::cHisMov )->cRefMov == cCodArt .AND. !( ::cHisMov )->( Eof() )

               if ( Empty( ::dConsolidacion ) .OR. ( ::cHisMov )->dFecMov >= ::dConsolidacion )





                  if !Empty( ( ::cHisMov )->cAliMov )                               .AND. ( Empty( cCodAlm )   .OR. cCodAlm == ( ::cHisMov )->cAliMov )  .AND. ( Empty( cValPr1 )   .OR. cValPr1 == ( ::cHisMov )->cValPr1 )  .AND. ( Empty( cValPr2 )   .OR. cValPr2 == ( ::cHisMov )->cValPr2 )  .AND. ( Empty( cLote )     .OR. cLote   == ( ::cHisMov )->cLote   )

                     nStkTotal               += nTotNMovAlm( ::cHisMov )

                  end





                  if !Empty( ( ::cHisMov )->cAloMov )                               .AND. ( Empty( cCodAlm )   .OR. cCodAlm == ( ::cHisMov )->cAloMov )  .AND. ( Empty( cValPr1 )   .OR. cValPr1 == ( ::cHisMov )->cValPr1 )  .AND. ( Empty( cValPr2 )   .OR. cValPr2 == ( ::cHisMov )->cValPr2 )  .AND. ( Empty( cLote )     .OR. cLote   == ( ::cHisMov )->cLote   )

                     nStkTotal               -= nTotNMovAlm( ::cHisMov )

                  end

               end

               ( ::cHisMov )->( dbSkip() )

            end

         end

      end





      SysRefresh()

      if !Empty( ::cAlbPrvL ) .AND. ( ::cAlbPrvL )->( dbSeek( cCodArt ) )

         while ( ::cAlbPrvL )->cRef == cCodArt .AND. !( ::cAlbPrvL )->( Eof() )






            if ( ::cAlbPrvL )->nCtlStk < 2                                                      .AND. ( Empty( ::dConsolidacion ) .OR. ( ::cAlbPrvL )->dFecAlb >= ::dConsolidacion )   .AND. ( Empty( cCodAlm )   .OR. cCodAlm == ( ::cAlbPrvL )->cAlmLin )                   .AND. ( Empty( cValPr1 )   .OR. cValPr1 == ( ::cAlbPrvL )->cValPr1 )                   .AND. ( Empty( cValPr2 )   .OR. cValPr2 == ( ::cAlbPrvL )->cValPr2 )                   .AND. ( Empty( cLote )     .OR. cLote   == ( ::cAlbPrvL )->cLote   )

               nStkTotal               += nTotNAlbPrv( ::cAlbPrvL )

            end

            ( ::cAlbPrvL )->( dbSkip() )

         end

      end





      SysRefresh()

      if !Empty( ::cFacPrvL ) .AND. ( ::cFacPrvL )->( dbSeek( cCodArt ) )

         while ( ::cFacPrvL )->cRef == cCodArt .AND. !( ::cFacPrvL )->( Eof() )






            if ( ::cFacPrvL )->nCtlStk < 2                                                      .AND. ( Empty( ::dConsolidacion ) .OR. ( ::cFacPrvL )->dFecFac >= ::dConsolidacion )   .AND. ( Empty( cCodAlm )   .OR. cCodAlm == ( ::cFacPrvL )->cAlmLin )                   .AND. ( Empty( cValPr1 )   .OR. cValPr1 == ( ::cFacPrvL )->cValPr1 )                   .AND. ( Empty( cValPr2 )   .OR. cValPr2 == ( ::cFacPrvL )->cValPr2 )                   .AND. ( Empty( cLote )     .OR. cLote   == ( ::cFacPrvL )->cLote   )

               nStkTotal               += nTotNFacPrv( ::cFacPrvL )

            end

            ( ::cFacPrvL )->( dbSkip() )

         end

      end





      SysRefresh()

      if !Empty( ::cRctPrvL ) .AND. ( ::cRctPrvL )->( dbSeek( cCodArt ) )

         while ( ::cRctPrvL )->cRef == cCodArt .AND. !( ::cRctPrvL )->( Eof() )






            if ( ::cRctPrvL )->nCtlStk < 2                                                      .AND. ( Empty( ::dConsolidacion ) .OR. ( ::cRctPrvL )->dFecFac >= ::dConsolidacion )   .AND. ( Empty( cCodAlm )   .OR. cCodAlm == ( ::cRctPrvL )->cAlmLin )                   .AND. ( Empty( cValPr1 )   .OR. cValPr1 == ( ::cRctPrvL )->cValPr1 )                   .AND. ( Empty( cValPr2 )   .OR. cValPr2 == ( ::cRctPrvL )->cValPr2 )                   .AND. ( Empty( cLote )     .OR. cLote   == ( ::cRctPrvL )->cLote   )

               nStkTotal               += nTotNRctPrv( ::cRctPrvL )

            end

            ( ::cRctPrvL )->( dbSkip() )

         end

      end





      SysRefresh()

      if !Empty( ::cAlbCliL ) .AND. ( ::cAlbCliL )->( dbSeek( cCodArt ) )

         while ( ::cAlbCliL )->cRef == cCodArt .AND. !( ::cAlbCliL )->( Eof() )






            if ( ::cAlbCliL )->nCtlStk < 2                                                      .AND. ( Empty( ::dConsolidacion ) .OR. ( ::cAlbCliL )->dFecAlb >= ::dConsolidacion )   .AND. ( Empty( cCodAlm )   .OR. cCodAlm == ( ::cAlbCliL )->cAlmLin )                   .AND. ( Empty( cValPr1 )   .OR. cValPr1 == ( ::cAlbCliL )->cValPr1 )                   .AND. ( Empty( cValPr2 )   .OR. cValPr2 == ( ::cAlbCliL )->cValPr2 )                   .AND. ( Empty( cLote )     .OR. cLote   == ( ::cAlbCliL )->cLote   )

               nStkTotal               -= nTotVAlbCli( ::cAlbCliL )

            end

            ( ::cAlbCliL )->( dbSkip() )

         end

      end





      SysRefresh()

      if !Empty( ::cFacCliL ) .AND. ( ::cFacCliL )->( dbSeek( cCodArt ) )

         while ( ::cFacCliL )->cRef == cCodArt .AND. !( ::cFacCliL )->( Eof() )






            if ( ::cFacCliL )->nCtlStk < 2                                                      .AND. ( Empty( ::dConsolidacion ) .OR. ( ::cFacCliL )->dFecFac >= ::dConsolidacion )   .AND. ( Empty( cCodAlm )   .OR. cCodAlm == ( ::cFacCliL )->cAlmLin )                   .AND. ( Empty( cValPr1 )   .OR. cValPr1 == ( ::cFacCliL )->cValPr1 )                   .AND. ( Empty( cValPr2 )   .OR. cValPr2 == ( ::cFacCliL )->cValPr2 )                   .AND. ( Empty( cLote )     .OR. cLote   == ( ::cFacCliL )->cLote   )

               nStkTotal               -= nTotVFacCli( ::cFacCliL )

            end

            ( ::cFacCliL )->( dbSkip() )

         end

      end





      SysRefresh()

      if !Empty( ::cFacRecL ) .AND. ( ::cFacRecL )->( dbSeek( cCodArt ) )

         while ( ::cFacRecL )->cRef == cCodArt .AND. !( ::cFacRecL )->( Eof() )






            if ( ::cFacRecL )->nCtlStk < 2                                                      .AND. ( Empty( ::dConsolidacion ) .OR. ( ::cFacRecL )->dFecFac >= ::dConsolidacion )   .AND. ( Empty( cCodAlm )   .OR. cCodAlm == ( ::cFacRecL )->cAlmLin )                   .AND. ( Empty( cValPr1 )   .OR. cValPr1 == ( ::cFacRecL )->cValPr1 )                   .AND. ( Empty( cValPr2 )   .OR. cValPr2 == ( ::cFacRecL )->cValPr2 )                   .AND. ( Empty( cLote )     .OR. cLote   == ( ::cFacRecL )->cLote   )

               nStkTotal               -= nTotVFacRec( ::cFacRecL )

            end

            ( ::cFacRecL )->( dbSkip() )

         end

      end





      SysRefresh()

      if !Empty( ::cTikL )

         if ( ::cTikL )->( dbSeek( cCodArt ) )

            while ( ::cTikL )->cCbaTil == cCodArt .AND. !( ::cTikL )->( Eof() )






               if ( ::cTikL )->nCtlStk < 2                                                      .AND. ( Empty( ::dConsolidacion ) .OR. ( ::cTikL )->dFecTik >= ::dConsolidacion )   .AND. ( Empty( cCodAlm )   .OR. cCodAlm == ( ::cTikL )->cAlmLin )                   .AND. ( Empty( cValPr1 )   .OR. cValPr1 == ( ::cTikL )->cValPr1 )                   .AND. ( Empty( cValPr2 )   .OR. cValPr2 == ( ::cTikL )->cValPr2 )                   .AND. ( Empty( cLote )     .OR. cLote   == ( ::cTikL )->cLote   )

                  if ( ::cTikL )->cTipTil == "1" .OR. ( ::cTikL )->cTipTil == "5"
                     nStkTotal               -= nTotVTikTpv( ::cTikL )
                  else
                     nStkTotal               += nTotVTikTpv( ::cTikL )
                  end

               end

               ( ::cTikL )->( dbSkip() )

            end

         end





         SysRefresh()

         nOrdAnt              := ( ::cTikL )->( OrdSetFocus( "CSTKCOM" ) )

         if ( ::cTikL )->( dbSeek( cCodArt ) )

            if !Empty( ( ::cTikL )->cComTil )

               while ( ::cTikL )->cComTil == cCodArt .AND. !( ::cTikL )->( Eof() )



                  if ( ::cTikL )->nCtlStk < 2                                                      .AND. ( Empty( ::dConsolidacion ) .OR. ( ::cTikL )->dFecTik >= ::dConsolidacion )   .AND. ( Empty( cCodAlm ) .OR. cCodAlm == ( ::cTikL )->cAlmLin )

                     nStkTotal               -= nTotVTikTpv( ::cTikL, .T. )

                  end

                  ( ::cTikL )->( dbSkip() )

               end

            end

         end

         ( ::cTikL )->( OrdSetFocus( nOrdAnt ) )

      end





      SysRefresh()

      if !Empty( ::cProducL ) .AND. ( ::cProducL )->( dbSeek( cCodArt ) )

         while ( ::cProducL )->cCodArt == cCodArt .AND. !( ::cProducL )->( Eof() )





            if ( Empty( ::dConsolidacion ) .OR. ( ::cProducL )->dFecOrd >= ::dConsolidacion )   .AND. ( Empty( cCodAlm )   .OR. cCodAlm == ( ::cProducL )->cAlmOrd )                   .AND. ( Empty( cValPr1 )   .OR. cValPr1 == ( ::cProducL )->cValPr1 )                   .AND. ( Empty( cValPr2 )   .OR. cValPr2 == ( ::cProducL )->cValPr2 )                   .AND. ( Empty( cLote )     .OR. cLote   == ( ::cProducL )->cLote   )

               nStkTotal               += NotCaja( ( ::cProducL )->nCajOrd ) * ( ::cProducL )->nUndOrd

            end

            ( ::cProducL )->( dbSkip() )

         end

      end





      SysRefresh()

      if !Empty( ::cProducM ) .AND. ( ::cProducM )->( dbSeek( cCodArt ) )

         while ( ::cProducM )->cCodArt == cCodArt .AND. !( ::cProducM )->( Eof() )





            if ( Empty( ::dConsolidacion ) .OR. ( ::cProducM )->dFecOrd >= ::dConsolidacion )   .AND. ( Empty( cCodAlm )   .OR. cCodAlm == ( ::cProducM )->cAlmOrd )                   .AND. ( Empty( cValPr1 )   .OR. cValPr1 == ( ::cProducM )->cValPr1 )                   .AND. ( Empty( cValPr2 )   .OR. cValPr2 == ( ::cProducM )->cValPr2 )                   .AND. ( Empty( cLote )     .OR. cLote   == ( ::cProducM )->cLote   )

               nStkTotal               -= NotCaja( ( ::cProducM )->nCajOrd ) * ( ::cProducM )->nUndOrd

            end

            ( ::cProducM )->( dbSkip() )

         end

      end

      CursorWE()

   end

   IIF( !Empty( ::cPedPrvL ), ( ::cPedPrvL )->( OrdSetFocus( nOrdPedPrvL ) ), )
   IIF( !Empty( ::cAlbPrvL ), ( ::cAlbPrvL )->( OrdSetFocus( nOrdAlbPrvL ) ), )
   IIF( !Empty( ::cFacPrvL ), ( ::cFacPrvL )->( OrdSetFocus( nOrdFacPrvL ) ), )
   IIF( !Empty( ::cRctPrvL ), ( ::cRctPrvL )->( OrdSetFocus( nOrdRctPrvL ) ), )
   IIF( !Empty( ::cPedCliL ), ( ::cPedCliL )->( OrdSetFocus( nOrdPedCliL ) ), )
   IIF( !Empty( ::cAlbCliL ), ( ::cAlbCliL )->( OrdSetFocus( nOrdAlbCliL ) ), )
   IIF( !Empty( ::cFacCliL ), ( ::cFacCliL )->( OrdSetFocus( nOrdFacCliL ) ), )
   IIF( !Empty( ::cFacRecL ), ( ::cFacRecL )->( OrdSetFocus( nOrdFacRecL ) ), )
   IIF( !Empty( ::cTikL    ), ( ::cTikL    )->( OrdSetFocus( nOrdTikCliL ) ), )
   IIF( !Empty( ::cProducL ), ( ::cProducL )->( OrdSetFocus( nOrdProducL ) ), )
   IIF( !Empty( ::cProducM ), ( ::cProducM )->( OrdSetFocus( nOrdProducM ) ), )
   IIF( !Empty( ::cHisMov  ), ( ::cHisMov  )->( OrdSetFocus( nOrdHisMov  ) ), )

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Calculo de stock" )

   end

   ErrorBlock( oBlock )

return ( nStkTotal )



UTILITY STATIC function TStock_aStockArticulo( cCodArt, cCodAlm, oBrw, lLote, lNumeroSerie, dFecIni, dFecFin, lNotPendiente) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nRec
   local oBlock
   local oError
   local dFecha         := Ctod( "" )
   local cSerie
   local nTotal
   local dFecDoc
   local nOrdAnt
   local oStocks
   local nOrdPedPrvL
   local nOrdAlbPrvL
   local nOrdFacPrvL
   local nOrdRctPrvL
   local nOrdPedCliL
   local nOrdAlbCliL
   local nOrdFacCliL
   local nOrdFacRecL
   local nOrdTikCliL
   local nOrdProducL
   local nOrdProducM
   local nOrdHisMov

   IIF( lLote == nil, lLote := !uFieldEmpresa( "lCalLot" ), ) ;
   IIF( lNotPendiente == nil, lNotPendiente := .F., ) ;

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   nOrdPedPrvL          := ( ::cPedPrvL )->( OrdSetFocus( "cRef"     ) )
   nOrdAlbPrvL          := ( ::cAlbPrvL )->( OrdSetFocus( "cStkFast" ) )
   nOrdFacPrvL          := ( ::cFacPrvL )->( OrdSetFocus( "cRef"     ) )
   nOrdRctPrvL          := ( ::cRctPrvL )->( OrdSetFocus( "cRef"     ) )
   nOrdPedCliL          := ( ::cPedCliL )->( OrdSetFocus( "cRef"     ) )
   nOrdAlbCliL          := ( ::cAlbCliL )->( OrdSetFocus( "cStkFast" ) )
   nOrdFacCliL          := ( ::cFacCliL )->( OrdSetFocus( "cRef"     ) )
   nOrdFacRecL          := ( ::cFacRecL )->( OrdSetFocus( "cRef"     ) )
   nOrdTikCliL          := ( ::cTikL    )->( OrdSetFocus( "cStkFast" ) )
   nOrdProducL          := ( ::cProducL )->( OrdSetFocus( "cCodArt"  ) )
   nOrdProducM          := ( ::cProducM )->( OrdSetFocus( "cCodArt"  ) )
   nOrdHisMov           := ( ::cHisMov  )->( OrdSetFocus( "cRefMov"  ) )

   lNumeroSerie         := .F.

   ::aStocks            := nil
   ::aStocks            := {}

   if !Empty( oBrw )
      oBrw:aArrayData   := {}
      oBrw:Refresh()
   end





   SysRefresh()

   ::GetConsolidacion( cCodArt )

   if ( ::cHisMov )->( dbSeek( cCodArt ) )

      while ( ::cHisMov )->cRefMov == cCodArt .AND. !( ::cHisMov )->( Eof() )


         if ( Empty( ::dConsolidacion ) .OR. ( ::cHisMov )->dFecMov >= ::dConsolidacion )                            .AND. ( Empty( dFecIni ) .OR. ( ( ::cHisMov )->dFecMov >= dFecIni .AND. ( ::cHisMov )->dFecMov <= dFecFin ) )

            if !Empty( ( ::cHisMov )->cAliMov ) .AND. ( Empty( cCodAlm ) .OR. ( ::cHisMov )->cAliMov == cCodAlm )

               with object ( SStock():New() )
                  :cAlias              := ( ::cHisMov )
                  :cCodigo             := ( ::cHisMov )->cRefMov
                  :cCodigoAlmacen      := ( ::cHisMov )->cAliMov
                  :cCodigoPropiedad1   := ( ::cHisMov )->cCodPr1
                  :cCodigoPropiedad2   := ( ::cHisMov )->cCodPr2
                  :cValorPropiedad1    := ( ::cHisMov )->cValPr1
                  :cValorPropiedad2    := ( ::cHisMov )->cValPr2
                  :cLote               := ( ::cHisMov )->cLote
                  :nUnidades           := nTotNMovAlm( ::cHisMov )
                  if !Empty( ::dConsolidacion )
                     :dConsolidacion   := ::dConsolidacion
                  end
                  ::Integra( hb_QWith(), lLote, lNumeroSerie )
               end

            end

            if !Empty( ( ::cHisMov )->cAloMov ) .AND. ( Empty( cCodAlm ) .OR. ( ::cHisMov )->cAloMov == cCodAlm )

               with object ( SStock():New() )
                  :cAlias              := ( ::cHisMov )
                  :cCodigo             := ( ::cHisMov )->cRefMov
                  :cCodigoAlmacen      := ( ::cHisMov )->cAloMov
                  :cCodigoPropiedad1   := ( ::cHisMov )->cCodPr1
                  :cCodigoPropiedad2   := ( ::cHisMov )->cCodPr2
                  :cValorPropiedad1    := ( ::cHisMov )->cValPr1
                  :cValorPropiedad2    := ( ::cHisMov )->cValPr2
                  :cLote               := ( ::cHisMov )->cLote
                  :nUnidades           := - nTotNMovAlm( ::cHisMov )
                  if !Empty( ::dConsolidacion )
                     :dConsolidacion   := ::dConsolidacion
                  end
                  ::Integra( hb_QWith(), lLote, lNumeroSerie )
               end

            end

         end

         ( ::cHisMov )->( dbSkip() )

      end

   end





   if IsTrue( ::lAlbPrv ) .AND. ( ::cAlbPrvL )->( dbSeek( cCodArt ) )

      while ( ::cAlbPrvL )->cRef == cCodArt .AND. !( ::cAlbPrvL )->( Eof() )




         if ( Empty( ::dConsolidacion ) .OR. ( ::cAlbPrvL )->dFecAlb >= ::dConsolidacion )                              .AND. ( Empty( dFecIni ) .OR. ( ( ::cAlbPrvL )->dFecAlb >= dFecIni .AND. ( ::cAlbPrvL )->dFecAlb <= dFecFin ) )   .AND. ( ( ( ::cAlbPrvL )->nCtlStk < 2 )                                                                           .AND. ( Empty( cCodAlm ) .OR. ( ::cAlbPrvL )->cAlmLin == cCodAlm ) )

            with object ( SStock():New() )
               :cAlias              := ( ::cAlbPrvL )
               :cCodigo             := ( ::cAlbPrvL )->cRef
               :cCodigoAlmacen      := ( ::cAlbPrvL )->cAlmLin
               :cCodigoPropiedad1   := ( ::cAlbPrvL )->cCodPr1
               :cCodigoPropiedad2   := ( ::cAlbPrvL )->cCodPr2
               :cValorPropiedad1    := ( ::cAlbPrvL )->cValPr1
               :cValorPropiedad2    := ( ::cAlbPrvL )->cValPr2
               :cLote               := ( ::cAlbPrvL )->cLote
               :dFechaCaducidad     := ( ::cAlbPrvL )->dFecCad
               :nUnidades           := nTotNAlbPrv( ::cAlbPrvL )
               ::Integra( hb_QWith(), lLote, lNumeroSerie )
            end

         end

         ( ::cAlbPrvL )->( dbSkip() )

      end

   end





   SysRefresh()

   if ( ::cFacPrvL )->( dbSeek( cCodArt ) )

      while ( ::cFacPrvL )->cRef == cCodArt .AND. !( ::cFacPrvL )->( Eof() )




         if ( Empty( ::dConsolidacion ) .OR. ( ::cFacPrvL )->dFecFac >= ::dConsolidacion )                              .AND. ( Empty( dFecIni ) .OR. ( ( ::cFacPrvL )->dFecFac >= dFecIni .AND. ( ::cFacPrvL )->dFecFac <= dFecFin ) )   .AND. ( ( ::cFacPrvL )->nCtlStk < 2 )                                                                             .AND. ( Empty( cCodAlm ) .OR. ( ::cFacPrvL )->cAlmLin == cCodAlm )

            with object ( SStock():New() )
               :cAlias              := ( ::cFacPrvL )
               :cCodigo             := ( ::cFacPrvL )->cRef
               :cCodigoAlmacen      := ( ::cFacPrvL )->cAlmLin
               :cCodigoPropiedad1   := ( ::cFacPrvL )->cCodPr1
               :cCodigoPropiedad2   := ( ::cFacPrvL )->cCodPr2
               :cValorPropiedad1    := ( ::cFacPrvL )->cValPr1
               :cValorPropiedad2    := ( ::cFacPrvL )->cValPr2
               :cLote               := ( ::cFacPrvL )->cLote
               :dFechaCaducidad     := ( ::cFacPrvL )->dFecCad
               :nUnidades           := nTotNFacPrv( ::cFacPrvL )
               ::Integra( hb_QWith(), lLote, lNumeroSerie )
            end

         end

         ( ::cFacPrvL )->( dbSkip() )

      end

   end





   SysRefresh()

   if ( ::cRctPrvL )->( dbSeek( cCodArt ) )

      while ( ::cRctPrvL )->cRef == cCodArt .AND. !( ::cRctPrvL )->( Eof() )




         if ( Empty( ::dConsolidacion ) .OR. ( ::cRctPrvL )->dFecFac >= ::dConsolidacion )                              .AND. ( Empty( dFecIni ) .OR. ( ( ::cRctPrvL )->dFecFac >= dFecIni .AND. ( ::cRctPrvL )->dFecFac <= dFecFin ) )   .AND. ( ( ::cRctPrvL )->nCtlStk < 2 )                                                                             .AND. ( Empty( cCodAlm ) .OR. ( ::cRctPrvL )->cAlmLin == cCodAlm )

            with object ( SStock():New() )
               :cAlias              := ( ::cRctPrvL )
               :cCodigo             := ( ::cRctPrvL )->cRef
               :cCodigoAlmacen      := ( ::cRctPrvL )->cAlmLin
               :cCodigoPropiedad1   := ( ::cRctPrvL )->cCodPr1
               :cCodigoPropiedad2   := ( ::cRctPrvL )->cCodPr2
               :cValorPropiedad1    := ( ::cRctPrvL )->cValPr1
               :cValorPropiedad2    := ( ::cRctPrvL )->cValPr2
               :cLote               := ( ::cRctPrvL )->cLote
               :dFechaCaducidad     := ( ::cRctPrvL )->dFecCad
               :nUnidades           := nTotNRctPrv( ::cRctPrvL )
               ::Integra( hb_QWith(), lLote, lNumeroSerie )
            end

         end

         ( ::cRctPrvL )->( dbSkip() )

      end

   end





   SysRefresh()

   if IsTrue( ::lAlbCli ) .AND. ( ::cAlbCliL )->( dbSeek( cCodArt ) )

      while ( ::cAlbCliL )->cRef == cCodArt .AND. !( ::cAlbCliL )->( Eof() )




         if ( Empty( ::dConsolidacion ) .OR. ( ::cAlbCliL )->dFecAlb >= ::dConsolidacion )                              .AND. ( Empty( dFecIni ) .OR. ( ( ::cAlbCliL )->dFecAlb >= dFecIni .AND. ( ::cAlbCliL )->dFecAlb <= dFecFin ) )   .AND. ( ( ( ::cAlbCliL )->nCtlStk < 2 )                                                                           .AND. ( Empty( cCodAlm ) .OR. ( ::cAlbCliL )->cAlmLin == cCodAlm ) )

            with object ( SStock():New() )
               :cAlias              := ( ::cAlbCliL )
               :cCodigo             := ( ::cAlbCliL )->cRef
               :cCodigoAlmacen      := ( ::cAlbCliL )->cAlmLin
               :cCodigoPropiedad1   := ( ::cAlbCliL )->cCodPr1
               :cCodigoPropiedad2   := ( ::cAlbCliL )->cCodPr2
               :cValorPropiedad1    := ( ::cAlbCliL )->cValPr1
               :cValorPropiedad2    := ( ::cAlbCliL )->cValPr2
               :cLote               := ( ::cAlbCliL )->cLote
               :dFechaCaducidad     := ( ::cAlbCliL )->dFecCad
               :nUnidades           := - nTotNAlbCli( ::cAlbCliL )
               ::Integra( hb_QWith(), lLote, lNumeroSerie )
            end

         end

         ( ::cAlbCliL )->( dbSkip() )

      end

   end





   SysRefresh()

   if ( ::cFacCliL )->( dbSeek( cCodArt ) )

      while ( ::cFacCliL )->cRef == cCodArt .AND. !( ::cFacCliL )->( Eof() )

         if !Empty( ( ::cFacCliL )->dFecAlb )
            dFecDoc                 := ( ::cFacCliL )->dFecAlb
         else
            dFecDoc                 := ( ::cFacCliL )->dFecFac
         end




         if ( Empty( ::dConsolidacion ) .OR. dFecDoc >= ::dConsolidacion )              .AND. ( Empty( dFecIni ) .OR. ( dFecDoc >= dFecIni .AND. dFecDoc <= dFecFin ) )   .AND. ( ( ( ::cFacCliL )->nCtlStk < 2 )                                           .AND. ( Empty( cCodAlm ) .OR. ( ::cFacCliL )->cAlmLin == cCodAlm ) )

            with object ( SStock():New() )
               :cAlias              := ( ::cFacCliL )
               :cCodigo             := ( ::cFacCliL )->cRef
               :cCodigoAlmacen      := ( ::cFacCliL )->cAlmLin
               :cCodigoPropiedad1   := ( ::cFacCliL )->cCodPr1
               :cCodigoPropiedad2   := ( ::cFacCliL )->cCodPr2
               :cValorPropiedad1    := ( ::cFacCliL )->cValPr1
               :cValorPropiedad2    := ( ::cFacCliL )->cValPr2
               :cLote               := ( ::cFacCliL )->cLote
               :dFechaCaducidad     := ( ::cFacCliL )->dFecCad
               :nUnidades           := - nTotNFacCli( ::cFacCliL )
               ::Integra( hb_QWith(), lLote, lNumeroSerie )
            end

         end

         ( ::cFacCliL )->( dbSkip() )

      end

   end





   SysRefresh()

   if ( ::cFacRecL )->( dbSeek( cCodArt ) )

      while ( ::cFacRecL )->cRef == cCodArt .AND. !( ::cFacRecL )->( Eof() )




         if ( Empty( ::dConsolidacion ) .OR. ( ::cFacRecL )->dFecFac >= ::dConsolidacion )                              .AND. ( Empty( dFecIni ) .OR. ( ( ::cFacRecL )->dFecFac >= dFecIni .AND. ( ::cFacRecL )->dFecFac <= dFecFin ) )   .AND. ( ( ( ::cFacRecL )->nCtlStk < 2 )                                                                           .AND. ( Empty( cCodAlm ) .OR. ( ::cFacRecL )->cAlmLin == cCodAlm ) )

            with object ( SStock():New() )
               :cAlias              := ( ::cFacRecL )
               :cCodigo             := ( ::cFacRecL )->cRef
               :cCodigoAlmacen      := ( ::cFacRecL )->cAlmLin
               :cCodigoPropiedad1   := ( ::cFacRecL )->cCodPr1
               :cCodigoPropiedad2   := ( ::cFacRecL )->cCodPr2
               :cValorPropiedad1    := ( ::cFacRecL )->cValPr1
               :cValorPropiedad2    := ( ::cFacRecL )->cValPr2
               :cLote               := ( ::cFacRecL )->cLote
               :nUnidades           := - nTotNFacRec( ::cFacRecL )
               ::Integra( hb_QWith(), lLote, lNumeroSerie )
            end

         end

         ( ::cFacRecL )->( dbSkip() )

      end

   end





   SysRefresh()

   if ( ::cTikL )->( dbSeek( cCodArt ) )

      while ( ::cTikL )->cCbaTil == cCodArt .AND. !( ::cTikL )->( Eof() )




         if ( Empty( ::dConsolidacion ) .OR. ( ::cTikL )->dFecTik >= ::dConsolidacion )                           .AND. ( Empty( dFecIni ) .OR. ( ( ::cTikL )->dFecTik >= dFecIni .AND. ( ::cTikL )->dFecTik <= dFecFin ) )   .AND. ( ( ( ::cTikL )->nCtlStk < 2 )                                                                        .AND. ( Empty( cCodAlm ) .OR. ( ::cTikL )->cAlmLin == cCodAlm ) )

            with object ( SStock():New() )
               :cAlias              := ( ::cTikL )
               :cCodigo             := ( ::cTikL )->cCbaTil
               :cCodigoAlmacen      := ( ::cTikL )->cAlmLin
               :cCodigoPropiedad1   := ( ::cTikL )->cCodPr1
               :cCodigoPropiedad2   := ( ::cTikL )->cCodPr2
               :cValorPropiedad1    := ( ::cTikL )->cValPr1
               :cValorPropiedad2    := ( ::cTikL )->cValPr2
               :cLote               := ( ::cTikL )->cLote
               if ( ( ::cTikL )->cTipTil == "1" .OR. ( ::cTikL )->cTipTil == "5" )
                  :nUnidades        := - nTotVTikTpv( ::cTikL )
               else
                  :nUnidades        := nTotVTikTpv( ::cTikL )
               end
               ::Integra( hb_QWith(), lLote, lNumeroSerie )
            end


         end

         ( ::cTikL )->( dbSkip() )

      end

   end





   SysRefresh()

   ( ::cTikL )->( dbGoTop() )

   nOrdAnt              := ( ::cTikL )->( OrdSetFocus( "cStkCom" ) )

   if ( ::cTikL )->( dbSeek( cCodArt ) )

      if !Empty( ( ::cTikL )->cComTil )

         while ( ::cTikL )->cComTil == cCodArt .AND. !( ::cTikL )->( Eof() )




            if ( Empty( ::dConsolidacion ) .OR. ( ::cTikL )->dFecTik >= ::dConsolidacion )                           .AND. ( Empty( dFecIni ) .OR. ( ( ::cTikL )->dFecTik >= dFecIni .AND. ( ::cTikL )->dFecTik <= dFecFin ) )   .AND. ( ( ( ::cTikL )->nCtlStk < 2 )                                                                        .AND. ( Empty( cCodAlm ) .OR. ( ::cTikL )->cAlmLin == cCodAlm ) )

               with object ( SStock():New() )
                  :cAlias              := ( ::cTikL )
                  :cCodigo             := ( ::cTikL )->cCbaTil
                  :cCodigoAlmacen      := ( ::cTikL )->cAlmLin
                  :cCodigoPropiedad1   := ( ::cTikL )->cCodPr1
                  :cCodigoPropiedad2   := ( ::cTikL )->cCodPr2
                  :cValorPropiedad1    := ( ::cTikL )->cValPr1
                  :cValorPropiedad2    := ( ::cTikL )->cValPr2
                  :cLote               := ( ::cTikL )->cLote
                  if ( ( ::cTikL )->cTipTil == "1" .OR. ( ::cTikL )->cTipTil == "5" )
                     :nUnidades        := - nTotVTikTpv( ::cTikL )
                  else
                     :nUnidades        := nTotVTikTpv( ::cTikL )
                  end
                  ::Integra( hb_QWith(), lLote, lNumeroSerie )
               end

            end

            ( ::cTikL )->( dbSkip() )

         end

      end

   end

   ( ::cTikL )->( OrdSetFocus( nOrdAnt ) )





   SysRefresh()

   if ( ::cProducL )->( dbSeek( cCodArt ) )

      while ( ::cProducL )->cCodArt == cCodArt .AND. !( ::cProducL )->( Eof() )



         if ( Empty( ::dConsolidacion ) .OR. ( ::cProducL )->dFecOrd >= ::dConsolidacion )                              .AND. ( Empty( dFecIni ) .OR. ( ( ::cProducL )->dFecOrd >= dFecIni .AND. ( ::cProducL )->dFecOrd <= dFecFin ) )   .AND. ( Empty( cCodAlm ) .OR. ( ::cProducL )->cAlmOrd == cCodAlm )

            with object ( SStock():New() )
               :cAlias              := ( ::cProducL )
               :cCodigo             := ( ::cProducL )->cCodArt
               :cCodigoAlmacen      := ( ::cProducL )->cAlmOrd
               :cCodigoPropiedad1   := ( ::cProducL )->cCodPr1
               :cCodigoPropiedad2   := ( ::cProducL )->cCodPr2
               :cValorPropiedad1    := ( ::cProducL )->cValPr1
               :cValorPropiedad2    := ( ::cProducL )->cValPr2
               :cLote               := ( ::cProducL )->cLote
               :nUnidades           := nTotNProduccion( ::cProducL )
               ::Integra( hb_QWith(), lLote, lNumeroSerie )
            end

         end

         ( ::cProducL )->( dbSkip() )

      end

   end





   SysRefresh()

   if ( ::cProducM )->( dbSeek( cCodArt ) )

      while ( ::cProducM )->cCodArt == cCodArt .AND. !( ::cProducM )->( Eof() )

         if !Empty( ::cProducT )
            ( ::cProducT )->( dbGoTop() )
            ( ::cProducT )->( dbSeek( ( ::cProducM )->cSerOrd + Str( ( ::cProducM )->nNumOrd ) + ( ::cProducM )->cSufOrd ) )
         end



         if ( Empty( ::dConsolidacion ) .OR. ( ::cProducM )->dFecOrd >= ::dConsolidacion )                              .AND. ( Empty( dFecIni ) .OR. ( ( ::cProducM )->dFecOrd >= dFecIni .AND. ( ::cProducM )->dFecOrd <= dFecFin ) )   .AND. ( Empty( cCodAlm ) .OR. ( ::cProducM )->cAlmOrd == cCodAlm )

            with object ( SStock():New() )
               :cAlias              := ( ::cProducM )
               :cCodigo             := ( ::cProducM )->cCodArt
               :cCodigoAlmacen      := ( ::cProducM )->cAlmOrd
               :cCodigoPropiedad1   := ( ::cProducM )->cCodPr1
               :cCodigoPropiedad2   := ( ::cProducM )->cCodPr2
               :cValorPropiedad1    := ( ::cProducM )->cValPr1
               :cValorPropiedad2    := ( ::cProducM )->cValPr2
               :cLote               := ( ::cProducM )->cLote
               :nUnidades           := - nTotNMaterial( ::cProducM )
               ::Integra( hb_QWith(), lLote, lNumeroSerie )
            end

         end

         ( ::cProducM )->( dbSkip() )

      end

   end

   if !lNotPendiente





      SysRefresh()

      ( ::cAlbPrvL )->( OrdSetFocus( "cPedRef" ) )

      if ( ::cPedPrvL )->( dbSeek( cCodArt ) )

         while ( ::cPedPrvL )->cRef == cCodArt .AND. !( ::cPedPrvL )->( Eof() )

            if Empty( cCodAlm ) .OR. ( ::cPedPrvL )->cAlmLin == cCodAlm

               if ( ::cAlbPrvL )->( dbSeek( ( ::cPedPrvL )->cSerPed + Str( ( ::cPedPrvL )->nNumPed ) + ( ::cPedPrvL )->cSufPed + cCodArt ) )

                  nTotal               := nTotNPedPrv( ::cPedPrvL )


                  while ( ::cPedPrvL )->cSerPed + Str( ( ::cPedPrvL )->nNumPed ) + ( ::cPedPrvL )->cSufPed + cCodArt == ( ::cAlbPrvL )->cCodPed + ( ::cAlbPrvL )->cRef .AND. !( ::cAlbPrvL )->( Eof() )

                     nTotal            -= nTotNAlbPrv( ::cAlbPrvL )

                     ( ::cAlbPrvL )->( dbSkip() )

                  end

               else

                  nTotal               := nTotNPedPrv( ::cPedPrvL )

               end

               with object ( SStock():New() )
                  :cCodigo             := ( ::cPedPrvL )->cRef
                  :cCodigoAlmacen      := ( ::cPedPrvL )->cAlmLin
                  :cCodigoPropiedad1   := ( ::cPedPrvL )->cCodPr1
                  :cCodigoPropiedad2   := ( ::cPedPrvL )->cCodPr2
                  :cValorPropiedad1    := ( ::cPedPrvL )->cValPr1
                  :cValorPropiedad2    := ( ::cPedPrvL )->cValPr2
                  :cLote               := ( ::cPedPrvL )->cLote
                  :nPendientesRecibir  := if( nTotal > 0, nTotal, 0 )
                  ::Integra( hb_QWith(), lLote, lNumeroSerie )
               end

            end

            ( ::cPedPrvL )->( dbSkip() )

         end

      end





      SysRefresh()

      ( ::cAlbCliL )->( OrdSetFocus( "cPedRef" ) )
      ( ::cFacCliL )->( OrdSetFocus( "cNumPedRef" ) )

      if ( ::cPedCliL )->( dbSeek( cCodArt ) )

         while ( ::cPedCliL )->cRef == cCodArt .AND. !( ::cPedCliL )->( Eof() )

            if Empty( cCodAlm ) .OR. ( ::cPedCliL )->cAlmLin == cCodAlm

               if ( ::cAlbCliL )->( dbSeek( ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed + cCodArt ) )

                  nTotal               := nTotNPedCli( ::cPedCliL )


                  while ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed + cCodArt == ( ::cAlbCliL )->cNumPed + ( ::cAlbCliL )->cRef .AND. !( ::cAlbCliL )->( Eof() )

                     nTotal            -= nTotNAlbCli( ::cAlbCliL )

                     ( ::cAlbCliL )->( dbSkip() )

                  end

               elseif ( ::cFacCliL )->( dbSeek( ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed + cCodArt ) )

                  nTotal               := nTotNPedCli( ::cPedCliL )


                  while ( ::cPedCliL )->cSerPed + Str( ( ::cPedCliL )->nNumPed ) + ( ::cPedCliL )->cSufPed + cCodArt == ( ::cFacCliL )->cNumPed + ( ::cFacCliL )->cRef .AND. !( ::cFacCliL )->( Eof() )

                     nTotal            -= nTotNFacCli( ::cFacCliL )

                     ( ::cFacCliL )->( dbSkip() )

                  end

               else

                  nTotal               := nTotNPedCli( ::cPedCliL )

               end

               with object ( SStock():New() )
                  :cCodigo             := ( ::cPedCliL )->cRef
                  :cCodigoAlmacen      := ( ::cPedCliL )->cAlmLin
                  :cCodigoPropiedad1   := ( ::cPedCliL )->cCodPr1
                  :cCodigoPropiedad2   := ( ::cPedCliL )->cCodPr2
                  :cValorPropiedad1    := ( ::cPedCliL )->cValPr1
                  :cValorPropiedad2    := ( ::cPedCliL )->cValPr2
                  :cLote               := ( ::cPedCliL )->cLote
                  :nPendientesEntregar := if( nTotal > 0, nTotal, 0 )
                  ::Integra( hb_QWith(), lLote, lNumeroSerie )
               end

               ( ::cPedCliL )->( dbSkip() )

            end

         end

      end

   end





   ( ::cPedPrvL )->( OrdSetFocus( nOrdPedPrvL ) )
   ( ::cAlbPrvL )->( OrdSetFocus( nOrdAlbPrvL ) )
   ( ::cFacPrvL )->( OrdSetFocus( nOrdFacPrvL ) )
   ( ::cRctPrvL )->( OrdSetFocus( nOrdRctPrvL ) )
   ( ::cPedCliL )->( OrdSetFocus( nOrdPedCliL ) )
   ( ::cAlbCliL )->( OrdSetFocus( nOrdAlbCliL ) )
   ( ::cFacCliL )->( OrdSetFocus( nOrdFacCliL ) )
   ( ::cFacRecL )->( OrdSetFocus( nOrdFacRecL ) )
   ( ::cTikL    )->( OrdSetFocus( nOrdTikCliL ) )
   ( ::cProducL )->( OrdSetFocus( nOrdProducL ) )
   ( ::cProducM )->( OrdSetFocus( nOrdProducM ) )
   ( ::cHisMov  )->( OrdSetFocus( nOrdHisMov  ) )





   if Empty( ::aStocks )
      ::aStocks                     := { sStock():New() }
   end





   if !Empty( ::tmpAlbCliL )

      nRec                          := ( ::tmpAlbCliL )->( Recno() )

      ( ::tmpAlbCliL )->( dbGoTop() )
      while !( ::tmpAlbCliL )->( Eof() )

         if ( ( ::tmpAlbCliL )->cRef == cCodArt ) .AND. ( Empty( cCodAlm ) .OR. ( ::tmpAlbCliL )->cAlmLin == cCodAlm )

            with object ( SStock():New() )
               :cCodigo             := ( ::tmpAlbCliL )->cRef
               :cCodigoAlmacen      := ( ::tmpAlbCliL )->cAlmLin
               :cCodigoPropiedad1   := ( ::tmpAlbCliL )->cCodPr1
               :cCodigoPropiedad2   := ( ::tmpAlbCliL )->cCodPr2
               :cValorPropiedad1    := ( ::tmpAlbCliL )->cValPr1
               :cValorPropiedad2    := ( ::tmpAlbCliL )->cValPr2
               :cLote               := ( ::tmpAlbCliL )->cLote
               :nUnidades           := - nTotNAlbCli( ::tmpAlbCliL )
               ::Integra( hb_QWith(), lLote, lNumeroSerie )
            end

         end

         ( ::tmpAlbCliL )->( dbSkip() )

      end

      ( ::tmpAlbCliL )->( dbGoTo( nRec ) )

   end





   if !Empty( ::tmpFacCliL )

      nRec                          := ( ::tmpFacCliL )->( Recno() )

      ( ::tmpFacCliL )->( dbGoTop() )
      while !( ::tmpFacCliL )->( Eof() )

         if ( ( ::tmpFacCliL )->cRef == cCodArt ) .AND. ( Empty( cCodAlm ) .OR. ( ::tmpFacCliL )->cAlmLin == cCodAlm )

            with object ( SStock():New() )
               :cCodigo             := ( ::tmpFacCliL )->cRef
               :cCodigoAlmacen      := ( ::tmpFacCliL )->cAlmLin
               :cCodigoPropiedad1   := ( ::tmpFacCliL )->cCodPr1
               :cCodigoPropiedad2   := ( ::tmpFacCliL )->cCodPr2
               :cValorPropiedad1    := ( ::tmpFacCliL )->cValPr1
               :cValorPropiedad2    := ( ::tmpFacCliL )->cValPr2
               :cLote               := ( ::tmpFacCliL )->cLote
               :nUnidades           := - nTotNFacCli( ::tmpFacCliL )
               ::Integra( hb_QWith(), lLote, lNumeroSerie )
            end

         end

         ( ::tmpFacCliL )->( dbSkip() )

      end

      ( ::tmpFacCliL )->( dbGoTo( nRec ) )

   end





   for each cSerie in ::aSeries
      aScan( ::aStocks, {|o| if( o:cNumeroSerie == cSerie, o:nUnidades -= 1, ) } )
   next





   if !Empty( oBrw )

      SysRefresh()

      oBrw:aArrayData               := {}

      for each oStocks in ::aStocks

         if !Empty( oStocks ) .AND. ( ( Round( oStocks:nUnidades, 6 ) <> 0.000000 ) .OR. ( Round( oStocks:nPendientesRecibir, 6 ) <> 0.000000 ) .OR. ( Round( oStocks:nPendientesEntregar, 6 ) <> 0.000000 ) )
            aAdd( oBrw:aArrayData, oStocks )
         end
      next

      oBrw:Refresh()

   end

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Calculo de stock" )

   end

   ErrorBlock( oBlock )

return ( ::aStocks )



UTILITY STATIC function TStock_nStockArticulo( cCodArt, cCodAlm, oBrw, lLote, lNumeroSerie, dFecIni, dFecFin) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nStockArticulo := 0

   ::aStockArticulo( cCodArt, cCodAlm, oBrw, lLote, lNumeroSerie, dFecIni, dFecFin )

   aEval( ::aStocks, {|o| nStockArticulo += o:nUnidades } )

Return ( nStockArticulo )



UTILITY STATIC function TStock_nStockSerie( cCodArt, cCodAlm, cNumeroSerie) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nRec
   local nUnidades      := 0
   local nOrdHisMov     := ( ::cHisMov  )->( OrdSetFocus( "cRefMov" ) )
   local nOrdAlbPrvS    := ( ::cAlbPrvS )->( OrdSetFocus( "cRefSer" ) )
   local nOrdFacPrvS    := ( ::cFacPrvS )->( OrdSetFocus( "cRefSer" ) )
   local nOrdRctPrvS    := ( ::cRctPrvS )->( OrdSetFocus( "cRefSer" ) )
   local nOrdAlbCliS    := ( ::cAlbCliS )->( OrdSetFocus( "cRefSer" ) )
   local nOrdFacCliS    := ( ::cFacCliS )->( OrdSetFocus( "cRefSer" ) )
   local nOrdFacRecS    := ( ::cFacRecS )->( OrdSetFocus( "cRefSer" ) )
   local nOrdTikCliS    := ( ::cTikS    )->( OrdSetFocus( "cRefSer" ) )
   local nOrdProducS    := ( ::cProducS )->( OrdSetFocus( "cCodArt" ) )
   local nOrdProducP    := ( ::cProducP )->( OrdSetFocus( "cCodArt" ) )
   local nOrdHisMovS    := ( ::cHisMovS )->( OrdSetFocus( "cCodArt" ) )

   if !Empty( cNumeroSerie )

      ::GetConsolidacion( cCodArt )





      if ( ::cHisMovS )->( dbSeek( cCodArt + cCodAlm + cNumeroSerie ) )

         while ( ::cHisMovS )->cCodArt == cCodArt .AND. ( ::cHisMovS )->cAlmOrd == cCodAlm .AND. ( ::cHisMovS )->cNumSer == cNumeroSerie .AND. !( ::cHisMovS )->( Eof() )

            if ( Empty( ::dConsolidacion ) .OR. ( ::cHisMovS )->dFecRem >= ::dConsolidacion )

               if ( ::cHisMovS )->lUndNeg
                  nUnidades--
               else
                  nUnidades++
               end

            end

            ( ::cHisMovS )->( dbSkip() )

         end

      end





      if ( ::cAlbPrvS )->( dbSeek( cCodArt + cCodAlm + cNumeroSerie ) )

         while ( ::cAlbPrvS )->cRef == cCodArt .AND. ( ::cAlbPrvS )->cAlmLin == cCodAlm .AND. ( ::cAlbPrvS )->cNumSer == cNumeroSerie .AND. !( ::cAlbPrvS )->( Eof() )

            if ( Empty( ::dConsolidacion ) .OR. ( ::cAlbPrvS )->dFecAlb >= ::dConsolidacion )

               if ( ::cAlbPrvS )->lUndNeg
                  nUnidades--
               else
                  nUnidades++
               end

            end

            ( ::cAlbPrvS )->( dbSkip() )

         end

      end





      if ( ::cFacPrvS )->( dbSeek( cCodArt + cCodAlm + cNumeroSerie ) )

         while ( ::cFacPrvS )->cRef == cCodArt .AND. ( ::cFacPrvS )->cAlmLin == cCodAlm .AND. ( ::cFacPrvS )->cNumSer == cNumeroSerie .AND. !( ::cFacPrvS )->( Eof() )

            if ( Empty( ::dConsolidacion ) .OR. ( ::cFacPrvS )->dFecFac >= ::dConsolidacion )

               if ( ::cFacPrvS )->lUndNeg
                  nUnidades--
               else
                  nUnidades++
               end

            end

            ( ::cFacPrvS )->( dbSkip() )

         end

      end





      if ( ::cRctPrvS )->( dbSeek( cCodArt + cCodAlm + cNumeroSerie ) )

         while ( ::cRctPrvS )->cRef == cCodArt .AND. ( ::cRctPrvS )->cAlmLin == cCodAlm .AND. ( ::cRctPrvS )->cNumSer == cNumeroSerie .AND. !( ::cRctPrvS )->( Eof() )

            if ( Empty( ::dConsolidacion ) .OR. ( ::cFacPrvS )->dFecFac >= ::dConsolidacion )

               if ( ::cRctPrvS )->lUndNeg
                  nUnidades--
               else
                  nUnidades++
               end

            end

            ( ::cRctPrvS )->( dbSkip() )

         end

      end





      if ( ::cAlbCliS )->( dbSeek( cCodArt + cCodAlm + cNumeroSerie ) )

         while ( ::cAlbCliS )->cRef == cCodArt .AND. ( ::cAlbCliS )->cAlmLin == cCodAlm .AND. ( ::cAlbCliS )->cNumSer == cNumeroSerie .AND. !( ::cAlbCliS )->( Eof() )

            if ( Empty( ::dConsolidacion ) .OR. ( ::cAlbCliS )->dFecAlb >= ::dConsolidacion )

               if ( ::cAlbCliS )->lUndNeg
                  nUnidades++
               else
                  nUnidades--
               end

            end

            ( ::cAlbCliS )->( dbSkip() )

         end

      end





      if ( ::cFacCliS )->( dbSeek( cCodArt + cCodAlm + cNumeroSerie ) )

         while ( ::cFacCliS )->cRef == cCodArt .AND. ( ::cFacCliS )->cAlmLin == cCodAlm .AND. ( ::cFacCliS )->cNumSer == cNumeroSerie .AND. !( ::cFacCliS )->( Eof() )

            if ( Empty( ::dConsolidacion ) .OR. ( ::cFacCliS )->dFecFac >= ::dConsolidacion )

               if ( ::cFacCliS )->lUndNeg
                  nUnidades++
               else
                  nUnidades--
               end

            end

            ( ::cFacCliS )->( dbSkip() )

         end

      end





      if ( ::cFacRecS )->( dbSeek( cCodArt + cCodAlm + cNumeroSerie ) )

         while ( ::cFacRecS )->cRef == cCodArt .AND. ( ::cFacRecS )->cAlmLin == cCodAlm .AND. ( ::cFacRecS )->cNumSer == cNumeroSerie .AND. !( ::cFacRecS )->( Eof() )

            if ( Empty( ::dConsolidacion ) .OR. ( ::cFacRecS )->dFecFac >= ::dConsolidacion )

               if ( ::cFacRecS )->lUndNeg
                  nUnidades++
               else
                  nUnidades--
               end

            end

            ( ::cFacRecS )->( dbSkip() )

         end

      end





      if ( ::cTikS )->( dbSeek( cCodArt + cCodAlm + cNumeroSerie ) )

         while ( ::cTikS )->cCbaTil == cCodArt .AND. ( ::cTikS )->cAlmLin == cCodAlm .AND. ( ::cTikS )->cNumSer == cNumeroSerie .AND. !( ::cTikS )->( Eof() )

            if ( Empty( ::dConsolidacion ) .OR. ( ::cTikS )->dFecTik >= ::dConsolidacion )

               if ( ::cTikS )->lUndNeg
                  nUnidades++
               else
                  nUnidades--
               end

            end

            ( ::cTikS )->( dbSkip() )

         end

      end





      if ( ::cProducS )->( dbSeek( cCodArt + cCodAlm + cNumeroSerie ) )

         while ( ::cProducS )->cCodArt == cCodArt .AND. ( ::cProducS )->cAlmOrd == cCodAlm .AND. ( ::cProducS )->cNumSer == cNumeroSerie .AND. !( ::cProducS )->( Eof() )

            if ( Empty( ::dConsolidacion ) .OR. ( ::cProducS )->dFecOrd >= ::dConsolidacion )

               if ( ::cProducS )->lUndNeg
                  nUnidades--
               else
                  nUnidades++
               end

            end

            ( ::cProducS )->( dbSkip() )

         end

      end





      if ( ::cProducP )->( dbSeek( cCodArt + cCodAlm + cNumeroSerie ) )

         while ( ::cProducP )->cCodArt == cCodArt .AND. ( ::cProducP )->cAlmOrd == cCodAlm .AND. ( ::cProducP )->cNumSer == cNumeroSerie .AND. !( ::cProducP )->( Eof() )

            if ( Empty( ::dConsolidacion ) .OR. ( ::cProducP )->dFecOrd >= ::dConsolidacion )

               if ( ::cProducP )->lUndNeg
                  nUnidades++
               else
                  nUnidades--
               end

            end

            ( ::cProducP )->( dbSkip() )

         end

      end

   end





   ( ::cHisMov  )->( OrdSetFocus( nOrdHisMov  ) )
   ( ::cAlbPrvS )->( OrdSetFocus( nOrdAlbPrvS ) )
   ( ::cFacPrvS )->( OrdSetFocus( nOrdFacPrvS ) )
   ( ::cRctPrvS )->( OrdSetFocus( nOrdRctPrvS ) )
   ( ::cAlbCliS )->( OrdSetFocus( nOrdAlbCliS ) )
   ( ::cFacCliS )->( OrdSetFocus( nOrdFacCliS ) )
   ( ::cFacRecS )->( OrdSetFocus( nOrdFacRecs ) )
   ( ::cTikS    )->( OrdSetFocus( nOrdTikCliS ) )
   ( ::cProducS )->( OrdSetFocus( nOrdProducS ) )
   ( ::cProducP )->( OrdSetFocus( nOrdProducP ) )
   ( ::cHisMovS )->( OrdSetFocus( nOrdHisMovS ) )

return ( nUnidades )








UTILITY STATIC function TStock_aStockAlmacen( oRemMov) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local cCodAlm
   local nOrdAnt
   local nOrdArt        := ( ::cArt     )->( OrdSetFocus( "Codigo"   ) )
   local nOrdAlbPrvL    := ( ::cAlbPrvL )->( OrdSetFocus( "cStkFast" ) )
   local nOrdFacPrvL    := ( ::cFacPrvL )->( OrdSetFocus( "cRef"     ) )
   local nOrdRctPrvL    := ( ::cRctPrvL )->( OrdSetFocus( "cRef"     ) )
   local nOrdAlbCliL    := ( ::cAlbCliL )->( OrdSetFocus( "cStkFast" ) )
   local nOrdFacCliL    := ( ::cFacCliL )->( OrdSetFocus( "cRef"     ) )
   local nOrdFacRecL    := ( ::cFacRecL )->( OrdSetFocus( "cRef"     ) )
   local nOrdTikCliL    := ( ::cTikL    )->( OrdSetFocus( "cStkFast" ) )
   local nOrdProducL    := ( ::cProducL )->( OrdSetFocus( "cCodArt"  ) )
   local nOrdProducM    := ( ::cProducM )->( OrdSetFocus( "cCodArt"  ) )
   local nOrdHisMov     := ( ::cHisMov  )->( OrdSetFocus( "cRefMov"  ) )

   cCodAlm              := oRemMov:oDbf:cAlmDes

   ( ::cArt )->( dbGoTop() )
   while !( ::cArt )->( eof() )



   if ( oRemMov:lFamilia      .OR. ( ( ::cArt )->Familia >= oRemMov:cFamiliaInicio        .AND. ( ::cArt )->Familia <= oRemMov:cFamiliaFin ) )      .AND. ( oRemMov:lTipoArticulo .OR. ( ( ::cArt )->cCodTip >= oRemMov:cTipoArticuloInicio   .AND. ( ::cArt )->cCodTip <= oRemMov:cTipoArticuloFin ) ) .AND. ( oRemMov:lArticulo     .OR. ( ( ::cArt )->Codigo >= oRemMov:cArticuloInicio        .AND. ( ::cArt )->Codigo <= oRemMov:cArticuloFin ) )





         if ( ::cAlbPrvL )->( dbSeek( ( ::cArt )->Codigo ) )

            while ( ::cAlbPrvL )->cRef == ( ::cArt )->Codigo .AND. !( ::cAlbPrvL )->( Eof() )


               if ( ::cAlbPrvL )->nCtlStk < 2            .AND. ( ::cAlbPrvL )->cAlmLin == cCodAlm

                  with object ( SStock():New() )
                     :cCodigo             := ( ::cAlbPrvL )->cRef
                     :cCodigoPropiedad1   := ( ::cAlbPrvL )->cCodPr1
                     :cCodigoPropiedad2   := ( ::cAlbPrvL )->cCodPr2
                     :cValorPropiedad1    := ( ::cAlbPrvL )->cValPr1
                     :cValorPropiedad2    := ( ::cAlbPrvL )->cValPr2
                     :cLote               := ( ::cAlbPrvL )->cLote
                     :nUnidades           := nTotNAlbPrv( ::cAlbPrvL )
                     ::Integra( hb_QWith() )
                  end

               end

               ( ::cAlbPrvL )->( dbSkip() )

            end

         end





         SysRefresh()

         if ( ::cFacPrvL )->( dbSeek( ( ::cArt )->Codigo ) )

            while ( ::cFacPrvL )->cRef == ( ::cArt )->Codigo .AND. !( ::cFacPrvL )->( Eof() )


               if ( ::cFacPrvL )->nCtlStk < 2            .AND. ( ::cFacPrvL )->cAlmLin == cCodAlm

                  with object ( SStock():New() )
                     :cCodigo             := ( ::cFacPrvL )->cRef
                     :cCodigoPropiedad1   := ( ::cFacPrvL )->cCodPr1
                     :cCodigoPropiedad2   := ( ::cFacPrvL )->cCodPr2
                     :cValorPropiedad1    := ( ::cFacPrvL )->cValPr1
                     :cValorPropiedad2    := ( ::cFacPrvL )->cValPr2
                     :cLote               := ( ::cFacPrvL )->cLote
                     :nUnidades           := nTotNFacPrv( ::cFacPrvL )
                     ::Integra( hb_QWith() )
                  end

               end

               ( ::cFacPrvL )->( dbSkip() )

            end

         end





         SysRefresh()

         if ( ::cRctPrvL )->( dbSeek( ( ::cArt )->Codigo ) )

            while ( ::cRctPrvL )->cRef == ( ::cArt )->Codigo .AND. !( ::cRctPrvL )->( Eof() )


               if ( ::cRctPrvL )->nCtlStk < 2            .AND. ( ::cRctPrvL )->cAlmLin == cCodAlm

                  with object ( SStock():New() )
                     :cCodigo             := ( ::cRctPrvL )->cRef
                     :cCodigoPropiedad1   := ( ::cRctPrvL )->cCodPr1
                     :cCodigoPropiedad2   := ( ::cRctPrvL )->cCodPr2
                     :cValorPropiedad1    := ( ::cRctPrvL )->cValPr1
                     :cValorPropiedad2    := ( ::cRctPrvL )->cValPr2
                     :cLote               := ( ::cRctPrvL )->cLote
                     :nUnidades           := nTotNRctPrv( ::cRctPrvL )
                     ::Integra( hb_QWith() )
                  end

               end

               ( ::cRctPrvL )->( dbSkip() )

            end

         end





         SysRefresh()

         if ( ::cAlbCliL )->( dbSeek( ( ::cArt )->Codigo ) )

            while ( ::cAlbCliL )->cRef == ( ::cArt )->Codigo .AND. !( ::cAlbCliL )->( Eof() )


               if ( ::cAlbCliL )->nCtlStk < 2            .AND. ( ::cAlbCliL )->cAlmLin == cCodAlm

                  with object ( SStock():New() )
                     :cCodigo             := ( ::cAlbCliL )->cRef
                     :cCodigoPropiedad1   := ( ::cAlbPrvL )->cCodPr1
                     :cCodigoPropiedad2   := ( ::cAlbPrvL )->cCodPr2
                     :cValorPropiedad1    := ( ::cAlbCliL )->cValPr1
                     :cValorPropiedad2    := ( ::cAlbCliL )->cValPr2
                     :cLote               := ( ::cAlbCliL )->cLote
                     :nUnidades           := - nTotVAlbCli( ::cAlbCliL )
                     ::Integra( hb_QWith() )
                  end

               end

               ( ::cAlbCliL )->( dbSkip() )

            end

         end





         SysRefresh()

         if ( ::cFacCliL )->( dbSeek( ( ::cArt )->Codigo ) )

            while ( ::cFacCliL )->cRef == ( ::cArt )->Codigo .AND. !( ::cFacCliL )->( Eof() )


               if ( ::cFacCliL )->nCtlStk < 2            .AND. ( ::cFacCliL )->cAlmLin == cCodAlm

                  with object ( SStock():New() )
                     :cCodigo             := ( ::cFacCliL )->cRef
                     :cCodigoPropiedad1   := ( ::cFacCliL )->cCodPr1
                     :cCodigoPropiedad2   := ( ::cFacCliL )->cCodPr2
                     :cValorPropiedad1    := ( ::cFacCliL )->cValPr1
                     :cValorPropiedad2    := ( ::cFacCliL )->cValPr2
                     :cLote               := ( ::cFacCliL )->cLote
                     :nUnidades           := - nTotVFacCli( ::cFacCliL )
                     ::Integra( hb_QWith() )
                  end

               end

               ( ::cFacCliL )->( dbSkip() )

            end

         end





         SysRefresh()

         if ( ::cFacRecL )->( dbSeek( ( ::cArt )->Codigo ) )

            while ( ::cFacRecL )->cRef == ( ::cArt )->Codigo .AND. !( ::cFacRecL )->( Eof() )


               if ( ::cFacRecL )->nCtlStk < 2            .AND. ( ::cFacRecL )->cAlmLin == cCodAlm

                  with object ( SStock():New() )
                     :cCodigo             := ( ::cFacRecL )->cRef
                     :cCodigoPropiedad1   := ( ::cFacRecL )->cCodPr1
                     :cCodigoPropiedad2   := ( ::cFacRecL )->cCodPr2
                     :cValorPropiedad1    := ( ::cFacRecL )->cValPr1
                     :cValorPropiedad2    := ( ::cFacRecL )->cValPr2
                     :cLote               := ( ::cFacRecL )->cLote
                     :nUnidades           := - nTotVFacRec( ::cFacRecL )
                     ::Integra( hb_QWith() )
                  end

               end

               ( ::cFacRecL )->( dbSkip() )

            end

         end





         SysRefresh()

         if ( ::cTikL )->( dbSeek( ( ::cArt )->Codigo ) )

            while ( ::cTikL )->cCbaTil == ( ::cArt )->Codigo .AND. !( ::cTikL )->( Eof() )


               if ( ::cTikL )->nCtlStk < 2            .AND. ( ::cTikL )->cAlmLin == cCodAlm

                  if ( ::cTikL )->cTipTil == "1" .OR. ( ::cTikL )->cTipTil == "5"

                     with object ( SStock():New() )
                        :cCodigo             := ( ::cTikL )->cCbaTil
                        :cCodigoPropiedad1   := ( ::cTikL )->cCodPr1
                        :cCodigoPropiedad2   := ( ::cTikL )->cCodPr2
                        :cValorPropiedad1    := ( ::cTikL )->cValPr1
                        :cValorPropiedad2    := ( ::cTikL )->cValPr2
                        :cLote               := ( ::cTikL )->cLote
                        :nUnidades           := - nTotVTikTpv( ::cTikL )
                        ::Integra( hb_QWith() )
                     end

                  else

                     with object ( SStock():New() )
                        :cCodigo             := ( ::cTikL )->cCbaTil
                        :cCodigoPropiedad1   := ( ::cTikL )->cCodPr1
                        :cCodigoPropiedad2   := ( ::cTikL )->cCodPr2
                        :cValorPropiedad1    := ( ::cTikL )->cValPr1
                        :cValorPropiedad2    := ( ::cTikL )->cValPr2
                        :cLote               := ( ::cTikL )->cLote
                        :nUnidades           := nTotVTikTpv( ::cTikL )
                        ::Integra( hb_QWith() )
                     end

                  end

               end

               ( ::cTikL )->( dbSkip() )

            end

         end





         SysRefresh()

         ( ::cTikL )->( dbGoTop() )

         nOrdAnt              := ( ::cTikL )->( OrdSetFocus( "CSTKCOM" ) )

         if ( ::cTikL )->( dbSeek( ( ::cArt )->Codigo ) )

            if !Empty( ( ::cTikL )->cComTil )

               while ( ::cTikL )->cComTil == ( ::cArt )->Codigo .AND. !( ::cTikL )->( Eof() )


                  if ( ::cTikL )->nCtlStk < 2            .AND. ( ::cTikL )->cAlmLim == cCodAlm

                     with object ( SStock():New() )
                        :cCodigo             := ( ::cTikL )->cCbaTil
                        :cCodigoPropiedad1   := ( ::cTikL )->cCodPr1
                        :cCodigoPropiedad2   := ( ::cTikL )->cCodPr2
                        :cValorPropiedad1    := ( ::cTikL )->cValPr1
                        :cValorPropiedad2    := ( ::cTikL )->cValPr2
                        :cLote               := ( ::cTikL )->cLote
                        :nUnidades           := - nTotVTikTpv( ::cTikL )
                        ::Integra( hb_QWith() )
                     end

                  end

                  ( ::cTikL )->( dbSkip() )

               end

            end

         end

         ( ::cTikL )->( OrdSetFocus( nOrdAnt ) )





         SysRefresh()

         if ( ::cProducL )->( dbSeek( ( ::cArt )->Codigo ) )

            while ( ::cProducL )->cCodArt == ( ::cArt )->Codigo .AND. !( ::cProducL )->( Eof() )

               if ( ::cProducL )->cAlmOrd == cCodAlm

                  with object ( SStock():New() )
                     :cCodigo             := ( ::cProducL )->cCodArt
                     :cCodigoPropiedad1   := ( ::cProducL )->cCodPr1
                     :cCodigoPropiedad2   := ( ::cProducL )->cCodPr2
                     :cValorPropiedad1    := ( ::cProducL )->cValPr1
                     :cValorPropiedad2    := ( ::cProducL )->cValPr2
                     :cLote               := ( ::cProducL )->cLote
                     :nUnidades           := nTotNProduccion( ::cProducL )
                     ::Integra( hb_QWith() )
                  end

               end

               ( ::cProducL )->( dbSkip() )

            end

         end





         SysRefresh()

         if ( ::cProducM )->( dbSeek( ( ::cArt )->Codigo ) )

            while ( ::cProducM )->cCodArt == ( ::cArt )->Codigo .AND. !( ::cProducM )->( Eof() )

               if ( ::cProducM )->cAlmOrd == cCodAlm

                  with object ( SStock():New() )
                     :cCodigo             := ( ::cProducM )->cCodArt
                     :cCodigoPropiedad1   := ( ::cProducM )->cCodPr1
                     :cCodigoPropiedad2   := ( ::cProducM )->cCodPr2
                     :cValorPropiedad1    := ( ::cProducM )->cValPr1
                     :cValorPropiedad2    := ( ::cProducM )->cValPr2
                     :cLote               := ( ::cProducM )->cLote
                     :nUnidades           := - nTotNMaterial( ::cProducM )
                     ::Integra( hb_QWith() )
                  end

               end

               ( ::cProducM )->( dbSkip() )

            end

         end





         SysRefresh()

         if ( ::cHisMov )->( dbSeek( ( ::cArt )->Codigo ) )

            while ( ::cHisMov )->cRefMov == ( ::cArt )->Codigo .AND. !( ::cHisMov )->( Eof() )

               if !Empty( ( ::cHisMov )->cAliMov ) .AND. ( ::cHisMov )->cAliMov == cCodAlm

                  with object ( SStock():New() )
                     :cCodigo             := ( ::cHisMov )->cRefMov
                     :cCodigoPropiedad1   := ( ::cHisMov )->cCodPr1
                     :cCodigoPropiedad2   := ( ::cHisMov )->cCodPr2
                     :cValorPropiedad1    := ( ::cHisMov )->cValPr1
                     :cValorPropiedad2    := ( ::cHisMov )->cValPr2
                     :cLote               := ( ::cHisMov )->cLote
                     :nUnidades           := nTotNMovAlm( ::cHisMov )
                     ::Integra( hb_QWith() )
                  end

               end

               if !Empty( ( ::cHisMov )->cAloMov ) .AND. ( ::cHisMov )->cAloMov == cCodAlm

                  with object ( SStock():New() )
                     :cCodigo             := ( ::cHisMov )->cRefMov
                     :cCodigoPropiedad1   := ( ::cHisMov )->cCodPr1
                     :cCodigoPropiedad2   := ( ::cHisMov )->cCodPr2
                     :cValorPropiedad1    := ( ::cHisMov )->cValPr1
                     :cValorPropiedad2    := ( ::cHisMov )->cValPr2
                     :cLote               := ( ::cHisMov )->cLote
                     :nUnidades           := - nTotNMovAlm( ::cHisMov )
                     ::Integra( hb_QWith() )
                  end

               end

               ( ::cHisMov )->( dbSkip() )

            end

         end

      end

      ( ::cArt )->( dbSkip() )

      oRemMov:oMtrStock:AutoInc()

   end





   ( ::cArt     )->( OrdSetFocus( nOrdArt     ) )
   ( ::cAlbPrvL )->( OrdSetFocus( nOrdAlbPrvL ) )
   ( ::cFacPrvL )->( OrdSetFocus( nOrdFacPrvL ) )
   ( ::cRctPrvL )->( OrdSetFocus( nOrdRctPrvL ) )
   ( ::cAlbCliL )->( OrdSetFocus( nOrdAlbCliL ) )
   ( ::cFacCliL )->( OrdSetFocus( nOrdFacCliL ) )
   ( ::cFacRecL )->( OrdSetFocus( nOrdFacRecL ) )
   ( ::cTikL    )->( OrdSetFocus( nOrdTikCliL ) )
   ( ::cProducL )->( OrdSetFocus( nOrdProducL ) )
   ( ::cProducM )->( OrdSetFocus( nOrdProducM ) )
   ( ::cHisMov  )->( OrdSetFocus( nOrdHisMov  ) )

return ( ::aStocks )



UTILITY STATIC function TStock_Integra( sStocks, lLote, lNumeroSerie) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nPos
   local cNumeroSerie
   local aNumeroSerie

   IIF( lLote == nil, lLote := .T., ) ;
   IIF( lNumeroSerie == nil, lNumeroSerie := .T., ) ;






























      nPos              := aScan( ::aStocks, {|o| o:cCodigo == sStocks:cCodigo .AND. o:cCodigoAlmacen == sStocks:cCodigoAlmacen .AND. o:cValorPropiedad1 == sStocks:cValorPropiedad1 .AND. o:cValorPropiedad2 == sStocks:cValorPropiedad2 .AND. if( lLote, o:cLote == sStocks:cLote, .T. ) .AND. if( lNumeroSerie, o:cNumeroSerie == sStocks:cNumeroSerie, .T. ) } )
      if nPos <> 0
         ::aStocks[ nPos ]:nUnidades               += sStocks:nUnidades
         ::aStocks[ nPos ]:nPendientesRecibir      += sStocks:nPendientesRecibir
         ::aStocks[ nPos ]:nPendientesEntregar     += sStocks:nPendientesEntregar
      else
         aAdd( ::aStocks, oClone( sStocks ) )
      end





Return ( nil )



UTILITY STATIC function TStock_lValidNumeroSerie( cCodArt, cCodAlm, uNumSer, lMessage) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local lValid         := .F.

   IIF( lMessage == nil, lMessage := .T., ) ;

   if !Empty( uNumSer )
      lValid            := ( ::nStockSerie( cCodArt, cCodAlm, uNumSer ) > 0 )
   end

return ( lValid )



UTILITY STATIC function TStock_BrowseNumeroSerie( oCol, cCodArt, cCodAlm, aNumSer, oBrwSer) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local oDlg
   local oGet
   local cGet
    local oBrw
   local uRet              := ""
   local oBrwCol
   local aStocks

   IIF( aNumSer == nil, aNumSer := {}, ) ;

   ::aSeries               := aNumSer

   oDlg = TDialog():New(,,,, "Seleccionar número de serie", "BrowseNumeroSerie",, .F.,,,,,, .F.,,,,,, .F., )





      oGet := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet, cGet:= u ) }, oDlg,,,,,,,,, .F.,, {|nKey,nFlags,Self| ( SeekOnStock( cGet, oBrw ) ) }, .F., .F.,,,,,, nil,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:SetArray( ::aStocks, , , .F. )

      oBrw:nMarqueeStyle   := 5
      oBrw:lRecordSelector := .F.
      oBrw:lHScroll        := .F.
      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }
      oBrw:cName           := "Browse.NumSer"
      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }

      oBrw:CreateFromResource( 105 )

      with object ( oBrw:AddCol() )
         :cHeader          := "Número de serie"
         :bStrData         := {|| if( !Empty( oBrw:aArrayData ), oBrw:aArrayData[ oBrw:nArrayAt ]:cNumeroSerie, "" ) }
         :nWidth           := 200
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Stock"
         :bStrData         := {|| if( !Empty( oBrw:aArrayData ), Trans( oBrw:aArrayData[ oBrw:nArrayAt ]:nUnidades, MasUnd() ), 0 ) }
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Prp. 1"
         :bStrData         := {|| if( !Empty( oBrw:aArrayData ), oBrw:aArrayData[ oBrw:nArrayAt ]:cValorPropiedad1, "" ) }
         :nWidth           := 60
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Prp. 2"
         :bStrData         := {|| if( !Empty( oBrw:aArrayData ), oBrw:aArrayData[ oBrw:nArrayAt ]:cValorPropiedad2, "" ) }
         :nWidth           := 60
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Lote"
         :bStrData         := {|| oBrw:aArrayData[ oBrw:nArrayAt ]:cLote }
         :nWidth           := 140
      end




      TButton():ReDefine( 500, {||( InsertOnStock( oCol, oBrw, oDlg, oBrwSer ) )}, oDlg,,, .F.,,,, .F. )




        TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

      oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )
      oDlg:AddFastKey( 115,       {|| oDlg:end( 1 ) } )
      oDlg:AddFastKey( 116,       {|| InsertOnStock( oCol, oBrw, oDlg, oBrwSer ) } )

      oDlg:bStart          := {|| ::aStockArticulo( cCodArt, cCodAlm, oBrw ) }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult == 1
      uRet                 := oBrw:aArrayData[ oBrw:nArrayAt ]:cNumeroSerie
   end

Return ( uRet )



UTILITY STATIC function TStock_nRiesgo( cCodigoCliente) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nRec
   local nOrd
   local oBlock
   local nRiesgo     := 0

   if Empty( cCodigoCliente )
      Return ( nRiesgo )
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   nRec              := ( ::cAlbCliT )->( Recno() )
   nOrd              := ( ::cAlbCliT )->( OrdSetFocus( "lCodCli" ) )

   if ( ::cAlbCliT )->( dbSeek( cCodigoCliente ) )

      while ( Alltrim( ( ::cAlbCliT )->cCodCli ) == Alltrim( cCodigoCliente ) ) .AND. !( ::cAlbCliT )->( Eof() )

         nRiesgo     += ( ::cAlbCliT )->nTotAlb - ( ::cAlbCliT )->nTotPag

         ( ::cAlbCliT )->( dbSkip() )

         SysRefresh()

      end

   end

   ( ::cAlbCliT )->( OrdSetFocus( nOrd ) )
   ( ::cAlbCliT )->( dbGoTo( nRec ) )



   nRec              := ( ::cFacCliP )->( Recno() )
   nOrd              := ( ::cFacCliP )->( OrdSetFocus( "lCodCli" ) )

   if ( ::cFacCliP )->( dbSeek( cCodigoCliente ) )

      while ( Alltrim( ( ::cFacCliP )->cCodCli ) == Alltrim( cCodigoCliente ) ) .AND. !( ::cFacCliP )->( Eof() )

         nRiesgo     += ( ::cFacCliP )->nImporte

         ( ::cFacCliP )->( dbSkip() )

         SysRefresh()

      end

   end

   ( ::cFacCliP )->( OrdSetFocus( nOrd ) )
   ( ::cFacCliP )->( dbGoTo( nRec ) )



   nRec              := ( ::cAntCliT )->( Recno() )
   nOrd              := ( ::cAntCliT )->( OrdSetFocus( "lCodCli" ) )

   if ( ::cAntCliT )->( dbSeek( cCodigoCliente ) )

      while ( Alltrim( ( ::cAntCliT )->cCodCli ) == Alltrim( cCodigoCliente ) ) .AND. !( ::cAntCliT )->( Eof() )

         nRiesgo     -= ( ::cAntCliT )->nTotAnt

         ( ::cAntCliT )->( dbSkip() )

         SysRefresh()

      end

   end

   ( ::cAntCliT )->( OrdSetFocus( nOrd ) )
   ( ::cAntCliT )->( dbGoTo( nRec ) )



   nRec              := ( ::cTikT )->( Recno() )
   nOrd              := ( ::cTikT )->( OrdSetFocus( "lCliTik" ) )

   if ( ::cTikT )->( dbSeek( cCodigoCliente ) )

      while ( Alltrim( ( ::cTikT )->cCliTik ) == Alltrim( cCodigoCliente ) ) .AND. !( ::cTikT )->( Eof() )

         nRiesgo     += ( ( ::cTikT )->nTotTik - ( ::cTikT )->nCobTik )

         ( ::cTikT )->( dbSkip() )

         SysRefresh()

      end

   end

   ( ::cTikT )->( OrdSetFocus( nOrd ) )
   ( ::cTikT )->( dbGoTo( nRec ) )

   end

   ErrorBlock( oBlock )

Return ( nRiesgo )



UTILITY STATIC function TStock_SetRiesgo( cCodigoCliente, oGetRiesgo, nRiesgoCliente, lAviso) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   local nRiesgo  := ::nRiesgo( cCodigoCliente )

   IIF( lAviso == nil, lAviso := uFieldEmpresa( "lSalPdt" , .F. ), ) ;

   if IsObject( oGetRiesgo )

      oGetRiesgo:cText( nRiesgo )

      if IsNum( nRiesgoCliente )

         if ( nRiesgo > nRiesgoCliente )
            oGetRiesgo:SetColor( ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ), ( 255 + ( 0 * 256 ) + ( 0 * 65536 ) ) )
         else
            oGetRiesgo:SetColor( ( 0 + ( 0 * 256 ) + ( 0 * 65536 ) ), ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ) )
         end

         oGetRiesgo:Refresh()

         if lAviso

            msgStop( "El riesgo alacanzado es de " + Alltrim( Trans( nRiesgo, cPorDiv() ) ) + "; sobre el establecido en su ficha " + Alltrim( Trans( nRiesgoCliente, cPorDiv() ) ) + ".", "El riesgo del cliente supera el límite establecido" )

         end

      end

   end

Return ( nRiesgo )



UTILITY STATIC function TStock_GetConsolidacion( cCodArt) ; local Self AS CLASS TStock := QSelf() AS CLASS TStock

   ::dConsolidacion     := nil





   if dbSeekInOrd( cCodArt, "CREFMOV", ::cHisMov )

      while ( ::cHisMov )->cRefMov == cCodArt .AND. !( ::cHisMov )->( Eof() )

         if ( ::cHisMov )->nTipMov == 4

            if Empty( ::dConsolidacion )

               ::dConsolidacion  := ( ::cHisMov )->dFecMov

            else

               if ( ::cHisMov )->dFecMov > ::dConsolidacion
                  ::dConsolidacion  := ( ::cHisMov )->dFecMov
               end

            end

         end

         ( ::cHisMov )->( dbSkip() )

      end

   end

Return ( ::dConsolidacion )




Static Function SeekOnStock( cSeek, oBrw )

   local nAt

   nAt               := aScan( oBrw:aArrayData, {|o| Alltrim( Upper( cValToChar( o:cNumeroSerie ) ) ) == Alltrim( Upper( cSeek ) ) } )
   if nAt > 0
      oBrw:nArrayAt  := nAt
   endif

   oBrw:Refresh()

Return ( .T. )



Static Function InsertOnStock( oCol, oBrw, oDlg, oBrwSer )

   if ( oBrwSer:nArrayAt == Len( oBrwSer:aArrayData ) )

      oDlg:End( 1 )

   else


      Eval( oCol:bOnPostEdit, oCol, oBrw:aArrayData[ oBrw:nArrayAt ]:cNumeroSerie )

      oBrwSer:GoDown()

      oBrw:aArrayData[ oBrw:nArrayAt ]:nUnidades--

      if ( oBrw:aArrayData[ oBrw:nArrayAt ]:nUnidades == 0 )

         aDel( oBrw:aArrayData, oBrw:nArrayAt, .T. )

         oBrw:Refresh()

      end

   end

Return ( .T. )
















_HB_CLASS STemporal ; UTILITY FUNCTION STemporal(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "STemporal" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { dFecMov} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "dFecMov" }, .F., .F. ), )
   _HB_MEMBER { cTimMov} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTimMov" }, .F., .F. ), )
   _HB_MEMBER { nTotEnt} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nTotEnt" }, .F., .F. ), )
   _HB_MEMBER { nTotSal} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nTotSal" }, .F., .F. ), )
   _HB_MEMBER { nImpEnt} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nImpEnt" }, .F., .F. ), )
   _HB_MEMBER { cTipo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTipo" }, .F., .F. ), )
   _HB_MEMBER { cNumero} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cNumero" }, .F., .F. ), )

   _HB_MEMBER New( dFecMov, cTimMov, nTotEnt, nTotSal, nImpEnt, cTipo, cNumero); IIF( .F., s_oClass:ModMethod( "New", @STemporal_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @STemporal_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS STemporal ;



UTILITY STATIC function STemporal_New( dFecMov, cTimMov, nTotEnt, nTotSal, nImpEnt, cTipo, cNumero) ; local Self AS CLASS STemporal := QSelf() AS CLASS STemporal

   IIF( cTipo == nil, cTipo := "", ) ;
   IIF( cNumero == nil, cNumero := "", ) ;

   ::dFecMov         := dFecMov
   ::cTimMov         := cTimMov
   ::nTotEnt         := Abs( nTotEnt )
   ::nTotSal         := Abs( nTotSal )
   ::nImpEnt         := Abs( nImpEnt )
   ::cTipo           := cTipo
   ::cNumero         := cNumero

RETURN ( Self )






_HB_CLASS SStock ; UTILITY FUNCTION SStock(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "SStock" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { cAlias} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cAlias" }, .F., .F. ), )
   _HB_MEMBER { cCodigo} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cCodigo" }, .F., .F. ), )
   _HB_MEMBER { dConsolidacion} ; IIF( !.F., s_oClass:AddMultiData(, Ctod( "" ), nScope + IIF( .F., 32, 0 ), { "dConsolidacion" }, .F., .F. ), )
   _HB_MEMBER { cCodigoAlmacen} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cCodigoAlmacen" }, .F., .F. ), )
   _HB_MEMBER { cNombreAlmacen} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cNombreAlmacen" }, .F., .F. ), )
   _HB_MEMBER { cCodigoPropiedad1} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cCodigoPropiedad1" }, .F., .F. ), )
   _HB_MEMBER { cCodigoPropiedad2} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cCodigoPropiedad2" }, .F., .F. ), )
   _HB_MEMBER { cValorPropiedad1} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cValorPropiedad1" }, .F., .F. ), )
   _HB_MEMBER { cValorPropiedad2} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cValorPropiedad2" }, .F., .F. ), )
   _HB_MEMBER { cLote} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cLote" }, .F., .F. ), )
   _HB_MEMBER { dFechaCaducidad} ; IIF( !.F., s_oClass:AddMultiData(, Ctod( "" ), nScope + IIF( .F., 32, 0 ), { "dFechaCaducidad" }, .F., .F. ), )
   _HB_MEMBER { cNumeroSerie} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cNumeroSerie" }, .F., .F. ), )
   _HB_MEMBER { nUnidades} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nUnidades" }, .F., .F. ), )
   _HB_MEMBER { nPendientesRecibir} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nPendientesRecibir" }, .F., .F. ), )
   _HB_MEMBER { nPendientesEntregar} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nPendientesEntregar" }, .F., .F. ), )
   _HB_MEMBER { cNumeroDocumento} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cNumeroDocumento" }, .F., .F. ), )
   _HB_MEMBER { cTipoDocumento} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cTipoDocumento" }, .F., .F. ), )

   WITH OBJECT <|Self|;

      ::cCodigo               := ""
      ::cCodigoAlmacen        := ""
      ::cNombreAlmacen        := ""
      ::cCodigoPropiedad1     := ""
      ::cCodigoPropiedad2     := ""
      ::cValorPropiedad1      := ""
      ::cValorPropiedad2      := ""
      ::cLote                 := ""
      ::cNumeroSerie          := ""
      ::dFechaCaducidad       := Ctod( "" )
      ::nUnidades             := 0
      ::nPendientesRecibir    := 0
      ::nPendientesEntregar   := 0

      RETURN ( Self )

   >; _HB_MEMBER New(); IIF( .F., s_oClass:ModInline( "New", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "New", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END

   WITH OBJECT <|Self|;
















      RETURN ( "Alias"                    + ::cAlias                                + "," +  "Codigo"                   + ::cCodigo                               + "," +  "CodigoAlmacen"            + ::cCodigoAlmacen                        + "," +  "NombreAlmacen"            + ::cNombreAlmacen                        + "," +  "CodigoPropiedad1"         + ::cCodigoPropiedad1                     + "," +  "CodigoPropiedad2"         + ::cCodigoPropiedad2                     + "," +  "ValorPropiedad1"          + ::cValorPropiedad1                      + "," +  "ValorPropiedad2"          + ::cValorPropiedad2                      + "," +  "Lote"                     + ::cLote                                 + "," +  "NumeroSerie"              + ::cNumeroSerie                          + "," +  "Unidades"                 + Str( ::nUnidades )                      + "," +  "PendientesRecibir"        + Str( ::nPendientesRecibir )             + "," +  "PendientesEntregar"       + Str( ::nPendientesEntregar )            + "," +  "Unidades != 0"            + cValToChar( ::nUnidades <> 0 )          + "," +  "PendientesRecibir != 0"   + cValToChar( ::nPendientesRecibir <> 0 ) + "," +  "PendientesEntregar != 0"  + cValToChar( ::nPendientesEntregar <> 0 ) )

   >; _HB_MEMBER Say(); IIF( .F., s_oClass:ModInline( "Say", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Say", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS SStock ;











FUNCTION putStock( cCodArt, cCodAlm, nUni, dbfMov, cTipMov )

   IIF( cCodAlm == nil, cCodAlm := oUser():cAlmacen(), ) ;
   IIF( cTipMov == nil, cTipMov := "MV", ) ;

    IF empty( cCodArt )
        RETURN .T.
    end

    IF nUni == 0
        RETURN .T.
    end





   IF ( dbfMov )->( dbSeek( cCodArt + cCodAlm + cTipMov ) )
      IF dbLock( dbfMov )
         ( dbfMov )->nStock   += nUni
         ( dbfMov )->( dbUnlock() )
      end
    ELSE
        ( dbfMov )->( dbAppend() )
        ( dbfMov )->CCODART     := cCodArt
        ( dbfMov )->CCODALM     := cCodAlm
      ( dbfMov )->CREFMOV  := cTipMov
        ( dbfMov )->NSTOCK      := nUni
    end

RETURN .T.







FUNCTION retStock( cCodArt, cCodAlm, dbfMov )

   local nRet  := 0

   IIF( cCodAlm == nil, cCodAlm := oUser():cAlmacen(), ) ;

    IF empty( cCodArt )
      nRet  := 0
    end

    IF ( dbfMov )->( dbSeek( cCodArt + cCodAlm ) )
      while ( dbfMov )->CCODART + ( dbfMov )->CCODALM == cCodArt + cCodAlm .AND. !( dbfMov )->( eof() )
         nRet  += ( dbfMov )->NSTOCK
         ( dbfMov )->( dbSkip() )
      end
    end

RETURN nRet



FUNCTION objStock( cCodArt, cCodAlm, oGetStk, dbfMov )

    IF oGetStk <> NIL
        oGetStk:cText( retStock( cCodArt, cCodAlm, dbfMov ) )
    end

RETURN .T.



FUNCTION ActStock( cCodAlm, dbfLine, bCondicion, lInc, lDel, dbfArticulo, dbfMov )

    local nUnits

   IIF( cCodAlm == nil, cCodAlm := oUser():cAlmacen(), ) ;
    IIF( lInc == nil, lInc := .T., ) ;
    IIF( lDel == nil, lDel := .T., ) ;

    WHILE Eval( bCondicion ) .AND. !(dbfLine)->( eof() )

      IF !empty( rtrim( (dbfLine)->CCBATIL ) ) .AND. ( dbfArticulo )->( DBSeek( (dbfLine)->CCBATIL ) )

         nUnits   := (dbfLine)->NUNTTIL

         IF !lInc
            nUnits := - nUnits
         end

         IF ( dbfMov )->( dbSeek( ( dbfArticulo )->CODIGO + cCodAlm + "MV" ) )
            IF dblock( dbfMov )
               ( dbfMov )->NSTOCK  += nUnits
               ( dbfMov )->( dbUnlock() )
            end
         ELSE
            ( dbfMov )->( dbAppend() )
            ( dbfMov )->CCODART := ( dbfArticulo )->CODIGO
                ( dbfMov )->CREFMOV := "MV"
            ( dbfMov )->CCODALM := cCodAlm
            ( dbfMov )->NSTOCK  := nUnits
         end

      end





      IF !empty( rtrim( (dbfLine)->CCOMTIL ) ) .AND. ( dbfArticulo )->( DBSeek( (dbfLine)->CCOMTIL ) )

         nUnits   := (dbfLine)->NUNTTIL

         IF !lInc
            nUnits := - nUnits
         end

         IF ( dbfMov )->( dbSeek( ( dbfArticulo )->CODIGO + cCodAlm + "MV" ) )
            IF dbLock( dbfMov )
               ( dbfMov )->NSTOCK  += nUnits
               ( dbfMov )->( dbUnlock() )
            end
         ELSE
            ( dbfMov )->( dbAppend() )
            ( dbfMov )->CCODART := ( dbfArticulo )->CODIGO
                ( dbfMov )->CREFMOV := "MV"
            ( dbfMov )->CCODALM := cCodAlm
            ( dbfMov )->NSTOCK  := nUnits
         end

      end

      IF lDel .AND. dbLock( dbfLine )
         ( dbfLine )->( dbDelete() )
         ( dbfLine )->( dbUnLock() )
      end

      ( dbfLine )->( dbSkip() )

   end

RETURN .T.






FUNCTION nTotStock( dbfMov, cCodArt, aGet, cCodAlm )

    local bCond
   local nUnits   := 0
   local nRecno   := ( dbfMov )->( RecNo() )

    IF !Empty( cCodAlm )
      bCond       := {|| cCodAlm == ( dbfMov )->CCODALM }
    ELSE
      bCond       := {|| .T. }
    end

    IF ( dbfMov )->( dbSeek( cCodArt ) )

        WHILE ( dbfMov )->CCODART == cCodArt .AND. ( dbfMov )->( !eof() )

            IF eval( bCond )
            nUnits += ( dbfMov )->NSTKACT
            end

            ( dbfMov )->( dbSkip() )

      end

    end

    ( dbfMov )->( dbGoTo( nRecno ) )

    IF aGet <> NIL
        aGet:SetText( nUnits )
    end

RETURN ( nUnits )






FUNCTION ActTpvStk( cCodAlm, dbfLine, bCondicion, lInc, lDel, dbfArticulo, dbfMov )

    local nUnits

   IIF( cCodAlm == nil, cCodAlm := oUser():cAlmacen(), ) ;
    IIF( lInc == nil, lInc := .T., ) ;
    IIF( lDel == nil, lDel := .T., ) ;

    WHILE Eval( bCondicion ) .AND. !(dbfLine)->( eof() )

      IF !empty( rtrim( (dbfLine)->CCBATIL ) ) .AND. ( dbfArticulo )->( DBSeek( (dbfLine)->CCBATIL ) )

         nUnits   := (dbfLine)->NUNTTIL

         IF !lInc
            nUnits := - nUnits
         end

         IF ( dbfMov )->( dbSeek( ( dbfArticulo )->CODIGO + cCodAlm + "MV" ) )
            IF dbLock( dbfMov )
               ( dbfMov )->NSTOCK  += nUnits
               ( dbfMov )->( dbUnlock() )
            end
         ELSE
            ( dbfMov )->( dbAppend() )
            ( dbfMov )->CCODART := ( dbfArticulo )->CODIGO
                ( dbfMov )->CREFMOV := "MV"
            ( dbfMov )->CCODALM := cCodAlm
            ( dbfMov )->NSTOCK  := nUnits
         end

      end

      IF lDel .AND. dbLock( dbfLine )
         ( dbfLine )->( dbDelete() )
         ( dbfLine )->( dbUnLock() )
      end

      ( dbfLine )->( dbSkip() )

   end

RETURN .T.

Function ScanInSerie( cMemoSerie, cNumeroSerie )



   WQout( { "memo:" + ( "," + cMemoSerie ) } )
   WQout( { "seri:" + ( "," + Alltrim( cNumeroSerie ) + "," ) } )
   WQout( { At( "," + cMemoSerie, "," + Alltrim( cNumeroSerie ) + "," ) <> 0 } )

Return ( At( "," + cMemoSerie, "," + Alltrim( cNumeroSerie ) + "," ) <> 0 )
