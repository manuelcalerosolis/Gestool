#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 6 ".\Prg\Tmasdet.prg"
static aObjBmps



_HB_CLASS TMasDet ; UTILITY FUNCTION TMasDet(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TMasDet" , {TMant():classh} ) ) ; ;

   _HB_MEMBER { oParent} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oParent" }, .F., .F. ), )

   _HB_MEMBER { oDbfVir} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDbfVir" }, .F., .F. ), )

   _HB_MEMBER { cFirstKey} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFirstKey" }, .F., .F. ), )

   _HB_MEMBER { cSerDoc} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSerDoc" }, .F., .F. ), )
   _HB_MEMBER { cNumDoc} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cNumDoc" }, .F., .F. ), )
   _HB_MEMBER { cSufDoc} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSufDoc" }, .F., .F. ), )

   _HB_MEMBER { aBmp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aBmp" }, .F., .F. ), )

   _HB_MEMBER { aIva} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aIva" }, .F., .F. ), )

   _HB_MEMBER { aGetVir} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aGetVir" }, .F., .F. ), )

   _HB_MEMBER { oBrwDet} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBrwDet" }, .F., .F. ), )

   _HB_MEMBER { bWhile} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bWhile" }, .F., .F. ), )

   _HB_MEMBER { bOnPreAppend, bOnPostAppend} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreAppend" , "bOnPostAppend" }, .F., .F. ), )
   _HB_MEMBER { bOnPreEdit, bOnPostEdit} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreEdit" , "bOnPostEdit" }, .F., .F. ), )
   _HB_MEMBER { bOnPreDelete, bOnPostDelete} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreDelete" , "bOnPostDelete" }, .F., .F. ), )
   _HB_MEMBER { bOnPreSave, bOnPostSave} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreSave" , "bOnPostSave" }, .F., .F. ), )
   _HB_MEMBER { bOnPreLoad, bOnPostLoad} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreLoad" , "bOnPostLoad" }, .F., .F. ), )

   _HB_MEMBER { bOnPreInsertDetail} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreInsertDetail" }, .F., .F. ), )
   _HB_MEMBER { bOnPreAppendDetail, bOnPostAppendDetail} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreAppendDetail" , "bOnPostAppendDetail" }, .F., .F. ), )
   _HB_MEMBER { bOnPreEditDetail, bOnPostEditDetail} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreEditDetail" , "bOnPostEditDetail" }, .F., .F. ), )
   _HB_MEMBER { bOnPreDeleteDetail, bOnPostDeleteDetail} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreDeleteDetail" , "bOnPostDeleteDetail" }, .F., .F. ), )
   _HB_MEMBER { bOnPreSaveDetail, bOnPostSaveDetail} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreSaveDetail" , "bOnPostSaveDetail" }, .F., .F. ), )
   _HB_MEMBER { bOnPreLoadDetail, bOnPostLoadDetail} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bOnPreLoadDetail" , "bOnPostLoadDetail" }, .F., .F. ), )



   _HB_MEMBER { oRadSelect} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oRadSelect" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nRadSelect} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nRadSelect" }, .F., .F. ), )
   _HB_MEMBER { oChkSelect} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oChkSelect" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lChkSelect} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .T., nScope + IIF( .F., 32, 0 ), { "lChkSelect" }, .F., .F. ), )
   _HB_MEMBER { oChkUnSelect} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oChkUnSelect" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lChkUnSelect} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .T., nScope + IIF( .F., 32, 0 ), { "lChkUnSelect" }, .F., .F. ), )
   _HB_MEMBER { oDlgSelect} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDlgSelect" }, .F., .F. ), )
   _HB_MEMBER { oTreeSelect} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTreeSelect" }, .F., .F. ), )
   _HB_MEMBER { oMtrSelect} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oMtrSelect" }, .F., .F. ), )
   _HB_MEMBER { cSerDocIni} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSerDocIni" }, .F., .F. ), )
   _HB_MEMBER { cSerDocFin} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSerDocFin" }, .F., .F. ), )
   _HB_MEMBER { nNumDocIni} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nNumDocIni" }, .F., .F. ), )
   _HB_MEMBER { nNumDocFin} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nNumDocFin" }, .F., .F. ), )
   _HB_MEMBER { cSufDocIni} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSufDocIni" }, .F., .F. ), )
   _HB_MEMBER { cSufDocFin} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSufDocFin" }, .F., .F. ), )

   _HB_MEMBER { oBtnCancel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBtnCancel" }, .F., .F. ), )

   _HB_MEMBER { nLenDocIni} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nLenDocIni" }, .F., .F. ), )

   _HB_MEMBER {AS LOGIC lNumDocChr} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lNumDocChr" }, .F., .F. ), )

   _HB_MEMBER {AS LOGIC lMoveDlgSelect} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lMoveDlgSelect" }, .F., .F. ), )

   _HB_MEMBER { cSerDocKey} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSerDocKey" }, .F., .F. ), )
   _HB_MEMBER { cNumDocKey} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cNumDocKey" }, .F., .F. ), )
   _HB_MEMBER { cSufDocKey} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSufDocKey" }, .F., .F. ), )

   _HB_MEMBER {AS LOGIC lAutoActions} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .T., nScope + IIF( .F., 32, 0 ), { "lAutoActions" }, .F., .F. ), )

   _HB_MEMBER {AS LOGIC lMinimize} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lMinimize" }, .F., .F. ), )

   _HB_MEMBER {AS LOGIC lFecha} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .T., nScope + IIF( .F., 32, 0 ), { "lFecha" }, .F., .F. ), )
   _HB_MEMBER {AS DATE dFechaDesde} ; IIF( !.F., s_oClass:AddMultiData( "DATE", CtoD( "01/01/" + Str( Year( Date() ) ) ), nScope + IIF( .F., 32, 0 ), { "dFechaDesde" }, .F., .F. ), )
   _HB_MEMBER {AS DATE dFechaHasta} ; IIF( !.F., s_oClass:AddMultiData( "DATE", Date(), nScope + IIF( .F., 32, 0 ), { "dFechaHasta" }, .F., .F. ), )

   _HB_MEMBER NewDetail( cPath, oParent); IIF( .F., s_oClass:ModMethod( "NewDetail", @TMasDet_NewDetail(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "NewDetail", @TMasDet_NewDetail(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Load(); IIF( .F., s_oClass:ModMethod( "Load", @TMasDet_Load(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Load", @TMasDet_Load(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER LoadAppend(); IIF( .F., s_oClass:ModInline( "LoadAppend", {|Self | Self, ( ::Load( .T. ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "LoadAppend", {|Self | Self, ( ::Load( .T. ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER Cancel(); IIF( .F., s_oClass:ModMethod( "Cancel", @TMasDet_Cancel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Cancel", @TMasDet_Cancel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Save(); IIF( .F., s_oClass:ModMethod( "Save", @TMasDet_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Save", @TMasDet_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER LoadDetails(); IIF( .F., s_oClass:ModMethod( "LoadDetails", @TMasDet_LoadDetails(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LoadDetails", @TMasDet_LoadDetails(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER End(); IIF( .F., s_oClass:ModMethod( "End", @TMasDet_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @TMasDet_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER EndResource( nMode); IIF( .F., s_oClass:ModMethod( "EndResource", @TMasDet_EndResource(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EndResource", @TMasDet_EndResource(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Append(); IIF( .F., s_oClass:ModMethod( "Append", @TMasDet_Append(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Append", @TMasDet_Append(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER EndAppend(); IIF( .F., s_oClass:ModMethod( "EndAppend", @TMasDet_EndAppend(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EndAppend", @TMasDet_EndAppend(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Dup(); IIF( .F., s_oClass:ModMethod( "Dup", @TMasDet_Dup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Dup", @TMasDet_Dup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER EndDup(); IIF( .F., s_oClass:ModMethod( "EndDup", @TMasDet_EndDup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EndDup", @TMasDet_EndDup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Edit(); IIF( .F., s_oClass:ModMethod( "Edit", @TMasDet_Edit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Edit", @TMasDet_Edit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER EndEdit(); IIF( .F., s_oClass:ModMethod( "EndEdit", @TMasDet_EndEdit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EndEdit", @TMasDet_EndEdit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Zoom(); IIF( .F., s_oClass:ModMethod( "Zoom", @TMasDet_Zoom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Zoom", @TMasDet_Zoom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Del(); IIF( .F., s_oClass:ModMethod( "Del", @TMasDet_Del(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Del", @TMasDet_Del(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Next( oBrw); IIF( .F., s_oClass:ModMethod( "Next", @TMasDet_Next(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Next", @TMasDet_Next(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Prior( oBrw); IIF( .F., s_oClass:ModMethod( "Prior", @TMasDet_Prior(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Prior", @TMasDet_Prior(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AppendDet(); IIF( .F., s_oClass:ModMethod( "AppendDet", @TMasDet_AppendDet(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AppendDet", @TMasDet_AppendDet(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER EditDet(); IIF( .F., s_oClass:ModMethod( "EditDet", @TMasDet_EditDet(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EditDet", @TMasDet_EditDet(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ZoomDet(); IIF( .F., s_oClass:ModMethod( "ZoomDet", @TMasDet_ZoomDet(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ZoomDet", @TMasDet_ZoomDet(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DeleteDet(); IIF( .F., s_oClass:ModMethod( "DeleteDet", @TMasDet_DeleteDet(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DeleteDet", @TMasDet_DeleteDet(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DelDetail(); IIF( .F., s_oClass:ModMethod( "DelDetail", @TMasDet_DelDetail(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DelDetail", @TMasDet_DelDetail(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DupDet( ); IIF( !.F., s_oClass:AddVirtual( "DupDet" ), )

   _HB_MEMBER Detalle( nMode ); IIF( !.F., s_oClass:AddVirtual( "Detalle" ), )

   _HB_MEMBER StartSelect( cChkTitle); IIF( .F., s_oClass:ModMethod( "StartSelect", @TMasDet_StartSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "StartSelect", @TMasDet_StartSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SelectRec( bAction, cDlgTitle, cChkTitle); IIF( .F., s_oClass:ModMethod( "SelectRec", @TMasDet_SelectRec(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SelectRec", @TMasDet_SelectRec(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER EvalSelect( bAction); IIF( .F., s_oClass:ModMethod( "EvalSelect", @TMasDet_EvalSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EvalSelect", @TMasDet_EvalSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER RollBack(); IIF( .F., s_oClass:ModMethod( "RollBack", @TMasDet_RollBack(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RollBack", @TMasDet_RollBack(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SaveDetails(); IIF( .F., s_oClass:ModMethod( "SaveDetails", @TMasDet_SaveDetails(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SaveDetails", @TMasDet_SaveDetails(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CancelDetails(); IIF( .F., s_oClass:ModMethod( "CancelDetails", @TMasDet_CancelDetails(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CancelDetails", @TMasDet_CancelDetails(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DefineDetails( ); IIF( !.F., s_oClass:AddVirtual( "DefineDetails" ), )

   _HB_MEMBER ReportDetails(); IIF( .F., s_oClass:ModMethod( "ReportDetails", @TMasDet_ReportDetails(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReportDetails", @TMasDet_ReportDetails(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GetNewCount( ); IIF( !.F., s_oClass:AddVirtual( "GetNewCount" ), )
   _HB_MEMBER PutNewCount( ); IIF( !.F., s_oClass:AddVirtual( "PutNewCount" ), )

   _HB_MEMBER GetFirstKey(); IIF( .F., s_oClass:ModInline( "GetFirstKey", {|Self | Self, ( if( ::bFirstKey <> nil, ::cFirstKey := Eval( ::bFirstKey, Self ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetFirstKey", {|Self | Self, ( if( ::bFirstKey <> nil, ::cFirstKey := Eval( ::bFirstKey, Self ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER CloseFiles(); IIF( .F., s_oClass:ModMethod( "CloseFiles", @TMasDet_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CloseFiles", @TMasDet_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AddDetail( oDetail); IIF( .F., s_oClass:ModMethod( "AddDetail", @TMasDet_AddDetail(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddDetail", @TMasDet_AddDetail(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Activate(); IIF( .F., s_oClass:ModMethod( "Activate", @TMasDet_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Activate", @TMasDet_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER oDefDiv( nId, nIdBmp, nIdChg, oDlg, nMode); IIF( .F., s_oClass:ModMethod( "oDefDiv", @TMasDet_oDefDiv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "oDefDiv", @TMasDet_oDefDiv(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER OpenDetails(); IIF( .F., s_oClass:ModInline( "OpenDetails", {|Self | Self, ( aSend( ::oDbfDet, "OpenFiles()" ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "OpenDetails", {|Self | Self, ( aSend( ::oDbfDet, "OpenFiles()" ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER CloseDetails(); IIF( .F., s_oClass:ModInline( "CloseDetails", {|Self | Self, ( aSend( ::oDbfDet, "CloseFiles()" ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "CloseDetails", {|Self | Self, ( aSend( ::oDbfDet, "CloseFiles()" ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER nRegisterToProcess(); IIF( .F., s_oClass:ModMethod( "nRegisterToProcess", @TMasDet_nRegisterToProcess(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nRegisterToProcess", @TMasDet_nRegisterToProcess(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TMasDet ;



UTILITY STATIC function TMasDet_NewDetail( cPath, oParent) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   ::cPath              := cPath
   ::oParent            := oParent

RETURN ( Self )



UTILITY STATIC function TMasDet_Load( lAppend) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   IIF( lAppend == nil, lAppend := .F., ) ;

   if Empty( ::oDbfVir )
      ::oDbfVir      := ::DefineFiles( cPatTmp(), cLocalDriver(), .T. )
   end

   if !( ::oDbfVir:Used() )
      ::oDbfVir:Activate( .F., .F. )
   end

   if ::oParent:cFirstKey <> nil

      if ( lAppend ) .AND. ::oDbf:Seek( ::oParent:cFirstKey )

         while !Empty( ::oDbf:OrdKeyVal() ) .AND. ( ::oDbf:OrdKeyVal() <= ::oParent:cFirstKey ) .AND. !::oDbf:Eof()

            if ::bOnPreLoad <> nil
               Eval( ::bOnPreLoad, Self )
            end

            ::oDbfVir:AppendFromObject( ::oDbf )








            if ::bOnPostLoad <> nil
               Eval( ::bOnPostLoad, Self )
            end

            ::oDbf:Skip()

         end

      end

   end

   ::oDbfVir:GoTop()

RETURN ( Self )



UTILITY STATIC function TMasDet_Save() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   ::oDbfVir:OrdSetFocus( 0 )

   ::oDbfVir:GoTop()
   while !::oDbfVir:eof()

      if ::bOnPreSaveDetail <> nil
         Eval( ::bOnPreSaveDetail, Self )
      end

      ::oDbf:AppendFromObject( ::oDbfVir )








      if ::bOnPostSaveDetail <> nil
         Eval( ::bOnPostSaveDetail, Self )
      endif

      ::oDbfVir:Skip()

   end

   ::Cancel()

RETURN ( Self )



UTILITY STATIC function TMasDet_Cancel() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local cFileName   := ::oDbfVir:cPath + ::oDbfVir:cName

   if !Empty( ::oDbfVir ) .AND. ::oDbfVir:Used()
      ::oDbfVir:Zap()
      ::oDbfVir:End()
   end

   dbfErase( cFileName )

RETURN ( Self )



UTILITY STATIC function TMasDet_LoadDetails( lAppend) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   IIF( lAppend == nil, lAppend := .F., ) ;

   CursorWait()

   ::GetFirstKey()

   if ::cFirstKey <> nil

      do case
         case ValType( ::oDbfDet ) == "O"

            ::oDbfVir         := ::DefineDetails( cPatTmp(), cLocalDriver(), .T. )

            if ::oDbfVir <> nil

               ::oDbfVir:Activate( .F., .F. )

               if ( lAppend ) .AND. ::oDbfDet:Seek( ::cFirstKey )

                  while !Empty( ::oDbfDet:OrdKeyVal() ) .AND. ( ::oDbfDet:OrdKeyVal() <= ::cFirstKey ) .AND. !::oDbfDet:Eof()

                     if ::bOnPreLoad <> nil
                        Eval( ::bOnPreLoad, Self )
                     end

                     ::oDbfVir:AppendFromObject( ::oDbfDet )

                     if ::bOnPostLoad <> nil
                        Eval( ::bOnPostLoad, Self )
                     end

                     ::oDbfDet:Skip()

                  end

                  ::oDbfVir:GoTop()

               end

            end

         case ValType( ::oDbfDet ) == "A"

            if lAppend
               aSend( ::oDbfDet, "LoadAppend()" )
            else
               aSend( ::oDbfDet, "Load()" )
            end

      end

   end

   CursorWE()

RETURN ( Self )



UTILITY STATIC function TMasDet_RollBack() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   ::GetFirstKey()

   if ::cFirstKey <> nil

      do case
         case IsObject( ::oDbfDet )

            while ::oDbfDet:Seek( ::cFirstKey )

               if ::bOnPreDeleteDetail <> nil
                  Eval( ::bOnPreDeleteDetail, Self )
               end

               ::oDbfDet:Delete( .F. )

               if ::bOnPostDeleteDetail <> nil
                  Eval( ::bOnPostDeleteDetail, Self )
               end

            end

         case IsArray( ::oDbfDet )

            aSend( ::oDbfDet, "RollBack()" )

         case IsNil( ::oDbfDet )

            if ::oParent:cFirstKey <> nil

               while ::oDbf:Seek( ::oParent:cFirstKey )

                  if ::bOnPreDeleteDetail <> nil
                     Eval( ::bOnPreDeleteDetail, Self )
                  end

                  ::oDbf:Delete( .F. )

                  if ::bOnPostDeleteDetail <> nil
                     Eval( ::bOnPostDeleteDetail, Self )
                  end

               end

            end

      end

   end

RETURN ( Self )



UTILITY STATIC function TMasDet_SaveDetails() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local nOrd

   do case
      case IsObject( ::oDbfDet )

         nOrd     := ::oDbfVir:OrdSetFocus( 0 )

         ::oDbfVir:GoTop()
         while !::oDbfVir:eof()

            if ::bOnPreSaveDetail <> nil
               Eval( ::bOnPreSaveDetail, Self )
            end

            ::oDbfDet:AppendFromObject( ::oDbfVir )

            if ::bOnPostSaveDetail <> nil
               Eval( ::bOnPostSaveDetail, Self )
            endif

            ::oDbfVir:Skip()

         end

      case IsArray( ::oDbfDet )

         aSend( ::oDbfDet, "Save()" )

   end



RETURN ( Self )



UTILITY STATIC function TMasDet_CancelDetails() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local cFileName

   do case
      case IsObject( ::oDbfDet )

         cFileName   := ::oDbfVir:cPath + ::oDbfVir:cName

         if !Empty( ::oDbfVir ) .AND. ::oDbfVir:Used()
            ::oDbfVir:Zap()
            ::oDbfVir:End()
         end

         dbfErase( cFileName )

      case IsArray( ::oDbfDet )

         aSend( ::oDbfDet, "Cancel()" )

   end

RETURN ( Self )



UTILITY STATIC function TMasDet_ReportDetails() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local n
   local aPrompt     := {}
   local aoCols      := {}
   local oDbfDet

   ::oDbf:GetStatus()

   do case
      case ValType( ::oDbfDet ) == "O"
         oDbfDet     := ::oDbfDet
         ::oDbfDet:GetStatus()
      case ValType( ::oDbfDet ) == "A"
         oDbfDet     := ::oDbfDet[ 1 ]:oDbf
         aSend( ::oDbfDet, "GetStatus()" )
   end





   for n := 1 to oDbfDet:FCount()

      if !oDbfDet:aTField[ n ]:lCalculate









         aAdd( aoCols, {   oDbfDet:aTField[ n ]:cName, oDbfDet:aTField[ n ]:cType, oDbfDet:aTField[ n ]:nLen, oDbfDet:aTField[ n ]:nDec, oDbfDet:aTField[ n ]:cPict, SubStr( oDbfDet:aTField[ n ]:cComment, 1, oDbfDet:aTField[ n ]:nLen + oDbfDet:aTField[ n ]:nDec ), !oDbfDet:aTField[ n ]:lHide, oDbfDet:aTField[ n ]:cComment, oDbfDet:aTField[ n ]:nLen + oDbfDet:aTField[ n ]:nDec } )

      endif

   next

   for n := 1 to len( oDbfDet:aTIndex )
      aAdd( aPrompt, { oDbfDet:aTIndex[ n ]:cComment } )
   next

   ::oReport            := TInfGen():New( ::oDbf:cComment, aoCols )

   ::oReport:lDefDivInf := .F.
   ::oReport:lDefSerInf := .F.
   ::oReport:lDefFecInf := .F.

   ::oReport:oParent    := Self
   ::oReport:oDbfMai    := ::oDbf
   ::oReport:oDbfDet    := oDbfDet

   ::oReport:AddTmpIndex( "cName", oDbfDet:OrdKey(), "!Deleted()" )

   ::oReport:AddGroup( {|| ::oReport:oDbfMai:OrdKeyVal() }, {|| "Grupo : " + ::oReport:oDbfMai:OrdKeyVal() } )

   ::oReport:StdResource()
   ::oReport:oDefDesHas()

   ::oReport:Activate()
   ::oReport:End()

   do case
      case ValType( ::oDbfDet ) == "O"
         ::oDbfDet:SetStatus()

      case ValType( ::oDbfDet ) == "A"
         aSend( ::oDbfDet, "SetStatus()" )

   end

   ::oDbf:SetStatus()

RETURN NIL



UTILITY STATIC function TMasDet_Append( oBrw) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local lAppend
   local lTrigger

   if ::lMinimize
      IIF( ::oWndBrw <> nil, ::oWndBrw:Minimize(), )
   end

   if ::bOnPreAppend <> nil
      lTrigger := Eval( ::bOnPreAppend, Self )
      if Valtype( lTrigger ) == "L" .AND. !lTrigger
         return .F.
      end
   end

   ::oDbf:Blank()
   ::oDbf:SetDefault()

   ::LoadDetails( .F. )

   lAppend       := ::Resource( 1 )

   if ::lAutoActions
      ::EndAppend( lAppend )
   end

   if ::lMinimize
      IIF( ::oWndBrw <> nil, ( ::oWndBrw:Maximize(), ::oWndBrw:Refresh() ), )
   end

   if lAppend .AND. !Empty( oBrw )
      oBrw:Refresh()
   end

   if ::bOnPostAppend <> nil
      Eval( ::bOnPostAppend, Self )
   end

return ( lAppend )



UTILITY STATIC function TMasDet_EndAppend( lAppend) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if lAppend

      ::GetNewCount()

      ::oDbf:Insert()

      ::SaveDetails( 1 )

      IIF( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

   else

      ::oDbf:Cancel()

      IIF( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

   end

   ::CancelDetails()

return ( lAppend )



UTILITY STATIC function TMasDet_Edit( oBrw) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local lEdit
   local lTrigger

   if ::oDbf:OrdKeyCount() == 0
      return .F.
   end

   if ::lMinimize
      IIF( ::oWndBrw <> nil, ::oWndBrw:Minimize(), )
   end

   if ::oDbf:RecLock()

      if ::bOnPreEdit <> nil
         lTrigger    := Eval( ::bOnPreEdit, Self )
         if Valtype( lTrigger ) == "L" .AND. !lTrigger
            ::oDbf:UnLock()
            return .F.
         end
      end

      ::oDbf:Load()

      ::LoadDetails( .T. )

      lEdit          := ::Resource( 2 )

      if ::lAutoActions
         ::EndEdit( lEdit )
      end

      if lEdit .AND. !Empty( oBrw )
         oBrw:Refresh()
      end

      if ::bOnPostEdit <> nil
         lTrigger    := Eval( ::bOnPostEdit, Self )
      end

      ::oDbf:UnLock()

   end

   if ::lMinimize
      IIF( ::oWndBrw <> nil, ::oWndBrw:Maximize(), )
   end

   IIF( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

RETURN ( .T. )



UTILITY STATIC function TMasDet_EndEdit( lEdit) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if lEdit

      ::RollBack()

      ::oDbf:Save()

      ::SaveDetails( 2 )

   else

      ::oDbf:Cancel()

   end

   ::CancelDetails()

Return ( lEdit )



UTILITY STATIC function TMasDet_Zoom( oBrw) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   ::GetFirstKey()

   ::oDbf:Load()
   ::LoadDetails( .T. )

   ::Resource( 3 )

   ::CancelDetails()
   ::oDbf:Cancel()

   if !Empty( oBrw )
      oBrw:Refresh()
   end

RETURN ( .T. )



UTILITY STATIC function TMasDet_Del( lHead, lDetail) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local lDel        := .F.
   local lTrigger

   IIF( lHead == nil, lHead := .T., ) ;
   IIF( lDetail == nil, lDetail := .T., ) ;

   if ::bOnPreDelete <> nil
      lTrigger    := Eval( ::bOnPreDelete, Self )
      if IsLogic( lTrigger ) .AND. !lTrigger
         return .F.
      end
   end

   if oUser():lNotConfirmDelete() .OR. ApoloMsgNoYes("¿Desea eliminar el registro en curso?", "Confirme supresión" )

      CursorWait()

      if lDetail
         ::RollBack()
      end

      if lHead
         ::oDbf:Delete( .T. )
      end

      lDel     := .T.

      CursorWE()

   end

   if ::bOnPostDelete <> nil
      return Eval( ::bOnPostDelete, Self )
   end

RETURN ( lDel )



UTILITY STATIC function TMasDet_Dup( oBrw) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local lAppend
   local lTrigger

   if ::bOnPreAppend <> nil
      lTrigger := Eval( ::bOnPreAppend, Self )
      if Valtype( lTrigger ) == "L" .AND. !lTrigger
         return .F.
      end
   end

   ::oDbf:Load()

   ::LoadDetails( .T. )

   lAppend       := ::Resource( 1 )

   if ::lAutoActions
      ::EndDup( lAppend )
   end

   if lAppend .AND. !Empty( oBrw )
      oBrw:Refresh()
   end

   if ::bOnPostAppend <> nil
      return ( Eval( ::bOnPostAppend, Self ) )
   end

RETURN ( lAppend )



UTILITY STATIC function TMasDet_EndDup( lAppend) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if lAppend

      ::GetNewCount()

      ::oDbf:Insert()

      ::SaveDetails( 1 )

      IIF( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

   else

      ::oDbf:Cancel()

      IIF( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

   end

   ::CancelDetails()

RETURN ( lAppend )



UTILITY STATIC function TMasDet_Next( nMode, oBrw) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local nRecno
   local lTrigger

   if ::oDbf:OrdKeyCount() == 0
      return .F.
   end

   nRecno      := ::oDbf:Recno()





   ::RollBack()

   ::oDbf:Save()

   ::SaveDetails( 2 )

   ::oDbf:UnLock()

   ::oDbf:Next()

   if !::oDbf:Eof()

      if ::oDbf:RecLock()

         if ::bOnPreEdit <> nil

            lTrigger    := Eval( ::bOnPreEdit, Self )
            if IsLogic( lTrigger ) .AND. !lTrigger
               ::oDbf:UnLock()
               return .F.
            end

         end

         ::oDbf:Load()

         ::LoadDetails( .T. )

      end

   else

      ::oDbf:GoTo( nRecno )

      RETURN ( .F. )

   end

   IIF( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

RETURN ( .T. )



UTILITY STATIC function TMasDet_Prior( nMode, oBrw) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local nRecno
   local lTrigger

   if ::oDbf:OrdKeyCount() == 0
      return .F.
   end

   nRecno      := ::oDbf:Recno()





   ::RollBack()

   ::oDbf:Save()

   ::SaveDetails( 2 )

   ::oDbf:UnLock()

   ::oDbf:Prior()

   if !::oDbf:Bof()

      if ::oDbf:RecLock()

         if ::bOnPreEdit <> nil

            lTrigger    := Eval( ::bOnPreEdit, Self )
            if IsLogic( lTrigger ) .AND. !lTrigger
               ::oDbf:UnLock()
               return .F.
            end

         end

         ::oDbf:Load()

         ::LoadDetails( .T. )

      end

   else

      ::oDbf:GoTo( nRecno )

      RETURN ( .F. )

   end

   IIF( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

RETURN ( .T. )



UTILITY STATIC function TMasDet_AppendDet() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local lTrigger

   while .T.

      if ::bOnPreAppendDetail <> nil
         lTrigger := Eval( ::bOnPreAppendDetail, Self )
         if Valtype( lTrigger ) == "L" .AND. !lTrigger
            return .F.
         end
      end

      ::oDbfVir:Blank()

      if ::Detalle( 1 )

         ::oDbfVir:Insert()

         if ::oBrwDet <> nil
            ::oBrwDet:Refresh()
         end

         if ::bOnPostAppendDetail <> nil
            Eval( ::bOnPostAppendDetail, Self )
         end

         if lEntCon()
            loop
         else
            exit
         end

      else

         ::oDbfVir:Cancel()

         if ::oBrwDet <> nil
            ::oBrwDet:Refresh()
         end

         exit

      end

   end

RETURN ( Self )



UTILITY STATIC function TMasDet_EditDet() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if ::oDbfVir:Recno() == 0
      Return ( Self )
   end

   ::oDbfVir:Load()

   if ::Detalle( 2 )

      ::oDbfVir:Save()

      if ::bOnPostEditDetail <> nil
         Eval( ::bOnPostEditDetail, Self )
      end

   else

      ::oDbfVir:Cancel()

   end

   IIF( ::oBrwDet <> nil, ::oBrwDet:Refresh(), )

RETURN ( Self )



UTILITY STATIC function TMasDet_ZoomDet() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if ::oDbfVir:Recno() == 0
      Return ( Self )
   end

   ::oDbfVir:Load()
   ::Detalle( 3 )
   ::oDbfVir:Cancel()

Return ( Self )



UTILITY STATIC function TMasDet_DeleteDet() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if ::oDbfVir:Recno() == 0
      RETURN ( Self )
   end

   if oUser():lNotConfirmDelete() .OR.  ApoloMsgNoYes("¿ Desea eliminar definitivamente este registro ?", "Confirme supersión" )

      ::oDbfVir:Delete( .T. )

      if ::bOnPostDeleteDetail <> nil
         Eval( ::bOnPostDeleteDetail, Self )
      end

      IIF( ::oBrwDet <> nil, ::oBrwDet:Refresh(), )

   end

RETURN ( Self )



UTILITY STATIC function TMasDet_DelDetail() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if ::oDbfVir:Recno() == 0
      Return ( Self )
   end

   if ::cFirstKey <> nil

      while ::oDbfVir:Seek( ::cFirstKey )

         ::oDbfVir:Delete( .F. )

         if ::bOnPostDeleteDetail <> nil
            Eval( ::bOnPostDeleteDetail, Self )
         end

      end

   end

RETURN ( Self )



UTILITY STATIC function TMasDet_SelectRec( bAction, cDlgTitle, cChkTitle, lClose) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local oSerDocIni
   local oNumDocIni
   local oSufDocIni
   local oBtnDocIni
   local oSerDocFin
   local oNumDocFin
   local oSufDocFin
   local oBtnDocFin
   local nMtrInf     := 0
   local cPicture    := "999999999"
   local oImageList

   IIF( bAction == nil, bAction := {|| MsgAlert( "bAction no pasado" ) }, ) ;
   IIF( cDlgTitle == nil, cDlgTitle := "", ) ;
   IIF( cChkTitle == nil, cChkTitle := "", ) ;
   IIF( lClose == nil, lClose := .F., ) ;

   if !Empty( ::oWndBrw:oBrw ) .AND. len( ::oWndBrw:oBrw:aSelected ) > 1
      ::nRadSelect   := 1
   else
      ::nRadSelect   := 2
   end

   oImageList        := TImageList():New( 16, 16 )
   oImageList:AddMasked( TBitmap():Define( "bRed" ), ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )
   oImageList:AddMasked( TBitmap():Define( "bGreen" ), ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )

   if ::cSerDocKey <> nil
      ::cSerDocIni   := ::cSerDocFin   := ::oDbf:FieldGetName( ::cSerDocKey )
   end

   ::nNumDocIni      := ::nNumDocFin   := ::oDbf:FieldGetName( ::cNumDocKey )
   ::cSufDocIni      := ::cSufDocFin   := ::oDbf:FieldGetName( ::cSufDocKey )

   if ValType( ::nNumDocIni ) == "C"
      ::lNumDocChr   := .T.
      ::nLenDocIni   := Len( ::nNumDocIni )
      ::nNumDocIni   := Val( Trans( ::nNumDocIni, cPicture ) )
      ::nNumDocFin   := Val( Trans( ::nNumDocFin, cPicture ) )
   else
      ::nLenDocIni   := Len( Str( ::nNumDocIni ) )
   end

   cPicture          := Replicate( "9", ::nLenDocIni )

   ::oDlgSelect = TDialog():New(,,,, cDlgTitle, "SelectRango",, .F.,,,,,, .F.,,,,,, .F., )



   ::oRadSelect := TRadMenu():Redefine( { | u | If( PCount()==0, ::nRadSelect, ::nRadSelect:= u ) }, ::oDlgSelect,, { 80, 81 },,,,, .F.,, )









   oSerDocIni := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, ::cSerDocIni, ::cSerDocIni:= u ) }, ::oDlgSelect,, "@!", {||    ( ::cSerDocIni >= "A" .AND. ::cSerDocIni <= "Z"  )},,,,,, .F., {||     ( ::nRadSelect == 2 )},, .F., .T., {||    ( UpSerie( oSerDocIni ) )}, {||  ( DwSerie( oSerDocIni ) )},,,, nil,,, )






   oBtnDocIni := TBtnBmp():ReDefine( 101, "Up16",,,,,, ::oDlgSelect, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F. )
   oBtnDocIni:bAction   := {|| dbFirst( ::oDbf:cAlias, ::cNumDocKey, oNumDocIni, ::cSerDocIni ) }






   oNumDocIni := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, ::nNumDocIni, ::nNumDocIni:= u ) }, ::oDlgSelect,, cPicture,,,,,,, .F., {||     ( ::nRadSelect == 2 )},, .F., .T.,,,,,, nil,,, )






   oBtnDocFin := TBtnBmp():ReDefine( 111, "Down16",,,,,, ::oDlgSelect, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F. )
   oBtnDocFin:bAction   := {|| dbLast( ::oDbf:cAlias, ::cNumDocKey, oNumDocFin, ::cSerDocFin ) }




   oSufDocIni := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, ::cSufDocIni, ::cSufDocIni:= u ) }, ::oDlgSelect,,,,,,,,, .F., {||     ( ::nRadSelect == 2 )},, .F., .F.,,,,,, nil,,, )









   oSerDocFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, ::cSerDocFin, ::cSerDocFin:= u ) }, ::oDlgSelect,, "@!", {||    ( ::cSerDocFin >= "A" .AND. ::cSerDocFin <= "Z"  )},,,,,, .F., {||     ( ::nRadSelect == 2 )},, .F., .T., {||    ( UpSerie( oSerDocFin ) )}, {||  ( DwSerie( oSerDocFin ) )},,,, nil,,, )






   oNumDocFin := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, ::nNumDocFin, ::nNumDocFin:= u ) }, ::oDlgSelect,, cPicture,,,,,,, .F., {||     ( ::nRadSelect == 2 )},, .F., .T.,,,,,, nil,,, )




   oSufDocFin := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, ::cSufDocFin, ::cSufDocFin:= u ) }, ::oDlgSelect,,,,,,,,, .F., {||     ( ::nRadSelect == 2 )},, .F., .F.,,,,,, nil,,, )







   TCheckBox():ReDefine( 300, { | u | If( PCount()==0, ::lFecha, ::lFecha:= u ) }, ::oDlgSelect,,,,,,, .F.,, .F. )





   TGetHlp():ReDefine( 310, { | u | If( PCount()==0, ::dFechaDesde, ::dFechaDesde:= u ) }, ::oDlgSelect,,,,,,,,, .F., {||     ( !::lFecha )},, .F., .T.,,,,,, nil,,, )





   TGetHlp():ReDefine( 320, { | u | If( PCount()==0, ::dFechaHasta, ::dFechaHasta:= u ) }, ::oDlgSelect,,,,,,,,, .F., {||     ( !::lFecha )},, .F., .T.,,,,,, nil,,, )



   ::oChkSelect := TCheckBox():ReDefine( 160, { | u | If( PCount()==0, ::lChkSelect, ::lChkSelect:= u ) }, ::oDlgSelect,,,,,,, .F.,, .F. )



   ::oChkUnSelect := TCheckBox():ReDefine( 180, { | u | If( PCount()==0, ::lChkUnSelect, ::lChkUnSelect:= u ) }, ::oDlgSelect,,,,,,, .F.,, .F. )

   ::oTreeSelect  := TTreeView():Redefine( 170, ::oDlgSelect )




   TButton():ReDefine( 1, {||( ::EvalSelect( bAction, ::oMtrSelect ), if( lClose, ::oDlgSelect:end(), if( !Empty( ::oWndBrw:oBrw ), ::oWndBrw:oBrw:Refresh(), ) ) )}, ::oDlgSelect,,, .F.,,,, .F. )




   ::oBtnCancel := TButton():ReDefine( 2, {||( ::oDlgSelect:end() )}, ::oDlgSelect,,, .F.,,,, .F. )






   ::oMtrSelect := TMeter():ReDefine( 200, { | u | If( PCount()==0, nMtrInf, nMtrInf:= u ) }, ::oDbf:LastRec(), ::oDlgSelect, .F.,, "Proceso", .F.,,,, )

   ::oDlgSelect:AddFastKey( 116, {|| ::EvalSelect( bAction, ::oMtrSelect ), if( lClose, ::oDlgSelect:end(), if( !Empty( ::oWndBrw:oBrw ), ::oWndBrw:oBrw:Refresh(), ) ) } )

   ::oDlgSelect:bStart := {|| ::StartSelect( cChkTitle, oSerDocIni, oSerDocFin, oImageList ), ::oTreeSelect:SetImageList( oImageList ) }

   ::oDlgSelect:Activate( ::oDlgSelect:bLClicked, ::oDlgSelect:bMoved, ::oDlgSelect:bPainted, .T.,,,, ::oDlgSelect:bRClicked,,, )

RETURN ( Self )



UTILITY STATIC function TMasDet_StartSelect( cChkTitle, oSerDocIni, oSerDocFin, oImageList) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   ::oTreeSelect:SetImageList( oImageList )

   if Empty( cChkTitle )
      ::oChkSelect:Hide()
   else
      SetWindowText( ::oChkSelect:hWnd, cChkTitle )
      ::oChkSelect:Refresh()
   end

   ::oChkUnSelect:Hide()

   if Empty( ::cSerDocKey )
      oSerDocIni:Hide()
      oSerDocFin:Hide()
   end

RETURN ( Self )



UTILITY STATIC function TMasDet_EvalSelect( bAction) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local nPos
   local aPos
   local cSeek
   local bCond
   local lWhile   := .T.





   if ::lMoveDlgSelect
      aPos        := { 0, 0 }
      ClientToScreen( ::oDlgSelect:hWnd, aPos )
      ::oDlgSelect:Move( aPos[ 1 ] - 22, aPos[ 2 ] - 510 )
   end

   ::oDbf:GetStatus()

   ::oDlgSelect:Disable()

   ::oTreeSelect:Enable()
   ::oTreeSelect:DeleteAll()

   ::oBtnCancel:bAction := {|| lWhile := .F. }
   ::oBtnCancel:Enable()

   if ::nRadSelect == 1

      for each nPos in ( ::oWndBrw:oBrw:aSelected )

         ::oDbf:GoTo( nPos )

         Eval( bAction, ::lChkSelect )

         ::oMtrSelect:Set( ::oDbf:OrdKeyNo() )

         SysRefresh()

         if !lWhile
            exit
         end

      next

      ::oMtrSelect:Set( ::oDbf:LastRec() )

   else





      if ::cSerDocKey == nil

         cSeek       := Str( ::nNumDocIni, ::nLenDocIni ) + ::cSufDocIni





         if ::lNumDocChr


            bCond    := {||   ::oDbf:FieldGetName( ::cNumDocKey ) + ::oDbf:FieldGetName( ::cSufDocKey ) >= Str( ::nNumDocIni, ::nLenDocIni ) + ::cSufDocIni .AND. ::oDbf:FieldGetName( ::cNumDocKey ) + ::oDbf:FieldGetName( ::cSufDocKey ) <= Str( ::nNumDocFin, ::nLenDocIni ) + ::cSufDocFin }

         else



            bCond    := {||   Str( ::oDbf:FieldGetName( ::cNumDocKey ), ::nLenDocIni ) + ::oDbf:FieldGetName( ::cSufDocKey ) >= Str( ::nNumDocIni, ::nLenDocIni ) + ::cSufDocIni .AND. Str( ::oDbf:FieldGetName( ::cNumDocKey ), ::nLenDocIni ) + ::oDbf:FieldGetName( ::cSufDocKey ) <= Str( ::nNumDocFin, ::nLenDocIni ) + ::cSufDocFin .AND. !::oDbf:Eof() }

         end

      else

         cSeek       := ::cSerDocIni + Str( ::nNumDocIni, ::nLenDocIni ) + ::cSufDocIni

         bCond       := {|| ::oDbf:FieldGetName( ::cSerDocKey ) + Str( ::oDbf:FieldGetName( ::cNumDocKey ), ::nLenDocIni ) + ::oDbf:FieldGetName( ::cSufDocKey ) >= Str( ::nNumDocIni, ::nLenDocIni ) + ::cSufDocIni .AND. ::oDbf:FieldGetName( ::cSerDocKey ) + Str( ::oDbf:FieldGetName( ::cNumDocKey ), ::nLenDocIni ) + ::oDbf:FieldGetName( ::cSufDocKey ) <= Str( ::nNumDocFin, ::nLenDocIni ) + ::cSufDocFin }

      end

      ::oDbf:Seek( cSeek, .T. )

      ::oMtrSelect:Set( ::oDbf:OrdKeyNo() )

      while ( lWhile ) .AND. Eval( bCond ) .AND. !::oDbf:eof()

         Eval( bAction, ::lChkSelect )

         ::oDbf:Skip()

         ::oMtrSelect:Set( ::oDbf:OrdKeyNo() )

      end

      ::oMtrSelect:Set( ::oDbf:LastRec() )

   end

   ::oDbf:SetStatus()

   ::oBtnCancel:bAction := {|| ::oDlgSelect:End() }

   if ::lMoveDlgSelect
      WndCenter( ::oDlgSelect:hWnd )
   end

   ::oDlgSelect:Enable()

RETURN NIL



UTILITY STATIC function TMasDet_AddDetail( oDetail) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if ::oDbfDet == nil
      ::oDbfDet   := {}
   end

   aAdd( ::oDbfDet, oDetail )

RETURN ( Self )



UTILITY STATIC function TMasDet_Activate() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if nAnd( ::nLevel, 1 ) == 0





      if ::oWndParent <> nil
         ::oWndParent:CloseAll()
      end

      if Empty( ::oDbf )
         if !::OpenFiles()
            return nil
         end
      end





      if !::lCreateShell
         ::CreateShell( ::nLevel )
      end

      if ::lAutoButtons
         ::oWndBrw:AutoButtons( Self )
      end

      if ::cHtmlHelp <> nil
         ::oWndBrw:cHtmlHelp  := ::cHtmlHelp
      end

      ::oWndBrw:Activate(  nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, {|| ::CloseFiles() } )

   else

      msgStop( "Acceso no permitido." )

   end

RETURN ( Self )



UTILITY STATIC function TMasDet_oDefDiv( nId, nIdBmp, nIdChg, oDlg, nMode) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local oCodDiv
   local oVdvDiv

   local This        := Self

   IIF( nId == nil, nId := 1130, ) ;
   IIF( nIdBmp == nil, nIdBmp := 1131, ) ;
   IIF( nIdChg == nil, nIdChg := 1132, ) ;
   IIF( oDlg == nil, oDlg := ::oFld:aDialogs[1], ) ;
   IIF( nMode == nil, nMode := 1, ) ;

   if Empty( ::oDbfDiv )
      ::oDbfDiv := DbfServer( "DIVISAS.DBF", ):NewOpen( "DIVISAS.DBF",, ( cDriver() ),, ( cPatDat() ), .F., .T., .F., .F. ) ; ::oDbfDiv:AddBag( "DIVISAS.CDX" ) ; ::oDbfDiv:AddBag( ) ; ::oDbfDiv:AutoIndex()
   end

   if Empty( ::oBandera )
      ::oBandera     := TBandera():New()
   end

   if Empty( ::oDbf:cCodDiv )
      ::oDbf:cCodDiv := cDivEmp()
   end








   oCodDiv := TGetHlp():ReDefine( ( nId ), { | u | If( PCount()==0, ::oDbf:cCodDiv, ::oDbf:cCodDiv:= u ) }, oDlg,, "@!", {||    ( This:lLoadDivisa() )},,,,,, .F., {||     ( nMode == 1 )},, .F., .F.,,,,, {|Self|( BrwDiv( oCodDiv, This:oBmpDiv, oVdvDiv, This:oDbfDiv:cAlias, This:oBandera ), This:lLoadDivisa() )}, nil, "LUPA",, )




   ::oBmpDiv := TBitmap():ReDefine( ( nIdBmp ), "BAN_EURO",, oDlg,,, .F., .F.,,, .F.,,, .F. )





   oVdvDiv := TGetHlp():ReDefine( ( nIdChg ), { | u | If( PCount()==0, ::oDbf:nVdvDiv, ::oDbf:nVdvDiv:= u ) }, oDlg,, "@E 999,999.9999",,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )

   ::lLoadDivisa()

RETURN ( Self )



UTILITY STATIC function TMasDet_CloseFiles() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if !Empty( ::oDbf ) .AND. ::oDbf:Used()
      ::oDbf:End()
   end

   if Valtype( ::oDbfDet ) == "A"
      aSend( ::oDbfDet, "End()" )
   else
      ::oDbfDet:End()
   end

RETURN ( .T. )



UTILITY STATIC function TMasDet_End() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if ::oDbfDiv <> nil .AND. ::oDbfDiv:Used()
      ::oDbfDiv:End()
      ::oDbfDiv   := nil
   end

   if ::oBandera <> nil
      ::oBandera:End()
      ::oBandera  := nil
   end

   ::TMant:End()

RETURN ( .T. )



UTILITY STATIC function TMasDet_EndResource( lOk, nMode, oDlg) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if !Empty( oDlg )
      oDlg:Disable()
   end

   do case
      case nMode == 1
         ::EndAppend( lOk )

      case nMode == 4
         ::EndDup( lOk )

      case nMode == 2
         ::EndEdit( lOk )

   end

   if !Empty( oDlg )
      oDlg:Enable()
   end

Return ( lOk )



UTILITY STATIC function TMasDet_nRegisterToProcess() ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local nRegisterToProcess   := 0

   do case
      case IsObject( ::oDbfDet )
         nRegisterToProcess   += ::oDbfDet:nRegisterLoaded
         nRegisterToProcess   += ::oDbfVir:LastRec()

      case IsArray( ::oDbfDet )
         aEval( ::oDbfDet, {|o| nRegisterToProcess += o:nRegisterLoaded } )
         aEval( ::oDbfDet, {|o| nRegisterToProcess += o:oDbfVir:LastRec() } )

   end

RETURN ( nRegisterToProcess )



function oCopy( oDbfOrg, oDbfDes, lApp )

    local i
   local nField   := oDbfOrg:FCount()

    IIF( lApp == nil, lApp := .F., ) ;

   if lApp
      ( oDbfOrg:nArea )->( dbAppend() )
   else
      ( oDbfDes:nArea )->( dbRLock() )
   end

    for i = 1 to nField
      ( oDbfDes:nArea )->( FieldPut( i, ( oDbfOrg )->( FieldGet( i ) ) ) )
    next

RETURN NIL



function ObjInspect( oObject, cTitle )

   local oIco
   local oBrw
   local oWndObj
   local aObjInfo
   local nItem       := 1

   CursorWait()











   IIF( aObjBmps == nil, aObjBmps := {  "Array"    , "Block"    , "Chain"    , "Date"     , "Logic"    , "Number"   , "Memo"     , "Object"   , "Undefined", "SmallBug" , "NoInfo"   }, ) ;

   if ValType( oObject ) == "O"
      aObjInfo = aOData( oObject )

      AEval( aObjInfo, { | cData, n | aObjInfo[ n ] := cChr2Data( cData ) } )
   endif



   IIF( cTitle == nil, cTitle := If( ValType( oObject ) == "O", "Object Inspector", "Array Inspector" ), ) ;

   oIco := TIcon():New( ,, "Objects",, )





   oWndObj := TMdiChild():New( 1, 1, 23, 33, If( ValType( oObject ) == "O", "Object Inspector: ", "Array Inspector: " ) + cTitle,,, oWnd(), oIco, .F.,,,,, .F., .F.,,, !.F., !.F., !.F., !.F., )






   oBrw := TWBrowse():New( 0, 0, 400, 400, {|| {"" } }, {"  ", "Data", "Value"}, {16, 90, 300}, oWndObj,,,,, {|nRow,nCol,nFlags|DataInspect( oObject, nItem, aObjInfo, cTitle )},,,,,,, .F.,, .F.,, .F.,,, )

   oBrw:bLine = { || aGetData( oObject, nItem, aObjInfo, cTitle ) }



   oBrw:bGoTop    = { || nItem := 1 }
   oBrw:bGoBottom = { || nItem := Eval( oBrw:bLogicLen ) }



   oBrw:bSkip     = { | nWant, nOld | nOld := nItem, nItem += nWant, nItem := Max( 1, Min( nItem, Eval( oBrw:bLogicLen ) ) ), nItem - nOld }


   oBrw:bLogicLen = { || If( ValType( oObject ) == "O", Len( aObjInfo ), Len( oObject ) ) }
   oBrw:cAlias    = "Array"

   oWndObj:SetControl( oBrw )

   oWndObj:Activate(, oWndObj:bLClicked, oWndObj:bRClicked, oWndObj:bMoved, oWndObj:bResized, oWndObj:bPainted, oWndObj:bKeyDown, oWndObj:bInit,,,,,,,,,,, oWndObj:bLButtonUp )

return nil



static function cGetData( uData, cType )

   local cResult := ""

   do case
      case cType == "B"
           cResult = "{ || ... }"

      case cType == "A"
           cResult = "[ ... ]"

      case cType == "O"
           cResult = "Object"

      case cType == "U"
           cResult = "Undefined"

      otherwise
           cResult = cValToChar( uData )
   endcase

return cResult



static function DataInspect( oObject, nItem, aObjInfo, cTitle )

   local cType := ValType( oObject )
   local cData, uData

   do case
      case cType == "A"
           cData = "[ " + AllTrim( Str( nItem ) ) + " ]"
           if Len( oObject[ nItem ] ) > 0
              ObjInspect( oObject[ nItem ], cTitle + cData )
           else
              MsgInfo( "Array is empty!", "Attention" )
           endif

      case cType == "O"
           cData = aObjInfo[ nItem ]
           uData = OSend( oObject, cData )
           if ValType( uData ) $ "AO"
              ObjInspect( OSend( oObject, cData ), cTitle + ":" + cData )
           else
              MsgInfo( "I don't find an Object or an Array there!", "Attention" )
           endif
   endcase

return nil



static function aGetData( oObject, nItem, aObjInfo )

   local uData, cData, cType

   do case
      case ValType( oObject ) == "A"
           uData = oObject[ nItem ]
           cData = "[ " + AllTrim( Str( nItem ) ) + " ]"

      case ValType( oObject ) == "O"
           uData = OSend( oObject, aObjInfo[ nItem ] )
           cData = aObjInfo[ nItem ]
   endcase

   cType = ValType( uData )

return { aObjBmps[ At( cType, "ABCDLNMOU" ) ], cData, cGetData( uData, cType ) }



static function cGetHierarchy( oObject )

   local nClass   := oObject:ClassH
   local cClasses := "Class Hierarchy:" + Chr(13)+Chr(10)
   local n := 1

   while n < nClass
      if oObject:ChildLevel( __ClassIns( n ) ) <> 0
         cClasses += __ClassNam( n ) + Chr(13)+Chr(10)
      endif
      n++
   end

   cClasses += oObject:ClassName()

return cClasses
