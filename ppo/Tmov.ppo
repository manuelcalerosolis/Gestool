#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 20 ".\Prg\Tmov.prg"
static oWndBrw
static dbfTMov
static bEdit := { |aTemp, aoGet, dbfTMov, oBrw, bWhen, bValid, nMode | EdtRec( aTemp, aoGet, dbfTMov, oBrw, bWhen, bValid, nMode ) }



function aItmMovAlm()

   local aItmMovAlm  := {}

   aAdd( aItmMovAlm, { "CCODMOV",   "C",  2,  0, "Código tipo de movimiento" ,       "",     "", "( cDbf )"} )
   aAdd( aItmMovAlm, { "CDESMOV",   "C", 20,  0, "Descripción tipo de movimiento" ,  "",     "", "( cDbf )"} )
   aAdd( aItmMovAlm, { "NTIPMOV",   "N",  1,  0, "Tipo de movimiento" ,              "",     "", "( cDbf )"} )
   aAdd( aItmMovAlm, { "LRECMOV",   "L",  1,  0, "Recalculable" ,                    "",     "", "( cDbf )"} )
   aAdd( aItmMovAlm, { "LMODMOV",   "L",  1,  0, "Modificable" ,                     "",     "", "( cDbf )"} )

return ( aItmMovAlm )



STATIC FUNCTION OpenFiles( cPatEmp )

   local lOpen       := .T.
   local oBlock      := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   local oError

   IIF( cPatEmp == nil, cPatEmp := cPatEmp(), ) ;

   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TMOV.DBF" ), ( cCheckArea( "TMOV", @dbfTMov ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TMOV.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Imposible abrir todas las bases de datos de tipos de movimientos" )

      CloseFiles()

      lOpen          := .F.

   end

   ErrorBlock( oBlock )

RETURN lOpen



STATIC FUNCTION CloseFiles()

   ( dbfTMOV )->( dbCloseArea() )

   oWndBrw  := nil

RETURN ( .T. )





FUNCTION TMov( oMenuItem, oWnd )

   local nLevel
   local aDbfBmp

   IIF( oMenuItem == nil, oMenuItem := "01042", ) ;
   IIF( oWnd == nil, oWnd := oWnd(), ) ;

   if oWndBrw == nil





      nLevel            := nLevelUsr( oMenuItem )
      if nAnd( nLevel, 1 ) <> 0
         msgStop( "Acceso no permitido." )
         return nil
      end





      if oWnd <> nil
         SysRefresh(); oWnd:CloseAll(); SysRefresh()
      end





      if !OpenFiles()
         return nil
      end





      AddMnuNext( "Cajeros", ProcName() )














   oWndBrw := TShell():New( 2, 10, 18, 70, "Tipos de movimientos de almacén",, oWnd,,, .F.,,, ( dbfTMov ),,,,, {"Codigo",    "Nombre"}, {||( WinAppRec( oWndBrw:oBrw, bEdit, dbfTMov ) )}, {||( if( !( dbfTMov )->lModMov, WinEdtRec( oWndBrw:oBrw, bEdit, dbfTMov ), MsgInfo( "Imposible modificar este movimiento" ) ), .F. )}, {||( if( !( dbfTMov )->lModMov, DBDelRec(  oWndBrw:oBrw, dbfTMov ),        MsgInfo( "Imposible eliminar este movimiento" ) ),  .F. )}, {||( WinDupRec( oWndBrw:oBrw, bEdit, dbfTMov ) )}, nil, nLevel, "Package_replace2_16", ( 106 + ( 70 * 256 ) + ( 18 * 65536 ) ),,, .T. )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Tipo"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfTMov )->nTipMov <= 1 }
         :nWidth           := 20
         :SetCheck( { "Sel16", "Cnt16" } )
         :AddResource( "reemplazar_16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodMov"
         :bEditValue       := {|| ( dbfTMov )->cCodMov }
         :nWidth           := 100
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cDesMov"
         :bEditValue       := {|| ( dbfTMov )->cDesMov }
         :nWidth           := 280
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      oWndBrw:CreateXFromCode()





      oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

      oWndBrw:AddSeaBar()








      oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







        oWndBrw:NewAt( "DUP",,, {||( oWndBrw:RecDup() )}, "(D)uplicar", "D",,, 2,, .F. )







        oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )







        oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdit, dbfTMov ) )}, "(Z)oom", "Z",,, 8,, .F. )







        oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )








        oWndBrw:NewAt( "IMP",,, {||( InfMovAlm():New( "Listado de tipos de movimientos de almacén" ):Play() )}, "(L)istado", "L",,, 32,, .F. )







      oWndBrw:NewAt( "END",,, {||( oWndBrw:End() )}, "(S)alir", "S",,,,, .F. )

      oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles( aDbfBmp ) )},, oWndBrw:bLButtonUp )

    ELSE

        oWndBrw:SetFocus()

    end

RETURN NIL





STATIC FUNCTION EdtRec( aTemp, aoGet, dbfTMov, oBrw, bWhen, bValid, nMode )

    local oDlg
    local oGet
   local oGet2

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "tipos de Movimientos", "TIPOMOV",, .F.,,,,,, .F.,,,,,, .F., )







        oGet := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTemp[1], aTemp[1]:= u ) }, oDlg,, "@!", {||    ( NotValid( oGet, dbfTMov, .T., "0" ) )}, "N/W*",,,,, .F., {||     ( nMode == 1 .OR. nMode == 4 )},, .F., .F.,,,,,, nil,,, )





      oGet2 := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTemp[2], aTemp[2]:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )




        TRadMenu():Redefine( { | u | If( PCount()==0, aTemp[3], aTemp[3]:= u ) }, oDlg,, { 130, 131 },,,,, .F., {||         ( nMode <> 3 )}, )





      TButton():ReDefine( 1, {||( if( lPreSave( aTemp, nMode, oGet, oGet2, dbfTMov ), ( WinGather( aTemp, aoGet, dbfTMov, oBrw, nMode ), oDlg:end( 1 ) ), ) )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )




   TButton():ReDefine( 559, {||( ChmHelp( "Tipos_de_Movimientos" ) )}, oDlg,,, .F.,,,, .F. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| if( lPreSave( aTemp, nMode, oGet, oGet2, dbfTMov ), ( WinGather( aTemp, aoGet, dbfTMov, oBrw, nMode ), oDlg:end( 1 ) ), ) } )
   end

   oDlg:AddFastKey ( 112, {|| ChmHelp( "Tipos_de_Movimientos" ) } )

   oDlg:bStart := {|| oGet:SetFocus() }

    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN ( oDlg:nResult == 1 )



STATIC FUNCTION lPreSave( aTemp, nMode, oGet, oGet2, dbfTMov )

   if nMode == 1 .OR. nMode == 4

      if Empty( aTemp[1] )
         MsgStop("El código del tipo de movimiento no puede estar vacío.")
         oGet:SetFocus()
         Return .F.
      end

      if dbSeekInOrd( aTemp[1], "CCODMOV", dbfTMov )
         MsgStop( "Código ya existe " + Rtrim( aTemp[1] ) )
         return .F.
      end

   end

   if Empty( aTemp[ 2 ] )
      MsgStop("La descripción del tipo de movimiento no puede estar vacía.")
      oGet2:SetFocus()
      Return .F.
   end

Return .T.





STATIC FUNCTION GenReport( dbfTMov )

    local oReport
    local oFont1
    local oFont2
    local nRecno         := ( dbfTMov )->( RecNo() )
   local cTitulo     := Padr( cCodEmp() + " - " + cNbrEmp(), 50 )
   local cSubTitulo  := Padr( "Listado de tipos de movimientos de almacen", 50 )
    local nDevice        := 1





    IF SetRep( @cTitulo, @cSubTitulo, @nDevice )

        (dbfTMov)->(DbGoTop())





      oFont1 := TFont():New( "Courier New", 0, -10,, .T.,,,,,,,,,,,, )
      oFont2 := TFont():New( "Courier New", 0, -10,,,,,,,,,,,,,, )

        IF nDevice == 1








            oReport := RptBegin({{||      Rtrim( cTitulo )}, {||    Rtrim( cSubTitulo )}}, {{||   "Fecha : " + dtoc(date())}}, {{||   "Página : " + str( oReport:nPage, 3 )}}, {oFont1, oFont2}, {}, .F.,,,, .T.,,, "Listando tipos de movimientos",, UPPER("RIGHT"), UPPER("CENTERED") )

        ELSE








            oReport := RptBegin({{||      Rtrim( cTitulo )}, {||    Rtrim( cSubTitulo )}}, {{||   "Fecha : " + dtoc(date())}}, {{||   "Página : " + str( oReport:nPage, 3 )}}, {oFont1, oFont2}, {}, .F.,,, .T., .F.,,, "Listando tipos de movimientos",, UPPER("RIGHT"), UPPER("CENTERED") )

        end



            RptAddColumn( {{|| "Tipo"}}, , {{||     (dbfTMov)->CCODMOV}},, {} , {||     2}, .F., ,, .F., .F.,, .F., .F.,,, .F., )



         RptAddColumn( {{|| "Descripción"}}, , {{||     (dbfTMov)->CDESMOV}},, {} , {||     2}, .F., ,, .F., .F.,, .F., .F.,,, .F., )

        RptEnd()

      IF !Empty( oReport ) .AND. oReport:lCreated
            oReport:Margin(0, 2, 2)
            oReport:bSkip    := {|| (dbfTMov)->(DbSkip()) }
        end

        oReport:Activate(, {|| !(dbfTMov)->(Eof())},,,,,,,,,,,, )

        oFont1:end()
        oFont2:end()

    end

    (dbfTMov)->(DbGoto( nRecno ) )

RETURN NIL





FUNCTION cTMov( oGet, dbfTMov, oGet2, lMessage )

   local oBlock
   local oError
   local lClose      := .F.
   local lValid      := .F.
   local xValor      := oGet:varGet()

   IIF( lMessage == nil, lMessage := .F., ) ;

   if Empty( xValor )
      IIF( oGet2 <> nil, oGet2:cText( "" ), )
      return .T.
   else
      xValor   := RJustObj( oGet, "0" )
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if dbfTMov == NIL
      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TMOV.DBF" ), ( cCheckArea( "TMOV", @dbfTMov ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TMOV.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose      := .T.
   end

   do case
   case ValType( dbfTMov ) == "C"

      If ( dbfTMov )->( dbSeek( xValor ) ) .OR. ( dbfTMov )->( dbSeek( Upper( xValor ) ) )

         oGet:cText( ( dbfTMov )->cCodMov )

         If oGet2 <> NIL
            oGet2:cText( ( dbfTMov )->cDesMov )
         end

         lValid   := .T.

      Else

         msgStop( "Tipo de movimiento no encontrado" )

      end

   case ValType( dbfTMov ) == "O"

      If dbfTMov:Seek( xValor ) .OR. dbfTMov:Seek( Upper( xValor ) )

         oGet:cText( dbfTMov:cCodMov )

         If oGet2 <> NIL
            oGet2:cText( dbfTMov:cDesMov )
         end

         lValid   := .T.

      Else

         msgStop( "Tipo de movimiento no encontrado" )

      end

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

    If lClose
      ( dbfTMov )->( dbCloseArea() )
    end

RETURN lValid



FUNCTION retTMov( dbfTMov, cCodMov )

   local oBlock
   local oError
    local cTemp     := 0
    local dbfAnt     := Alias()
    local lClose    := .F.

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

    IF dbfTMov == NIL
      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TMOV.DBF" ), ( cCheckArea( "TMOV", @dbfTMov ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TMOV.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
        lClose := .T.
    end

   IF ( dbfTMov )->( DbSeek( cCodMov ) )
        cTemp = (dbfTMov)->CDESMOV
    end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

    IF lClose
        ( dbfTMov )->( dbCloseArea() )
    end

    IF dbfAnt <> ""
        dbSelectArea( ( dbfAnt ) )
    end

RETURN cTemp



FUNCTION BrwTMov( oGet, dbfTMov, oGet2 )

   local oBlock
   local oError
    local oDlg
   local oGet1
   local cGet1
    local oBrw
   local nOrd     := GetBrwOpt( "BrwTMov" )
   local oCbxOrd
   local aCbxOrd  := { "Código", "Nombre" }
   local cCbxOrd
   local lClose   := .F.
   local nLevel   := nLevelUsr( "01042" )
   local oBtn
   local oSayTit
   local oFont

   nOrd           := Min( Max( nOrd, 1 ), len( aCbxOrd ) )
   cCbxOrd        := aCbxOrd[ nOrd ]





   if nAnd( nLevel, 1 ) <> 0
      msgStop( "Acceso no permitido." )
      return nil
   end

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      if Empty( dbfTMov )
         dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TMOV.DBF" ), ( cCheckArea( "TMOV", @dbfTMov ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
         if !lAIS() ; ordListAdd( ( cPatDat() + "TMOV.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
         lClose      := .T.
      end

      if ValType( dbfTMov ) == "O"
         dbfTMov     := dbfTMov:cAlias
      end

      ( dbfTMov )->( dbGoTop() )


      oDlg = TDialog():New(,,,,, "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F., )











         oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, dbfTMov ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfTMov ) ) }, .F., .F.,,,,,, nil, "FIND",, )


































         oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( dbfTMov )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:refresh(), oGet1:SetFocus() )},,,, .F.,,,,,, )



         oBrw                 := IXBrowse():New( oDlg )

         oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
         oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

         oBrw:cAlias          := dbfTMov

         oBrw:nMarqueeStyle   := 5
         oBrw:cName           := "Browse.Tipos de movimientos de almacen"

         with object ( oBrw:AddCol() )
            :cHeader          := "Tipo"
            :nHeadBmpNo       := 3
            :bStrData         := {|| "" }
            :bEditValue       := {|| ( dbfTMov )->nTipMov <= 1 }
            :nWidth           := 20
            :SetCheck( { "Sel16", "Cnt16" } )
            :AddResource( "reemplazar_16" )
         end

         with object ( oBrw:AddCol() )
            :cHeader          := "Código"
            :cSortOrder       := "cCodMov"
            :bEditValue       := {|| ( dbfTMov )->cCodMov }
            :nWidth           := 100
            :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
         end

         with object ( oBrw:AddCol() )
            :cHeader          := "Nombre"
            :cSortOrder       := "cDesMov"
            :bEditValue       := {|| ( dbfTMov )->cDesMov }
            :nWidth           := 280
            :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
         end

         oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
         oBrw:bRClicked       := {| nRow, nCol, nFlags | oBrw:RButtonDown( nRow, nCol, nFlags ) }

         oBrw:CreateFromResource( 105 )






















         TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




         TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )






         TButton():ReDefine( 500, {||( WinAppRec( oBrw, bEdit, dbfTMov ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 2 ) <> 0 )},,, .F. )




         TButton():ReDefine( 501, {||( WinEdtRec( oBrw, bEdit, dbfTMov ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 4 ) <> 0 )},,, .F. )

      oDlg:AddFastKey( 113,       {|| if( nAnd( nLevel, 2 ) <> 0, WinAppRec( oBrw, bEdit, dbfTMov ), ) } )
      oDlg:AddFastKey( 114,       {|| if( nAnd( nLevel, 4 ) <> 0, WinEdtRec( oBrw, bEdit, dbfTMov ), ) } )
      oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
      oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

      oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )








      if oDlg:nResult == 1

         oGet:cText( ( dbfTMov )->cCodMov )
         oGet:lValid()

         if ValType( oGet2 ) == "O"
            oGet2:cText( ( dbfTMov )->cDesMov )
         end

      end

      oGet:setFocus()

      DestroyFastFilter( dbfTMov )

      SetBrwOpt( "BrwTMov", ( dbfTMov )->( OrdNumber() ) )

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClose
        ( dbfTMov )->( dbCloseArea() )
   end

RETURN ( oDlg:nResult == 1 )




























FUNCTION lTMov( dbfTMov, cCodMov )

   local oBlock
   local oError
    local lReturn
    local nOrdAnt
   local lClose   := .F.

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

    IF dbfTMov == NIL
      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TMOV.DBF" ), ( cCheckArea( "TMOV", @dbfTMov ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TMOV.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose      := .T.
   end

   if ( dbfTMov )->( dbSeek( cCodMov ) )
      lReturn     := .T.
   else
      MsgStop( "Tipo de movimiento inexistente" )
      lReturn     := .F.
   end

   ( dbfTMov )->( OrdSetFocus( nOrdAnt ) )

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

    IF lClose
        ( dbfTMov )->( dbCloseArea() )
    end

RETURN lReturn



FUNCTION mkTMov( cPath, lAppend )

   local nCont
    local dbfTMov


   local aTMov := {  { "EI", "Exs. Iniciales",     1, .T., .T. }, { "MV", "Movimientos",        2, .T., .T. }, { "RG", "Reg. Almacen",       2, .T., .T. } }

    IIF( lAppend == nil, lAppend := .F., ) ;

   dbCreate( cPath + "TMOV.DBF", aSqlStruct( aItmMovAlm() ), cDriver() )







   dbUseArea( .T., cDriver(), cPath + "TMOV.DBF", cCheckArea( "TMOV", @dbfTMov ), .F. )
   for nCont := 1 to Len( aTMov )
      dbGather( aTMov[ nCont ], dbfTMov, .T. )
   next
    ( dbfTMov )->( dbCloseArea() )



RETURN .T.



FUNCTION rxTMov( cPath, oMeter )

    local dbfTMov

   IIF( cPath == nil, cPath := cPatDat(), ) ;

   if !lExistTable( cPath + "TMOV.DBF" )
        mkTMov( cPath )
   end

   fEraseIndex( cPath + "TMOV.DCX" )

   dbUseArea( .T., cDriver(), cPath + "TMOV.DBF", cCheckArea( "TMOV", @dbfTMov ), .F. )
   if !( dbfTMov )->( neterr() )
      ( dbfTMov )->( __dbPack() )

      ( dbfTMov )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfTMov )->( ordCreate( cPath + "TMOV.CDX", "CCODMOV", "Field->CCODMOV", {|| Field->CCODMOV }, ) )

      ( dbfTMov )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfTMov )->( ordCreate( cPath + "TMOV.CDX", "CDESMOV", "Field->CDESMOV", {|| Field->CDESMOV } ) )

      ( dbfTMov )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de movimientos de almacén" )
   end

RETURN NIL



FUNCTION IsTMov( cPath )

   IIF( cPath == nil, cPath := cPatDat(), ) ;

   if !lExistTable( cPath + "TMOV.Dbf" )
      dbCreate( cPath + "TMOV.DBF", aSqlStruct( aItmMovAlm() ), cDriver() )
   end

   if !lExistIndex( cPath + "TMOV.Cdx" )
      rxTMov( cPath )
   end

Return ( .T. )
