#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 439 ".\Prg\Wbrowse.prg"
extern DBSKIP



_HB_CLASS TWBrowse ; UTILITY FUNCTION TWBrowse(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TWBrowse" , {TControl():classh} ) ) ; ;

   _HB_MEMBER { cAlias, cField, uValue1, uValue2} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAlias" , "cField" , "uValue1" , "uValue2" }, .F., .F. ), )
   _HB_MEMBER { bLine, bSkip, bGoTop, bGoBottom, bLogicLen, bChange, bAdd} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bLine" , "bSkip" , "bGoTop" , "bGoBottom" , "bLogicLen" , "bChange" , "bAdd" }, .F., .F. ), )
   _HB_MEMBER { nRowPos, nColPos, nLen, nAt, nColAct} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nRowPos" , "nColPos" , "nLen" , "nAt" , "nColAct" }, .F., .F. ), )



   _HB_MEMBER { nMaxFilter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nMaxFilter" }, .F., .F. ), )

   _HB_MEMBER { lHitTop, lHitBottom, lCaptured, lMChange} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lHitTop" , "lHitBottom" , "lCaptured" , "lMChange" }, .F., .F. ), )
   _HB_MEMBER { lAutoEdit, lAutoSkip} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lAutoEdit" , "lAutoSkip" }, .F., .F. ), )
   _HB_MEMBER {AS LOGICAL lCellStyle} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lCellStyle" }, .F., .F. ), )
   _HB_MEMBER { aHeaders, aColSizes} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aHeaders" , "aColSizes" }, .F., .F. ), )
   _HB_MEMBER { nClrBackHead, nClrForeHead} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrBackHead" , "nClrForeHead" }, .F., .F. ), )
   _HB_MEMBER { nClrBackFocus, nClrForeFocus} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrBackFocus" , "nClrForeFocus" }, .F., .F. ), )
   _HB_MEMBER { aJustify, aActions} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aJustify" , "aActions" }, .F., .F. ), )
   _HB_MEMBER { oGet} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oGet" }, .F., .F. ), )
   _HB_MEMBER { nLineStyle} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nLineStyle" }, .F., .F. ), )
   _HB_MEMBER { lIconView, aIcons, bIconDraw, bIconText} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lIconView" , "aIcons" , "bIconDraw" , "bIconText" }, .F., .F. ), )
   _HB_MEMBER { nIconPos} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nIconPos" }, .F., .F. ), )

   _HB_MEMBER { bLogicPos} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bLogicPos" }, .F., .F. ), )
   _HB_MEMBER { bGoLogicPos} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bGoLogicPos" }, .F., .F. ), )
   _HB_MEMBER { lAdjLastCol} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lAdjLastCol" }, .F., .F. ), )
   _HB_MEMBER { lAdjBrowse} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lAdjBrowse" }, .F., .F. ), )
   _HB_MEMBER { lDrawHeaders} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lDrawHeaders" }, .F., .F. ), )
   _HB_MEMBER { aHJustify} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aHJustify" }, .F., .F. ), )
   _HB_MEMBER { bTextColor, bBkColor} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bTextColor" , "bBkColor" }, .F., .F. ), )
   _HB_MEMBER { nClrLine} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrLine" }, .F., .F. ), )

   _HB_MEMBER { aFooters} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aFooters" }, .F., .F. ), )
   _HB_MEMBER { lDrawFooters} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lDrawFooters" }, .F., .F. ), )
   _HB_MEMBER { aFJustify} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aFJustify" }, .F., .F. ), )
   _HB_MEMBER { nClrFBack, nClrFFore} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrFBack" , "nClrFFore" }, .F., .F. ), )
   _HB_MEMBER { nClrNFBack, nClrNFFore} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrNFBack" , "nClrNFFore" }, .F., .F. ), )

   _HB_MEMBER { lVScroll} ; IIF( !.F., s_oClass:AddMultiClsData(,, nScope + IIF( .F., 32, 0 ) + 64, { "lVScroll" }, .F. ), )
   _HB_MEMBER { lHScroll} ; IIF( !.F., s_oClass:AddMultiClsData(,, nScope + IIF( .F., 32, 0 ) + 64, { "lHScroll" }, .F. ), )
   _HB_MEMBER { nFreeze} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nFreeze" }, .F., .F. ), )
   _HB_MEMBER { aTmpColSizes} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aTmpColSizes" }, .F., .F. ), )
   _HB_MEMBER { bEdit} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bEdit" }, .F., .F. ), )
   _HB_MEMBER { lDrawSelect} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lDrawSelect" }, .F., .F. ), )
   _HB_MEMBER { lOnlyBorder} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lOnlyBorder" }, .F., .F. ), )
   _HB_MEMBER { lDrawFocusRect} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lDrawFocusRect" }, .F., .F. ), )

   _HB_MEMBER { nHeaderHeight} ; IIF( !.F., s_oClass:AddMultiData(, -1, nScope + IIF( .F., 32, 0 ), { "nHeaderHeight" }, .F., .F. ), )
   _HB_MEMBER { nFooterHeight} ; IIF( !.F., s_oClass:AddMultiData(, -1, nScope + IIF( .F., 32, 0 ), { "nFooterHeight" }, .F., .F. ), )
   _HB_MEMBER { nLineHeight} ; IIF( !.F., s_oClass:AddMultiData(, -1, nScope + IIF( .F., 32, 0 ), { "nLineHeight" }, .F., .F. ), )
   _HB_MEMBER { bFont} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bFont" }, .F., .F. ), )
   _HB_MEMBER { lSelect} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lSelect" }, .F., .F. ), )


   _HB_MEMBER { lWorking} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lWorking" }, .F., .F. ), )
   _HB_MEMBER { cBuffer} ; IIF( !.F., s_oClass:AddMultiData(, "", nScope + IIF( .F., 32, 0 ), { "cBuffer" }, .F., .F. ), )
   _HB_MEMBER { nBuffer} ; IIF( !.F., s_oClass:AddMultiData(, 50, nScope + IIF( .F., 32, 0 ), { "nBuffer" }, .F., .F. ), )
   _HB_MEMBER { bSeek} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bSeek" }, .F., .F. ), )
   _HB_MEMBER { bUpdateBuffer} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bUpdateBuffer" }, .F., .F. ), )

   _HB_MEMBER { bGoLeft} ; IIF( !.F., s_oClass:AddMultiData(, {|| .T. }, nScope + IIF( .F., 32, 0 ), { "bGoLeft" }, .F., .F. ), )
   _HB_MEMBER { bGoRight} ; IIF( !.F., s_oClass:AddMultiData(, {|| .T. }, nScope + IIF( .F., 32, 0 ), { "bGoRight" }, .F., .F. ), )

   _HB_MEMBER { oTXT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTXT" }, .F., .F. ), )
   _HB_MEMBER { nTXTFrom} ; IIF( !.F., s_oClass:AddMultiData(, 1, nScope + IIF( .F., 32, 0 ), { "nTXTFrom" }, .F., .F. ), )
   _HB_MEMBER { nTXTSkip} ; IIF( !.F., s_oClass:AddMultiData(, 4, nScope + IIF( .F., 32, 0 ), { "nTXTSkip" }, .F., .F. ), )
   _HB_MEMBER { nTXTMaxSkip} ; IIF( !.F., s_oClass:AddMultiData(, 49, nScope + IIF( .F., 32, 0 ), { "nTXTMaxSkip" }, .F., .F. ), )

   _HB_MEMBER { nColFPressed} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nColFPressed" }, .F., .F. ), )
   _HB_MEMBER { nColHPressed} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nColHPressed" }, .F., .F. ), )

   _HB_MEMBER { nHeaderStyle} ; IIF( !.F., s_oClass:AddMultiData(, 3, nScope + IIF( .F., 32, 0 ), { "nHeaderStyle" }, .F., .F. ), )
   _HB_MEMBER { nFooterStyle} ; IIF( !.F., s_oClass:AddMultiData(, 3, nScope + IIF( .F., 32, 0 ), { "nFooterStyle" }, .F., .F. ), )

   _HB_MEMBER { nLogicLen} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nLogicLen" }, .F., .F. ), )
   _HB_MEMBER { lLogicLen} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lLogicLen" }, .F., .F. ), )
   _HB_MEMBER { nLogicPos} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nLogicPos" }, .F., .F. ), )
   _HB_MEMBER { lLogicPos} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lLogicPos" }, .F., .F. ), )
   _HB_MEMBER { lGoTop} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lGoTop" }, .F., .F. ), )
   _HB_MEMBER { lGoBottom} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lGoBottom" }, .F., .F. ), )

   _HB_MEMBER {AS LOGICAL lRegistered} ; IIF( !.F., s_oClass:AddMultiClsData("LOGICAL",, nScope + IIF( .F., 32, 0 ) + 64, { "lRegistered" }, .F. ), )





   _HB_MEMBER { bDel, bDup, bMod, bZoo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bDel" , "bDup" , "bMod" , "bZoo" }, .F., .F. ), )
   _HB_MEMBER { aLinActions} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aLinActions" }, .F., .F. ), )
   _HB_MEMBER { oFontFooter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFontFooter" }, .F., .F. ), )









   _HB_MEMBER New( nRow, nCol, nWidth, nHeigth, bLine, aHeaders,  aColSizes, oWnd, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nForeBack, cMsg, lUpdate, cAlias, lPixel, bWhen, lDesign, bValid, bLClick, aActions) AS CLASS TWBrowse; IIF( .F., s_oClass:ModMethod( "New", @TWBrowse_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TWBrowse_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));




   _HB_MEMBER ReDefine( nId, bLine, oDlg, aHeaders, aColSizes, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nClrBack, cMsg, lUpdate, cAlias, bWhen, bValid, bLClick, aActions) AS CLASS TWBrowse; IIF( .F., s_oClass:ModMethod( "ReDefine", @TWBrowse_ReDefine(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReDefine", @TWBrowse_ReDefine(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nAtCol(nCol); IIF( .F., s_oClass:ModInline( "nAtCol", {|Self,nCol | Self, ::nWCol( nCol ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "nAtCol", {|Self,nCol | Self, ::nWCol( nCol ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER nAtIcon( nRow, nCol); IIF( .F., s_oClass:ModMethod( "nAtIcon", @TWBrowse_nAtIcon(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nAtIcon", @TWBrowse_nAtIcon(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER lCloseArea(); IIF( .F., s_oClass:ModInline( "lCloseArea", {|Self | Self, If( ! Empty( ::cAlias ), ( ::cAlias )->( DbCloseArea() ),), If( ! Empty( ::cAlias ), ::cAlias := "",), .T. }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lCloseArea", {|Self | Self, If( ! Empty( ::cAlias ), ( ::cAlias )->( DbCloseArea() ),), If( ! Empty( ::cAlias ), ::cAlias := "",), .T. }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER LDblClick( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "LDblClick", @TWBrowse_LDblClick(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LDblClick", @TWBrowse_LDblClick(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Default(); IIF( .F., s_oClass:ModMethod( "Default", @TWBrowse_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Default", @TWBrowse_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER BugUp(); IIF( .F., s_oClass:ModInline( "BugUp", {|Self | Self, ::UpStable() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "BugUp", {|Self | Self, ::UpStable() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Display(); IIF( .F., s_oClass:ModMethod( "Display", @TWBrowse_Display(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Display", @TWBrowse_Display(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DrawIcons(); IIF( .F., s_oClass:ModMethod( "DrawIcons", @TWBrowse_DrawIcons(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DrawIcons", @TWBrowse_DrawIcons(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));








   _HB_MEMBER DrawLine(nRow); IIF( .F., s_oClass:ModInline( "DrawLine", {|Self,nRow | Self, WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight ), wBrwLine( ::hWnd, ::hDC, If( nRow == nil, ::nRowPos, nRow ),  Eval( ::bLine ), ::GetColSizes(), ::nColPos, ::nClrText, ::nClrPane, If( ::oFont <> nil, ::oFont:hFont, 0 ), ValType( ::aColSizes ) == "B", ::aJustify, nil, ::nLineStyle, 0, .F., ::bTextColor, ::bBkColor, ::nClrLine,,,::bFont ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "DrawLine", {|Self,nRow | Self, WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight ), wBrwLine( ::hWnd, ::hDC, If( nRow == nil, ::nRowPos, nRow ),  Eval( ::bLine ), ::GetColSizes(), ::nColPos, ::nClrText, ::nClrPane, If( ::oFont <> nil, ::oFont:hFont, 0 ), ValType( ::aColSizes ) == "B", ::aJustify, nil, ::nLineStyle, 0, .F., ::bTextColor, ::bBkColor, ::nClrLine,,,::bFont ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER DrawSelect(); IIF( .F., s_oClass:ModMethod( "DrawSelect", @TWBrowse_DrawSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DrawSelect", @TWBrowse_DrawSelect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER lEditCol( nCol, uVar, cPicture, bValid, nClrFore, nClrBack, aItems, bAction); IIF( .F., s_oClass:ModMethod( "lEditCol", @TWBrowse_lEditCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lEditCol", @TWBrowse_lEditCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Edit( nCol, lModal); IIF( .F., s_oClass:ModMethod( "Edit", @TWBrowse_Edit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Edit", @TWBrowse_Edit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER EditCol( nCol, uVar, cPicture, bValid, nClrFore, nClrBack, aItems, bAction); IIF( .F., s_oClass:ModMethod( "EditCol", @TWBrowse_EditCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EditCol", @TWBrowse_EditCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER GetColSizes(); IIF( .F., s_oClass:ModInline( "GetColSizes", {|Self | Self, If( ValType( ::aColSizes ) == "A", ::aColSizes, Eval( ::aColSizes ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetColSizes", {|Self | Self, If( ValType( ::aColSizes ) == "A", ::aColSizes, Eval( ::aColSizes ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER GetDlgCode( nLastKey); IIF( .F., s_oClass:ModMethod( "GetDlgCode", @TWBrowse_GetDlgCode(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetDlgCode", @TWBrowse_GetDlgCode(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GoUp(); IIF( .F., s_oClass:ModMethod( "GoUp", @TWBrowse_GoUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoUp", @TWBrowse_GoUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoDown(); IIF( .F., s_oClass:ModMethod( "GoDown", @TWBrowse_GoDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoDown", @TWBrowse_GoDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoLeft(); IIF( .F., s_oClass:ModMethod( "GoLeft", @TWBrowse_GoLeft(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoLeft", @TWBrowse_GoLeft(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoRight(); IIF( .F., s_oClass:ModMethod( "GoRight", @TWBrowse_GoRight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoRight", @TWBrowse_GoRight(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoTop(); IIF( .F., s_oClass:ModMethod( "GoTop", @TWBrowse_GoTop(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoTop", @TWBrowse_GoTop(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoBottom(); IIF( .F., s_oClass:ModMethod( "GoBottom", @TWBrowse_GoBottom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoBottom", @TWBrowse_GoBottom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER GotFocus(); IIF( .F., s_oClass:ModInline( "GotFocus", {|Self | Self, ::TControl:GotFocus(), If( ::nLen > 0 .AND. ! EmptyAlias( ::cAlias ) .AND.  ! ::lIconView, ::DrawSelect(),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GotFocus", {|Self | Self, ::TControl:GotFocus(), If( ::nLen > 0 .AND. ! EmptyAlias( ::cAlias ) .AND.  ! ::lIconView, ::DrawSelect(),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER HScroll( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "HScroll", @TWBrowse_HScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HScroll", @TWBrowse_HScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DrawIcon(nIcon, lFocused); IIF( .F., s_oClass:ModMethod( "DrawIcon", @TWBrowse__DrawIcon(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "DrawIcon", @TWBrowse__DrawIcon(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );

   _HB_MEMBER Initiate(hDlg); IIF( .F., s_oClass:ModInline( "Initiate", {|Self,hDlg | Self, ::TControl:Initiate( hDlg ), ::Default() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Initiate", {|Self,hDlg | Self, ::TControl:Initiate( hDlg ), ::Default() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER IsColVisible( nCol); IIF( .F., s_oClass:ModMethod( "IsColVisible", @TWBrowse_IsColVisible(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "IsColVisible", @TWBrowse_IsColVisible(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER KeyDown( nKey, nFlags); IIF( .F., s_oClass:ModMethod( "KeyDown", @TWBrowse_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyDown", @TWBrowse_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER KeyChar( nKey, nFlags); IIF( .F., s_oClass:ModMethod( "KeyChar", @TWBrowse_KeyChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyChar", @TWBrowse_KeyChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER LButtonDown( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "LButtonDown", @TWBrowse_LButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LButtonDown", @TWBrowse_LButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER LButtonUp( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "LButtonUp", @TWBrowse_LButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LButtonUp", @TWBrowse_LButtonUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER LostFocus(hCtlFocus); IIF( .F., s_oClass:ModInline( "LostFocus", {|Self,hCtlFocus | Self, ::TControl:LostFocus( hCtlFocus ), If( ::nLen > 0 .AND. ! EmptyAlias( ::cAlias ) .AND.  ! ::lIconView, ::DrawSelect(),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "LostFocus", {|Self,hCtlFocus | Self, ::TControl:LostFocus( hCtlFocus ), If( ::nLen > 0 .AND. ! EmptyAlias( ::cAlias ) .AND.  ! ::lIconView, ::DrawSelect(),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER MouseMove( nRow, nCol, nKeyFlags); IIF( .F., s_oClass:ModMethod( "MouseMove", @TWBrowse_MouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseMove", @TWBrowse_MouseMove(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER MouseWheel( nKeys, nDelta, nXPos, nYPos); IIF( .F., s_oClass:ModMethod( "MouseWheel", @TWBrowse_MouseWheel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "MouseWheel", @TWBrowse_MouseWheel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER PageUp( nLines); IIF( .F., s_oClass:ModMethod( "PageUp", @TWBrowse_PageUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PageUp", @TWBrowse_PageUp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PageDown( nLines); IIF( .F., s_oClass:ModMethod( "PageDown", @TWBrowse_PageDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PageDown", @TWBrowse_PageDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Paint(); IIF( .F., s_oClass:ModMethod( "Paint", @TWBrowse_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paint", @TWBrowse_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER RecAdd(); IIF( .F., s_oClass:ModInline( "RecAdd", {|Self | Self, If( ::bAdd <> nil, Eval( ::bAdd ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "RecAdd", {|Self | Self, If( ::bAdd <> nil, Eval( ::bAdd ),) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER RecCount(uSeekValue); IIF( .F., s_oClass:ModMethod( "RecCount", @TWBrowse__RecCount(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "RecCount", @TWBrowse__RecCount(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );

   _HB_MEMBER Report( cTitle, lPreview); IIF( .F., s_oClass:ModMethod( "Report", @TWBrowse_Report(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Report", @TWBrowse_Report(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ReSize( nSizeType, nWidth, nHeight); IIF( .F., s_oClass:ModMethod( "ReSize", @TWBrowse_ReSize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReSize", @TWBrowse_ReSize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER nRowCount(); IIF( .F., s_oClass:ModMethod( "nRowCount", @TWBrowse_nRowCount(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nRowCount", @TWBrowse_nRowCount(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetArray( aArray); IIF( .F., s_oClass:ModMethod( "SetArray", @TWBrowse_SetArray(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetArray", @TWBrowse_SetArray(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetCols( aData, aHeaders, aColSizes); IIF( .F., s_oClass:ModMethod( "SetCols", @TWBrowse_SetCols(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetCols", @TWBrowse_SetCols(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetFilter( cField, uVal1, uVal2); IIF( .F., s_oClass:ModMethod( "SetFilter", @TWBrowse_SetFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetFilter", @TWBrowse_SetFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetTree( oTree); IIF( .F., s_oClass:ModMethod( "SetTree", @TWBrowse_SetTree(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetTree", @TWBrowse_SetTree(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ShowSizes(); IIF( .F., s_oClass:ModMethod( "ShowSizes", @TWBrowse_ShowSizes(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ShowSizes", @TWBrowse_ShowSizes(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Skip( n); IIF( .F., s_oClass:ModMethod( "Skip", @TWBrowse_Skip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Skip", @TWBrowse_Skip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER UpStable(); IIF( .F., s_oClass:ModInline( "UpStable", {|Self | Self, ( if( ::nRowPos < ::nRowCount(), ::nRowPos++, ), ::Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "UpStable", {|Self | Self, ( if( ::nRowPos < ::nRowCount(), ::nRowPos++, ), ::Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER VertLine( nColPos, nColInit); IIF( .F., s_oClass:ModMethod( "VertLine", @TWBrowse_VertLine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "VertLine", @TWBrowse_VertLine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER VScroll( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "VScroll", @TWBrowse_VScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "VScroll", @TWBrowse_VScroll(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DrawHeaders( nColPressed); IIF( .F., s_oClass:ModMethod( "DrawHeaders", @TWBrowse_DrawHeaders(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DrawHeaders", @TWBrowse_DrawHeaders(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DrawFooters( nColPressed); IIF( .F., s_oClass:ModMethod( "DrawFooters", @TWBrowse_DrawFooters(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DrawFooters", @TWBrowse_DrawFooters(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GetColHeader( nMRow, nMCol); IIF( .F., s_oClass:ModMethod( "GetColHeader", @TWBrowse_GetColHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetColHeader", @TWBrowse_GetColHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GetColFooter( nMRow, nMCol); IIF( .F., s_oClass:ModMethod( "GetColFooter", @TWBrowse_GetColFooter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetColFooter", @TWBrowse_GetColFooter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GoToCol( nCol); IIF( .F., s_oClass:ModMethod( "GoToCol", @TWBrowse_GoToCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GoToCol", @TWBrowse_GoToCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Refresh( lSysRefresh); IIF( .F., s_oClass:ModMethod( "Refresh", @TWBrowse_Refresh(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Refresh", @TWBrowse_Refresh(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nWRow( nMRow); IIF( .F., s_oClass:ModMethod( "nWRow", @TWBrowse_nWRow(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nWRow", @TWBrowse_nWRow(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nWCol( nMCol); IIF( .F., s_oClass:ModMethod( "nWCol", @TWBrowse_nWCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nWCol", @TWBrowse_nWCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Set3DStyle(); IIF( .F., s_oClass:ModMethod( "Set3DStyle", @TWBrowse_Set3DStyle(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Set3DStyle", @TWBrowse_Set3DStyle(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER aBrwPosRect(); IIF( .F., s_oClass:ModMethod( "aBrwPosRect", @TWBrowse_aBrwPosRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "aBrwPosRect", @TWBrowse_aBrwPosRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DbfSeek( lSoftSeek, bEof); IIF( .F., s_oClass:ModMethod( "DbfSeek", @TWBrowse_DbfSeek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DbfSeek", @TWBrowse_DbfSeek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetTXT( uTxt); IIF( .F., s_oClass:ModMethod( "SetTXT", @TWBrowse_SetTXT(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetTXT", @TWBrowse_SetTXT(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER Destroy(); IIF( .F., s_oClass:ModInline( "Destroy", {|Self | Self, If( ::oTXT <>Nil, (::oTXT:End(), ::oTXT:= Nil),), If( ::oFontFooter <> Nil, ::oFontFooter:End(), ), ::TControl:Destroy() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Destroy", {|Self | Self, If( ::oTXT <>Nil, (::oTXT:End(), ::oTXT:= Nil),), If( ::oFontFooter <> Nil, ::oFontFooter:End(), ), ::TControl:Destroy() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER IsOverHeader( nMRow, nMCol); IIF( .F., s_oClass:ModMethod( "IsOverHeader", @TWBrowse_IsOverHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "IsOverHeader", @TWBrowse_IsOverHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER IsOverFooter( nMRow, nMCol); IIF( .F., s_oClass:ModMethod( "IsOverFooter", @TWBrowse_IsOverFooter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "IsOverFooter", @TWBrowse_IsOverFooter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER VerifyLogicLen( nLogicLen); IIF( .F., s_oClass:ModMethod( "VerifyLogicLen", @TWBrowse_VerifyLogicLen(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "VerifyLogicLen", @TWBrowse_VerifyLogicLen(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER VerifyLogicPos( nLogicPos); IIF( .F., s_oClass:ModMethod( "VerifyLogicPos", @TWBrowse_VerifyLogicPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "VerifyLogicPos", @TWBrowse_VerifyLogicPos(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER RightButtonDown( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "RightButtonDown", @TWBrowse_RightButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RightButtonDown", @TWBrowse_RightButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ExportToExcel(); IIF( .F., s_oClass:ModInline( "ExportToExcel", {|Self | Self, TOleExcel():New():ExportBrowse( Self ):End() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ExportToExcel", {|Self | Self, TOleExcel():New():ExportBrowse( Self ):End() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER ExportToWord(); IIF( .F., s_oClass:ModInline( "ExportToWord", {|Self | Self, TOleWord():New():ExportBrowse( Self ):End() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ExportToWord", {|Self | Self, TOleWord():New():ExportBrowse( Self ):End() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )








; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TWBrowse ;



UTILITY STATIC function TWBrowse_nRowCount() ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
   WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )

   If ! "TCBROWSE" $ ::ClassName
      return wBrwRows( ::hWnd, 0, If( ::oFont <> nil, ::oFont:hFont, 0 ) )
   EndIf

return nWRows( ::hWnd, 0, If( ::oFont <> nil, ::oFont:hFont, 0 ) ) - 1





UTILITY STATIC function TWBrowse_New( nRow, nCol, nWidth, nHeigth, bLine, aHeaders, aColSizes, oWnd, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nClrBack, cMsg, lUpdate, cAlias, lPixel, bWhen, lDesign, bValid, bLClick, aActions) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse











   IIF( nRow == nil, nRow := 0, ) ; IIF( nCol == nil, nCol := 0, ); IIF( nHeigth == nil, nHeigth := 100, ); IIF( nWidth == nil, nWidth := 100, ); IIF( oWnd == nil, oWnd := GetWndDefault(), ); IIF( nClrFore == nil, nClrFore := GetSysColor( 8 ), ); IIF( nClrBack == nil, nClrBack := GetSysColor( 5 ), ); IIF( lUpdate == nil, lUpdate := .F., ); IIF( cAlias == nil, cAlias := Alias(), ); IIF( lPixel == nil, lPixel := .F., ); IIF( lDesign == nil, lDesign := .F., ); IIF( bRClick == nil, bRClick := {| nRow, nCol, nFlags | ::RightButtonDown( nRow, nCol, nFlags ) }, );





   ::cCaption   = ""
   ::nTop       = nRow * If( lPixel, 1, 14 )
   ::nLeft      = nCol * If( lPixel, 1, 8 )
   ::nBottom    = ::nTop + nHeigth - 1
   ::nRight     = ::nLeft + nWidth - 1
   ::oWnd       = oWnd
   ::lHitTop    = .F.
   ::lHitBottom = .F.
   ::lFocused   = .F.
   ::lCaptured  = .F.
   ::lMChange   = .T.
   ::nRowPos    = 1
   ::nColPos    = 1
   ::nColAct    = 1




   ::nStyle     = nOr(  1073741824,  8388608, 268435456, 65536, If( lDesign, 67108864, 0 ) )
   ::nId        = ::GetNewId()
   ::cAlias     = cAlias
   ::bLine      = bLine
   ::lAutoEdit  = .F.
   ::lAutoSkip  = .F.
   ::lIconView  = .F.
   ::lCellStyle = .F.
   ::nIconPos   = 0

   ::SetFilter( cField, uVal1, uVal2 )

   ::bAdd       = { || ( ::cAlias )->( DbAppend() ), ::UpStable() }

   ::aHeaders   = aHeaders
   ::aColSizes  = aColSizes
   ::nLen       = 0
   ::lDrag      = lDesign
   ::lCaptured  = .F.
   ::lMChange   = .T.
   ::bChange    = bChange
   ::bLClicked  = bLClick
   ::bLDblClick = bLDblClick
   ::bRClicked  = bRClick

   ::oCursor    = oCursor
   ::oFont      = oFont

   ::nLineStyle := 7
   ::nClrLine   := ( 234 + ( 233 * 256 ) + ( 225 * 65536 ) )


   If (::lVScroll== Nil .OR. (::lVScroll<>Nil .AND. ::lVScroll))
      ::nStyle:= nOr( ::nStyle, 2097152 )
   EndIf
   If (::lHScroll== Nil .OR. (::lHScroll<>Nil .AND. ::lHScroll))
      ::nStyle:= nOr( ::nStyle, 1048576 )
   EndIf


   ::nClrBackHead  := GetSysColor( 15 )
   ::nClrForeHead  := GetSysColor( 18 )
   ::nClrBackFocus := GetSysColor( 13 )
   ::nClrForeFocus := GetSysColor( 14)


   ::nClrFBack     := ::nClrBackHead
   ::nClrFFore     := ::nClrForeHead

   ::nClrNFBack    := GetSysColor( 13 )
   ::nClrNFFore    := ::nClrForeFocus

   ::cMsg          = cMsg
   ::lUpdate       = lUpdate
   ::bWhen         = bWhen
   ::bValid        = bValid
   ::aActions      = aActions

   ::SetColor( nClrFore, nClrBack )





   ::Register( nOr( 1, 2, 8 ) )

   if ! Empty( oWnd:hWnd )
      ::Create()
      ::Default()
      ::lVisible = .T.
      oWnd:AddControl( Self )
   else
      oWnd:DefControl( Self )
      ::lVisible = .F.
   endif

   if lDesign
      ::CheckDots()
   endif

return Self






UTILITY STATIC function TWBrowse_ReDefine( nId, bLine, oDlg, aHeaders, aColSizes, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nClrBack, cMsg, lUpdate, cAlias, bWhen, bValid, bLClick, aActions) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse






   IIF( oDlg == nil, oDlg := GetWndDefault(), ) ; IIF( nClrFore == nil, nClrFore := GetSysColor( 8 ), ); IIF( nClrBack == nil, nClrBack := GetSysColor( 5 ), ); IIF( lUpdate == nil, lUpdate := .F., ); IIF( cAlias == nil, cAlias := Alias(), ); IIF( bRClick == nil, bRClick := {| nRow, nCol, nFlags | ::RightButtonDown( nRow, nCol, nFlags ) }, );

   ::lHitTop    = .F.
   ::lHitBottom = .F.
   ::lFocused   = .F.
   ::nId        = nId
   ::nRowPos    = 1
   ::nColPos    = 1
   ::nColAct    = 1
   ::cAlias     = cAlias
   ::oWnd       = oDlg
   ::aHeaders   = aHeaders
   ::aColSizes  = aColSizes
   ::nClrPane   = 12632256
   ::nClrText   = 16777215
   ::nLen       = 0
   ::lDrag      = .F.
   ::lCaptured  = .F.
   ::lVisible   = .F.
   ::lCaptured  = .F.
   ::lMChange   = .T.

   ::bLine      = bLine
   ::bChange    = bChange
   ::bLClicked  = bLClick
   ::bLDblClick = bLDblClick
   ::bRClicked  = bRClick

   ::oCursor    = oCursor
   ::oFont      = oFont

   ::nLineStyle := 7
   ::nClrLine   := ( 234 + ( 233 * 256 ) + ( 225 * 65536 ) )

   ::nClrBackHead  := GetSysColor( 15 )
   ::nClrForeHead  := GetSysColor( 18 )
   ::nClrBackFocus := GetSysColor( 13 )
   ::nClrForeFocus := GetSysColor( 14 )

   ::nClrFBack     := ::nClrBackHead
   ::nClrFFore     := ::nClrForeHead

   ::nClrNFBack    := GetSysColor( 13 )
   ::nClrNFFore    := ::nClrForeFocus

   ::cMsg          = cMsg
   ::lUpdate       = lUpdate
   ::bWhen         = bWhen
   ::bValid        = bValid
   ::aActions      = aActions
   ::lAutoEdit     = .F.
   ::lAutoSkip     = .F.
   ::lIconView     = .F.
   ::lCellStyle    = .F.
   ::nIconPos      = 0

   ::SetColor( nClrFore, nClrBack )

   ::SetFilter( cField, uVal1, uVal2 )
   ::bAdd       = { || ( ::cAlias )->( DbAppend() ), ::UpStable() }

   ::Register( nOr( 1, 2, 8 ) )

   oDlg:DefControl( Self )

return Self



UTILITY STATIC function TWBrowse_DrawSelect() ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

 LOCAL nTextColor, nBkColor

   WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )
   If ::nLen < 1
      return Nil
   EndIf

   ::lSelect:= .T.

   If ! ::lDrawSelect
      ::DrawLine()
      ::lSelect:= .F.
      return Nil
   EndIf

   If ::lOnlyBorder
      nTextColor:= ::nClrText
      nBkColor  := ::nClrPane
   Else
      nTextColor:= If( ::lFocused, ::nClrForeFocus, ::nClrNFFore )
      nBkColor  := If( ::lFocused, ::nClrBackFocus, ::nClrNFBack )
   EndIf

   if ::lCellStyle
      ::DrawLine()







      WBrwLine( ::hWnd, ::hDC, ::nRowPos, Eval( ::bLine ), ::GetColSizes(), ::nColPos, nTextColor, nBkColor, If( ::oFont <> nil, ::oFont:hFont, 0 ), ValType( ::aColSizes ) == "B", ::aJustify,, ::nLineStyle, ::nColAct, ::lFocused, ::bTextColor, ::bBkColor, ::nClrLine, .F., .T., ::bFont, ::lDrawFocusRect )

   else







      WBrwLine( ::hWnd, ::hDC, ::nRowPos, Eval( ::bLine ), ::GetColSizes(), ::nColPos, nTextColor, nBkColor, If( ::oFont <> nil, ::oFont:hFont, 0 ), ValType( ::aColSizes ) == "B", ::aJustify,, ::nLineStyle,  .F., ::lFocused, ::bTextColor, ::bBkColor, ::nClrLine, .F., .T., ::bFont, ::lDrawFocusRect )

   endif
   ::lSelect:= .F.
return nil



UTILITY STATIC function TWBrowse_DrawIcons() ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nWidth := ::nWidth(), nHeight := ::nHeight()
   local nRow := 10, nCol := 10
   local n := 1, nIcons := Int( nWidth / 50 ) * Int( nHeight / 50 )
   local hIcon := ExtractIcon( "user.exe", 0 )
   local oFont, cText

   oFont := TFont():New( "Ms Sans Serif", 0, -8,,,,,,, .T.,,,,,,, )

   SelectObject( ::hDC, oFont:hFont )
   SetBkColor( ::hDC, 8388608 )
   SetTextColor( ::hDC, 16777215 )

   while n <= nIcons .AND. ! ( ::cAlias )->( EoF() )
      if ::bIconDraw <> nil .AND. ::aIcons <> nil
         hIcon = ::aIcons[ Eval( ::bIconDraw, Self ) ]
      endif
      DrawIcon( ::hDC, nRow, nCol, hIcon )
      if ::bIconText <> nil
         cText = cValToChar( Eval( ::bIconText, Self ) )
      else
         cText = Str( ( ::cAlias )->( RecNo() ) )
      endif

      DrawText( ::hDC, cText, { nRow + 35, nCol - 5, nRow + 48, nCol + 40 }, 1 )
      nCol += 50
      if nCol >= nWidth - 32
         nRow += 50
         nCol  = 10
      endif
      ( ::cAlias )->( DbSkip() )
      n++
   end
   ( ::cAlias )->( DbSkip( 1 - n ) )

   oFont:End()

return nil



UTILITY STATIC function TWBrowse_ReSize( nSizeType, nWidth, nHeight) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   ::nRowPos = Min( ::nRowPos, Max( ::nRowCount(), 1 ) )

return ::TControl:ReSize( nSizeType, nWidth, nHeight )



UTILITY STATIC function TWBrowse_SetArray( aArray) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   ::nAt       = 1
   ::cAlias    = "ARRAY"

   ::bLogicLen = { || ::nLen := Len( aArray ) }

   ::bLogicPos  := Nil
   ::bGoLogicPos:= Nil

   ::bGoTop    = { || ::nAt := 1 }
   ::bGoBottom = { || ::nAt := Eval( ::bLogicLen ) }


   ::bSkip     = { | nSkip, nOld | nOld := ::nAt, ::nAt += nSkip, ::nAt := Min( Max( ::nAt, 1 ), Eval( ::bLogicLen ) ), ::nAt - nOld }
return nil



UTILITY STATIC function TWBrowse_SetTree( oTree) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local oItem := oTree:oFirst

   ::lMChange   = .F.
   ::bLine      = { || oItem:GetLabel() }
   ::aColSizes  = { || oItem:ColSizes() }
   ::bGoTop     = { || oItem := oTree:oFirst }
   ::bGoBottom  = { || oItem := oTree:GetLast() }
   ::bSkip      = { | n | oItem := oItem:Skip( @n ), ::Cargo := oItem, n }
   ::bLogicLen  = { || ::nLen := oTree:nCount() }

   ::bLogicPos   := Nil
   ::bGoLogicPos := Nil
   ::lDrawHeaders:= .F.


   ::bLDblClick = { || If( oItem:oTree <> nil, ( oItem:Toggle(), ::Refresh() ),) }
   ::Cargo      = oItem


   ::bKeyChar   = { | nKey | If( nKey == 13 .AND. oItem:oTree <> nil, ( oItem:Toggle(), ::Refresh() ),) }

   if ::oHScroll <> nil
      ::oHScroll:SetRange( 0, 0 )
      ::oHScroll = nil
   endif

   oTree:Draw()

return nil



UTILITY STATIC function TWBrowse_Paint() ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nSkip
   local nRealSkip

   WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )
   if ::lIconView
      ::DrawIcons()
      return 0
   endif


   if ::nRowPos == 1 .AND. ! Empty( ::cAlias ) .AND.  Upper( ::cAlias ) <> "ARRAY" .AND. Upper( ::cAlias ) <> "_TXT_"
      if ! ( ::cAlias )->( EoF() )
         ( ::cAlias )->( DbSkip( -1 ) )
         if ! ( ::cAlias )->( BoF() )
            ( ::cAlias )->( DbSkip() )
         endif
      endif
   endif

   ::DrawHeaders()

   ::DrawFooters()

   if ::bLogicLen <> nil
      ::nLen   := Eval( ::bLogicLen )
   else
      ::nLen   := 0
   end

   if ::nLen > 0





   nSkip    := 1 - ::nRowPos
   nRealSkip:= ::Skip( nSkip )
   if nSkip <> nRealSkip
      ::nRowPos-= nRealSkip - nSkip
      ::nRowPos:= Max( ::nRowPos, 1 )
   EndIf








      ::Skip( ::nRowPos - wBrwPane( ::hWnd, ::hDC, Self, ::bLine, ::aColSizes, ::nColPos, ::nClrText, ::nClrPane, If( ::oFont <> nil, ::oFont:hFont, 0 ), ::aJustify,  ::nLineStyle, 0  , .F., ::bTextColor, ::bBkColor, ::nClrLine, ::oBrush:nRGBColor, ::bFont ) )


      if ::nLen < ::nRowPos
         ::nRowPos = ::nLen
      endif
      ::DrawSelect()

   endif

   If ::oVScroll <> Nil .AND. ::bLogicPos <> Nil
      ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )
   EndIf


   if ! Empty( ::cAlias ) .AND. Upper( ::cAlias ) <> "ARRAY"  .AND. Upper( ::cAlias ) <> "_TXT_"
       ::lHitTop    = ( ::cAlias )->( BoF() )
       ::lHitBottom = ( ::cAlias )->( EoF() )
   endif

return 0



UTILITY STATIC function TWBrowse_GoUp() ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )
   ::lGoTop:= .F.
   ::lGoBottom:= .F.

   if ( ::nLen := Eval( ::bLogicLen ) ) < 1
      return nil
   endif


   if ! ::lHitTop

      ::DrawLine()
      if ::Skip( -1 ) == -1
         ::lHitBottom = .F.
         if ::nRowPos > 1
            ::nRowPos--
         else
            WBrwScrl( ::hWnd, -1, If( ::oFont <> nil, ::oFont:hFont, 0 ), ::nLineStyle, ::hDC )
         endif
         ::nLogicPos--
      else
         ::lHitTop = .T.
      endif
      ::DrawSelect()
      if ::oVScroll <> nil

         If ::bLogicPos <> Nil
            ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )
         Else
            ::oVScroll:GoUp()
         EndIf


      endif
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif

   endif


return nil



UTILITY STATIC function TWBrowse_GoDown() ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nLines := ::nRowCount()

    WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )
   ::lGoTop:= .F.
   ::lGoBottom:= .F.

   if ( ::nLen := Eval( ::bLogicLen ) ) < 1
      return nil
   endif


   if ! ::lHitBottom

      ::DrawLine()
      if ::Skip( 1 ) == 1
         ::lHitTop = .F.
         if ::nRowPos < nLines
            ::nRowPos++
         else
            WBrwScrl( ::hWnd, 1, If( ::oFont <> nil, ::oFont:hFont, 0 ), ::nLineStyle, ::hDC )
         endif
         ::nLogicPos++
      else
         ::lHitBottom = .T.
      endif

      ::DrawSelect()

      if ::oVScroll <> nil
         If ::bLogicPos <> Nil
            ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )
         Else
            ::oVScroll:GoDown()
         EndIf
      endif

      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif

   endif

return nil



UTILITY STATIC function TWBrowse_GoLeft( lRefresh) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
 LOCAL aSizes:= ::GetColSizes()
 LOCAL nCols := Len( aSizes )
 LOCAL lColVisible, lRefreshAll:= .T.
 LOCAL lGoLeft:= Eval( ::bGoLeft )


    IIF( lRefresh == nil, lRefresh := .T., ) ;

    WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )

    If ::cAlias == "_TXT_"
       If lGoLeft .AND. ::nTXTFrom > 1
          ::nTXTFrom-= ::nTXTSkip
          return .T.
       Else
          MsgBeep()
          return .F.
       EndIf
    EndIf

    If !( ::nColAct > 1 ) .OR. ! lGoLeft
       return .F.
    Else
         If ::aTmpColSizes == Nil
            ::aTmpColSizes:= AClone( aSizes )
         EndIf

       If ::nFreeze > 0
          ::nFreeze:= Max( Min( ::nFreeze, nCols - 1 ), 1 )
          ::nColPos:= 1
          If !::lCellStyle
             ::nColAct--
             aSizes[::nColAct]:= ::aTmpColSizes[::nColAct]
             If ::nColAct <= ::nFreeze + 1
                ::nColAct:= 1
             EndIf
             if lRefresh
                IIF( ::nLen > 0, ::Refresh(), )
             endif
          Else
             ::nColAct--
             lColVisible:= !( aSizes[::nColAct] == 0 )
             aSizes[::nColAct]:= ::aTmpColSizes[::nColAct]
             if lRefresh
                If !lColVisible
                   IIF( ::nLen > 0, ::Refresh(), )
                Else
                   lRefreshAll:= .F.
                   IIF( ::nLen > 0, ::DrawSelect(), )
                EndIf
             endif
          EndIf

       Else

          If !::lCellStyle
             ::nColAct--
             ::nColPos--
             IIF( ::nLen > 0, ::Refresh(), )

          Else
             ::nColAct--
             lColVisible:= .T.
             While .T.
                If ! ::IsColVisible( ::nColAct ) .AND. ::nColAct < ::nColPos
                   lColVisible:= .F.
                   ::nColPos--
                   Loop
                Else
                   Exit
                EndIf
             EndDo
             if lRefresh
                If !lColVisible
                   IIF( ::nLen > 0, ::Refresh(), )
                Else
                   lRefreshAll:= .F.
                   IIF( ::nLen > 0, ::DrawSelect(), )
                EndIf
             endif
          EndIf

       EndIf

       If ::oHScroll <> Nil .AND. lRefresh
          ::oHScroll:SetPos( ::nColAct )
       EndIf

       if ::bChange <> nil
          Eval( ::bChange, Self )
       endif

    EndIf
return lRefreshAll



UTILITY STATIC function TWBrowse_GoRight( lRefresh) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

 LOCAL aSizes:= ::GetColSizes()
 LOCAL nCols := Len( aSizes )
 LOCAL lColVisible, nColAct, lRefreshAll:= .T.
 LOCAL lGoRight:= Eval( ::bGoRight )

    IIF( lRefresh == nil, lRefresh := .T., ) ;

    WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )

    If ::cAlias == "_TXT_"
       If lGoRight .AND. ::nTXTFrom <= ::nTXTMaxSkip
          ::nTXTFrom+= ::nTXTSkip
          return .T.
       Else
          MsgBeep()
          return .F.
       EndIf
    EndIf

    If !( ::nColAct < nCols ) .OR. ! lGoRight
       return .F.
    Else
         If ::aTmpColSizes == Nil
            ::aTmpColSizes:= AClone( aSizes )
         EndIf



       If !::lCellStyle .AND. ::IsColVisible( nCols ) .AND. ::oHScroll == Nil

          return .F.
       EndIf


       If ::nFreeze > 0
          ::nFreeze:= Max( Min( ::nFreeze, nCols - 1 ), 1 )
          ::nColPos:= 1
          If !::lCellStyle
             ::nColAct:= Max( ::nColAct, ::nFreeze + 1 )
             If ::nColAct < nCols
                aSizes[::nColAct]:= 0
                ::nColAct++
                if lRefresh
                   IIF( ::nLen > 0, ::Refresh(), )
                endif
             EndIf
          Else
             lColVisible:= .T.
             ::nColAct++
             nColAct:= ::nFreeze + 1
             While .T.
                If ! ::IsColVisible( ::nColAct ) .AND. nColAct < ::nColAct
                   lColVisible:= .F.
                   aSizes[nColAct]:= 0
                   nColAct++
                   Loop
                Else
                   Exit
                EndIf
             EndDo
             if lRefresh
                If !lColVisible
                   IIF( ::nLen > 0, ::Refresh(), )
                Else
                   lRefreshAll:= .F.
                   IIF( ::nLen > 0, ::DrawSelect(), )
                EndIf
             endif
          EndIf

       Else

          If !::lCellStyle
             ::nColAct++
             ::nColPos++
             IIF( ::nLen > 0, ::Refresh(), )
          Else
             ::nColAct++
             lColVisible:= .T.
             While .T.
                If ! ::IsColVisible( ::nColAct ) .AND. ::nColAct > ::nColPos
                   lColVisible:= .F.
                   ::nColPos++
                   Loop
                Else
                   Exit
                EndIf
             EndDo
             if lRefresh
                If !lColVisible
                   IIF( ::nLen > 0, ::Refresh(), )
                Else
                   lRefreshAll:= .F.
                   IIF( ::nLen > 0, ::DrawSelect(), )
                EndIf
             endif
          EndIf

       EndIf

       If ::oHScroll <> Nil .AND. lRefresh
          ::oHScroll:SetPos( ::nColAct )
       EndIf

       if ::bChange <> nil
          Eval( ::bChange, Self )
       endif

    EndIf

return lRefreshAll



UTILITY STATIC function TWBrowse_GoTop() ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   ::lGoTop:= .T.
   ::lGoBottom:= .F.

   WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )

   if ( ::nLen := Eval( ::bLogicLen ) ) < 1
      return nil
   endif

   if ! ::lHitTop

      Eval( ::bGoTop )

      ::nRowPos = 1
      ::Refresh()
      ::lHitTop = .T.
      ::lHitBottom = .F.

      if ::oVScroll <> nil

         If ::bLogicPos <> Nil
            ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )
         Else
            ::oVScroll:GoTop()
         EndIf

      endif

      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif

   endif

return nil



UTILITY STATIC function TWBrowse_GoBottom() ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nSkipped
   local nLines
   local n

   ::lGoTop:= .F.
   ::lGoBottom:= .T.

   WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )
   nLines := ::nRowCount()
   ::lLogicPos:= .T.

   if ( ::nLen := Eval( ::bLogicLen ) ) < 1
      return nil
   endif

   if ! ::lHitBottom

      ::lHitBottom = .T.
      ::lHitTop    = .F.

      Eval( ::bGoBottom )

      nSkipped = ::Skip( -( nLines - 1 ) )
      ::nRowPos = 1 - nSkipped

      ::GetDC()
      for n = 1 to -nSkipped
          ::DrawLine( n )
          ::Skip( 1 )
      next
      ::DrawSelect()
      ::ReleaseDC()
      if ::oVScroll <> nil
         ::nLen = Eval( ::bLogicLen )

         If ::bLogicPos <> Nil
            ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )
         Else
            if ::oVScroll:nMax <> ::nLen
               ::oVScroll:SetRange( 1, ::nLen )
            endif
            ::oVScroll:GoBottom()
         EndIf

      endif


      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif

   endif

return nil



UTILITY STATIC function TWBrowse_LDblClick( nRow, nCol, nKeyFlags) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
   local nClickRow := ::nWRow( nRow )
   local nBrwCol

   if nClickRow == ::nRowPos .AND. ::nLen > 0

      nBrwCol = ::nAtCol( nCol )
      if ::lAutoEdit .AND. nBrwCol > 0
         ::Edit( nBrwCol )
      else
         return ::TControl:LDblClick( nRow, nCol, nKeyFlags )
      endif

   else
      return ::TControl:LDblClick( nRow, nCol, nKeyFlags )
   endif

return nil



UTILITY STATIC function TWBrowse_LButtonDown( nRow, nCol, nKeyFlags) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nClickRow, nSkipped
   local nColPos := 0, nColInit := ::nColPos - 1
   local nAtCol

   if ::lDrag
      return ::TControl:LButtonDown( nRow, nCol, nKeyFlags )
   endif

   nClickRow = ::nWRow( nRow )

   if ::nLen < 1 .AND. nClickRow <> 0
      return nil
   endif







   if ::lMChange .AND.  (::IsOverHeader( nRow, nCol ) .OR. ::IsOverFooter( nRow, nCol )) .AND. AScan( ::GetColSizes(), { | nColumn | nColPos += nColumn, nColInit++, nCol >= nColPos - 1 .AND.  nCol <= nColPos + 1 }, ::nColPos ) <> 0


      if ! ::lCaptured
         ::lCaptured = .T.
         ::Capture()
         ::VertLine( nColPos, nColInit )
      endif
      return nil
   endif

   ::SetFocus()

   if ::IsOverHeader(nRow,nCol) .AND. Valtype(nKeyFlags) == "N" .AND. ::nWCol(nCol) > 0







      if Valtype( ::aActions ) == "A"                          .AND. ( nAtCol := ::nAtCol( nCol ) ) <= Len( ::aActions )   .AND. ::aActions[ nAtCol ] <> nil

         ::DrawHeaders() ; ::DrawFooters() ; ::ReleaseDC()

         Eval( ::aActions[ nAtCol ], Self, nRow, nCol )

         ::DrawHeaders(); ::DrawFooters(); ::ReleaseDC()

      endif

      if Valtype( ::aActions ) == "B"

         ::DrawHeaders(); ::DrawFooters(); ::ReleaseDC()

         Eval( ::aActions, ::nAtCol( nCol ), Self, nRow, nCol )

         ::DrawHeaders(); ::DrawFooters(); ::ReleaseDC()

      end





   endif


   if nClickRow > 0 .AND. nClickRow <> ::nRowPos .AND.  nClickRow < ::nRowCount() + 1  .AND. ::nWCol(nCol) > 0

      ::DrawLine()
      nSkipped  = ::Skip( nClickRow - ::nRowPos )
      ::nRowPos += nSkipped
      ::lGoTop:= .F.
      ::lGoBottom:= .F.
      if ::oVScroll <> nil
         If ::bLogicPos <> Nil
            ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )
         Else
            ::oVScroll:SetPos( ::oVScroll:GetPos() + nSkipped )
         EndIf
      endif

      if ::lCellStyle

         If ( nAtCol:= ::nAtCol( nCol ) ) > 0
            ::GoToCol( nAtCol )
         EndIf

      endif

      ::DrawSelect()
      ::lHitTop = .F.
      ::lHitBottom = .F.
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif

   else

      if ::lCellStyle
           If ( nAtCol:= ::nAtCol( nCol ) ) > 0
              ::GoToCol( nAtCol )
           EndIf
      endif
   endif





   if ::aLinActions <> nil .AND. ( nAtCol := ::nAtCol( nCol ) ) <= Len( ::aLinActions )
      if ::aLinActions[ nAtCol ] <> nil
         Eval( ::aLinActions[ nAtCol ], Self, nRow, nCol )
      endif
   endif





   ::TControl:LButtonDown( nRow, nCol, nKeyFlags )

return 0



UTILITY STATIC function TWBrowse_LButtonUp( nRow, nColM, nFlags) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
 LOCAL aSizes, nColChange

   if ::lDrag
      return ::TControl:LButtonUp( nRow, nColM, nFlags )
   endif

   if ::lCaptured
      ::lCaptured = .F.
      ReleaseCapture()

      nColChange:= ::VertLine()




      If ::nFreeze > 0
         aSizes:= ::GetColSizes()
         If ::aTmpColSizes == Nil
            ::aTmpColSizes:= AClone( aSizes )
         Else
            ::aTmpColSizes[nColChange]:= aSizes[nColChange]
         EndIf
      EndIf


   endif

   ::TControl:LButtonUp( nRow, nColM, nFlags )

return nil



UTILITY STATIC function TWBrowse_Default() ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local n, aFields
   local cAlias := Alias()
   local nElements, nTotal := 0
   local nDefaultHeight


   if ::oFont == nil
      ::oFont = ::oWnd:oFont
   endif





   nDefaultHeight := 16

   If ::nHeaderHeight <= 0
      ::nHeaderHeight:= nDefaultHeight
   EndIf
   If ::nFooterHeight <= 0
      ::nFooterHeight:= nDefaultHeight
   EndIf
   If ::nLineHeight <= 0
      ::nLineHeight:= nDefaultHeight
   EndIf

   IIF( ::aHeaders == nil, ::aHeaders := {}, ) ; IIF( ::aColSizes == nil, ::aColSizes := {}, );

   if ::bLine == nil
      if Empty( ::cAlias )
         ::cAlias = cAlias
      else
         cAlias = ::cAlias
      endif
      ::bLine  = { || _aFields( Self ) }
      if ::aJustify == nil
         ::aJustify = Array( nElements := Len( Eval( ::bLine ) ) )
         for n = 1 to nElements
             ::aJustify[ n ] = ( ValType( ( cAlias )->( FieldGet( n ) ) ) == "N" )
         next
      endif
   endif

   IIF( nElements == nil, nElements := Len( Eval( ::bLine ) ), ) ;

   if Len( ::aHeaders ) < nElements
      if ::Cargo == nil
         ::aHeaders = Array( nElements )
         if !Empty( cAlias )
            for n = 1 to nElements
                ::aHeaders[ n ] = ( cAlias )->( FieldName( n ) )
            next
         else
            aFill( ::aHeaders, "" )
         endif
      else
         ::aHeaders = { "" }
      endif
   endif

   IIF( ::aColSizes == nil, ::aColSizes := Afill(Array( nElements ), 0 ), ) ;

   if Len( ::GetColSizes() ) < nElements
      ::aColSizes = Afill(Array( nElements ), 0 )
      if !Empty( cAlias )
         aFields = Eval( ::bLine )
         for n = 1 to nElements





             ::aColSizes[ n ] := If( ValType( aFields[ n ] ) <> "C", 15, GetTextWidth( 0, Replicate( "B",  Max( Len( ::aHeaders[ n ] ),  Len( aFields[ n ] ) ) + 1 ), If( ! Empty( ::oFont ), ::oFont:hFont,) ) )
         next
      endif
   endif


   if lAnd( GetWindowLong( ::hWnd, -16 ), 2097152 ) .OR.  GetClassName( ::hWnd ) == "ListBox"

      if ::bLogicLen <> nil
         ::nLen := Eval( ::bLogicLen )
      else
         ::nLen := 0
      end

      If ::bLogicPos == Nil
         ::oVScroll := TScrollBar():WinNew( Min( 1, ::nLen ), ::nLen,, (!.F.) .OR. .T., Self,,,,,,,,, .F.,, )
      Else
         ::oVScroll := TScrollBar():WinNew( 1, If( ::nLen == 0, 0, 100 ),, (!.F.) .OR. .T., Self,,,,,,,,, .F.,, )
      EndIf
      ::oVScroll:SetPage( Min( ::nRowCount(), ::nLen - 1 ) )

   endif

   if lAnd( GetWindowLong( ::hWnd, -16 ), 1048576 )
      if ::Cargo == nil


         ::oHScroll := TScrollBar():WinNew( 1, Len( ::GetColSizes() ),, (!.T.), Self,,,,,,,,, .F.,, )

         AEval( ::GetColSizes(), { | nSize | nTotal += nSize } )

         ::oHScroll:SetPage( 1, Len( ::GetColSizes() ) )
      endif
   endif


   if ::uValue1 <> nil
      Eval( ::bGoTop )
   endif
   if ::bChange <> nil
      Eval( ::bChange, Self )
   endif




   ::lVScroll:= Nil
   ::lHScroll:= Nil
return nil



UTILITY STATIC function TWBrowse_KeyDown( nKey, nFlags) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local lRefresh

   do case
      case nKey == 38
           ::cBuffer:= ""
           ::GoUp()

      case nKey == 40
           ::cBuffer:= ""
           ::GoDown()

      case nKey == 37
           ::cBuffer:= ""
           If ::GoLeft()
              ::Refresh()
           EndIf

      case nKey == 39
           ::cBuffer:= ""
           If ::GoRight()
              ::Refresh()
           EndIf

      case nKey == 36
           ::cBuffer:= ""
           ::GoTop()

      case nKey == 35
           ::cBuffer:= ""
           ::GoBottom()

      case nKey == 33
           ::cBuffer:= ""
           if GetKeyState( 17 )
              ::GoTop()
           else
              ::PageUp()
           endif

      case nKey == 34
           ::cBuffer:= ""
           if GetKeyState( 17 )
              ::GoBottom()
           else
              ::PageDown()
           endif


      case nKey == 13 .AND. ::bMod <> nil
           Eval( ::bMod )

      case ::bSeek <> Nil .AND. !::lWorking .AND. nKey == 8
           ::lWorking:= .T.
           ::cBuffer := SubStr( ::cBuffer, 1, Len(::cBuffer) - 1 )
           if "L" $ ValType( lRefresh:= Eval( ::bSeek ) ) .AND. lRefresh
              ::nRowPos:= Max( Min( ::nLen, ::nRowCount ), 1 )
              ::Refresh()
           endif
           ::lWorking:= .F.

      case ::bSeek <> Nil .AND. ( nKey == 16 .OR. nKey >= 32 )

           ::TControl:KeyDown( nKey, nFlags )

      otherwise
           ::cBuffer:= ""
           IIF( ::bSeek <> Nil .AND. ::bUpdateBuffer <> Nil, Eval( ::bUpdateBuffer ), )


           if nKey == 9 .AND. ::bKeyDown <> nil
              Eval( ::bKeyDown, nKey, nFlags )
           endif

           return ::TControl:KeyDown( nKey, nFlags )
   endcase

   IIF( ::bSeek <> Nil .AND. ::bUpdateBuffer <> Nil, Eval( ::bUpdateBuffer ), )

return 0



UTILITY STATIC function TWBrowse_DbfSeek( lSoftSeek, bEof, nLenBuffer, lUpper, cBuffer) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nRecNo := (::cAlias)->( Recno() )




   IIF( lSoftSeek == nil, lSoftSeek := .T., ) ; IIF( bEof == nil, bEof := {|| .T. }, ); IIF( lUpper == nil, lUpper := .T., ); IIF( cBuffer == nil, cBuffer := ::cBuffer, );

   cBuffer:= If( ! lUpper, cBuffer, Upper( cBuffer ) )

   If nLenBuffer <> Nil
      cBuffer:= SubStr( cBuffer, 1, nLenBuffer )
   EndIf

   If Len( cBuffer ) > 0 .AND. ! Empty( cBuffer )

      (::cAlias)->( DbSeek( cBuffer, lSoftSeek ) )

      if nRecNo <> (::cAlias)->( Recno() )
         if ( ::cAlias ) ->( Eof() )
            ( ::cAlias ) -> ( DbGoto( nRecNo ) )
            Eval( bEof )
         else
            if ::bChange <> nil
               Eval( ::bChange, Self )
            endif
            return .T.
         endif
      endif
   EndIf
   if ::bChange <> nil
      Eval( ::bChange, Self )
   endif
return .F.



UTILITY STATIC function TWBrowse_KeyChar( nKey, nFlags) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

 LOCAL lRefresh

   do case
      case nKey == 18
           ::cBuffer:= ""
           ::oVScroll:PageUp()

      case nKey == 3
           ::cBuffer:= ""
           ::oVScroll:PageDown()

      case ::bSeek <> Nil .AND. !::lWorking .AND. nKey >= 32


           ::lWorking:= .T.
           if Len( ::cBuffer ) < ::nBuffer
              ::cBuffer += Chr( nKey )
              if "L" $ ValType( lRefresh:= Eval( ::bSeek ) ) .AND. lRefresh
                 ::nRowPos:= Max( Min( ::nLen, ::nRowCount ), 1 )
                 ::Refresh()
              endif
           endif
           ::lWorking:= .F.

      otherwise
           return ::TControl:KeyChar( nKey, nFlags )
   endcase

   IIF( ::bSeek <> Nil .AND. ::bUpdateBuffer <> Nil, Eval( ::bUpdateBuffer ), )

return 0



UTILITY STATIC function TWBrowse_PageUp( nLines) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nSkipped

   WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )

   IIF( nLines == nil, nLines := ::nRowCount(), ) ;

   nSkipped = ::Skip( -nLines )

   if ( ::nLen := Eval( ::bLogicLen ) ) < 1
      return nil
   endif

   if ! ::lHitTop

      if nSkipped == 0
         ::lHitTop = .T.
      else
         ::lHitBottom = .F.
         if -nSkipped < nLines
            ::nRowPos = 1
            if ::oVScroll <> nil
               If ::bLogicPos <> Nil
                  ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )
               Else
                  ::oVScroll:SetPos( 1 )
               EndIf
            endif
         else

            nSkipped = ::Skip( -nLines )
            ::Skip( -nSkipped )

            if ::oVScroll <> nil

               If ::bLogicPos <> Nil
                  ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )
               Else
                  ::oVScroll:SetPos( ::oVScroll:GetPos() + nSkipped )
               EndIf

            endif

         endif
         ::Refresh()
         if ::bChange <> nil
            Eval( ::bChange, Self )
         endif

      endif



   else
      if ::oVScroll <> nil

         If ::bLogicPos <> Nil
            ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )
         Else
            ::oVScroll:GoTop()
         EndIf

      endif
   endif

return nil



UTILITY STATIC function TWBrowse_PageDown( nLines) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nSkipped, n

   WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )

   ::lGoTop:= .F.
   ::lGoBottom:= .F.

   IIF( nLines == nil, nLines := ::nRowCount(), ) ;

   if ( ::nLen := Eval( ::bLogicLen ) ) < 1
      return nil
   endif

   if ! ::lHitBottom

      ::DrawLine()
      nSkipped = ::Skip( ( nLines * 2 ) - ::nRowPos )

      if nSkipped <> 0
         ::lHitTop = .F.
      endif

      do case
         case nSkipped == 0 .OR. nSkipped < nLines
              if nLines - ::nRowPos < nSkipped
                 ::GetDC()
                 ::Skip( -( nLines ) )
                 for n = 1 to ( nLines - 1 )
                     ::Skip( 1 )
                     ::DrawLine( n )
                 next
                 ::ReleaseDC()
                 ::Skip( 1 )
              endif
              ::nRowPos = Min( ::nRowPos + nSkipped, nLines )
              ::lHitBottom = .T.
              if ::oVScroll <> nil
                  If ::bLogicPos <> Nil
                     ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )
                  Else
                     ::oVScroll:GoBottom()
                  EndIf

              endif

         otherwise
              ::GetDC()
              for n = nLines to 1 step -1
                  ::DrawLine( n )
                  ::Skip( -1 )
              next
              ::ReleaseDC()
              ::Skip( ::nRowPos )
      endcase
      ::DrawSelect()

      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif

      ::lLogicPos:= .T.
      if ::oVScroll <> nil
         if ! ::lHitBottom

            If ::bLogicPos <> Nil
               ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )
            Else
               ::oVScroll:SetPos( ::oVScroll:GetPos() + nSkipped - ( nLines - ::nRowPos ) )
            EndIf

         else
            If ::bLogicPos <> Nil
               ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )
            Else
               ::oVScroll:GoBottom()
            EndIf

         endif
      endif

   endif

return nil



UTILITY STATIC function TWBrowse_VScroll( nWParam, nLParam) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nLen
   local nLines      := ::nRowCount()
   local nScrollCode := nLoWord( nWParam )
   local nPos        := nHiWord( nWParam )

   if GetFocus() <> ::hWnd
      SetFocus( ::hWnd )
   endif

   do case
      case nScrollCode == 0
           ::GoUp()

      case nScrollCode == 1
           ::GoDown()

      case nScrollCode == 2
           ::PageUp()

      case nScrollCode == 3
           ::PageDown()

      case nScrollCode == 6
           ::GoTop()

      case nScrollCode == 7
           ::GoBottom()

      case nScrollCode == 4
           if ( ::nLen := Eval( ::bLogicLen ) ) < 1
              return 0
           endif

           if nPos <= 1
              ::GoTop()

           elseif nPos == ::oVScroll:GetRange()[ 2 ]
              ::GoBottom()

           else

              ::lHitTop = .F.
              ::lHitBottom = .F.


              If ::bGoLogicPos <> Nil

                 CursorWait()

                 Eval( ::bGoLogicPos, Int( nPos / 100 * ::nLen ) )

                 ::oVScroll:SetPos( ( Eval( ::bLogicPos ) - 1 ) / Max( 1, ::nLen - 1 ) * 100 )

                 ::Refresh()


                 CursorArrow()
                 if ::bChange <> nil
                    Eval( ::bChange, Self )
                 endif
                 return 0

              Else

                 CursorWait()
                 ::Skip( nPos - ::oVScroll:GetPos() )
                 CursorArrow()

              EndIf
           endif

           ::oVScroll:SetPos( nPos )

           nLen = Eval( ::bLogicLen )
           if nPos - ::oVScroll:nMin < nLines
              ::nRowPos = 1
           endif
           if ::oVScroll:nMax - nPos < Min( nLines, nLen )
              ::nRowPos = Min( nLines, nLen ) - ( ::oVScroll:nMax - nPos )
           endif
           ::Refresh()
           if ::bChange <> nil
              Eval( ::bChange, Self )
           endif

      otherwise
           return nil
   endcase

return 0



UTILITY STATIC function TWBrowse_HScroll( nWParam, nLParam) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nCol := ::nColPos






      local nScrollCode := nLoWord( nWParam )
      local nPos        := nHiWord( nWParam )


   if ::oGet <> nil .AND. ! Empty( ::oGet:hWnd )
      ::oGet:End()
   endif






   If ::oHScroll == nil
      return 0
   EndIf



   do case
      case nScrollCode == 0
           If ::GoLeft()
              ::Refresh()
           EndIf
      case nScrollCode == 1
           If ::GoRight()
              ::Refresh()
           EndIf

      case nScrollCode == 2

           If ! ::nFreeze > 0

              while ::nColPos > 1 .AND.  (::IsColVisible( nCol ) .OR. ::nColPos == nCol)
                 ::nColPos--
              end
              ::nColAct := ::nColPos
              ::oHScroll:SetPos( ::nColAct )
              ::Refresh()

           Else
              ::GoLeft()
           EndIf

      case nScrollCode == 3

           If ! ::nFreeze > 0

              while nCol < Len( ::GetColSizes() ) .AND.  (::IsColVisible( nCol ) .OR. ::nColPos == nCol)
                 nCol++
              end
              ::nColPos := nCol
              ::nColAct := nCol
              ::oHScroll:SetPos( nCol )
              ::Refresh()

           Else
              ::GoRight()
           EndIf

      case nScrollCode == 6
           ::GoToCol( 1 )


      case nScrollCode == 7
           ::GoToCol( Len( ::GetColSizes() ) )

      case nScrollCode == 4
           ::GoToCol( nPos )

      otherwise
           return nil
   endcase

return 0



UTILITY STATIC function TWBrowse_Skip( n) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   if ::bSkip <> nil
      return Eval( ::bSkip, n )
   endif

return ( ::cAlias )->( DbSkipper( n ) )



static function BrwGoBottom( uExpr )

   local lSoftSeek := Set( 9, .T. )

   if ValType( uExpr ) == "C"

      DbSeek( SubStr( uExpr, 1, Len( uExpr ) - 1 ) +  Chr( Asc( SubStr( uExpr, Len( uExpr ) ) ) + 1 ) )
   else
      DbSeek( uExpr + 1 )
   endif
   DbSkip( -1 )

   Set( 9, lSoftSeek )

return nil





static function BuildSkip( cAlias, cField, uValue1, uValue2 )

   local bSkipBlock
   local cType := ValType( uValue1 )

   do case
      case cType == "C"


           bSkipBlock = { | n | ( cAlias )->( BrwGoTo( n,  &( "{||" + cField + ">= '" + uValue1 + "' .and." +  cField + "<= '" + uValue2 + "' }" ) ) ) }

      case cType == "D"


           bSkipBlock = { | n | ( cAlias )->( BrwGoTo( n,  &( "{||" + cField + ">= CToD( '" + DToC( uValue1 ) + "') .and." +  cField + "<= CToD( '" + DToC( uValue2 ) + "') }" ) ) ) }

      case cType == "N"


           bSkipBlock = { | n | ( cAlias )->( BrwGoTo( n,  &( "{||" + cField + ">= " + cValToChar( uValue1 ) + " .and." +  cField + "<= " + cValToChar( uValue2 ) + " }" ) ) ) }

      case cType == "L"


           bSkipBlock = { | n | ( cAlias )->( BrwGoTo( n,  &( "{||" + cField + ">= " + cValToChar( uValue1 ) + " .and." +  cField + "<= " + cValToChar( uValue2 ) + " }" ) ) ) }
   endcase

return bSkipBlock



static function BrwGoTo( n, bWhile )

   local nSkipped := 0, nDirection := If( n > 0, 1, -1 )

   while nSkipped <> n .AND. Eval( bWhile ) .AND. ! EoF() .AND. ! BoF()
      DbSkip( nDirection )
      nSkipped += nDirection
   enddo

   do case
      case EoF()
         DbSkip( -1 )
         nSkipped += -nDirection

      case BoF()
         DbGoTo( RecNo() )
         nSkipped++

      case ! Eval( bWhile )
         DbSkip( -nDirection )
         nSkipped += -nDirection
   endcase

return nSkipped




UTILITY STATIC function TWBrowse__RecCount(uSeekValue) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nRecNo := ( ::cAlias )->( RecNo() )
   local nRecs  := 1
   local bField := &( "{ || " + ::cField + "}" )

   if ! ( ::cAlias )->( DbSeek( uSeekValue, .T. ) )

      if ( ::cAlias )->( Eval( bField ) ) > ::uValue2  .OR. ( ::cAlias )->( EoF() )
         nRecs := 0
      endif
   endif



   if ::nMaxFilter == nil
      while ::Skip( 1 ) == 1
         nRecs++
      end
   else
      while ::Skip( 1 ) == 1 .AND. nRecs < ::nMaxFilter
         nRecs++
      end
   endif

   ( ::cAlias )->( DbGoTo( nRecNo ) )

return nRecs



static function GenLocal( aArray, nPos )

return { || If( nPos <= Len( aArray ), aArray[ nPos ], "  " ) }

static function GenBlock( bLine, nPos ) ;  return { || Eval( bLine )[ nPos ] }



UTILITY STATIC function TWBrowse_Report( cTitle, lPreview) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local oRpt

   local nRecNo := If( Upper( ::cAlias ) <> "ARRAY" .AND.  Upper( ::cAlias ) <> "_TXT_" , ( ::cAlias )->( RecNo() ), 0 )
   local aData  := Eval( ::bLine )
   local n
   local nCharWidth

   nCharWidth := GetTextWidth( 0, "B", If( ::oFont <> nil, ::oFont:hFont, 0 ))

   IIF( cTitle == nil, cTitle := ::oWnd:cTitle, ) ; IIF( lPreview == nil, lPreview := .T., );

   if lPreview


      oRpt := RptBegin({{|| cTitle}}, {{|| "Fecha: " + DToC( Date() ) + ", Hora: " + Time()}}, {{|| "Pgina: " + Str( oRpt:nPage, 3 )}}, {}, {}, .F.,,,, .T.,,,,,, )
   else


      oRpt := RptBegin({{|| cTitle}}, {{|| "Fecha: " + DToC( Date() ) + ", Hora: " + Time()}}, {{|| "Pgina: " + Str( oRpt:nPage, 3 )}}, {}, {}, .F.,,,, .F.,,,,,, )
   endif

   if Empty( oRpt ) .OR. oRpt:oDevice:hDC == 0
      return nil
   else
      Eval( ::bGoTop )
   endif

   if ::aColSizes == nil
      ::aColSizes = Array( Len( aData ) )
      for n = 1 to Len( aData )
         ::aColSizes[ n ] = 80
      next
   else
      if Len( ::aColSizes ) < Len( aData )
         n = Len( ::aColSizes )
         while n++ < Len( aData )
            AAdd( ::aColSizes, 80 )
         end
      endif
   endif

   for n = 1 to Len( aData )
      if ValType( aData[ n ] ) <> "N"


         oRpt:AddColumn( TrColumn():New( { GenLocal( ::aHeaders, n ) },, { GenBlock( ::bLine, n ) }, Int( ::aColSizes[ n ]/ nCharWidth ),,,,,,,,, oRpt ) )
      else


         oRpt:AddColumn( TrColumn():New( { GenLocal( ::aHeaders, n ) },, { { || "   " } }, Int( ::aColSizes[ n ] / nCharWidth ),,,,,,,,, oRpt ) )
      endif
   next
   RptEnd()

   oRpt:bSkip = { || oRpt:Cargo := ::Skip( 1 ) }
   oRpt:Cargo = 1




   oRpt:Activate(, {|| If( Upper( ::cAlias ) == "ARRAY" .OR. Upper( ::cAlias ) == "_TXT_" , oRpt:nCounter < Eval( ::bLogicLen ), oRpt:Cargo == 1 )},,,,,,,,,,,, )

   if Upper( ::cAlias ) <> "ARRAY" .AND. Upper( ::cAlias ) <> "_TXT_"
      ( ::cAlias )->( DbGoTo( nRecNo ) )
   endif
   ::Refresh()

return nil














































UTILITY STATIC function TWBrowse_SetFilter( cField, uVal1, uVal2) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local bGoTop, bGoBottom, bLogicLen, bLogicPos, bGoLogicPos, bSkip
   local cIndexType

   IIF( uVal2 == nil, uVal2 := uVal1, ) ;

   ::cField       := cField
   ::uValue1      := uVal1
   ::uValue2      := uVal2

   if Select( ::cAlias ) == 0
      Return nil
   end

   if uVal1 <> nil
      cIndexType  := ( ::cAlias )->( ValType( &( IndexKey() ) ) )


      if ( ::cAlias )->( ValType( &cField ) ) <> cIndexType .OR.  ValType( uVal1 ) <> cIndexType .OR.  ValType( uVal2 ) <> cIndexType
         MsgAlert( "TWBrowse SetFilter() types don't match with current Index Key type!" )
      endif
   endif



   if !Empty( ::cAlias )

      bGoTop       = If( uVal1 <> nil, { || ( ::cAlias )->( DbSeek( uVal1, .T. ) ) }, { || ( ::cAlias )->( DbGoTop() ) } )
      ::bGoTop     = {|| If( Empty( ::cAlias ), 0, Eval( bGoTop ) ) }

      bGoBottom    = If( uVal2 <> nil, { || ( ::cAlias )->( BrwGoBottom( uVal2 ) ) }, { || ( ::cAlias )->( DbGoBottom() ) } )
      ::bGoBottom  = {|| If( Empty( ::cAlias ), 0, Eval( bGoBottom ) ) }


      bSkip        = If( uVal1 <> nil, BuildSkip( ::cAlias, cField, uVal1, uVal2 ), { | n | ( ::cAlias )->( DbSkipper( n ) ) } )
      ::bSkip      = {|n| If( Empty( ::cAlias ), 0, Eval( bSkip, n ) ) }



      If cDriver() $ ( ::cAlias )->( RddName() )

          bLogicLen     = { |n| n := If( Empty( Select( ::cAlias ) ), 0, ( ::cAlias )->( OrdKeyCount() ) ), If( "N" $ ValType( n ), n, 0 ) }
          ::bLogicLen   = { |n| If( Empty( Select( ::cAlias ) ), 0, Eval( bLogicLen ) ) }

          bLogicPos     = { |n| n := If( Empty( Select( ::cAlias ) ), 0, ( ::cAlias )->( OrdKeyNo() ) ), If( "N" $ ValType( n ), n, 0 ) }
          ::bLogicPos   = { |n| If( Empty( Select( ::cAlias ) ), 0, Eval( bLogicPos ) ) }

          bGoLogicPos   = { |nKeyNo| If( Empty( Select( ::cAlias ) ), 0, ( ::cAlias )->( OrdKeyGoTo( nKeyNo ) ) ) }
          ::bGoLogicPos = { |n| If( Empty( Select( ::cAlias ) ), 0, Eval( bGoLogicPos, n ) ) }

      Else



          bLogicLen    = If( uVal1 <> nil, { || ( ::cAlias )->( Self:RecCount( uVal1 ) ) }, { || ( ::cAlias )->( RecCount() ) } )
          ::bLogicLen   = {|n| If( Empty( ::cAlias ), 0, Eval( bLogicLen ) ) }

          ::bLogicPos   = Nil
          ::bGoLogicPos = Nil

      EndIf


      ::nLen       = Eval( ::bLogicLen )

      ::lHitTop    = .F.
      ::lHitBottom = .F.

      if uVal1 <> nil
         Eval( ::bGoTop )
      endif
   else
      ::bLogiclen = { || 0 }
   endif

return nil



UTILITY STATIC function TWBrowse_MouseMove( nRow, nCol, nKeyFlags) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nColPos := 0

   ::TControl:MouseMove( nRow, nCol, nKeyFlags )

   if ::lDrag
      return ::TControl:MouseMove( nRow, nCol, nKeyFlags )
   endif

   if ::lCaptured
      CursorWE()
      ::VertLine( nCol )
      return 0
   endif






   if ::lMChange .AND.  (::IsOverHeader( nRow, nCol ) .OR. ::IsOverFooter( nRow, nCol )) .AND. AScan( ::GetColSizes(), { | nColumn | nColPos += nColumn, nCol >= nColPos - 1 .AND.  nCol <= nColPos + 1 }, ::nColPos ) <> 0
      CursorWE()
   else
      ::TControl:MouseMove( nRow, nCol, nKeyFlags )
   endif

return 0



UTILITY STATIC function TWBrowse_MouseWheel( nKeys, nDelta, nXPos, nYPos) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local aPos := { nYPos, nXPos }

   aPos = ScreenToClient( ::hWnd, aPos )

   if aPos[ 1 ] > ::nHeight * 0.80
      if nDelta > 0
         ::GoUp()

      else
         ::GoDown()

      endif
   else
      if lAnd( nKeys, 16 )
         if nDelta > 0
            ::PageUp()
         else
            ::PageDown()
         endif
      else
         if nDelta > 0
            ::GoUp()
         else
            ::GoDown()
         endif
      endif
   endif

return nil




UTILITY STATIC function TWBrowse_VertLine( nColPos, nColInit) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local oRect, aSizes, nFor

   static nCol, nWidth, nMin, nOldPos := 0

   if nColInit <> nil
      nCol    = nColInit
      nWidth  = nColPos
      nOldPos = 0
      nMin := 0
      aSizes := ::GetColSizes()

      FOR nFor := ::nColPos TO nColInit - 1
          nMin += aSizes[nFor]
      NEXT

      nMin += 5
   endif

   if nColPos == nil .AND. nColInit == nil
      ::aColSizes[ nCol ] -= ( nWidth - nOldPos )
      ::Refresh()
   endif

   if nColPos <> nil
     nColPos := Max(nColPos, nMin)
   endif

   oRect = ::GetRect()
   ::GetDC()
   if nOldPos <> 0

      InvertRect( ::hDC, { 0, nOldPos - 0.5, oRect:nBottom, nOldPos + 0.5 } )
      nOldPos = 0
   endif
   if nColPos <> nil .AND. ( nColPos - 2 ) > 0

      InvertRect( ::hDC, { 0, nColPos - 0.5, oRect:nBottom, nColPos + 0.5 } )
      nOldPos = nColPos
   endif
   ::ReleaseDC()

return nCol



UTILITY STATIC function TWBrowse_nAtIcon( nRow, nCol) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nIconsByRow := Int( ::nWidth() / 50 )

   nRow -= 9
   nCol -= 1

   if ( nCol % 50 ) >= 9 .AND. ( nCol % 50 ) <= 41
      return Int( ( nIconsByRow * Int( nRow / 50 ) ) + Int( nCol / 50 ) ) + 1
   else
      return 0
   endif

return nil



UTILITY STATIC function TWBrowse_Display() ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nRecs

   ::BeginPaint()
   if ::oVScroll <> nil

      if ::bLogicLen <> nil
         nRecs := Eval( ::bLogicLen )
      else
         nRecs := 0
      end

      If ::bLogicPos <> Nil

         If nRecs > 0 .AND. ::oVScroll:GetRange()[1] < 1
            ::oVScroll:SetRange( 1, 100 )
         ElseIf nRecs < 1
            ::oVScroll:SetRange( 1, 100 )

         EndIf
         ::oVScroll:SetPage( Min( ::nRowCount(), ::nLen - 1 ) )

      Else

         if ::oVScroll:nMax <> nRecs .OR. nRecs <> ::nLen
            ::oVScroll:SetRange( 1, ::nLen := nRecs )
            ::oVScroll:SetPage( Min( ::nRowCount(), ::nLen - 1 ) )
         endif
     EndIf
   endif

   if ::oHScroll <> nil
      ::oHScroll:SetRange( 1, Len( ::GetColSizes() ) )
      ::oHScroll:SetPage( 1, Len( ::GetColSizes() ) )
   endif

   ::Paint()
   ::EndPaint()

return 0



UTILITY STATIC function TWBrowse_GetDlgCode( nLastKey) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse




   if ! ::oWnd:lValidating

      if nLastKey == 38 .OR. nLastKey == 40  .OR. nLastKey == 13 .OR. nLastKey == 9
         ::oWnd:nLastKey = nLastKey
      else
         ::oWnd:nLastKey = 0
      endif
   endif

return If( IsWindowEnabled( ::hWnd ), 4, 0 )



function _aFields( Self )

   local aFld, aSizes, cAlias := ::cAlias
   local nCols, nFirstCol, nLastCol, nWidth, nBrwWidth

   if Empty( cAlias )
      return {}
   endif

   if Len( ::aColSizes ) == 0
      return Array( ( cAlias )->( Fcount() ) )
   endif

  aSizes    = ::aColSizes
  nCols     = Len( aSizes )
  nFirstCol = ::nColPos
  nLastCol  = nFirstCol
  nWidth    = 0
  nBrwWidth = ::nWidth()
  aFld      = Array( nCols )

  AFill( aFld, "" )

  while nWidth < nBrwWidth .AND. nLastCol <= nCols
     nWidth += aSizes[ nLastCol ]
     if ValType( ( cAlias )->( FieldGet( nLastCol ) ) ) == "M"

        aFld[ nLastCol ] = If( ! Empty( ( cAlias )->(  FieldGet( nLastCol ) ) ), "<Memo>", "<memo>" )
        nLastCol++
     else
        aFld[ nLastCol ] = cValToChar( ( cAlias )->( FieldGet( nLastCol ) ) )
        nLastCol++
     endif
  end

return aFld



UTILITY STATIC function TWBrowse_SetCols( aData, aHeaders, aColSizes) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local aFields
   local nElements, n

   nElements   := Len( aData )

   ::aHeaders  := If( aHeaders  <> nil, aHeaders, ::aHeaders )
   ::aColSizes := If( aColSizes <> nil, aColSizes, {} )
   ::bLine     := {|| _aData( aData ) }
   ::aJustify  := AFill( Array( nElements ), .F. )

   if Len( ::GetColSizes() ) < nElements
      ::aColSizes = AFill( Array( nElements ), 0 )
      aFields = Eval( ::bLine )
      for n = 1 to nElements





          ::aColSizes[ n ] := If( ValType( aFields[ n ] ) <> "C", 15, GetTextWidth( 0, Replicate( "B",  Max( Len( ::aHeaders[ n ] ),  Len( aFields[ n ] ) ) + 1 ), If( ! Empty( ::oFont ), ::oFont:hFont,) ) )
      next
   endif

   if ::oHScroll <> nil
      ::oHScroll:nMax := ::GetColSizes()
   endif

return nil



UTILITY STATIC function TWBrowse_ShowSizes() ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local cText := ""


   AEval( ::aColSizes, { | v,e | cText += ::aHeaders[ e ] + ": " + Str( v, 3 ) + Chr(13)+Chr(10) } )

   MsgInfo( cText )

return nil



UTILITY STATIC function TWBrowse__DrawIcon(nIcon, lFocused) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local nIconsByRow := Int( ::nWidth() / 50 )
   local nRow := Int( --nIcon / nIconsByRow )
   local nCol := If( nRow > 0, nIcon % ( nRow * nIconsByRow ), nIcon )

   IIF( lFocused == nil, lFocused := .F., ) ;

   if lFocused

      DrawIconFocus( ::GetDC(), ( nRow * 50 ) + 10, ( nCol * 50 ) + 10, ExtractIcon( "user.exe" ) )
   else

      DrawIcon( ::GetDC(), ( nRow * 50 ) + 10, ( nCol * 50 ) + 10, ExtractIcon( "user.exe" ) )
   endif

return nil



UTILITY STATIC function TWBrowse_IsColVisible( nCol) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

 LOCAL aSizes:= ::GetColSizes()
 LOCAL nLenSizes:= Len( aSizes )
 LOCAL nSizeAcum:= 0, nId

 LOCAL nBrwWidth := ::nWidth -  If( ::oVScroll <> nil, If( ::oVScroll <> Nil .AND. Eval(::bLogicLen) > 1, 18, 0 ) , 0 )

    For nId = ::nColPos To nLenSizes
        If nId < 1
          return .F.
        EndIf
        nSizeAcum+= aSizes[nId]
        If nId == nCol
           If nSizeAcum <= nBrwWidth
              return .T.
           EndIf
           Exit
        EndIf
    Next

return .F.


UTILITY STATIC function TWBrowse_DrawHeaders( nColPressed) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
   If ::lDrawHeaders
      WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )
      IIF( nColPressed == nil, nColPressed := ::nColHPressed, ) ;




      WBrwLine( ::hWnd, ::hDC, 0, ::aHeaders, ::GetColSizes(), ::nColPos, ::nClrForeHead, ::nClrBackHead, If( ::oFont <> nil, ::oFont:hFont, 0 ),.F., If( ::aHJustify <> Nil, ::aHJustify, ::aJustify ), nColPressed, ::nHeaderStyle, 0, .F., ::bTextColor, ::bBkColor, ::nClrLine,,,::bFont )

      EndIf
return Nil


UTILITY STATIC function TWBrowse_DrawFooters( nColPressed) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   LOCAL aFooters
   LOCAL nLen
   LOCAL cType

   if ::lDrawFooters

      cType       := Valtype( ::aFooters )

      If Empty( ::oFontFooter )
         ::oFontFooter:= ::oFont
      EndIf

      If "B" $ cType
         aFooters := Eval( ::aFooters )
      ElseIf "A"$cType
         aFooters := aClone( ::aFooters )
      Else
         aFooters := {}
      EndIf

      If Len( aFooters ) <> ( nLen := Len( ::GetColSizes() ) )
         ASize( aFooters, nLen )
      EndIf

      AEval( aFooters, {|uElem,n| aFooters[n] := If( "B" $ ValType( uElem ), Eval( uElem ), uElem ) } )

      WBrwSet( ::lAdjLastCol, ::lAdjBrowse, ::lDrawHeaders, ::lDrawFooters, ::nHeaderHeight, ::nFooterHeight, ::nLineHeight )

      IIF( nColPressed == nil, nColPressed := ::nColFPressed, ) ;





      WBrwLine( ::hWnd, ::hDC, 0, aFooters, ::GetColSizes(), ::nColPos, ::nClrFFore, ::nClrFBack, If( ::oFontFooter <> nil, ::oFontFooter:hFont, 0 ),.F., If( ::aFJustify <> Nil, ::aFJustify, ::aJustify ), nColPressed, ::nFooterStyle, 0, .F., ::bTextColor, ::bBkColor, ::nClrLine, .T.,,::bFont )

   end

return Nil


UTILITY STATIC function TWBrowse_IsOverHeader( nMRow, nMCol) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

    If ::lDrawHeaders .AND. nMRow <= ::nHeaderHeight
       If nMCol <> Nil
          return ::nWCol( nMCol ) > 0
       Else
          return .T.
       EndIf
    EndIf
return .F.

UTILITY STATIC function TWBrowse_IsOverFooter( nMRow, nMCol) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
 LOCAL aRect
    If ::lDrawFooters
       aRect:= GetClientRect( ::hWnd )

       If nMRow <= aRect[3] .AND. nMRow >= ( aRect[3] - (::nFooterHeight+1) )
          If nMCol <> Nil
             return ::nWCol( nMCol ) > 0
          Else
             return .T.
          EndIf
       EndIf
    EndIf
return .F.

UTILITY STATIC function TWBrowse_GetColHeader( nMRow, nMCol) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
   If ::IsOverHeader( nMRow, nMCol )
      return ::nWCol( nMCol )
   EndIf
return 0

UTILITY STATIC function TWBrowse_GetColFooter( nMRow, nMCol) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
   If ::IsOverFooter( nMRow, nMCol )
      return ::nWCol( nMCol )
   EndIf
return 0


UTILITY STATIC function TWBrowse_GoToCol( nCol) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
 LOCAL nCols
 LOCAL nLen:= ::nLen
 LOCAL lRefreshAll:= .F., nColAct

    If nCol > ::nColAct
      ::nLen:= 0
       nCols:= Len( ::aColSizes() )


       while nCol > ::nColAct .AND. ::nColAct < nCols
          nColAct:= ::nColAct
          If ::GoRight(.F.) .AND. !lRefreshAll
             lRefreshAll:= .T.
          EndIf
          If nColAct == ::nColAct
             Exit
          EndIf
       EndDo

    ElseIf nCol < ::nColAct
      ::nLen:= 0
       while nCol < ::nColAct .AND. ::nColAct > 1
          nColAct:= ::nColAct
          If ::GoLeft(.F.) .AND. !lRefreshAll
             lRefreshAll:= .T.
          EndIf
          If nColAct == ::nColAct
             Exit
          EndIf
       EndDo

    EndIf

    If lRefreshAll
       ::Refresh()
    Else
       ::nLen:= nLen
       ::DrawSelect()
    EndIf

    If ::oHScroll <> Nil
       ::oHScroll:SetPos( ::nColAct )
    EndIf

return Nil


UTILITY STATIC function TWBrowse_Refresh( lSysRefresh) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

    local n

    IIF( lSysRefresh == nil, lSysRefresh := .F., ) ;

    ::lLogicLen:= .T.
    ::lLogicPos:= .T.

    if Valtype( ::aTmpColSizes ) == "A" .AND. Valtype( ::aColSizes ) == "A"
       if Len( ::aTmpColSizes ) <> Len( ::aColSizes )
         ::aTmpColSizes:= aSize( ::aTmpColSizes, Len(::aColSizes) )
         for n = 1 To Len( ::aTmpColSizes )
            if ::aTmpColSizes[n] == nil
               ::aTmpColSizes[n]:= ::aColSizes[n]
            endif
         next
       endif
    endif

    if ::oHScroll <> nil .AND. ::oHScroll:GetRange[2] <> Len( ::GetColSizes() )
       ::oHScroll:SetRange( 1, Len( ::GetColSizes() ) )
       ::oHScroll:SetPage( 1, Len( ::GetColSizes() ) )
    endif


    If ::Cargo <> Nil .OR.  !( ::nLen := Eval( ::bLogicLen ) ) > 0
       ::TControl:Refresh()
    Else

       ::lHitBottom  := .F.
       ::lHitTop     := .F.

       ::DrawFooters()

       ::TControl:Refresh( .F. )

       If lSysRefresh
          SysRefresh()
       EndIf

    EndIf
return 0



static function _aData( aFields )

   local nFor
   local nLen   := Len( aFields )
   local aFld   := Array( nLen )

   for nFor = 1 to nLen
      aFld[ nFor ] = Eval( aFields[ nFor ] )
   next

return aFld


























































































STATIC Function EmptyAlias( cAlias )
 LOCAL lEmpty:= .T.

    If ! Empty( cAlias )
       If cAlias == "ARRAY" .OR. cAlias == "_TXT_"
          lEmpty:= .F.
       Else
          lEmpty:= ! Select( cAlias ) > 0
       EndIf
    EndIf
return lEmpty



UTILITY STATIC function TWBrowse_nWRow( nMRow) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
 LOCAL aRect, nRows, nHeight, nRow

    If ::IsOverHeader( nMRow ) .OR. ::IsOverFooter( nMRow )
       return 0
    EndIf

    nRows:= ::nRowCount()
    nHeight:= ::nLineHeight + 1

    aRect:= { 0, nHeight }

    If ::lDrawHeaders
       aRect[1]:= ::nHeaderHeight + 1
       aRect[2]:= aRect[1] + nHeight
    EndIf

    For nRow = 1 To nRows
        If nMRow >= aRect[1] .AND. nMRow <= aRect[2]
           return nRow
        EndIf
        aRect[1]+= nHeight
        aRect[2]+= nHeight
    Next

return 0


UTILITY STATIC function TWBrowse_nWCol( nMCol) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
 LOCAL aSizes, nAcum:= 0, nBrwWidth, nCol


    nBrwWidth := ::nWidth - If( ::oVScroll <> nil, If( ::oVScroll <> Nil .AND. Eval(::bLogicLen) > 1, 18, 0 ), 0 )
    aSizes:= ::GetColSizes()
    If ::lAdjLastCol
       aSizes[Len(aSizes)]:= nBrwWidth
    EndIf
    For nCol = ::nColPos To Len( aSizes )
        If nMCol <= ( nAcum + aSizes[nCol] )
           return nCol
        EndIf
        nAcum+= aSizes[nCol]
        If nAcum >= nBrwWidth
           Exit
        EndIf
    Next

return 0


UTILITY STATIC function TWBrowse_Set3DStyle() ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   ::nLineStyle    := 3


   ::nClrForeHead  := GetSysColor( 9 )
   ::nClrBackHead  := GetSysColor( 2 )


   ::nClrFFore     := ::nClrForeHead
   ::nClrFBack     := ::nClrBackHead


   ::nClrBackFocus := 8421376
   ::nClrForeFocus := 16777215


   ::nClrNFBack    := 8421504
   ::nClrNFFore    := 16777215


   ::SetColor( 0, GetSysColor( 15 ) )

   ::Refresh()

return nil



UTILITY STATIC function TWBrowse_aBrwPosRect( nCol, nRow) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   LOCAL nColIni  := ::nColPos
   LOCAL aColSizes:= ::aColSizes
   LOCAL aDim, nWidth, nHeight

    IIF( nCol == nil, nCol := ::nColPos, ) ;
    IIF( nRow == nil, nRow := ::nRowPos, ) ;

    If nCol < nColIni
       nColIni:= nCol
    EndIf

    aDim    := WBrwRect( ::hWnd, nRow, aColSizes, nColIni, nCol, ::nLineStyle, If( ::oVScroll <> Nil .AND. Eval(::bLogicLen) > 1, 18, 0 ) )

    nWidth  := aDim[ 4 ] - aDim[ 2 ] - 1
    nHeight := aDim[ 3 ] - aDim[ 1 ] - 1

    If ::nLineStyle == 3
       aDim[1]--
       aDim[2]--
       aDim[3]--
       aDim[4]--
    EndIf
    aDim[1]+= 2 + If( "TDIALOG" $ ::oWnd:ClassName, 1, 0 )
    aDim[2]+= 2 + If( "TDIALOG" $ ::oWnd:ClassName, 1, 0 )

return { aDim[1], aDim[2], aDim[3] + nWidth, aDim[4] + nHeight, nWidth, nHeight }




UTILITY STATIC function TWBrowse_EditCol( nCol, uVar, cPicture, bValid, nClrFore, nClrBack, aItems, bAction) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local oFont
   local uTemp
   local aDim, aPos
   local cType
   local nWidth, nHeight

   LOCAL nColorCol

   IIF( nCol == nil, nCol := ::nColAct, ) ;

   If nClrFore == Nil

      If "B"$Valtype( ::bTextColor ) .AND.  "N"$Valtype( nColorCol:= Eval( ::bTextColor, ::nRowPos, nCol ) )

         nClrFore:= nColorCol
      Else
         nClrFore := ::nClrText
      EndIf
   EndIf

   If nClrBack == Nil

      If "B"$Valtype( ::bBkColor ) .AND.  "N"$Valtype( nColorCol:= Eval( ::bBkColor, ::nRowPos, nCol ) )

         nClrBack:= nColorCol
      Else
         nClrBack := ::nClrPane
      EndIf
   EndIf


   If "B"$ValType( nClrFore )
      nClrFore:= Eval( nClrFore )
   EndIf
   If "B"$ValType( nClrBack )
      nClrBack:= Eval( nClrBack )
   EndIf


   uTemp   := uVar

   aDim    := ::aBrwPosRect( nCol )


   aPos    := { aDim[ 1 ], aDim[ 2 ] }
   cType   := ValType( uVar )

   nWidth  := aDim[ 4 ] - aDim[ 2 ]
   nWidth  := ::aColSizes[nCol]
   nHeight := aDim[ 3 ] - aDim[ 1 ]

   ScreenToClient( Self:hWnd, aPos )

   IF ::lCellStyle .AND. nCol <> ::nColAct
        ::nColAct := nCol
         if ::oHScroll <> nil
            ::oHScroll:SetPos(nCol)
         endif
        ::Refresh(.F.)
   ENDIF



   IIF( nClrFore == nil, nClrFore := ::nClrText, ) ; IIF( nClrBack == nil, nClrBack := ::nClrPane, ); IIF( bValid == nil, bValid := {|| nil }, );

   if ::oGet <> nil .AND. ! Empty( ::oGet:hWnd )
      ::oGet:End()
   endif

   if ::oFont <> nil

      oFont = TFont():New( ::oFont:cFaceName, ::oFont:nWidth, ::oFont:nHeight, .F., ::oFont:lBold )
   endif

   do case
      case cType == "L"
           IIF( aItems == nil, aItems := { ".T.", ".F." }, ) ;
           uVar = If( uTemp, aItems[ 1 ], aItems[ 2 ] )




           ::oGet := TComboBox():New( aPos[ 1 ] + 1, aPos[ 2 ] + 1, { | u | If( PCount()==0, uVar, uVar:= u ) }, aItems, Min(100,Max(nWidth,50)), 100, Self,, {|Self|::End()},, nClrFore, nClrBack, .T., oFont,, .F.,, .F.,,,,, )

      case aItems <> nil




           ::oGet := TComboBox():New( aPos[ 1 ] + 1, aPos[ 2 ] + 1, { | u | If( PCount()==0, uVar, uVar:= u ) }, aItems, nWidth, Max( 200, Len( aItems ) * 25 ), Self,, {|Self|::End()},, nClrFore, nClrBack, .T., oFont,, .F.,, .F.,,,,, )

      otherwise





          ::oGet := TGet():New( aPos[ 1 ] + 1, aPos[ 2 ] + 1, { | u | If( PCount()==0, uVar, uVar:= u ) }, Self, nWidth, nHeight,,, nClrFore, nClrBack, oFont, .F.,, .T.,, .F.,, .F., .F.,, .F., .F., .F.,, .F.,,,,,,, "uVar", )

          ::oGet:oGet:Picture = cPicture
   endcase

   ::nLastKey := 0
   ::oGet:Set3dLook()
   ::oGet:SetFocus()

   if ::oGet:ClassName() <> "TGET"
      ::oGet:Refresh()
   endif







   ::oGet:bLostFocus := {|| If( ::oGet:ClassName() == "TGET", ( ::oGet:Assign(), ::oGet:VarPut( ::oGet:oGet:VarGet())), ::oGet:VarPut( If( cType == "L", ( uVar == aItems[ 1 ] ), ::oGet:VarGet() ) ) ), If( Self:nLastKey <> 27, Eval( bValid, uVar, Self:nLastKey ), Eval( bValid, nil, Self:nLastKey ) ), ::oGet:End() }



   ::oGet:bKeyDown := { | nKey | If( nKey == 13 .OR.  nKey == 27, ( Self:nLastKey := nKey, ::oGet:End()), ) }
return .F.



UTILITY STATIC function TWBrowse_Edit( nCol, lModal) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
 local oDlg
 LOCAL oTWBrowse:= Self


    oDlg = TDialog():New( 0, 0, 0, 0,,,, .F., nOR( 268435456, 2147483648 ),,,,, .T.,,,,,, .F., )
      oDlg:bStart:= {|| __Edit( oTWBrowse, nCol, lModal ), oDlg:End() }
    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .F.,,,, oDlg:bRClicked,,, )
return Nil



STATIC Function __Edit(Self, nCol, lModal )

 LOCAL nCols:=  Len( Eval( ::bLine ) ), nFail:= 0
 LOCAL lFirstEdit:= .T.
 LOCAL uControl, nControl:= 0
 LOCAL lDrawSelect:= ::lDrawSelect
 LOCAL lCellStyle := ::lCellStyle












   local uTemp, cType, lAutoSave, lContinue:= .T.


   ::lDrawSelect:= .F.
   ::lCellStyle := .T.

   ::DrawSelect()


   IIF( nCol == nil, nCol := 1, ) ; IIF( lModal == nil, lModal := .T., );

   ::GotoCol( nCol )

   while .T.
      uTemp = Eval( ::bLine )[ nCol ]


      If ::GetColSizes()[ nCol ] > 0 .AND. ! "N" $ ValType( uTemp )

        nFail:= 0

        If ::bEdit <> Nil
            uControl:= Eval( ::bEdit, nCol, uTemp, lFirstEdit )
            lFirstEdit:= .F.
            Do Case
            Case "L" $ ValType( uControl )
               If uControl
                  lContinue:= .T.
                  nControl:= 1
               Else
                  lContinue:= .F.
                  nControl:= 0
               EndIf
            Case "N" $ ValType( uControl )
               If uControl < -3 .OR. uControl > 3 .OR. uControl == 0
                  lContinue:= .F.
                  nControl:= 0
               Else
                  lContinue:= .T.
                  nControl:= uControl
               EndIf
            Otherwise
               lContinue:= .F.
               nControl:= 0
            EndCase


        Else

           if ! Empty( ::cAlias ) .AND. Upper( ::cAlias ) <> "ARRAY" .AND. Upper( ::cAlias ) <> "_TXT_"
              lAutoSave = ( cValToChar( ( ::cAlias )->( FieldGet( nCol ) ) ) == uTemp )
              if ( ::cAlias )->( dbRLock() )
                 if lContinue := ::lEditCol( nCol, @uTemp )
                    if lAutoSave
                       cType = ValType( ( ::cAlias )->( FieldGet( nCol ) ) )
                       do case
                          case cType == "D"
                             ( ::cAlias )->( FieldPut( nCol, CToD( uTemp ) ) )

                          case cType == "L"
                             ( ::cAlias )->( FieldPut( nCol, Upper( uTemp ) == ".T." ) )

                          case cType == "N"
                             ( ::cAlias )->( FieldPut( nCol, Val( uTemp ) ) )

                          otherwise
                             ( ::cAlias )->( FieldPut( nCol, uTemp ) )
                       endcase
                    endif
                    ::DrawSelect()
                 endif
                 ( ::cAlias )->( DbUnLock() )
              else
                 MsgStop( "Record locked!", "Please, try again" )
              endif
           else
              ::lEditCol( nCol, @uTemp )
           endif

        EndIf

      Else

        nFail++
        If nFail > nCols
           lContinue:= .F.
        EndIf

      EndIf






      if lContinue .AND. ( ::lAutoSkip .OR. nControl <> 0 )








         Do Case

         Case nControl == 1 .OR. nControl == 0
              nCol++
              If nCol > nCols
                 nCol:= 1
                 ::GoDown()
                 ::GotoCol( nCol )
              Else
                 ::GoRight()
              EndIf

         Case nControl == 2
              ::GoToCol( 1 )
              nCol:= 1
              ::GoDown()
              nControl:= 1


         Case nControl == 3
              ::GoDown()

         Case nControl == -1
              nCol--
              If nCol < 1
                 nCol:= nCols
                 ::GoUp()
                 ::GotoCol( nCol )
              Else
                 ::GoLeft()
              EndIf

         Case nControl == -2
              nCol:= 1
              ::GoToCol( 1 )
              ::GoUp()
              nControl:= 1

         Case nControl == -3
              ::GoUp()
         EndCase

         If ::oHScroll <> Nil
            ::oHScroll:SetPos( nCol )
         EndIf

      EndIf






   if ! ( ::lAutoSkip .AND. lContinue ); exit; end; end



   ::lDrawSelect:= lDrawSelect
   ::lCellStyle := lCellStyle

   If ! ::lCellStyle
      ::nColPos:= 1
      ::nColAct:= 1
      ::Refresh()
   EndIf
   If ::oHScroll <> Nil
      ::oHScroll:SetPos( ::nColAct )
   EndIf

   ::DrawSelect()

return nil


UTILITY STATIC function TWBrowse_lEditCol( nCol, uVar, cPicture, bValid, nClrFore, nClrBack, aItems, bAction, bOnInit, bOnCreate, bOnStart) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local oDlg, oGet, oFont, oBtn
   local uTemp
   local aDim
   local lOk
   local cType
   LOCAL uJustify
   LOCAL bInit
   local nDif

   LOCAL nColorCol
   LOCAL bOldValid




   IIF( nCol == nil, nCol := ::nColAct, ) ; IIF( bAction == nil, bAction := {|| .T. }, ); IIF( bOnInit == nil, bOnInit := {|| .T. }, ); IIF( bOnStart == nil, bOnStart := {|| .T. }, );

   If nClrFore == Nil

      If "B"$Valtype( ::bTextColor ) .AND.  "N"$Valtype( nColorCol := Eval( ::bTextColor, ::nRowPos, nCol ) )

         nClrFore:= nColorCol
      Else
         nClrFore := ::nClrText
      EndIf
   EndIf

   If nClrBack == Nil

      If "B"$Valtype( ::bBkColor ) .AND.  "N"$Valtype( nColorCol:= Eval( ::bBkColor, ::nRowPos, nCol ) )

         nClrBack:= nColorCol
      Else
         nClrBack := ::nClrPane
      EndIf
   EndIf


   If "B"$ValType( nClrFore )
      nClrFore:= Eval( nClrFore )
   EndIf
   If "B"$ValType( nClrBack )
      nClrBack:= Eval( nClrBack )
   EndIf


   uTemp  := uVar

   aDim   := ::aBrwPosRect( nCol )


   lOk    := .F.
   cType  := ValType( uVar )

   IF ::lCellStyle .AND. nCol <> ::nColAct
        ::nColAct := nCol
         if ::oHScroll <> nil
            ::oHScroll:SetPos(nCol)
         endif
        ::Refresh(.F.)
   ENDIF



   oDlg = TDialog():New( 0, 0, 0, 0,,,, .F., nOR( 268435456, 2147483648, 4 ), nClrFore, nClrBack,,, .T.,,,,,, .F., )

   if ::oFont <> nil
      oFont = TFont():New( ::oFont:cFaceName, ::oFont:nWidth, ::oFont:nHeight, .F., ::oFont:lBold )
   endif

   do case
      case cType == "L"
           IIF( aItems == nil, aItems := { ".T.", ".F." }, ) ;
           uVar = If( uTemp, aItems[ 1 ], aItems[ 2 ] )



           oGet := TComboBox():New( 0, 0, { | u | If( PCount()==0, uVar, uVar:= u ) }, aItems, ( aDim[ 4 ] - aDim[ 2 ] ) * 0.50, 50, oDlg,, {|Self|( oDlg:End(), lOk := .T. )},, nClrFore, nClrBack, .F., oFont,, .F.,, .F.,,,,, )

      case aItems <> nil



           oGet := TComboBox():New( 0, 0, { | u | If( PCount()==0, uVar, uVar:= u ) }, aItems, ( aDim[ 4 ] - aDim[ 2 ] ) * 0.50, 50, oDlg,, {|Self|( oDlg:End(), lOk := .T. )},, nClrFore, nClrBack, .F., oFont,, .F.,, .F.,,,,, )

      otherwise

         If cType == "C" .AND. At( Chr(13)+Chr(10), uVar ) > 0

            oGet := TMultiGet():New( 0, 0, { | u | If( PCount()==0, uVar, uVar:= u ) }, oDlg, 0, 0, oFont, .F., nClrFore, nClrBack,, .F.,, .F.,, .F., .F., .F.,,, .F., .T., .T. )
            oGet:bGotFocus := {|| PostMessage(oGet:hWnd, 177, 0, 0)}
         else






            oGet := TGet():New( 0, 0, { | u | If( PCount()==0, uVar, uVar:= u ) }, oDlg, 0, 0, cPicture,, nClrFore, nClrBack, oFont, .F.,, .F.,, .F.,, .F., .F.,, .F., .F., .T.,,,,,,,,, "uVar", )
         EndIf







         If ValType( ::aJustify ) $ "AB"
            If "B" $ ValType( ::aJustify )
               uJustify:= Eval( ::aJustify )
            Else
               uJustify:= AClone( ::aJustify )
            EndIf
            If nCol <= Len( uJustify )
               uJustify:= uJustify[ nCol ]

               If "L" $ ValType( uJustify )
                  uJustify:= If( uJustify, 1, 0 )
               ElseIf ! "N" $ ValType( uJustify )
                  uJustify:= 0
               EndIf

               If lAnd( uJustify, 1 )
                  oGet:nStyle:= nOr( oGet:nStyle, 2 )
               ElseIf lAnd( uJustify, 2 )
                  oGet:nStyle:= nOr( oGet:nStyle, 1 )
               EndIf

            EndIf
         EndIf




   EndCase


   IIF( bOnCreate == nil, bOnCreate := {|oGet, oDlg| .T. }, ) ;
   Eval( bOnCreate, oGet, oDlg )

   bOldValid:= oGet:bValid

   IIF( bOldValid == nil, bOldValid := {|| .T. }, ) ; IIF( bValid == nil, bValid := {|| .T. }, );

   oGet:bValid:= {|| ValidlEditCol( Self, oGet, oDlg, bOldValid, bValid, bAction, @lOk ) }


   oBtn := TButton():New( 10, 0, "", oDlg,,,,,, .F., .F., .F.,, .F.,,, .F. )


   If ::nLineStyle == 3


      bInit:= {|| nDif:= ((aDim[6]-GetTextHeight(oGet:hWnd))/2), oDlg:Move( aDim[ 1 ], aDim[ 2 ], aDim[ 5 ], aDim[ 6 ] ), oGet:Move( 1+nDif, 0, aDim[ 5 ], aDim[ 6 ] )  }

   Else


      bInit:= {|| nDif:= ((aDim[6]-GetTextHeight(oGet:hWnd))/2), oDlg:Move( aDim[ 1 ], aDim[ 2 ], aDim[ 5 ], aDim[ 6 ] ), oGet:Move( 0+nDif, 1, aDim[ 5 ], aDim[ 6 ] )  }
   EndIf

   oDlg:bStart := {|| Eval( bOnStart, oGet, oDlg ) }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .F.,,, {|Self|( Eval( bInit ), Eval( bOnInit, oGet, oDlg ) )}, oDlg:bRClicked,,, )

   if ! lOk
      uVar = uTemp
   else
      if cType == "L"
         uVar = ( uVar == aItems[ 1 ] )
      endif
   endif


return lOk



static function ValidlEditCol( Self, oGet, oDlg, bOldValid, bValid, bAction, lOk )

   local lValid:= .F.
   local bOriginal

   bOriginal:= oGet:bValid
   oGet:bValid:= NIL

   if Eval( bOldValid, oGet )
      ::nLastKey:= oDlg:nLastKey
      if Eval( bValid, oGet )
         lOk:= .T.
         Eval( bAction )
         oDlg:End()
         lValid:= .T.
      endif
   endif

   oGet:bValid:= bOriginal

return lValid



UTILITY STATIC function TWBrowse_SetTXT( uTXT) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse
 LOCAL cType, oTXT

   IIF( uTXT == nil, uTXT := "", ) ;
   cType:= Valtype( uTXT )

   If cType == "C"
      If !File( uTXT )
         uTXT:= cGetFile( "*.txt", "Text Files" )
         If !File( uTXT )
            return .F.
         EndIf
      EndIf
      ::oTXT:= oTXT:= TTxtFile():New( uTXT, 0 )
   ElseIf cType == "O"
      oTXT:= uTXT
   Else
      return .F.
   EndIf

   ::lDrawHeaders  := .F.
   ::aHeaders      := { "" }
   ::aJustify      := { .F. }
   ::aColSizes     := { 2000 }
   ::nLineStyle    := 0
   ::cAlias        := "_TXT_"


   ::bLine         := { |cLine| cLine:= oTXT:ReadLine(), If( IsOem( cLine ), cLine:= OemToAnsi( cLine ),), { SubStr( cLine, ::nTXTFrom ) } }
   ::bLogicLen     := { || ::nLen := oTXT:RecCount() }
   ::bLogicPos     := nil
   ::bGoLogicPos   := nil
   ::bGoTop        := { || oTXT:GoTop() }
   ::bGoBottom     := { || oTXT:GoBottom() }


   ::bSkip         := { | nSkip, nOld | nOld:= oTXT:RecNo(),  oTXT:Skip( nSkip ),    oTXT:RecNo() - nOld }
return nil



UTILITY STATIC function TWBrowse_VerifyLogicLen( nLogicLen) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   IIF( nLogicLen == nil, nLogicLen := 0, ) ;


   if nLogicLen > 0 .AND. ! Empty( ::cAlias ) .AND. Upper( ::cAlias ) <> "ARRAY" .AND. Upper( ::cAlias ) <> "_TXT_"
      if (::cAlias)->( Eof() )
         (::cAlias)->( DbGoTop() )
         if (::cAlias)->( Eof() )
            nLogicLen:= 0
         endif
      endif
   endif

return nLogicLen



UTILITY STATIC function TWBrowse_VerifyLogicPos( nLogicPos) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   IIF( nLogicPos == nil, nLogicPos := 0, ) ;

   if ::lHitTop
      nLogicPos:= 1
      ::lHitBottom:= .F.
   elseif ::lHitBottom .AND. ::nLogicLen <> nil
      nLogicPos:= ::nLogicLen
      ::lHitTop:= .F.
   endif

return nLogicPos

























































UTILITY STATIC function TWBrowse_RightButtonDown( nRow, nCol, nFlags) ; local Self AS CLASS TWBrowse := QSelf() AS CLASS TWBrowse

   local oMenu
   local bMenuSelect

   if oUser():lAdministrador()

      if !::IsOverHeader( nRow, nCol )

         oMenu          := MenuBegin( .T. )
         bMenuSelect    := ::bMenuSelect

         ::bMenuSelect  := nil

         MenuAddItem( "Exportar a E&xcel", "Exportar rejilla de datos a Excel", .F., .T., {|| ::ExportToExcel() }, , "Text_Sum_16", oMenu )

         MenuAddItem( "Exportar a &Word", "Exportar rejilla de datos a Word", .F., .T., {|| ::ExportToWord() }, , "Text_Rich_16", oMenu )

         MenuEnd()

         oMenu:Activate( nRow, nCol, Self )

         ::bMenuSelect  := bMenuSelect

      end

   end

Return Self
