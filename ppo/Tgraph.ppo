#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 35 ".\Prg\Tgraph.prg"
_HB_CLASS TGraph ; UTILITY FUNCTION TGraph(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TGraph" , {TControl():classh} ) ) ; ;

   _HB_MEMBER {AS LOGICAL lRegistered} ; IIF( !.F., s_oClass:AddMultiClsData("LOGICAL",, nScope + IIF( .F., 32, 0 ) + 64, { "lRegistered" }, .F. ), )

   _HB_MEMBER { l3D} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "l3D" }, .F., .F. ), )
   _HB_MEMBER { lxGrid} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lxGrid" }, .F., .F. ), )
   _HB_MEMBER { lyGrid} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lyGrid" }, .F., .F. ), )
   _HB_MEMBER { lDotted} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lDotted" }, .F., .F. ), )
   _HB_MEMBER { lxVal} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lxVal" }, .F., .F. ), )
   _HB_MEMBER { lyVal} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lyVal" }, .F., .F. ), )
   _HB_MEMBER { nBarD} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nBarD" }, .F., .F. ), )
   _HB_MEMBER { lTitle} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lTitle" }, .F., .F. ), )
   _HB_MEMBER { lLegends} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lLegends" }, .F., .F. ), )
   _HB_MEMBER { nType} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nType" }, .F., .F. ), )
   _HB_MEMBER { cTitle} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTitle" }, .F., .F. ), )
   _HB_MEMBER { cPicture} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPicture" }, .F., .F. ), )
   _HB_MEMBER { aSeries} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aSeries" }, .F., .F. ), )
   _HB_MEMBER { aData} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aData" }, .F., .F. ), )
   _HB_MEMBER { aSTemp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aSTemp" }, .F., .F. ), )
   _HB_MEMBER { aDTemp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aDTemp" }, .F., .F. ), )
   _HB_MEMBER { aYVals} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aYVals" }, .F., .F. ), )
   _HB_MEMBER { aYTemp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aYTemp" }, .F., .F. ), )
   _HB_MEMBER { aFont} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aFont" }, .F., .F. ), )

   _HB_MEMBER { nClrT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrT" }, .F., .F. ), )
   _HB_MEMBER { nClrX} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrX" }, .F., .F. ), )
   _HB_MEMBER { nClrY} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrY" }, .F., .F. ), )
   _HB_MEMBER { nClrL} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrL" }, .F., .F. ), )
   _HB_MEMBER { nClrV} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrV" }, .F., .F. ), )
   _HB_MEMBER { nClrST} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrST" }, .F., .F. ), )
   _HB_MEMBER { nClrXT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrXT" }, .F., .F. ), )
   _HB_MEMBER { nClrYT} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrYT" }, .F., .F. ), )
   _HB_MEMBER { nPieX} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nPieX" }, .F., .F. ), )
   _HB_MEMBER { nPieSt} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nPieSt" }, .F., .F. ), )
   _HB_MEMBER { nPoint} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nPoint" }, .F., .F. ), )
   _HB_MEMBER { nBarSep} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nBarSep" }, .F., .F. ), )
   _HB_MEMBER { nXRanges} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nXRanges" }, .F., .F. ), )
   _HB_MEMBER { nValues} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nValues" }, .F., .F. ), )
   _HB_MEMBER { lViewVal} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lViewVal" }, .F., .F. ), )
   _HB_MEMBER { nClr, hPen, hOldPen} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClr" , "hPen" , "hOldPen" }, .F., .F. ), )
   _HB_MEMBER { nPenWidth} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nPenWidth" }, .F., .F. ), )
   _HB_MEMBER { lBorders} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lBorders" }, .F., .F. ), )
   _HB_MEMBER { lcTitle} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lcTitle" }, .F., .F. ), )
   _HB_MEMBER { nClrGrid} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrGrid" }, .F., .F. ), )
   _HB_MEMBER { nClrBack} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrBack" }, .F., .F. ), )
   _HB_MEMBER { nClrBLeg} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nClrBLeg" }, .F., .F. ), )
   _HB_MEMBER { cBitmap} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cBitmap" }, .F., .F. ), )
   _HB_MEMBER { cSubTit} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSubTit" }, .F., .F. ), )
   _HB_MEMBER { cTitX} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTitX" }, .F., .F. ), )
   _HB_MEMBER { cTitY} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTitY" }, .F., .F. ), )
   _HB_MEMBER { nMaxVal} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nMaxVal" }, .F., .F. ), )
   _HB_MEMBER { nMinVal} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nMinVal" }, .F., .F. ), )
   _HB_MEMBER { lPopUp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lPopUp" }, .F., .F. ), )
   _HB_MEMBER { lSelView} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lSelView" }, .F., .F. ), )
   _HB_MEMBER { lSelBack} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lSelBack" }, .F., .F. ), )
   _HB_MEMBER { nLanguage} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nLanguage" }, .F., .F. ), )
   _HB_MEMBER { aSTitle} ; IIF( !.F., s_oClass:AddMultiData(, {.T.,.T.,.T.,.T.}, nScope + IIF( .F., 32, 0 ), { "aSTitle" }, .F., .F. ), )

   _HB_MEMBER { nTRight} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nTRight" }, .F., .F. ), )
   _HB_MEMBER { nTLeft} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nTLeft" }, .F., .F. ), )
   _HB_MEMBER { nTCent} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nTCent" }, .F., .F. ), )
   _HB_MEMBER { oPrn} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oPrn" }, .F., .F. ), )
   _HB_MEMBER { lBordLeg} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lBordLeg" }, .F., .F. ), )


   _HB_MEMBER New( nRow, nCol, oWnd, nWidth, nHeight, cTitle, lDesign, lPixel,  l3D, lxGrid, lyGrid, lXval , lYval, lPupUp, lLegends, nType) AS CLASS TGraph; IIF( .F., s_oClass:ModMethod( "New", @TGraph_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TGraph_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));


   _HB_MEMBER ReDefine( nId, oWnd, cTitle, l3D, lxGrid, lyGrid,  lXval, lYval, lPupUp, lLegends, nType) AS CLASS TGraph; IIF( .F., s_oClass:ModMethod( "ReDefine", @TGraph_ReDefine(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReDefine", @TGraph_ReDefine(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Initiate(hDlg); IIF( .F., s_oClass:ModInline( "Initiate", {|Self,hDlg | Self, ::TControl:Initiate( hDlg ), ::Default() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Initiate", {|Self,hDlg | Self, ::TControl:Initiate( hDlg ), ::Default() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER Default(); IIF( .F., s_oClass:ModMethod( "Default", @TGraph_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Default", @TGraph_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Paint(); IIF( .F., s_oClass:ModMethod( "Paint", @TGraph_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paint", @TGraph_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Display(); IIF( .F., s_oClass:ModMethod( "Display", @TGraph_Display(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Display", @TGraph_Display(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DrawBar(); IIF( .F., s_oClass:ModMethod( "DrawBar", @TGraph_DrawBar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DrawBar", @TGraph_DrawBar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DrawBox( nTop, nLeft, nBottom, nRight, nColor); IIF( .F., s_oClass:ModMethod( "DrawBox", @TGraph_DrawBox(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DrawBox", @TGraph_DrawBox(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DrawLine( nY, nX, nHigh, nWidth, nColor, lDotted); IIF( .F., s_oClass:ModMethod( "DrawLine", @TGraph_DrawLine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DrawLine", @TGraph_DrawLine(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DrawPoint(); IIF( .F., s_oClass:ModMethod( "DrawPoint", @TGraph_DrawPoint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DrawPoint", @TGraph_DrawPoint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DrawPie(); IIF( .F., s_oClass:ModMethod( "DrawPie", @TGraph_DrawPie(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DrawPie", @TGraph_DrawPie(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DrawPoly(); IIF( .F., s_oClass:ModMethod( "DrawPoly", @TGraph_DrawPoly(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DrawPoly", @TGraph_DrawPoly(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER AddSerie(); IIF( .F., s_oClass:ModMethod( "AddSerie", @TGraph_AddSerie(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddSerie", @TGraph_AddSerie(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SelSerie(); IIF( .F., s_oClass:ModMethod( "SelSerie", @TGraph_SelSerie(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SelSerie", @TGraph_SelSerie(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetYVals(); IIF( .F., s_oClass:ModMethod( "SetYVals", @TGraph_SetYVals(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetYVals", @TGraph_SetYVals(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SelPeriod(); IIF( .F., s_oClass:ModMethod( "SelPeriod", @TGraph_SelPeriod(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SelPeriod", @TGraph_SelPeriod(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Destroy(); IIF( .F., s_oClass:ModMethod( "Destroy", @TGraph_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Destroy", @TGraph_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER End(); IIF( .F., s_oClass:ModInline( "End", {|Self | Self, ::Destroy() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "End", {|Self | Self, ::Destroy() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER FillRect(); IIF( .F., s_oClass:ModMethod( "FillRect", @TGraph__FillRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "FillRect", @TGraph__FillRect(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );
   _HB_MEMBER CreatePen(); IIF( .F., s_oClass:ModMethod( "CreatePen", @TGraph__CreatePen(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ), s_oClass:AddMethod( "CreatePen", @TGraph__CreatePen(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ) ) );
   _HB_MEMBER DeletePen(); IIF( .F., s_oClass:ModMethod( "DeletePen", @TGraph_DeletePen(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DeletePen", @TGraph_DeletePen(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER nMax(); IIF( .F., s_oClass:ModMethod( "nMax", @TGraph_nMax(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "nMax", @TGraph_nMax(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Save2Bmp( cFile); IIF( .F., s_oClass:ModMethod( "Save2Bmp", @TGraph_Save2Bmp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Save2Bmp", @TGraph_Save2Bmp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Copy2ClipBoard(); IIF( .F., s_oClass:ModMethod( "Copy2ClipBoard", @TGraph_Copy2ClipBoard(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Copy2ClipBoard", @TGraph_Copy2ClipBoard(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PopMenu( nRow, nCol, nKey); IIF( .F., s_oClass:ModMethod( "PopMenu", @TGraph_PopMenu(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PopMenu", @TGraph_PopMenu(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Print( oPrn, nTop, nLeft, nWidth, nHeight); IIF( .F., s_oClass:ModMethod( "Print", @TGraph_Print(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Print", @TGraph_Print(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));




   _HB_MEMBER GetTextWidth(oFont, cText); IIF( .F., s_oClass:ModInline( "GetTextWidth", {|Self,oFont, cText | Self, If( Empty( ::oPrn ), GetTextWidth( ::hDC, cText, oFont:hFont ), ::oPrn:GetTextWidth( cText, oFont ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GetTextWidth", {|Self,oFont, cText | Self, If( Empty( ::oPrn ), GetTextWidth( ::hDC, cText, oFont:hFont ), ::oPrn:GetTextWidth( cText, oFont ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )



   _HB_MEMBER Say(nRow, nCol, cText, oFont, nClrText, nPad, nWidth); IIF( .F., s_oClass:ModInline( "Say", {|Self,nRow, nCol, cText, oFont, nClrText, nPad, nWidth | Self, If( Empty( ::oPrn ), ::TControl:Say( nRow, nCol, cText, nClrText, , oFont, .T., .T., nPad ), ::oPrn:Say( nRow, nCol, cText, oFont, nWidth, nClrText, , nPad ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Say", {|Self,nRow, nCol, cText, oFont, nClrText, nPad, nWidth | Self, If( Empty( ::oPrn ), ::TControl:Say( nRow, nCol, cText, nClrText, , oFont, .T., .T., nPad ), ::oPrn:Say( nRow, nCol, cText, oFont, nWidth, nClrText, , nPad ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )


   _HB_MEMBER SetType(nType); IIF( .F., s_oClass:ModInline( "SetType", {|Self,nType | Self, ( ::nType := nType, ::Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetType", {|Self,nType | Self, ( ::nType := nType, ::Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TGraph ;




UTILITY STATIC function TGraph_New( nTop, nLeft, oWnd, nWidth, nHeight, cTitle, lDesign, lPixel,   l3D, lxGrid, lyGrid, lxVal, lyVal , lPopUp, lLegends, nType) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph




















   IIF( nTop == nil, nTop := 0, ) ; IIF( nLeft == nil, nLeft := 0, ); IIF( oWnd == nil, oWnd := GetWndDefault(), ); IIF( nWidth == nil, nWidth := 100, ); IIF( nHeight == nil, nHeight := 100, ); IIF( lDesign == nil, lDesign := .F., ); IIF( lPixel == nil, lPixel := .T., ); IIF( l3D == nil, l3D := .T., ); IIF( lxGrid == nil, lxGrid := .T., ); IIF( lyGrid == nil, lyGrid := .T., ); IIF( lxVal == nil, lxVal := .T., ); IIF( lyVal == nil, lyVal := .T., ); IIF( lPopUp == nil, lPopUp := .F., ); IIF( lLegends == nil, lLegends := .T., ); IIF( cTitle == nil, cTitle := "", ); IIF( nType == nil, nType := 1, );







      ::nTop   := If( lPixel, nTop , nTop  * 14 )
      ::nLeft  := If( lPixel, nLeft, nLeft * 8 )


   ::aFont := Array(9)
   ::aFont[1] := TFont():New( "Arial", 0, -15, .F., .T.,   0, 0, ,.F., .F.)
   ::aFont[2] := TFont():New( "Arial", 0, -10, .F., .F.,   0, 0, ,.F., .F.)
   ::aFont[3] := TFont():New( "Arial", 0, -10, .F., .F.,   0, 0, ,.F., .F.)
   ::aFont[4] := TFont():New( "Arial", 0, -10, .F., .F.,   0, 0, ,.F., .F.)
   ::aFont[5] := TFont():New( "Arial", 0, -10, .F., .T.,   0, 0, ,.F., .F.)
   ::aFont[6] := TFont():New( "Arial", 0, -10, .F., .T., 898, 0, ,.F., .F.)
   ::aFont[7] := TFont():New( "Arial", 0, -10, .F., .T.,   0, 0, ,.F., .F.)
   ::aFont[8] := TFont():New( "Arial", 0, -11, .F., .F.,   0, 0, ,.F., .F.)
   ::aFont[9] := TFont():New( "Arial", 0, -11, .F., .F.,   0, 0, ,.F., .F.)

   ::nBottom  := ::nTop + nHeight - 1
   ::nRight   := ::nLeft + nWidth - 1
   ::oWnd     := oWnd

   ::nStyle   := nOR( 1073741824, 268435456, If( lDesign, nOr( 67108864, 65536 ), 0 ) )
   ::nId      := ::GetNewId()
   ::lDrag    := lDesign
   ::cTitle   := ""
   ::l3D      := l3D
   ::lxGrid   := lxGrid
   ::lyGrid   := lyGrid
   ::lxVal    := lxVal
   ::lyVal    := lyVal
   ::lTitle   := .T.
   ::lLegends := lLegends
   ::nType    := nType
   ::aYVals   := {}
   ::aYTemp   := {}

   ::nMaxVal  := 0
   ::nMinVal  := 0
   ::nXRanges := 4
   ::nBarSep  := 1
   ::nPieSt   := 0
   ::nPoint   := 1
   ::nClrT    := 0
   ::nClrX    := 0
   ::nClrY    := 0
   ::nClrL    := 0
   ::nClrV    := 0
   ::nClrST   := 0
   ::nClrXT   := 0
   ::nClrYT   := 0
   ::nClrGrid := 8421504
   ::nClrBack := 16777215
   ::nClrText := 0
   ::nClrPane := ( 239 + ( 239 * 256 ) + ( 239 * 65536 ) )
   ::nClrBLeg := 16777215
   ::nPenWidth:= 2
   ::nBarD    := 15
   ::cPicture := "@E 999,999.99"
   ::nValues  := 1
   ::nPieX    := 1
   ::lDotted  := .T.
   ::lViewVal := .F.
   ::lBorders := .F.
   ::lcTitle  := .T.
   ::aSeries  := {}
   ::aData    := {}
   ::aSTemp   := {}
   ::aDTemp   := {}
   ::lPopUp   := lPopUp
   ::lSelView := .T.
   ::lSelBack := .T.
   ::nLanguage:=  2
   ::cBitMap  := NIL
   ::cSubTit  := ""
   ::cTitX    := ""
   ::cTitY    := ""
   ::nTLeft   := 0
   ::nTRight  := 2
   ::nTCent   := 6







   ::Register( nOR( 1, 2 ) )

   IF ! Empty( oWnd:hWnd )
      ::Create()
      ::Default()
      oWnd:AddControl( Self )
   ELSE
      oWnd:DefControl( Self )
   ENDIF
   IF lDesign
      ::CheckDots()
   ENDIF

RETURN (Self)


UTILITY STATIC function TGraph_ReDefine( nId, oWnd, cTitle, l3D, lxGrid, lyGrid, lXval,  lYval, lPopUp, lLegends, nType) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph










   IIF( oWnd == nil, oWnd := GetWndDefault(), ) ; IIF( cTitle == nil, cTitle := "", ); IIF( l3D == nil, l3D := .T., ); IIF( lxGrid == nil, lxGrid := .T., ); IIF( lyGrid == nil, lyGrid := .T., ); IIF( lxVal == nil, lxVal := .T., ); IIF( lyVal == nil, lyVal := .T., ); IIF( lPopUp == nil, lPopUp := .F., ); IIF( lLegends == nil, lLegends := .T., ); IIF( nType == nil, nType := 1, );

   ::aFont := Array(9)
   ::aFont[1] := TFont():New( "Arial", 0, -15, .F., .T.,   0, 0, ,.F., .F.)
   ::aFont[2] := TFont():New( "Arial", 0, -10, .F., .F.,   0, 0, ,.F., .F.)
   ::aFont[3] := TFont():New( "Arial", 0, -10, .F., .F.,   0, 0, ,.F., .F.)
   ::aFont[4] := TFont():New( "Arial", 0, -10, .F., .F.,   0, 0, ,.F., .F.)
   ::aFont[5] := TFont():New( "Arial", 0, -10, .F., .T.,   0, 0, ,.F., .F.)
   ::aFont[6] := TFont():New( "Arial", 0, -10, .F., .T., 898, 0, ,.F., .F.)
   ::aFont[7] := TFont():New( "Arial", 0, -10, .F., .T.,   0, 0, ,.F., .F.)
   ::aFont[8] := TFont():New( "Arial", 0, -10, .F., .F.,   0, 0, ,.F., .F.)
   ::aFont[9] := TFont():New( "Arial", 0, -11, .F., .T.,   0, 0, ,.F., .F.)

   ::nId      := nId
   ::oWnd     := oWnd
   ::lDrag    := .F.
   ::cTitle   := ""
   ::l3D      := l3D
   ::lxGrid   := lxGrid
   ::lyGrid   := lyGrid
   ::lxVal    := lxVal
   ::lyVal    := lyVal
   ::lTitle   := .T.
   ::lLegends := lLegends
   ::nType    := nType
   ::aYVals   := {}
   ::aYTemp   := {}

   ::nMaxVal  := 0
   ::nMinVal  := 0
   ::nXRanges := 4
   ::nBarSep  := 1
   ::nPieSt   := 0
   ::nPoint   := 1
   ::nClrT    := 0
   ::nClrX    := 0
   ::nClrY    := 0
   ::nClrL    := 0
   ::nClrV    := 0
   ::nClrST   := 0
   ::nClrXT   := 0
   ::nClrYT   := 0
   ::nClrGrid := 8421504
   ::nClrBack := 16777215
   ::nClrText := 0
   ::nClrPane := ( 239 + ( 239 * 256 ) + ( 239 * 65536 ) )
   ::nClrBLeg := 16777215
   ::nPenWidth:= 2
   ::nBarD    := 15
   ::cPicture := "@E 999,999.99"
   ::nValues  := 1
   ::nPieX    := 1
   ::lDotted  := .T.
   ::lViewVal := .F.
   ::lBorders := .F.
   ::lcTitle  := .T.
   ::aSeries  := {}
   ::aData    := {}
   ::aSTemp   := {}
   ::aDTemp   := {}
   ::lPopUp   := lPopUp
   ::lSelView := .T.
   ::lSelBack := .T.
   ::nLanguage:=  2
   ::cBitMap  := NIL
   ::cSubTit  := ""
   ::cTitX    := ""
   ::cTitY    := ""
   ::nTLeft   := 0
   ::nTRight  := 2
   ::nTCent   := 6







   ::Register( nOR( 1, 2 ) )
   IF oWnd <> nil
      oWnd:DefControl( Self )
   ENDIF

RETURN Self


UTILITY STATIC function TGraph_Destroy() ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph
   LOCAL nI
   FOR nI = 1 TO 8
      ::aFont[nI]:End()
   next
   ::TControl:End()
RETURN (Nil)


UTILITY STATIC function TGraph_AddSerie( aDat, cLegend, nColor) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph
   AAdd( ::aSeries, { cLegend, nColor } )
   AAdd( ::aData, aDat )
   AAdd( ::aSTemp , { cLegend, nColor } )
   AAdd( ::aDTemp, aDat )
RETURN Len( ::aSeries )


UTILITY STATIC function TGraph_SelSerie( nlSerie) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph
   LOCAL nJ, nI, aSLoc, aDLoc:={}
   IF ValType(nLSerie)="L"
      ::aYVals  := ::aYTemp
      ::aSeries := ::aSTemp
      ::aData   := ::aDTemp
   ELSE
      ::aYVals  := {}
      ::aSeries := {}
      ::aData   := {}
      FOR nJ := 1 TO Len( ::aSTemp )
         IF nJ = nlSerie
            aSLoc := { ::aSTemp[nJ,1], ::aSTemp[nJ,2] }
            FOR nI :=1 TO Len( ::aDTemp[nJ] )
               AAdd(aDLoc, ::aDTemp[nJ,nI] )
            next
            nJ := Len( ::aSTemp )
         ENDIF
      next
      AAdd( ::aSeries, aSLoc )
      AAdd( ::aData, aDLoc )
      ::aYVals := ::aYTemp
   ENDIF
RETURN (Nil)

UTILITY STATIC function TGraph_SelPeriod( nPeriod) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph
   LOCAL nJ, nI, aSLoc, aDLoc:={}
   IF Len(::aYVals)>0
      ::aYVals  := {}
      ::aSeries := {}
      ::aData   := {}
      FOR nJ := 1 TO Len( ::aSTemp )
         aSLoc := { ::aSTemp[nJ,1], ::aSTemp[nJ,2] }
         AAdd( ::aSeries, aSLoc )
         FOR nI :=1 TO Len( ::aDTemp[nJ] )
            IF nI = nPeriod
               aDLoc := {}
               AAdd(aDLoc, ::aDTemp[nJ,nI] )
               AAdd( ::aData, aDLoc )
            ENDIF
         next
      next
      ::aYVals := { ::aYTemp[nPeriod] }
   ENDIF
RETURN (Nil)


UTILITY STATIC function TGraph_SetYVals( aTextos) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph
   LOCAL aRet := AClone( ::aYVals )
   ::aYVals := aTextos
   ::aYTemp := aTextos
RETURN (aRet)

UTILITY STATIC function TGraph_Display() ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph
   ::BeginPaint()
   ::Paint()
   ::EndPaint()
RETURN (Nil)


UTILITY STATIC function TGraph_Default() ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph
   IF ::oFont <> nil
      ::SetFont( ::oFont )
   ELSE
      ::SetFont( ::oWnd:oFont )
   ENDIF
RETURN (Nil)



UTILITY STATIC function TGraph_Paint( nTop, nLeft, nBottom, nRight) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph

   LOCAL nI, nPos, nMax, nMin, nMaxBar, nDeep, nJ, aPoint
   LOCAL nPenWidth, lBar, nWBar, nWText, l3D, nClrLine
   LOCAL nRange, aRange := {}, nResH, nResV,  nWide
   LOCAL nXMax, nXMin, nHigh, nRel, nWPic, nWLeg:=0
   LOCAL nZero, nRPos, nRNeg, lyVal, lxVal, aCoord[4]
   LOCAL nHTit := IF(!Empty(::cTitle) ,Abs(::aFont[1]:nHeight),0)
   LOCAL nSTit := IF(!Empty(::cSubTit),Abs(::aFont[5]:nHeight),0)
   LOCAL nXTit := IF(!Empty(::cTitX)  ,Abs(::aFont[6]:nHeight),0)
   LOCAL nYTit := IF(!Empty(::cTitY)  ,Abs(::aFont[7]:nHeight),0)
   LOCAL nLTit := IF(Len(::aYVals)>0  ,Abs(::aFont[4]:nHeight),0)

   l3D   := IF( ::nType == 3, .F., ::l3D   )
   lyVal := IF( ::nType == 4  , .F., ::lyVal )
   lxVal := IF( ::nType == 4  , .F., ::lxVal )

   nWLeg := 80
   FOR nI := 1 TO Len( ::aSeries )
      nWLeg := Max( 5+GetTextWidth(::aFont[4],Alltrim(::aSeries[nI,1])), nWLeg )
   next
   nWPic := Max( ::GetTextWidth(::aFont[2],::cPicture), 30 )

   IIF( nTop == nil, nTop := 1+IF(::lTitle,IF(!Empty(::cSubTit),nSTit,0)+nHTit+30,15), ) ;
   IIF( nLeft == nil, nLeft := 1+IF(::lTitle,IF(!Empty(::cTitX  ),nXTit,0)+15,15)+::nBarD, ) ;
   IIF( nBottom == nil, nBottom := ::nHeight-2-IF(::lTitle  ,nYTit+15,15), ) ;
   IIF( nRight == nil, nRight := ::nWidth -2-IF(::lLegends,nWLeg+ 5,15), ) ;

   nLeft   += IF(::lxVal,nWPic,0)
   nBottom -= IF(::lyVal,nLTit,0)

   nResH   := nResV := 1
   IF !Empty(::oPrn)
      nResH   := ::oPrn:nLogPixelX() / 88
      nResV   := ::oPrn:nLogPixelY() / 90
      nTop    += 1+IF(::lTitle,IF(!Empty(::cSubTit),nSTit,0)+nHTit+30,15)
      nLeft   += 1+IF(::lTitle,IF(!Empty(::cTitX  ),nXTit,0)+15,15)+::nBarD
      nBottom -= ::nHeight-2-IF(::lTitle  ,nYTit+15,15)
      nRight  -= ::nWidth -2-IF(::lLegends,nWLeg+ 5,15)
   ENDIF
   nDeep   := IF( l3D, (::nBarD*nResV), 1 )
   nMaxBar := nBottom - nTop - nDeep
   nWide   := (nRight-nLeft) / (::nMax()+1)

   IF ::lPopUp
      ::bRCliCked := {| nRow, nCol, nKey | ::PopMenu( nRow, nCol, nKey ) }
   ENDIF
   nPenWidth   := ::nPenWidth
   ::nPenWidth := 1



   IF Empty( ::oPrn )
      ::EraseBkGnd(::hDC)
      WndBoxIn(::hDC,1,1,::nHeight-1,::nWidth-1)
      ::FillRect( 2, 2, ::nHeight-2, ::nWidth-2, ::nClrPane )
   ENDIF



   IF ! Empty( ::cBitmap ) .AND. File( AnsiToOem( Lfn2Sfn( ::cBitmap ) ) )
      ::SayBitmap( 0, 0, AnsiToOem( Lfn2Sfn( ::cBitmap ) ), ::nWidth, ::nHeight )
   ELSEIF Empty( ::oPrn ) .AND. ::nType <> 4
      ::FillRect( nTop, nLeft, nBottom-nDeep, nRight, ::nClrBack )
   ENDIF



   IF ::nType <> 4 .AND. !l3D
      ::Drawline( nBottom, nLeft , nBottom, nRight, ( 225 + ( 225 * 256 ) + ( 225 * 65536 ) ))
      ::Drawline( nTop   , nRight, nBottom, nRight, ( 225 + ( 225 * 256 ) + ( 225 * 65536 ) ))
      ::Drawline( nTop   , nLeft , nTop   , nRight, ( 128 + ( 128 * 256 ) + ( 128 * 65536 ) ))
      ::Drawline( nTop   , nLeft , nBottom, nLeft , ( 128 + ( 128 * 256 ) + ( 128 * 65536 ) ))
   ENDIF

   IF l3D .AND. ::nType <> 4

      ::DrawLine(nBottom-nDeep  ,nLeft   ,nBottom  , nLeft-nDeep   , 8421504 )
      ::DrawLine(nBottom-nDeep  ,nRight-1,nBottom  , nRight-nDeep-1, 0)
      ::DrawLine(nTop+1,nLeft-1 ,nTop+nDeep+1      , nLeft -nDeep-1, 0)
      ::DrawLine(nTop-2         ,nLeft ,nTop+nDeep , nLeft-nDeep-2 , 0)
      ::DrawLine(nBottom-nDeep+1,nRight+1,nBottom+3, nRight-nDeep-1, 0)

      FOR nI := 1 TO nDeep
         ::DrawLine(nTop+nI+1, nLeft-nI, nBottom-nDeep+nI, nLeft-nI, 12632256)
      next

      ::DrawLine(nTop         ,nLeft        ,nTop           ,nRight       ,0)
      ::DrawLine(nTop- 2      ,nLeft        ,nTop- 2        ,nRight+ 2    ,0)
      ::DrawLine(nTop         ,nLeft        ,nBottom-nDeep  ,nLeft        ,8421504 )
      ::DrawLine(nTop+nDeep   ,nLeft-nDeep  ,nBottom+ 0     ,nLeft-nDeep  ,0)
      ::DrawLine(nTop+nDeep   ,nLeft-nDeep-2,nBottom+ 2     ,nLeft-nDeep-2,0)
      ::DrawLine(nTop         ,nRight       ,nBottom-nDeep  ,nRight       ,0)
      ::DrawLine(nTop- 2      ,nRight+ 2    ,nBottom-nDeep+1,nRight+ 2    ,0)
      ::DrawLine(nBottom-nDeep,nLeft        ,nBottom-nDeep  ,nRight       ,8421504 )
      ::DrawLine(nBottom+ 0   ,nLeft-nDeep  ,nBottom+ 0     ,nRight-nDeep ,0)
      ::DrawLine(nBottom+ 2   ,nLeft-nDeep-2,nBottom+ 2     ,nRight-nDeep ,0)

   ENDIF



   IF ::lTitle
      IF ::nType <> 4
         nPos := 0
         IF ::lcTitle
            nWText := ::GetTextWidth(::aFont[1],Alltrim(::cTitle))
            nPos   := (nRight-nLeft) / 2
         ENDIF
         IF ::aSTitle[1]
            ::Say( nTop-(15*nResV+nStit+nHTit)+1.5, nLeft+nPos+1.5, ::cTitle, ::aFont[1], 12632256, IF(::lcTiTle,::nTCent,0) )
         ENDIF
         ::Say( nTop-(15*nResV+nStit+nHTit), nLeft+nPos, ::cTitle, ::aFont[1], ::nClrT, IF(::lcTitle,::nTCent,0) )
         IF !Empty( ::cSubTit )
            IF ::aSTitle[2]
               ::Say( nTop-(8*nResV+nSTit)+1.5, nLeft+1.5, ::cSubTit, ::aFont[5], 12632256 )
            ENDIF
            ::Say( nTop-(8*nResV+nStit), nLeft, ::cSubTit, ::aFont[5], ::nClrST )
         ENDIF
         IF !Empty( ::cTitX )
            nWText := ::GetTextWidth(::aFont[6],::cTitX)
            nPos   := ( (nBottom-nTop) / 2 ) - nDeep
            nRPos  := nLeft-(10+IF(lxVal,nWPic,0)+IF(!Empty(::cTitX),nXTit,0)+nDeep)
            IF ::aSTitle[3]
               ::Say( nBottom-nPos-nDeep+1.5, nRPos+1.5, ::cTitX, ::aFont[6], 12632256, ::nTCent )
            ENDIF
            ::Say( nBottom-nPos-nDeep, nRPos, ::cTitX, ::aFont[6], ::nClrXT, ::nTCent )
         ENDIF
         IF !Empty( ::cTitY )
            nWText := ::GetTextWidth(::aFont[7],::cTitY)
            nPos   := ( (nRight-nLeft) / 2 ) - nDeep
            nRPos  := nBottom+(IF(lyVal,nLTit,0)+IF(!Empty(::cTitY),nYTit,0))-2
            IF ::aSTitle[4]
               ::Say( nRPos+1.5, nLeft+nPos+1.5, ::cTitY, ::aFont[7], 12632256, ::nTCent )
            ENDIF
            ::Say( nRPos, nLeft+nPos, ::cTitY, ::aFont[7], ::nClrYT, ::nTCent )
         ENDIF
      ELSE
         nPos := nLeft-nDeep-IF(::lxVal,nWPic,0)
         IF ::lcTitle
            nWText := ::GetTextWidth(::aFont[1],::cTitle)
            nPos   += ( nRight - nPos - nWText*nResH ) / 2
         ENDIF
         IF ::aSTitle[1]
            ::Say( nTop-(15*nResV+nStit+nHTit)+1.5, nPos+1.5, ::cTitle, ::aFont[1], 12632256 )
         ENDIF
         ::Say( nTop-(15*nResV+nStit+nHTit), nPos, ::cTitle, ::aFont[1], ::nClrT )
         nPos := nLeft-nDeep-IF(::lxVal,nWPic,0)
         IF !Empty( ::cSubTit ) .AND. ::l3D
            IF ::aSTitle[2]
               ::Say( nTop-( 8*nResV+nSTit)+1.5, nPos+1.5, ::cSubTit, ::aFont[5], 12632256 )
            ENDIF
            ::Say( nTop-( 8*nResV+nStit), nPos, ::cSubTit, ::aFont[5], ::nClrST )
         ENDIF
      ENDIF

   ENDIF



   IF ::nType == 4
      ::DrawPie( { nTop+nDeep, nLeft-nDeep-IF(::lxVal,nWPic,0), nBottom, IF(::lLegends,nRight+nWLeg-15,nRight) }, nWLeg, nResH, nResV )
      RETURN (Nil)
   ENDIF



   IF ::lLegends
      IF ::lBordLeg
         nPos := nTop - 1
         aCoord[ 1 ]:= nPos
         aCoord[ 2 ]:= nRight + ( 8 * nResH )
         aCoord[ 3 ]:= nPos   + ( Len( ::aSeries ) * ( 15*nResV ) ) + 1
         aCoord[ 4 ]:= nRight + (nWLeg * nResH)
         ::DrawLine( aCoord[ 1 ]-1, aCoord[ 2 ]-1, aCoord[ 1 ]-1, aCoord[ 4 ], 8421504 )
         ::DrawLine( aCoord[ 1 ]-1, aCoord[ 2 ]-1, aCoord[ 3 ], aCoord[ 2 ]-1, 8421504 )
         ::DrawLine( aCoord[ 3 ], aCoord[ 2 ], aCoord[ 3 ], aCoord[ 4 ], 12632256 )
         ::DrawLine( aCoord[ 1 ]  , aCoord[ 4 ], aCoord[ 3 ], aCoord[ 4 ], 12632256 )
         ::FillRect( aCoord[1], aCoord[2], aCoord[3], aCoord[4], ::nClrBLeg )
      ENDIF

      nPos := nTop + 2
      FOR nI := 1 TO Len( ::aSeries )
         ::DrawBar( nRight+(10*nResH), nPos+(9*nResV),  8*nResH, 7*nResV, 1, ::aSeries[nI,2] )
         ::Say( nPos, nRight+(20*nResH), ::aSeries[nI,1], ::aFont[4], ::nClrL )
         nPos += 15*nResV
      next
   ENDIF


   nMax := IF( ::nMaxVal <> 0 , ::nMaxVal , 0 )
   FOR nJ := 1 TO Len( ::aSeries )
      FOR nI :=1 TO Len( ::aData[nJ] )
         nMax := Max( ::aData[nJ,nI], nMax )
      next
   next
   nMin := IF( ::nMinVal <> 0 , ::nMinVal , 0 )
   FOR nJ := 1 TO Len( ::aSeries )
      FOR nI :=1 TO Len( ::aData[nJ] )
         nMin := Min( ::aData[nJ,nI], nMin )
      next
   next

   nXMax := IF( nMax > 0, DetMaxVal( nMax ), 0 )
   nXMin := IF( nMin < 0, DetMaxVal( nMin ), 0 )
   nHigh := nXMax + nXMin
   nMax  := Max( nXMax, nXMin )

   nRel:= ( nMaxBar / nHigh )
   nMaxBar := nMax * nRel



   nZero:=Max(nBottom+(nXMin* -1*nRel),IF(nXMax>0,nTop+(nXMax*nRel)+nDeep,0))
   IF l3D
      FOR nI := 1 TO nDeep+1
         ::DrawLine(nZero-nI+1, nLeft-nDeep+nI, nZero-nI+1, nRight-nDeep+nI, 12632256)
      next
   ENDIF

   aPoint := Array( Len( ::aSeries ), Len( ::aData[1] ), 2 )
   nRange := nMax / ::nXRanges


   FOR nI = 1 TO ::nXRanges
      AAdd( aRange, nRange * nI )
   next

   AAdd( aRange, nMax )



   nRPos := nRNeg := nZero - nDeep
   FOR nI := 0 TO ::nXRanges
      IF lxVal
         IF nXMax >= nRange*nI

            ::Say( nRPos+nDeep-5, nLeft-nDeep-10, Tran( nRange* nI, ::cPicture ),  ::aFont[2], ::nClrX, ::nTRight )
         ENDIF
         IF nXMin* -1 <= nRange* -nI

            ::Say( nRNeg+nDeep-5, nLeft-nDeep-10, Tran( nRange* -nI, ::cPicture ),  ::aFont[2], ::nClrX, ::nTRight )
         ENDIF
      ENDIF
      IF ::lxGrid
         IF nXMax > nRange*nI
            ::DrawLine( nRPos+nDeep, nLeft-nDeep, nRPos, nLeft, ::nClrGrid, ::lDotted )
            ::DrawLine( nRPos, nLeft, nRPos, nRight, ::nClrGrid, ::lDotted )
         ENDIF
         IF nXMin* -1 <  nRange* -nI
            ::DrawLine( nRNeg+nDeep, nLeft-nDeep, nRNeg, nLeft, ::nClrGrid, ::lDotted )
            ::DrawLine( nRNeg, nLeft, nRNeg, nRight, ::nClrGrid, ::lDotted )
         ENDIF
      ENDIF
      nRPos -= ( nMaxBar / ::nXRanges )
      nRNeg += ( nMaxBar / ::nXRanges )
   next

   IF !lxVal
      ::Say( nZero-5, nLeft-nDeep-3, "0", ::aFont[8], ::nClrV, ::nTRight)
   ENDIF

   IF ::lYGrid
      nPos:= nTop
      nI  := nLeft + nWide
      FOR nJ := 1 TO ::nMax()
         ::Drawline( nBottom-nDeep , nI , nPos , nI , ::nClrGrid, ::lDotted )
         ::Drawline( nBottom , nI-nDeep , nBottom-nDeep , nI , ::nClrGrid, ::lDotted )
         nI += nWide
      NEXT
   ENDIF

   nMin := nMax / nMaxBar
   nMin := IF(nMin=0,0.01,nMin)

   IF lyVal .AND. Len(::aYVals)>0
      nI := nLeft + nWide
      FOR nJ := 1 TO ::nMax()
         ::Say(nBottom+ 5, nI-nDeep, ::aYVals[nJ], ::aFont[3], ::nClrY, ::nTCent)
         nI += nWide
      NEXT
   ENDIF



   nWBar:=0
   IF ::nType == 1 .OR. ::nType == 5
      IF Len(::aData[1])=1
         nWide:=nWide*1.5
         nWBar := (nWide / ( Len(::aSeries) + 1 )) - ::nBarSep
         nPos  := nLeft + (nWBar/2) + (nWide/6) - nDeep + ::nBarSep
      ELSE
         nWBar := (nWide / ( Len(::aSeries) + 1 )) - ::nBarSep
         nWBar += (nWBar/2)/(Len(::aSeries)+0.5)
         nPos  := nLeft + nWide - ((nWide-nWBar+(nWBar/2))/2) - nDeep + ::nBarSep
      ENDIF
      FOR nI=1 TO Len( ::aData[1] )
         FOR nJ=1 TO Len( ::aSeries )
            ::DrawBar(nPos,nZero,::aData[nJ,nI]/nMin+nDeep,nWBar,nDeep,::aSeries[nJ,2],nI,nJ)
            nPos+=nWBar+::nBarSep
         next
         nPos+=(nWBar/2)+::nBarSep
      next
   ENDIF



   IF ::nType == 2  .OR. ::nType == 5 .OR. ::nType == 3
      nPos := nLeft + nWide
      FOR nI := 1 TO Len(::aData[1])
         FOR nJ=1 TO Len( ::aSeries )
            IF !l3D
               ::DrawPoint(nPos,nZero,::aData[nJ,nI]/nMin+nDeep,::aSeries[nJ,2],nResV,nResH)
            ENDIF
            aPoint[nJ,nI,2]:=nPos
            aPoint[nJ,nI,1]:=nZero-(::aData[nJ,nI]/nMin+nDeep)
         next
         nPos += nWide
      next
      FOR nI := 1 TO Len(::aData[1])-1
         FOR nJ := 1 TO Len(::aSeries)
            IF l3D
               nClrLine:=IF(Len(::aYVals)>0,0,::aSeries[nJ,2])


               ::DrawPoly({{aPoint[nJ,nI,2],aPoint[nJ,nI,1]},{aPoint[nJ,nI+1,2],aPoint[nJ,nI+1,1]},  {aPoint[nJ,nI+1,2]-nDeep,aPoint[nJ,nI+1,1]+nDeep},{aPoint[nJ,nI,2]-nDeep,aPoint[nJ,nI,1]+nDeep},  {aPoint[nJ,nI,2],aPoint[nJ,nI,1]}},::aSeries[nJ,2])
               ::DrawLine(aPoint[nJ,nI,1],aPoint[nJ,nI,2],aPoint[nJ,nI,1]+nDeep,aPoint[nJ,nI,2]-nDeep,nClrLine)
               ::DrawLine(aPoint[nJ,nI,1],aPoint[nJ,nI,2],aPoint[nJ,nI+1,1],aPoint[nJ,nI+1,2],0)
               ::DrawLine(aPoint[nJ,nI,1]+nDeep,aPoint[nJ,nI,2]-nDeep,aPoint[nJ,nI+1,1]+nDeep,aPoint[nJ,nI+1,2]-nDeep,0)
               ::DrawLine(aPoint[nJ,nI+1,1],aPoint[nJ,nI+1,2],aPoint[nJ,nI+1,1]+nDeep,aPoint[nJ,nI+1,2]-nDeep,0)
            ELSE
               IF ::nType <> 3
                  ::nPenWidth := nPenWidth
               ENDIF
               ::DrawLine(aPoint[nJ,nI,1],aPoint[nJ,nI,2],aPoint[nJ,nI+1,1],aPoint[nJ,nI+1,2],::aSeries[nJ,2])
            ENDIF
         next
      next
   ENDIF



   IF ::nType == 3 .OR. ::nType == 5
      IF Len(::aData[1])=1
         nWide:=nWide*1.5
         nWBar := (nWide / ( Len(::aSeries) + 1 )) - ::nBarSep
         nPos  := nLeft + (nWBar/2) + (nWide/6) - nDeep + ::nBarSep
         FOR nI=1 TO Len( ::aData[1] )
            FOR nJ=1 TO Len( ::aSeries )
               ::DrawPoint(nPos,nZero,::aData[nJ,nI]/nMin+nDeep,::aSeries[nJ,2],nResV,nResH)
               nPos+=nWBar+::nBarSep
            next
            nPos+=(nWBar/2)+::nBarSep
         next
      ELSE
         nPos := nLeft + nWide
         FOR nI := 1 TO Len(::aData[1])
            FOR nJ=1 TO Len( ::aSeries )
               ::DrawPoint(nPos,nZero,::aData[nJ,nI]/nMin+nDeep,::aSeries[nJ,2],nResV,nResH)
               aPoint[nJ,nI,2]:=nPos
               aPoint[nJ,nI,1]:=nZero-(::aData[nJ,nI]/nMin)
            next
            nPos+= nWide
         next
      ENDIF
   ENDIF



   lBar:=IF(::nType=1 .OR. ::nType=5 .OR. Len(::aData[1])=1,.T.,.F.)
   IF ::lViewVal
      IF Len(::aData[1])=1
         nPos:=nLeft+(nWBar/2)+(nWide/6)+::nBarSep
      ELSE
         nPos:=nLeft+IF(lBar,nWide-IF(Len(::aSeries)>1,nWBar+(nWBar/2)+::nBarSep,nWBar-nDeep)+nDeep,nWide)
         nPos+=IF(!::l3D,(nWBar-nWBar/2),0)
      ENDIF
      FOR nI := 1 TO Len(::aData[1])
         FOR nJ := 1 TO Len(::aSeries)
            if ::aData[nJ,nI] <> 0
            ::Say(nZero-(::aData[nJ,nI]/nMin+nDeep),nPos,Tran(::aData[nJ,nI],::cPicture),::aFont[9],::nClrV,::nTRight)
            end
            nPos += IF(lBar,nWBar+::nBarSep,0)
         next
         nPos += IF(lBar,(nWBar/2)+::nBarSep,nWide)
      next
   ENDIF



   ::nPenWidth := 1
   IF l3D
      ::DrawLine(nZero-nDeep, nRight-1   , nZero, nRight-nDeep-1, IF(nXMin<>0,8421504,0))
      ::DrawLine(nZero      , nLeft-nDeep, nZero, nRight-nDeep  , IF(nXMin<>0,8421504,0))
   ELSE
      IF nXMax<>0 .AND. nXMin<>0
         ::DrawLine(nZero-1, nLeft-2, nZero-1, nRight, 255 )
      ELSE
         ::DrawLine(nZero-1, nLeft-2, nZero-1, nRight, 0)
      ENDIF
   ENDIF

   ::nPenWidth := nPenWidth
   ::DeletePen()

RETURN (Nil)


UTILITY STATIC function TGraph_DrawBar( nY, nX, nHigh, nWidth, nDeep, nColor, nI, nJ) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph

   LOCAL nColTop, nShadow, hPen, hOldPen, nHTem:=nHigh

   nColTop := ClrShadow( nColor , 15 )
   nShadow := ClrShadow( nColTop, 15 )
   hOldPen := SelectObject(::hDC,hPen := GetStockObject(8))


   ::FillRect( nX, nY+1, nX+nDeep-nHigh, nY+nWidth+1, nColor )




   ::DrawPoly( {{nY+nWidth+1,nX-1},{nY+nWidth+1,nX+nDeep-nHigh}, {nY+nWidth+nDeep,nX-nHigh+1},{nY+nWidth+nDeep,nX-nDeep}, {nY+nWidth+1,nX-1}}, nShadow )


   nHigh   := Max( nHigh, nDeep )


   ::DrawPoly( {{nY+1,nX-nHigh+nDeep},{nY+nWidth+1,nX-nHigh+nDeep}, {nY+nWidth+nDeep,nX-nHigh+1},{nY+nDeep,nX-nHigh+1}, {nY+1,nX-nHigh+nDeep}}, nColTop )

   SelectObject(::hDC,hOldPen)
   DeleteObject(hPen)


   IF ::lBorders
      ::DrawBox( nY, nX, nHTem, nWidth, nDeep )
   ENDIF

RETURN (Nil)


UTILITY STATIC function TGraph_DrawPoint( nY, nX, nHigh, nColor, nResV, nResH) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph

   nColor := ClrShadow( nColor , 15 )

   IF ::nType == 3 .OR. ::nType == 5
      IF ::nPoint=1
         ::DrawLine(nX-nHigh, nY-3*nResH, nX-nHigh, nY+4*nResH, nColor)
         ::Circle(nX-nHigh-3*nResV, nY-3*nResH, 8*nResH)
         ::DrawLine(nX-nHigh, nY-2*nResH, nX-nHigh, nY+3*nResH, nColor)
         ::Circle(nX-nHigh-3*nResV, nY-3*nResH, 7*nResH)
         ::DrawLine(nX-nHigh, nY-2*nResH, nX-nHigh, nY+3*nResH, nColor)
         ::Circle(nX-nHigh-2*nResV, nY-2*nResH, 6*nResH)
         ::DrawLine(nX-nHigh-1*nResV, nY-1*nResH, nX-nHigh-1*nResV, nY+2*nResH, nColor)
         ::DrawLine(nX-nHigh        , nY-3*nResH, nX-nHigh        , nY+3*nResH, nColor)
         ::DrawLine(nX-nHigh+1*nResV, nY-2*nResH, nX-nHigh+1*nResV, nY+3*nResH, nColor)
         ::DrawLine(nX-nHigh+2*nResV, nY-2*nResH, nX-nHigh+2*nResV, nY+3*nResH, nColor)
      ENDIF

      IF ::nPoint=2
         ::DrawLine( nX - nHigh , nY -5, nX - nHigh , nY + 6, nColor )
         ::DrawLine( nX - nHigh - 5 , nY , nX - nHigh + 6 , nY , nColor )
         ::FillRect( nX - nHigh-2, nY-2, nX - nHigh + 3, nY+3, nColor )
      ENDIF

      IF ::nPoint=3
         ::DrawLine( nX - nHigh , nY -4, nX - nHigh , nY + 5, nColor )
         ::DrawLine( nX - nHigh - 4 , nY , nX - nHigh + 5 , nY , nColor )
         ::Circle( nX - nHigh -3, nY -3, 8)
         ::Circle( nX - nHigh -2, nY -2, 6)
         ::Circle( nX - nHigh -1, nY -1, 4)
      ENDIF

   ENDIF

   IF ::nType == 2 .AND. Len( ::aYVals ) > 0
      ::Circle( nX - nHigh - 2*nResV, nY - 2*nResH, 6*nResV, 0 )
   ENDIF

RETURN (Nil)


UTILITY STATIC function TGraph_DrawLine( nY1, nX1, nY2, nX2, nColor, lDotted) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph

   LOCAL hPen, nPend, nInter, nI

   IIF( lDotted == nil, lDotted := .F., ) ;

   hPen := ::CreatePen( nColor )
   IF !lDotted
      MoveTo( ::hDC, nX1, nY1 )
      LineTo( ::hDC, nX2, nY2 )
   ELSE
      IF nX1 == nX2
         IF nY1 <= nY2
            FOR nI = nY1 TO nY2 STEP 3
               MoveTo( ::hDC, nX1, nI )
               LineTo( ::hDC, nX2, MIN(nI+2,nY2) )
            next
         ELSE
            FOR nI = nY1 TO nY2 STEP -3
               MoveTo( ::hDC, nX1, nI )
               LineTo( ::hDC, nX2, MAX(nI-2,nY2) )
            next
         ENDIF
      ELSE
         nPend := (nY2-nY1)/(nX2-nX1)
         nInter := nY1-nPend * nX1
         FOR nI = nX1 TO nX2 STEP 3
            MoveTo( ::hDC, nI, nInter+nPend*nI )
            LineTo( ::hDC, MIN(nI+2,nX2), nInter+nPend*(Min(nI+2,nX2)) )
         next
      ENDIF
   ENDIF
   DeleteObject( hPen )

RETURN (Nil)


UTILITY STATIC function TGraph_DrawPoly( aPoly, nColor) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph

   LOCAL hBrush, hOldBrush, hOldPen

   hBrush := CreateSolidBrush( nColor )
   hOldBrush := SelectObject( ::hDC, hBrush )
   hOldPen   := SelectObject( ::hDC, GetStockObject( 8 ) )

   PolyPolygon( ::hDC, aPoly )

   SelectObject( ::hDC, hOldBrush )
   SelectObject( ::hDC, hOldPen )
   DeleteObject( hBrush )

RETURN (Nil)


Static Function ClrShadow( nColor, nFactor )

   LOCAL aHSL, aRGB

   aHSL := RGB2HSL( nRGBRed(nColor) , nRGBGreen(nColor) , nRGBBlue(nColor) )
   aHSL[3] -= nFactor
   aRGB := HSL2RGB( aHSL[1], aHSL[2], aHSL[3] )

RETURN nRGB( aRGB[1], aRGB[2], aRGB[3] )


UTILITY STATIC function TGraph_nMax() ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph
   LOCAL nI, nMax := 0
   FOR nI :=1 TO Len( ::aData )
      nMax := Max( Len(::aData[nI]) , nMax )
   next
RETURN( nMax )


UTILITY STATIC function TGraph_DrawPie( aRect, nWLeg, nResH, nResV, lPrint) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph

   LOCAL hMemCDC, hPen, hOldPen, hBrush, hBOld, hOldFont, nI
   LOCAL nY, nX, nAngle, nCount, nSizeX, nSizeY, nAngT
   LOCAL aItems := {}, hBru1, hBruO, nFor, nSum
   LOCAL hMyDC, aPT1, aPT2, nyEdge, nxEdge, cText, aSRect[4]
   LOCAL nDiam, aGRect[4], aColor, nColor, nPos, aPt3, nColr
   LOCAL nSepX, nSepY, hBrDark, nClr, aValrs:={} , aCoord[4]
   LOCAL nXSep, nYSep, cVals, nRow, nCol, nWText, nLenL

   IIF( lPrint == nil, lPrint := .F., ) ;

   ::nValues:=IF(Len(::aYVals)>0,::nValues,2)


   aColor:={( 128 + ( 128 * 256 ) + ( 255 * 65536 ) ),( 255 + ( 100 * 256 ) + ( 10 * 65536 ) ),( 50 + ( 200 * 256 ) + ( 50 * 65536 ) ),( 180 + ( 50 * 256 ) + ( 130 * 65536 ) ), ( 255 + ( 255 * 256 ) + ( 10 * 65536 ) ),( 10 + ( 255 * 256 ) + ( 255 * 65536 ) ),( 255 + ( 10 * 256 ) + ( 255 * 65536 ) ),( 180 + ( 10 * 256 ) + ( 50 * 65536 ) ), ( 10 + ( 128 * 256 ) + ( 10 * 65536 ) ),( 255 + ( 100 * 256 ) + ( 80 * 65536 ) ),( 100 + ( 80 * 256 ) + ( 255 * 65536 ) ),( 255 + ( 100 * 256 ) + ( 255 * 65536 ) ) }
   nColor:= 1
   nSum  := 0

   IF ::nValues == 1 .AND. Len(::aData[1])>1
      FOR nFor := 1 TO Len( ::aData[1] )
         nSum += Abs(::aData[::nPieX, nFor])
         AAdd( aValrs, ::aData[::nPieX, nFor] )
      next
      FOR nFor := 1 TO Len( ::aData[1] )
         IF ::aData[::nPieX, nFor]<>0
            AAdd( aItems, { Abs(::aData[::nPieX, nFor] * 360) / nSum, aColor[nColor] } )
            nColor++
            IF nColor>12
               nColor:=1
            ENDIF
         ENDIF
      next
   ENDIF

   hMemCDC := ::hDC
   hPen    := CreatePen( 0, 1, ( 0 + ( 0 * 256 ) + ( 0 * 65536 ) ) )
   hOldPen := SelectObject( hMemCDC, GetStockObject( 8 ) )

   IF ::nValues == 2 .OR. Len(::aData[1])=1
      nColor:= 1
      nSum  := 0
      FOR nFor := 1 TO Len( ::aData )
         nSum += Abs(::aData[nFor,::nPieX])
         AAdd( aValrs, ::aData[nFor,::nPieX] )
      next
      FOR nFor := 1 TO Len( ::aData )
         IF ::aData[nFor,::nPieX]<>0
            AAdd( aItems, { Abs(::aData[nFor,::nPieX] * 360) / nSum, ::aSeries[nFor,2] } )
            nColor++
            IF nColor>12
               nColor:=1
            ENDIF
         ENDIF
      next
   ENDIF

   IF ::lLegends
      nWLeg:=0
      IF ::nValues == 1
         FOR nI := 1 TO Len( ::aYVals )
            nWLeg := Max( 30+::GetTextWidth(::aFont[4],Alltrim(::aYVals[nI])), nWLeg )
         next
         nLenL := (Len(::aData[1])*(15*nResV)) - ::nBarD + 1
      ENDIF
      IF ::nValues == 2
         nWLeg:=0
         FOR nI := 1 TO Len( ::aSeries )
            nWLeg := Max( 30+::GetTextWidth(::aFont[4],Alltrim(::aSeries[nI,1])), nWLeg )
         next
         nLenL := (Len(::aSeries)*(15*nResV))  - ::nBarD + 1
      ENDIF
      aRect[4] -= nWLeg

      IF ::lBordLeg
         aCoord[1]:= aRect[1] - ::nBarD
         aCoord[2]:= aRect[4] + 8
         aCoord[3]:= aRect[1] + nLenL
         aCoord[4]:= aRect[4] + Max(nWLeg,30)
         ::DrawLine( aCoord[1]-1, aCoord[2]-1, aCoord[1]-1, aCoord[4]  , 8421504 )
         ::DrawLine( aCoord[1]-1, aCoord[2]-1, aCoord[3]  , aCoord[2]-1, 8421504 )
         ::DrawLine( aCoord[3]  , aCoord[2]  , aCoord[3]  , aCoord[4]  , 12632256)
         ::DrawLine( aCoord[1]  , aCoord[4]  , aCoord[3]  , aCoord[4]  , 12632256)
         ::FillRect( aCoord[1], aCoord[2], aCoord[3], aCoord[4], ::nClrBLeg )
      ENDIF

      nColor:=1
      nPos := aRect[1] - ::nBarD + 2
      IF ::nValues == 1 .AND. Len(::aData[1])>1
         FOR nFor := 1 TO Len( ::aData[1] )
            ::Say( nPos, aRect[4]+(25*nResH), ::aYVals[nFor], ::aFont[4], ::nClrL )
            ::DrawBar( aRect[4]+(10*nResH), nPos+(9*nResV), 8*nResH, 7*nResV, 1, aColor[nColor] )
            nPos += 15*nResV
            nColor++
            IF nColor>12
               nColor:=1
            ENDIF
         next
      ENDIF
      IF ::nValues == 2 .OR. Len(::aData[1])=1
         FOR nFor := 1 TO Len( ::aSeries )
            ::Say( nPos, aRect[4]+(20*nResH), ::aSeries[nFor,1], ::aFont[4], ::nClrL )
            ::DrawBar( aRect[4]+(10*nResH), nPos+(9*nResV), 8*nResH, 7*nResV, 1, ::aSeries[nFor,2] )
            nPos += 15*nResV
            nColor++
            IF nColor>12
               nColor:=1
            ENDIF
         next
      ENDIF
   ENDIF

   aCoord[1]:= aRect[1] - ::nBarD
   aCoord[2]:= aRect[2]
   aCoord[3]:= aRect[3]
   aCoord[4]:= aRect[4]
   ::DrawLine( aCoord[1]-1, aCoord[2]-1, aCoord[1]-1, aCoord[4]  , 8421504 )
   ::DrawLine( aCoord[1]-1, aCoord[2]-1, aCoord[3]  , aCoord[2]-1, 8421504 )
   ::DrawLine( aCoord[3]  , aCoord[2]  , aCoord[3]  , aCoord[4]  , 12632256)
   ::DrawLine( aCoord[1]  , aCoord[4]  , aCoord[3]  , aCoord[4]  , 12632256)
   ::FillRect( aCoord[1], aCoord[2], aCoord[3], aCoord[4], ::nClrBack )

   IF ::l3D

      nxEdge := ( aCoord[4] - aCoord[2] ) / 4 * 3
      nyEdge := aCoord[3] - aCoord[1]
      nyEdge := Min ( nyEdge , nxEdge  / 3 )

      aGRect[1] := 0
      aGRect[2] := 0
      aGRect[3] := nyEdge
      aGRect[4] := nxEdge
      nX := aCoord[2] + Abs( (aCoord[4]-aCoord[2]) - aGRect[4] ) / 2
      nY := aCoord[1] + Abs( (aCoord[3]-aCoord[1]) - aGRect[3] ) / 2

      aSRect[1] := aGRect[1] + (nY+10*nResV)
      aSRect[2] := aGRect[2] + nX
      aSRect[3] := aGRect[3] + (nY+10*nResV)
      aSRect[4] := aGRect[4] + nX
      SelectObject( hMemCDC, hPen )
      SelectObject( hMemCDC, GetStockObject( 5 ) )

      hBrush  := CreateSolidBrush( ClrShadow( 32896, 3 ) )
      hBOld   := SelectObject( hMemCDC, hBrush )
      Ellipse( hMemCDC, aSRect[2], aSRect[1], aSRect[4], aSRect[3] )
      SelectObject( hMemCDC, hBOld )
      DeleteObject( hBrush )

      aGRect[1] += nY - (10*nResV)
      aGRect[2] += nX
      aGRect[3] += nY - (10*nResV)
      aGRect[4] += nX

      hBrush  := CreateSolidBrush( ClrShadow( 32896, 3 ) )
      hBOld   := SelectObject( hMemCDC, hBrush )



      FillRect( hMEMCDC, { aGRect[1]+((aGRect[3]-aGRect[1])/2),  aSRect[2],  aSRect[3]-((aSRect[3]-aSRect[1])/2), aSRect[4] }, hBrush )
      SelectObject( hMemCDC, hBOld )
      DeleteObject( hBrush )

   ELSE

      aGRect[1] := aCoord[1] + 10
      aGRect[2] := aCoord[2] + 10
      aGRect[3] := aCoord[3] - 10
      aGRect[4] := aCoord[4] - 10

      nDiam := Min( aGRect[3]-aGRect[1], aGRect[4]-aGRect[2] )

      aGRect[1] := 0
      aGRect[2] := 0
      aGRect[3] := aGRect[1] + nDiam
      aGRect[4] := aGRect[2] + nDiam

      nX := aCoord[2] + Abs( (aCoord[4]-aCoord[2]) - aGRect[4] ) / 2
      nY := aCoord[1] + Abs( (aCoord[3]-aCoord[1]) - aGRect[3] ) / 2

      aGRect[1] += nY
      aGRect[2] += nX
      aGRect[3] += nY
      aGRect[4] += nX

   ENDIF

   nAngle := ::nPieSt
   aPT1   := CountPoint( aGRect, nAngle )

   FOR nCount := 1 TO Len( aItems )

      hBru1 := CreateSolidBrush( aItems[nCount,2] )
      hBruO := SelectObject( hMemCDC, hBru1 )
      SelectObject( hMemCDC, GetStockObject( 8 ) )
      nAngle += aItems[nCount,1]
      nAngT := nAngle - aItems[nCount,1]
      aPT2  := CountPoint( aGRect, nAngle )

      IF (nAngle-nAngT)>1

         Pie( hMemCDC, aGRect[1], aGRect[2], aGRect[3]+1, aGRect[4]+1,  aPT2[2], aPT2[1], aPT1[2], aPT1[1] )
      ENDIF
      SelectObject( hMemCDC, hPen )
      IF Len( aItems ) > 1
         MoveTo( hMemCDC, aPT1[1], aPT1[2] )

         LineTo( hMemCDC, ((aGRect[4]-aGRect[2]) / 2) + aGRect[2],  ((aGRect[3]-aGRect[1]) / 2) + aGRect[1] )
         MoveTo( hMemCDC, aPT2[1], aPT2[2] )

         LineTo( hMemCDC, ((aGRect[4]-aGRect[2]) / 2) + aGRect[2],  ((aGRect[3]-aGRect[1]) / 2) + aGRect[1] )
         IF ::l3D .AND. aItems[nCount,1]<>0
            nAngT := nAngle - aItems[nCount,1]
            aPt3  := CountPoint( aGRect, nAngT )
            IF nAngle > 100 .AND. nAngT < 260
               hBrDark := CreateSolidBrush( ClrShadow( aItems[nCount,2], 48 ) )
               hBru1 := SelectObject( hMemCDC, hBrDark )
               IF nAngle < 270
                  MoveTo( hMemCDC, aPT2[1], aPT2[2] )
                  LineTo( hMemCDC, aPT2[1], aPT2[2] + 20*nResV )
                  FOR nI=3 TO 5
                     nClr := GetPixel( hMemCDC, aPt2[1]+(1*nResV), aPt2[2]+(nI*nResH) )
                     ExtFloodFill( hMemCDC, aPt2[1]+(1*nResV), aPt2[2]+(nI*nResH), nClr, 1 )
                  next
               ELSE
                  IF nAngT <  90
                     nAngT := nAngle - (aItems[nCount,1]/2)
                     aPt3  := CountPoint( aGRect, nAngT )
                  ENDIF
                  FOR nI=3 TO 5
                     nClr := GetPixel( hMemCDC, aPt3[1]-(1*nResV), aPt3[2]+(nI*nResH) )
                     ExtFloodFill( hMemCDC, aPt3[1]-(1*nResV), aPt3[2]+(nI*nResH), nClr, 1 )
                  next
               ENDIF
               SelectObject( hMemCDC, hBru1 )
               DeleteObject( hBrDark )
            ENDIF
         ENDIF
      ENDIF

      hOldFont := SelectObject( hMemCDC, ::aFont[2]:hFont )
      SetBkMode( hMemCDC, 1 )

      IF aItems[nCount,1] > 3
         nAngT   := nAngle - (aItems[nCount,1] / 2)
         aPt3    := CountPoint( aGRect, nAngT )
         hMyDC   := hMemCDC
         hMemCDC := ::oWnd:GetDC()
         cText   := Tran( aItems[nCount,1]*100/360, "999%" )
         nSizeX  := GetTextWidth( hMemCDC, cText ) * nResH
         nSizeY  := Abs(::aFont[2]:nHeight) * nResV
         ::oWnd:ReleaseDC()
         hMemCDC := hMyDC
         IF     nAngT >=   0 .AND. nAngT <  20
            nSepX:=  5              ; nXSep:= 20
            nSepY:= -8              ; nYSep:=  0
         ELSEIF nAngT >=   0 .AND. nAngT <  45
            nSepX:= 25              ; nXSep:= 20
            nSepY:= -5              ; nYSep:=  0
         ELSEIF nAngT >=  45 .AND. nAngT <  90
            nSepX:= 25              ; nXSep:= 25
            nSepY:= -5              ; nYSep:= - 5
         ELSEIF nAngT >=  90 .AND. nAngT < 135
            nSepX:= 25              ; nXSep:= 40
            nSepY:= IF(::l3D,25, 5) ; nYSep:= -20
         ELSEIF nAngT >= 135 .AND. nAngT < 180
            nSepX:= 25              ; nXSep:= 20
            nSepY:= IF(::l3D,25, 5) ; nYSep:= -20
         ELSEIF nAngT >= 180 .AND. nAngT < 225
            nSepX:= -15              ; nXSep:= 10
            nSepY:= IF(::l3D,25, 5) ; nYSep:= -20
         ELSEIF nAngT >= 225 .AND. nAngT < 270
            nSepX:= -15              ; nXSep:= -20
            nSepY:= IF(::l3D,25, 5) ; nYSep:= -20
         ELSEIF nAngT >= 270 .AND. nAngT < 315
            nSepX:= -20              ; nXSep:= 0
            nSepY:= -5              ; nYSep:= 0
         ELSEIF nAngT >= 315 .AND. nAngT < 360
            nSepX:= -20              ; nXSep:= 0
            nSepY:= -8              ; nYSep:= 0
         ENDIF
         nColr := IF(aValrs[nCount]<0,128,::nClrX)
         ::Say(aPt3[2]-(nSizeY/2)+nSepY,aPt3[1]-(nSizeX/2)+nSepX,cText,::aFont[8],nColr)
         IF ::lViewVal
            cVals := Tran( aValrs[nCount],::cPicture )
            ::Say(aPt3[2]+(nSizeY/2)+nYSep,aPt3[1]-(nSizeX/2)-nXSep,cVals,::aFont[9],nColr)
         ENDIF
      ENDIF

      SelectObject( hMemCDC, hOldFont )
      SelectObject( hMemCDC, hBruO )

      DeleteObject( hBru1 )

      aPT1[1] := aPT2[1]
      aPT1[2] := aPT2[2]
   next

   IF !Empty( ::cTitY )
      nWText := GetTextWidth( ::cTitY, ::aFont[9] )
      nCol   := aCoord[4]-nWText-25
      nRow   := aCoord[3]-25
      IF ::aSTitle[4]
         ::Say( nRow+1.5, nCol+1.5, ::cTitY, ::aFont[9], 12632256, ::nTRight )
      ENDIF
      ::Say( nRow, nCol, ::cTitY, ::aFont[9], ::nClrYT, ::nTRight )
   ENDIF

   IF nSum==0
      aPT2  := CountPoint( aGRect, nAngle )
      hBru1 := CreateSolidBrush( 16777215 )
      hBruO := SelectObject( hMemCDC, hBru1 )
      SelectObject( hMemCDC, GetStockObject( 8 ) )

      Pie( hMemCDC, aGRect[1], aGRect[2], aGRect[3]+1, aGRect[4]+1,  aPT2[2], aPT2[1], aPT1[2], aPT1[1] )
      SelectObject( hMemCDC, hPen )
   ENDIF

   SelectObject( hMemCDC, hPen )
   SelectObject( hMemCDC, GetStockObject( 5 ) )

   Ellipse( hMemCDC, aGRect[2], aGRect[1], aGRect[4], aGRect[3] )

   SelectObject( hMemCDC, hOldPen )
   SelectObject( hMemCDC, hBOld )
   DeleteObject( hPen )
   DeleteObject( hBrush )

RETURN (Nil)


UTILITY STATIC function TGraph__CreatePen(nColor) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph

   IF ::nClr <> nColor
      ::DeletePen()
      ::nClr    := nColor
      ::hPen    := CreatePen( 0, ::nPenWidth, nColor)
      ::hOldPen := SelectObject( ::hDC, ::hPen )
   ENDIF

RETURN (.T.)


UTILITY STATIC function TGraph_DeletePen() ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph

   IF ::hOldPen   <> -1
      SelectObject( ::hDC, ::hOldPen )
      IIF( !Empty( ::hPen ), DeleteObject( ::hPen ), )
      ::hPen      = -1
      ::hOldPen   = -1
   ENDIF

RETURN (Nil)


UTILITY STATIC function TGraph__FillRect(nTop, nLeft, nBottom, nRight, nColor) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph

   LOCAL hBru, hOld

   hBru := CreateSolidBrush( nColor )
   hOld := SelectObject( ::hDC, hBru )
   FillRect( ::hDC, { nTop, nLeft, nBottom, nRight }, hBru )
   SelectObject( ::hDC, hOld )
   DeleteObject( hBru )

RETURN (Nil)


UTILITY STATIC function TGraph_Print( oPrn, nTop, nLeft, nWidth, nHeight) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph

   LOCAL nRight, nBottom, nI
   LOCAL cOldBitmap:= ::cBitmap




   LOCAL aOldF := { oClone( ::aFont[1] ), oClone( ::aFont[2] ),  oClone( ::aFont[3] ), oClone( ::aFont[4] ),  oClone( ::aFont[5] ), oClone( ::aFont[6] ),  oClone( ::aFont[7] ), oClone( ::aFont[8] ),  oClone( ::aFont[9] ) }
   ::oPrn    := oPrn
   ::nTRight := 1
   ::nTLeft  := 0
   ::nTCent  := 2
   ::cBitmap := " "

   nRight    := nLeft + nWidth
   nBottom   := nTop  + nHeight

   ::oWnd:ReleaseDC()

   ::aFont[1] := TFont():New( aOldF[1]:cFaceName, 0, -aOldF[1]:nHeight+3,, .T.,,,,,,,,,,, oPrn, )
   ::aFont[2] := TFont():New( aOldF[2]:cFaceName, 0, -aOldF[2]:nHeight+3,,,,,,,,,,,,, oPrn, )
   ::aFont[3] := TFont():New( aOldF[3]:cFaceName, 0, -aOldF[3]:nHeight+3,,,,,,,,,,,,, oPrn, )
   ::aFont[4] := TFont():New( aOldF[4]:cFaceName, 0, -aOldF[4]:nHeight+3,,,,,,,,,,,,, oPrn, )
   ::aFont[5] := TFont():New( aOldF[5]:cFaceName, 0, -aOldF[5]:nHeight+3,,,,,,,,,,,,, oPrn, )
   ::aFont[6] := TFont():New( aOldF[6]:cFaceName, 0, -aOldF[6]:nHeight+3,,,898,,,,,,,,,, oPrn, )
   ::aFont[7] := TFont():New( aOldF[7]:cFaceName, 0, -aOldF[7]:nHeight+3,,,,,,,,,,,,, oPrn, )
   ::aFont[8] := TFont():New( aOldF[8]:cFaceName, 0, -aOldF[8]:nHeight+3,,,,,,,,,,,,, oPrn, )
   ::aFont[9] := TFont():New( aOldF[9]:cFaceName, 0, -aOldF[9]:nHeight+3,,,,,,,,,,,,, oPrn, )

   ::hDC := oPrn:hDCOut
   ::Paint( nTop, nLeft, nBottom, nRight )
   ::hDC := Nil

   FOR nI = 1 TO 9
      ::aFont[nI]:End()
      ::aFont[nI] := aOldF[nI]
   next

   ::cBitmap := cOldBitmap
   ::oPrn    := NIL
   ::nTLeft  := 0
   ::nTRight := 2
   ::nTCent  := 6

RETURN (Nil)


Static Function CountPoint( aRect, nAngle )

   LOCAL dAngle, rX, rY, nX, nY, nRX, nRY

   while nAngle <   0
      nAngle += 360
   ENDDO
   while nAngle > 359
      nAngle -= 360
   ENDDO

   dAngle := nAngle * PI()   / 180.0
   rX := (aRect[3]-aRect[1]) /   2.0
   rY := (aRect[4]-aRect[2]) /   2.0

   nRX := rY * Sin( dAngle )
   nRY := 0.0 - ( rX * Cos( dAngle ) )
   nX  := nRX + ( ( aRect[4] + aRect[2] ) / 2.0 )
   nY  := nRY + ( ( aRect[3] + aRect[1] ) / 2.0 )

RETURN ( { nX, nY } )


UTILITY STATIC function TGraph_DrawBox( nY, nX, nHigh, nWidth, nDeep) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph


   ::DrawLine(nX, nY       , nX-nHigh+nDeep , nY        , 0 )
   ::DrawLine(nX, nY+nWidth, nX-nHigh+nDeep , nY+nWidth , 0 )
   ::DrawLine(nX-nHigh+nDeep, nY, nX-nHigh+nDeep , nY+nWidth , 0 )
   ::DrawLine(nX, nY, nX , nY+nWidth , 0 )
   IF ::l3D

      ::DrawLine(nX-nHigh+nDeep, nY+nWidth, nX-nHigh, nY+nDeep+nWidth, 0 )
      ::DrawLine(nX, nY+nWidth, nX-nDeep, nY+nWidth+nDeep, 0 )
      IF nHigh > 0
         ::DrawLine(nX-nDeep, nY+nWidth+nDeep, nX-nHigh, nY+nWidth+nDeep, 0 )
         ::DrawLine(nX-nHigh, nY+nDeep, nX-nHigh , nY+nWidth+nDeep , 0 )
         ::DrawLine(nX-nHigh+nDeep, nY, nX-nHigh, nY+nDeep  , 0 )
      ELSE
         ::DrawLine(nX-nDeep, nY+nWidth+nDeep, nX-nHigh+1, nY+nWidth+nDeep, 0 )
         ::DrawLine(nX, nY, nX-nDeep, nY+nDeep  , 0 )
      ENDIF
   ENDIF

RETURN ( NIL )

UTILITY STATIC function TGraph_Save2Bmp( cFile) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph

   LOCAL hBmp, hDib
   IIF( cFile == nil, cFile := "TGraph.Bmp", ) ;

   hBmp := WndBitmap( Self:hWnd )
   hDib := DibFromBitmap( hBmp )
   DibWrite( cFile, hDib )
   GloBalFree( hDib )
   DeleteObject( hBmp )

RETURN ( FILE( cFile ) )


UTILITY STATIC function TGraph_Copy2ClipBoard() ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph











   WndCopy( Self:hWnd, .F., .T. )
   IF ::nLanguage=2
      MsgInfo("La imagen ha sido enviada al portapapeles.","Informacin")
   ELSE
      MsgInfo("Graph image on clipboard.","Info")
   ENDIF
RETURN (Nil)


UTILITY STATIC function TGraph_PopMenu( nRow, nCol, nKey) ; local Self AS CLASS TGraph := QSelf() AS CLASS TGraph

   LOCAL oPopup, oItem[15], nOpt:=0, cFile
   LOCAL aLang, nI:=::nLanguage, cMsg






































   aLang:={ {"&View",                "&3D",               "&Titles" ,          "&X Values",         "&Y Labels",         "&Legends",          "&Values",           "X &Grid",           "Y G&rid",           "&Bar border",       "Graph &Type",          "&Bar",              "&Line",             "&Point",            "P&ie",              "&Background",          "&Select",           "&Remove",           "&Copy" },              {"&Ver",                "&3D",              "&Ttulos",         "Valores en &X",    "Etiquetas en &Y",  "&Leyendas",        "&Valores",         "&Rejilla en X",    "Re&jilla en Y",    "&Bordes",          "Grfica &tipo",       "&Barras",          "&Lneas",          "&Puntos",          "P&ie",             "Imagen de &fondo",    "&Selecionar",      "&Remover",         "&Copiar" } }

   oPopUp := MenuBegin( .T.,,, .F., .F. )
      MenuAddItem()
      IF ::lSelView
         MenuAddItem( aLang[nI, 1],, .F.,,,,,,,,, .F.,,, .F. )
            MenuBegin( .F.,,, .F., .F. )
               oItem[ 1] := MenuAddItem( aLang[nI, 2],, .F.,, {|oMenuItem|( ::l3D      := !::l3D     , ::Refresh() )},,,,,,, .F.,,, .F. )
               oItem[ 2] := MenuAddItem( aLang[nI, 3],, .F.,, {|oMenuItem|( ::lTitle   := !::lTitle  , ::Refresh() )},,,,,,, .F.,,, .F. )
               IF ::nType <> 4
                  oItem[ 3] := MenuAddItem( aLang[nI, 4],, .F.,, {|oMenuItem|( ::lxVal    := !::lxVal   , ::Refresh() )},,,,,,, .F.,,, .F. )
                  oItem[ 4] := MenuAddItem( aLang[nI, 5],, .F.,, {|oMenuItem|( ::lyVal    := !::lyVal   , ::Refresh() )},,,,,,, .F.,,, .F. )
               ENDIF
               oItem[ 5] := MenuAddItem( aLang[nI, 6],, .F.,, {|oMenuItem|( ::lLegends := !::lLegends, ::Refresh() )},,,,,,, .F.,,, .F. )
               oItem[ 6] := MenuAddItem( aLang[nI, 7],, .F.,, {|oMenuItem|( ::lViewVal := !::lViewVal, ::Refresh() )},,,,,,, .F.,,, .F. )
               IF ::nType <> 4
                  oItem[ 7] := MenuAddItem( aLang[nI, 8],, .F.,, {|oMenuItem|( ::lxGrid   := !::lxGrid  , ::Refresh() )},,,,,,, .F.,,, .F. )
                  oItem[ 8] := MenuAddItem( aLang[nI, 9],, .F.,, {|oMenuItem|( ::lyGrid   := !::lyGrid  , ::Refresh() )},,,,,,, .F.,,, .F. )
               ENDIF
               IF ::nType == 1
                  oItem[ 9] := MenuAddItem( aLang[nI,10],, .F.,, {|oMenuItem|( ::lBorders := !::lBorders, ::Refresh() )},,,,,,, .F.,,, .F. )
               ENDIF
            MenuEnd()
      ENDIF
      MenuAddItem( aLang[nI,11],, .F.,,,,,,,,, .F.,,, .F. )
         MenuBegin( .F.,,, .F., .F. )
            oItem[10] := MenuAddItem( aLang[nI,12],, .F.,, {|oMenuItem|( ::nType := 1   , ::Refresh() )},,,,,,, .F.,,, .F. )
            oItem[11] := MenuAddItem( aLang[nI,13],, .F.,, {|oMenuItem|( ::nType := 2  , ::Refresh() )},,,,,,, .F.,,, .F. )
            oItem[12] := MenuAddItem( aLang[nI,14],, .F.,, {|oMenuItem|( ::nType := 3 , ::Refresh() )},,,,,,, .F.,,, .F. )
            oItem[13] := MenuAddItem( aLang[nI,15],, .F.,, {|oMenuItem|( ::nType := 4   , ::Refresh() )},,,,,,, .F.,,, .F. )
         MenuEnd()
      IF ::lSelBack
         MenuAddItem( aLang[nI,16],, .F.,,,,,,,,, .F.,,, .F. )
            MenuBegin( .F.,,, .F., .F. )
               oItem[14] := MenuAddItem( aLang[nI,17],, .F.,, {|oMenuItem|nOpt:=1},,,,,,, .F.,,, .F. )
               oItem[15] := MenuAddItem( aLang[nI,18],, .F.,, {|oMenuItem|nOpt:=2},,,,,,, .F.,,, .F. )
            MenuEnd()
         MenuAddItem()
      ENDIF
      MenuAddItem( aLang[nI,19],, .F.,, {|oMenuItem|nOpt:=3},,,,,,, .F.,,, .F. )
      MenuAddItem()

   MenuEnd()

   IF ::lSelView
      oItem[ 1]:SetCheck(::l3D)
      oItem[ 2]:SetCheck(::lTitle)
      IF ::nType <> 4
         oItem[ 3]:SetCheck(::lxVal)
         oItem[ 4]:SetCheck(::lyVal)
      ENDIF
      oItem[ 5]:SetCheck(::lLegends)
      oItem[ 6]:SetCheck(::lViewVal)
      IF ::nType <> 4
         oItem[ 7]:SetCheck(::lxGrid)
         oItem[ 8]:SetCheck(::lyGrid)
      ENDIF
      IF ::nType == 1
         oItem[ 9]:SetCheck(::lBorders)
      ENDIF
   ENDIF
   oItem[10]:SetCheck(IF(::nType=1  ,.T.,.F.))
   oItem[11]:SetCheck(IF(::nType=2 ,.T.,.F.))
   oItem[12]:SetCheck(IF(::nType=3,.T.,.F.))
   oItem[13]:SetCheck(IF(::nType=4  ,.T.,.F.))
   IF ::lSelBack
      oItem[14]:SetCheck(IF(File(::cBitmap),.F.,.T.))
      oItem[15]:SetCheck(IF(File(::cBitmap),.T.,.F.))
   ENDIF
   IF Len(::aData[1])<=1
      oItem[11]:Disable()
      oItem[12]:Disable()
   ENDIF
   oPopup:Activate( nRow, nCol, ::oWnd, ! .F., )

   DO CASE
      CASE nOpt = 1
         cMsg := IF ( ::nLanguage=2,"Seleccione imagen de fondo","Select background image" )



           IF !Empty( ( cFile:=cGetFile("Bitmaps|*.bmp","" ) ) )

            ::cBitmap:= cFile
            ::Refresh( .F. )
         ENDIF
      CASE nOpt = 2
         ::cBitmap:= ""
         ::Refresh(.F.)
      CASE nOpt = 3
         ::Copy2Clipboard()
      CASE nOpt = 4
         ::Save2Bmp()
   ENDCASE

RETURN (Nil)



static FUNCTION DetMaxVal(nNum)
   LOCAL nE, nMax, nMan, nVal, nOffset
   nE:=9
   nVal:=0
   nNum:=Abs(nNum)
   while .T.
      nMax := 10^nE
      IF Int(nNum/nMax)>0
         nMan:=(nNum/nMax)-Int(nNum/nMax)
         nOffset:=1
         nOffset:=IF(nMan<=.75,.75,nOffset)
         nOffset:=IF(nMan<=.50,.50,nOffset)
         nOffset:=IF(nMan<=.25,.25,nOffset)
         nOffset:=IF(nMan<=.00,.00,nOffset)
         nVal := (Int(nNum/nMax)+nOffset)*nMax
         EXIT
      ENDIF
      nE--
   ENDDO
RETURN (nVal)


static FUNCTION RGB2HSL( nR, nG, nB )

   LOCAL nMax, nMin
   LOCAL nH, nS, nL

   IF nR < 0
      nR := Abs( nR )
      nG := nRGBGreen( nR )
      nB := nRGBBlue( nR )
      nR := nRGBRed( nR )
   ENDIF

   nR := nR / 255
   nG := nG / 255
   nB := nB / 255
   nMax := Max( nR, Max( nG, nB ) )
   nMin := Min( nR, Min( nG, nB ) )
   nL := ( nMax + nMin ) / 2

   IF nMax = nMin
      nH := 0
      nS := 0
   ELSE
      IF nL < 0.5
         nS := ( nMax - nMin ) / ( nMax + nMin )
      ELSE
         nS := ( nMax - nMin ) / ( 2.0 - nMax - nMin )
      ENDIF
      DO CASE
         CASE nR = nMax
            nH := ( nG - nB ) / ( nMax - nMin )
         CASE nG = nMax
            nH := 2.0 + ( nB - nR ) / ( nMax - nMin )
         CASE nB = nMax
            nH := 4.0 + ( nR - nG ) / ( nMax - nMin )
      ENDCASE
   ENDIF

   nH := Int( (nH * 239) / 6 )
   IF nH < 0 ; nH += 240 ; ENDIF
   nS := Int( nS * 239 )
   nL := Int( nL * 239 )

RETURN { nH, nS, nL }


static FUNCTION HSL2RGB( nH, nS, nL )

   LOCAL nFor
   LOCAL nR, nG, nB
   LOCAL nTmp1, nTmp2, aTmp3 := { 0, 0, 0 }

   nH /= 239
   nS /= 239
   nL /= 239
   IF nS == 0
      nR := nL
      nG := nL
      nB := nL
   ELSE
      IF nL < 0.5
         nTmp2 := nL * ( 1 + nS )
      ELSE
         nTmp2 := nL + nS - ( nL * nS )
      ENDIF
      nTmp1 := 2 * nL - nTmp2
      aTmp3[1] := nH + 1 / 3
      aTmp3[2] := nH
      aTmp3[3] := nH - 1 / 3
      FOR nFor := 1 TO 3
         IF aTmp3[nFor] < 0
            aTmp3[nFor] += 1
         ENDIF
         IF aTmp3[nFor] > 1
            aTmp3[nFor] -= 1
         ENDIF
         IF 6 * aTmp3[nFor] < 1
            aTmp3[nFor] := nTmp1 + ( nTmp2 - nTmp1 ) * 6 * aTmp3[nFor]
         ELSE
            IF 2 * aTmp3[nFor] < 1
               aTmp3[nFor] := nTmp2
            ELSE
               IF 3 * aTmp3[nFor] < 2
                  aTmp3[nFor] := nTmp1 + ( nTmp2 - nTmp1 ) * ( ( 2 / 3 ) - aTmp3[nFor] ) * 6
               ELSE
                  aTmp3[nFor] := nTmp1
               ENDIF
            ENDIF
         ENDIF
      next
      nR := aTmp3[1]
      nG := aTmp3[2]
      nB := aTmp3[3]
   ENDIF

RETURN { Int( nR * 255 ), Int( nG * 255 ), Int( nB * 255 ) }



static FUNC PI(); RETURN (3.1415926536)

static FUNC RadToDeg(x); RETURN (180.0*x/PI())

static FUNC DegToRad(x); RETURN (x*PI()/180.0)

static FUNC Signo(nValue)
RETURN (IF(nValue<0, -1.0, 1.0))



FUNCTION GetPrtCoors(oGraph)








   LOCAL oDlg, nTop        := 2.5, nLeft       := 2.5, nHeight     := 8.0, nWidth      := 9.5, aPrinters   := GetPrinters(), cPrinter    := PrnGetName(), lPrnDefault := .T.

   oDlg = TDialog():New(,,,,, "IMP_GRAPH",, .F.,,,,,, .F.,,,,,, .F., )





   TGet():ReDefine( 100, { | u | If( PCount()==0, nTop, nTop:= u ) }, oDlg,, "99.99",,,,,,, .F.,,, .F., .T.,,,,,,, "nTop", )





   TGet():ReDefine( 110, { | u | If( PCount()==0, nLeft, nLeft:= u ) }, oDlg,, "99.99",,,,,,, .F.,,, .F., .T.,,,,,,, "nLeft", )





   TGet():ReDefine( 120, { | u | If( PCount()==0, nHeight, nHeight:= u ) }, oDlg,, "99.99",,,,,,, .F.,,, .F., .T.,,,,,,, "nHeight", )





   TGet():ReDefine( 130, { | u | If( PCount()==0, nWidth, nWidth:= u ) }, oDlg,, "99.99",,,,,,, .F.,,, .F., .T.,,,,,,, "nWidth", )



   TCheckBox():ReDefine( 140, { | u | If( PCount()==0, lPrnDefault, lPrnDefault:= u ) }, oDlg,,,,,,, .F.,, )





   TComboBox():ReDefine( 150, { | u | If( PCount()==0, cPrinter, cPrinter:= u ) }, aPrinters, oDlg,,,,,,, .F., {||     !lPrnDefault},,,,, )




   TButton():ReDefine( 1, {||( PrintGraph( oGraph, nTop, nLeft, nWidth, nHeight, lPrnDefault, cPrinter ), oDlg:End() )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 2, {||( oDlg:End() )}, oDlg,,, .F.,,,, .F. )

   oDlg:AddFastKey( 116, {|| PrintGraph( oGraph, nTop, nLeft, nWidth, nHeight, lPrnDefault, cPrinter ), oDlg:End() } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN ( nil )



FUNCTION PrintGraph( oGraph, nTop, nLeft, nWidth, nHeight, lPrnDefault, cPrinter )

   LOCAL oPrn

   if !Empty( cPrinter ) .AND. !lPrnDefault
      oPrn := PrintBegin( oGraph:cTitle, .F., .T., cPrinter, .F., .F. )
   else
      oPrn := PrintBegin( oGraph:cTitle, .F., .T.,, .F., .F. )
   end

      oPrn:Cmtr2Pix( @nTop  , @nLeft )

      oPrn:Cmtr2Pix( @nWidth, @nHeight )

      PageBegin()

         oGraph:Print( oPrn, nTop, nLeft, nWidth, nHeight )

      PageEnd()

   PrintEnd()

RETURN Nil



Function GraphPropierties( oGraph )

   local oCbx
   local aType    := { "Barras", "Lineas", "Puntos", "Tarta", "Combinado" }
   local oDlg
   local oPnt
   local aPoint   := { "Punto", "Cruz", "Forma" }
   local cPoint   := aPoint[ oGraph:nPoint ]
   local nType    := oGraph:nType
   local cType    := aType[ nType ]
   local l3D      := oGraph:l3D
   local lTitle   := oGraph:lTitle
   local lxVal    := oGraph:lxVal
   local lyVal    := oGraph:lyVal
   local lLegends := oGraph:lLegends
   local lxGrid   := oGraph:lxGrid
   local lyGrid   := oGraph:lyGrid
   local nXRanges := oGraph:nXRanges
   local nBarD    := oGraph:nBarD
   local nValues  := oGraph:nValues
   local cTitle   := PadR( oGraph:cTitle, 50 )
   local cPicture := oGraph:cPicture
   local lViewVal := oGraph:lViewVal

   oDlg = TDialog():New(,,,,, "Prop_Graph",, .F.,,,,,, .F.,,,,,, .F., )

      TCheckBox():ReDefine( 101, { | u | If( PCount()==0, l3d, l3d:= u ) }, oDlg,,,,,,, .F.,, )

      TCheckBox():ReDefine( 102, { | u | If( PCount()==0, lTitle, lTitle:= u ) }, oDlg,,,,,,, .F.,, )

      TCheckBox():ReDefine( 103, { | u | If( PCount()==0, lxVal, lxVal:= u ) }, oDlg,,,,,,, .F.,, )

      TCheckBox():ReDefine( 104, { | u | If( PCount()==0, lyVal, lyVal:= u ) }, oDlg,,,,,,, .F.,, )

      TCheckBox():ReDefine( 105, { | u | If( PCount()==0, lLegends, lLegends:= u ) }, oDlg,,,,,,, .F.,, )

      TCheckBox():ReDefine( 106, { | u | If( PCount()==0, lxGrid, lxGrid:= u ) }, oDlg,,,,,,, .F.,, )

      TCheckBox():ReDefine( 107, { | u | If( PCount()==0, lyGrid, lyGrid:= u ) }, oDlg,,,,,,, .F.,, )

      TGet():ReDefine( 108, { | u | If( PCount()==0, nXRanges, nXRanges:= u ) }, oDlg,, "99",,,,,,, .F.,,, .F., .T.,,,,,,, "nXRanges", )

      TGet():ReDefine( 109, { | u | If( PCount()==0, nBarD, nBarD:= u ) }, oDlg,, "99",,,,,,, .F.,,, .F., .T.,,,,,,, "nBarD", )

      oCbx := TComboBox():ReDefine( 110, { | u | If( PCount()==0, cType, cType:= u ) }, aType, oDlg,,,,,,, .F.,,,,,, )



      oPnt := TComboBox():ReDefine( 112, { | u | If( PCount()==0, cPoint, cPoint:= u ) }, aPoint, oDlg,,,,,,, .F.,, { "Point13", "Cross13", "Shape13" },,,, )
      TGet():ReDefine( 115, { | u | If( PCount()==0, cTitle, cTitle:= u ) }, oDlg,,,,,,,,, .F.,,, .F., .F.,,,,,,, "cTitle", )

      TGet():ReDefine( 116, { | u | If( PCount()==0, cPicture, cPicture:= u ) }, oDlg,, "@X",,,,,,, .F.,,, .F., .F.,,,,,,, "cPicture", )

      TCheckBox():ReDefine( 117, { | u | If( PCount()==0, lViewVal, lViewVal:= u ) }, oDlg,,,,,,, .F.,, )

      TButton():ReDefine( 1, {||oDlg:End( 1 )}, oDlg,,, .F.,,,, .F. )

      TButton():ReDefine( 2, {||oDlg:End()}, oDlg,,, .F.,,,, .T. )

      oDlg:AddFastKey( 116, {|| oDlg:End( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult == 1

      oGraph:l3D        := l3D
      oGraph:lTitle     := lTitle
      oGraph:lxVal      := lxVal
      oGraph:lyVal      := lyVal
      oGraph:lLegends   := lLegends
      oGraph:lxGrid     := lxGrid
      oGraph:lyGrid     := lyGrid
      oGraph:nXRanges   := nXRanges
      oGraph:nBarD      := nBarD
      oGraph:nValues    := nValues
      oGraph:cTitle     := cTitle
      oGraph:cPicture   := cPicture
      oGraph:nType      := nType
      oGraph:lViewVal   := lViewVal
      oGraph:nType      := oCbx:nAt
      oGraph:nPoint     := oPnt:nAt

      oGraph:Refresh()

   end

Return ( nil )
