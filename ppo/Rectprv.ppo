#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 216 ".\Prg\Rectprv.prg"
memvar cDbf
memvar cDbfCol
memvar cDbfRec
memvar cDbfAlm
memvar cDbfPrv
memvar cDbfPgo
memvar cDbfIva
memvar cDbfDiv
memvar cDbfArt
memvar cDbfKit
memvar cDbfPro
memvar cDbfTblPro
memvar aTotIva
memvar aIvaUno
memvar aIvaDos
memvar aIvaTre
memvar aDatVcto
memvar aImpVcto
memvar nTotBrt
memvar nTotNet
memvar nTotSup
memvar nTotIva
memvar nTotReq
memvar nTotRet
memvar nTotFac
memvar nTotDto
memvar nTotDpp
memvar nTotUno
memvar nTotDos
memvar nTotImp
memvar nTotUnd
memvar nPagFac
memvar nTipRet
memvar nTotPage
memvar cPinDivFac
memvar cPirDivFac
memvar cPicEurFac
memvar nDinDivFac
memvar nDirDivFac
memvar nVdvDivFac
memvar nPagina
memvar lEnd
memvar aImpVto
memvar aDatVto





static oWndBrw
static oBrwIva
static oInf

static dbfRctPrvT
static dbfRctPrvL
static dbfRctPrvS
static filRctPrvL
static tmpRctPrvT
static tmpRctPrvP
static tmpRctPrvL
static tmpRctPrvI
static dbfRctPrvP
static dbfRctPrvI
static dbfRctPrvD

static dbfPedPrvT
static dbfPedPrvL
static dbfAlbPrvT
static dbfAlbPrvL
static dbfFacPrvT
static dbfFacPrvL
static dbfPrvBnc

static dbfIva
static dbfInci
static dbfPrv
static dbfArtPrv
static dbfFPago
static dbfTmp
static dbfKit
static dbfArticulo
static dbfUbicaL
static dbfCodebar
static dbfFamilia
static dbfTblCnv
static dbfArtCom
static dbfPro
static dbfDoc
static dbfCajT
static dbfTblPro
static dbfDiv
static dbfUsr
static dbfFlt
static dbfCount
static oBandera
static dbfDelega
static dbfEmp
static dbfAlm
static dbfAlbCliL
static dbfFacCliL
static dbfFacRecL
static dbfTikCliL
static dbfProLin
static dbfProMat
static dbfHisMov
static oStock
static cNewFile
static cPicEur
static cPicUnd
static cPinDiv
static cPouDiv
static cPorDiv
static cTmpInc
static cTmpDoc
static cTmpPgo
static cTmpSer

static dbfTmpInc
static dbfTmpDoc
static dbfTmpPgo
static dbfTmpSer

static cPirDiv
static nDinDiv
static nRinDiv

static oGetTotal
static oGetTotPg
static oGetRet
static oGetNet
static oGetIva
static oGetReq
static oGetPgd
static oGetPdt
static oUsr
static cUsr
static oFntTot
static oBanco

static oMnuPgo
static oMnuRec

static aNumAlb          := {}
static nGetNeto         := 0
static nGetIva          := 0
static nGetReq          := 0
static nGetPgd          := 0

static cOldCodCli       := ""
static cOldCodArt       := ""
static cOldPrpArt       := ""
static cOldUndMed       := ""
static lOpenFiles       := .F.
static lExternal        := .F.
static nLabels          := 1
static cFiltroUsuario   := ""
static bEdtRec          := { |aTmp, aGet, dbfRctPrvT, oBrw, bWhen, bValid, nMode, cNumFac | EdtRec( aTmp, aGet, dbfRctPrvT, oBrw, bWhen, bValid, nMode, cNumFac ) }
static bEdtDet          := { |aTmp, aGet, dbfRctPrvT, oBrw, bWhen, bValid, nMode, aFac    | EdtDet( aTmp, aGet, dbfRctPrvT, oBrw, bWhen, bValid, nMode ) }
static bEdtInc          := { |aTmp, aGet, dbfRctPrvI, oBrw, bWhen, bValid, nMode, aTmpLin | EdtInc( aTmp, aGet, dbfRctPrvI, oBrw, bWhen, bValid, nMode, aTmpLin ) }
static bEdtDoc          := { |aTmp, aGet, dbfRctPrvD, oBrw, bWhen, bValid, nMode, aTmpLin | EdtDoc( aTmp, aGet, dbfRctPrvD, oBrw, bWhen, bValid, nMode, aTmpLin ) }
static bEdtPgo          := { |aTmp, aGet, dbfFacCliP, oBrw, bWhen, bValid, nMode, aTmpFac | EdtPgo( aTmp, aGet, dbfFacCliP, oBrw, bWhen, bValid, nMode, aTmpFac ) }
static oUndMedicion









STATIC FUNCTION OpenFiles( lExt )

   local oBlock

   if lOpenFiles
      MsgStop( "Imposible abrir ficheros de facturas rectificativas a proveedores" )
      Return ( .F. )
   end

   IIF( lExt == nil, lExt := .F., ) ;

   lExternal            := lExt

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      DisableAcceso()

      lOpenFiles        := .T.

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvT.DBF" ), ( cCheckArea( "FACPRVT", @dbfRctPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvL.DBF" ), ( cCheckArea( "FACPRVL", @dbfRctPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvI.DBF" ), ( cCheckArea( "FACPRVI", @dbfRctPrvI ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvI.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvD.DBF" ), ( cCheckArea( "FACPRVD", @dbfRctPrvD ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvD.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvS.DBF" ), ( cCheckArea( "FACPRVS", @dbfRctPrvS ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACPRVP.DBF" ), ( cCheckArea( "FACPRVP", @dbfRctPrvP ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FACPRVP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ( dbfRctPrvP )->( OrdSetFocus( "rNumFac" ) )

      dbUseArea( .T., ( cDriver() ), ( cPatPrv() + "PROVEE.DBF" ), ( cCheckArea( "PROVEE", @dbfPrv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatPrv() + "PROVEE.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIVA.DBF" ), ( cCheckArea( "TIVA", @dbfIva ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TIVA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "PROVART.DBF" ), ( cCheckArea( "PROVART", @dbfArtPrv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "PROVART.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ARTICULO.DBF" ), ( cCheckArea( "ARTICULO", @dbfArticulo ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ARTICULO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ArtCodebar.Dbf" ), ( cCheckArea( "CODEBAR", @dbfCodebar ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ArtCodebar.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "FAMILIAS.DBF" ), ( cCheckArea( "FAMILIAS", @dbfFamilia ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "FAMILIAS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ARTKIT.DBF" ), ( cCheckArea( "ARTTIK", @dbfKit ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ARTKIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatGrp() + "FPAGO.DBF" ), ( cCheckArea( "FPAGO", @dbfFPago ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatGrp() + "FPAGO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ArtDiv.Dbf" ), ( cCheckArea( "ARTCOM", @dbfArtCom ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ArtDiv.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "DIVISAS.DBF" ), ( cCheckArea( "DIVISAS", @dbfDiv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "DIVISAS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "CNFFLT.DBF" ), ( cCheckArea( "CNFFLT", @dbfFlt ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "CNFFLT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TBLCNV.DBF" ), ( cCheckArea( "TBLCNV", @dbfTblCnv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TBLCNV.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "Cajas.Dbf" ), ( cCheckArea( "CAJAS", @dbfCajT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "Cajas.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end



      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPROVT.DBF" ), ( cCheckArea( "PEDPROVT", @dbfPedPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPROVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPROVL.DBF" ), ( cCheckArea( "PEDPROVL", @dbfPedPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPROVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBPROVT.DBF" ), ( cCheckArea( "ALBPROVT", @dbfAlbPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBPROVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBPROVL.DBF" ), ( cCheckArea( "ALBPROVL", @dbfAlbPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBPROVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACPRVT.DBF" ), ( cCheckArea( "FACPRVT", @dbfFacPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FACPRVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACPRVL.DBF" ), ( cCheckArea( "FACPRVL", @dbfFacPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FACPRVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TIPINCI.DBF" ), ( cCheckArea( "TIPINCI", @dbfInci ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TIPINCI.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "PRO.DBF" ), ( cCheckArea( "PRO", @dbfPro ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "PRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "TBLPRO.DBF" ), ( cCheckArea( "TBLPRO", @dbfTblPro ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "TBLPRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatAlm() + "ALMACEN.DBF" ), ( cCheckArea( "ALMACEN", @dbfAlm ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatAlm() + "ALMACEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RDOCUMEN.DBF" ), ( cCheckArea( "RDOCUMEN", @dbfDoc ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RDOCUMEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "CTIPO" )

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "USERS.DBF" ), ( cCheckArea( "USERS", @dbfUsr ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "USERS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatAlm() + "UBICAL.DBF" ), ( cCheckArea( "UBICAL", @dbfUbicaL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatAlm() + "UBICAL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "DELEGA.DBF" ), ( cCheckArea( "DELEGA", @dbfDelega ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "DELEGA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "NCOUNT.DBF" ), ( cCheckArea( "NCOUNT", @dbfCount ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "NCOUNT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "EMPRESA.DBF" ), ( cCheckArea( "EMPRESA", @dbfEmp ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "EMPRESA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBCLIL.DBF" ), ( cCheckArea( "ALBCLIL", @dbfAlbCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBCLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cStkFast" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACCLIL.DBF" ), ( cCheckArea( "FACCLIL", @dbfFacCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FACCLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cRef" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacRecL.DBF" ), ( cCheckArea( "FacRecL", @dbfFacRecL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacRecL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cRef" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TIKEL.DBF" ), ( cCheckArea( "TIKEL", @dbfTikCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TIKEL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "CSTKFAST" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PROLIN.DBF" ), ( cCheckArea( "PROLIN", @dbfProLin ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PROLIN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cCodArt" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PROMAT.DBF" ), ( cCheckArea( "PROMAT", @dbfProMat ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PROMAT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cCodArt" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "HISMOV.DBF" ), ( cCheckArea( "HISMOV", @dbfHisMov ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "HISMOV.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cRefMov" )

      dbUseArea( .T., ( cDriver() ), ( cPatPrv() + "PRVBNC.DBF" ), ( cCheckArea( "PRVBNC", @dbfPrvBnc ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatPrv() + "PRVBNC.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end



      oUndMedicion      := UniMedicion():Create( cPatGrp() )
      if !oUndMedicion:OpenFiles()
         lOpenFiles     := .F.
      end

      oBandera          := TBandera():New()

      oStock            := TStock():Create( cPatGrp() )
      if !oStock:lOpenFiles()
         lOpenFiles     := .F.
      else

      oStock:cKit       := dbfKit

      oStock:cPedPrvT   := dbfPedPrvT
      oStock:cPedPrvL   := dbfPedPrvL
      oStock:cAlbPrvT   := dbfAlbPrvT
      oStock:cAlbPrvL   := dbfAlbPrvL
      oStock:cFacPrvT   := dbfFacPrvT
      oStock:cFacPrvL   := dbfFacPrvL
      oStock:cRctPrvT   := dbfRctPrvT
      oStock:cRctPrvL   := dbfRctPrvL
      oStock:cRctPrvS   := dbfRctPrvS

      oStock:cAlbCliL   := dbfAlbCliL
      oStock:cFacCliL   := dbfFacCliL
      oStock:cFacRecL   := dbfFacRecL
      oStock:cTikL      := dbfTikCliL

      oStock:cProducL   := dbfProLin
      oStock:cProducM   := dbfProMat

      oStock:cHisMov    := dbfHisMov

      end

      oBanco            := TBancos():Create()
      if !oBanco:OpenFiles()
         lOpenFiles     := .F.
      end

      oFntTot           := TFont():New( "Arial", 8, 26, .F., .T. )





      public nTotBrt    := 0
      public nTotNet    := 0
      public nTotSup    := 0
      public nTotIva    := 0
      public nTotReq    := 0
      public nTotRet    := 0
      public nTotFac    := 0
      public nTotDto    := 0
      public nTotDpp    := 0
      public nTotUno    := 0
      public nTotDos    := 0
      public nTotImp    := 0
      public nTotUnd    := 0
      public nPagFac    := 0
      public nTipRet    := 0
      public aTotIva    := { { 0,0,nil,0,0,0 }, { 0,0,nil,0,0,0 }, { 0,0,nil,0,0,0 } }
      public aIvaUno    := aTotIva[ 1 ]
      public aIvaDos    := aTotIva[ 2 ]
      public aIvaTre    := aTotIva[ 3 ]





      if oUser():lFiltroVentas()
         cFiltroUsuario := "Field->cCodUsr == '" + oUser():cCodigo() + "' .and. Field->cCodCaj == '" + oUser():cCaja() + "'"
      end

      EnableAcceso()

   RECOVER

      lOpenFiles        := .F.

      EnableAcceso()

      msgStop( "Imposible abrir ficheros de facturas rectificativas a proveedores" )

   end

   ErrorBlock( oBlock )

   if !lOpenFiles
      CloseFiles()
   end

Return ( lOpenFiles )



Static Function CloseFiles()

   DisableAcceso()

   DestroyFastFilter( dbfRctPrvT, .T., .T. )

   if dbfRctPrvT <> nil
      ( dbfRctPrvT )->( dbCloseArea() )
   end

   if dbfRctPrvL <> nil
      ( dbfRctPrvL )->( dbCloseArea() )
   end

   if dbfRctPrvI <> nil
      ( dbfRctPrvI )->( dbCloseArea() )
   end

   if dbfRctPrvD <> nil
      ( dbfRctPrvD )->( dbCloseArea() )
   end

   if dbfRctPrvS <> nil
      ( dbfRctPrvS )->( dbCloseArea() )
   end

   if dbfPedPrvT <> nil
      ( dbfPedPrvT )->( dbCloseArea() )
   end

   if dbfPedPrvL <> nil
      ( dbfPedPrvL )->( dbCloseArea() )
   end

   if dbfPrv <> nil
      ( dbfPrv )->( dbCloseArea() )
   end

   if dbfIva <> nil
      ( dbfIva )->( dbCloseArea() )
   end

   if dbfArtPrv <> nil
      ( dbfArtPrv )->( dbCloseArea() )
   end

   if dbfFPago <> nil
      ( dbfFPago )->( dbCloseArea() )
   end

   if dbfArticulo <> nil
      ( dbfArticulo )->( dbCloseArea() )
   end

   if dbfCodebar <> nil
      ( dbfCodebar )->( dbCloseArea() )
   end

   if dbfFamilia <> nil
      ( dbfFamilia )->( dbCloseArea() )
   end

   if dbfKit <> nil
      ( dbfKit )->( dbCloseArea() )
   end

   if !Empty( dbfFlt )
      ( dbfFlt )->( dbCloseArea() )
   end

   if dbfRctPrvP <> nil
      ( dbfRctPrvP )->( dbCloseArea() )
   end

   if dbfArtCom <> nil
      ( dbfArtCom )->( dbCloseArea() )
   end

   if dbfDiv <> nil
      ( dbfDiv )->( dbCloseArea() )
   end

   if ( dbfTblCnv ) <> nil
      ( dbfTblCnv )->( dbCloseArea() )
   end

   if dbfPro <> nil
      ( dbfPro )->( dbCloseArea() )
   end

   if dbfTblPro <> nil
      ( dbfTblPro )->( dbCloseArea() )
   end

   if dbfAlbPrvT <> nil
      ( dbfAlbPrvT )->( dbCloseArea() )
   end

   if dbfAlbPrvL <> nil
      ( dbfAlbPrvL )->( dbCloseArea() )
   end

   if dbfFacPrvT <> nil
      ( dbfFacPrvT )->( dbCloseArea() )
   end

   if dbfFacPrvL <> nil
      ( dbfFacPrvL )->( dbCloseArea() )
   end

   if dbfAlm <> nil
      ( dbfAlm )->( dbCloseArea() )
   end

   if dbfDoc <> nil
      ( dbfDoc )->( dbCloseArea() )
   end

   if dbfCajT <> nil
      ( dbfCajT )->( dbCloseArea() )
   end

   if dbfUbicaL <> nil
      ( dbfUbicaL )->( dbCloseArea() )
   end

   if dbfUsr <> nil
      ( dbfUsr )->( dbCloseArea() )
   end

   if dbfInci <> nil
      ( dbfInci )->( dbCloseArea() )
   end

   if dbfDelega <> nil
      ( dbfDelega )->( dbCloseArea() )
   end

   if dbfCount <> nil
      ( dbfCount )->( dbCloseArea() )
   end

   if dbfEmp <> nil
      ( dbfEmp )->( dbCloseArea() )
   end

   if dbfAlbCliL <> nil
      ( dbfAlbCliL )->( dbCloseArea() )
   end

   if dbfFacCliL <> nil
      ( dbfFacCliL )->( dbCloseArea() )
   end

   if dbfFacRecL <> nil
      ( dbfFacRecL )->( dbCloseArea() )
   end

   if dbfTikCliL <> nil
      ( dbfTikCliL )->( dbCloseArea() )
   end

   if dbfProLin <> nil
      ( dbfProLin )->( dbCloseArea() )
   end

   if dbfProMat <> nil
      ( dbfProMat )->( dbCloseArea() )
   end

   if dbfHisMov <> nil
      ( dbfHisMov )->( dbCloseArea() )
   end

   if dbfPrvBnc <> nil
      ( dbfPrvBnc )->( dbCloseArea() )
   end

   if !Empty( oUndMedicion )
      oUndMedicion:end()
   end

   if oStock <> nil
      oStock:end()
   end

   if oBanco <> nil
      oBanco:CloseFiles()
      oBanco:End()
   end

   dbfRctPrvT  := nil
   dbfRctPrvL  := nil
   dbfRctPrvI  := nil
   dbfRctPrvD  := nil
   dbfRctPrvP  := nil
   dbfRctPrvS  := nil
   dbfPrv      := nil
   dbfIva      := nil
   dbfArtPrv   := nil
   dbfFPago    := nil
   dbfUbicaL   := nil
   dbfArticulo := nil
   dbfCodebar  := nil
   dbfKit      := nil
   dbfFlt      := nil
   dbfArtCom   := nil
   dbfDiv      := nil
   oBandera    := nil
   dbfTblCnv   := nil
   dbfPro      := nil
   dbfTblPro   := nil
   dbfAlbPrvT  := nil
   dbfAlbPrvL  := nil
   dbfFacPrvT  := nil
   dbfFacPrvL  := nil
   dbfDoc      := nil
   dbfCajT     := nil
   dbfUsr      := nil
   oStock      := nil
   dbfInci     := nil
   dbfDelega   := nil
   dbfCount    := nil
   oBanco      := nil
   dbfEmp      := nil

   dbfAlbCliL  := nil
   dbfFacCliL  := nil
   dbfFacRecL  := nil

   dbfTikCliL  := nil
   dbfProLin   := nil
   dbfProMat   := nil
   dbfHisMov   := nil

   dbfPrvBnc   := nil

   lOpenFiles  := .F.

   EnableAcceso()

RETURN ( !lOpenFiles )



FUNCTION RctPrv( oMenuItem, oWnd, cCodPrv, cCodArt, cNumFac )

   local oSnd
   local oRpl
   local oImp
   local oRotor
   local oDel
   local oPrv
   local oPdf
   local oMail
   local oBtnEur
   local nLevel
   local lEuro          := .F.
   local oLiq

   IIF( oMenuItem == nil, oMenuItem := "01099", ) ;
   IIF( oWnd == nil, oWnd := oWnd(), ) ;
   IIF( cCodPrv == nil, cCodPrv := "", ) ;
   IIF( cCodArt == nil, cCodArt := "", ) ;
   IIF( cNumFac == nil, cNumFac := "", ) ;





   nLevel            := nLevelUsr( oMenuItem )
   if nAnd( nLevel, 1 ) <> 0
      msgStop( "Acceso no permitido." )
      return .F.
   end





   if oWnd <> nil
      SysRefresh(); oWnd:CloseAll(); SysRefresh()
   end

   if !OpenFiles()
      return .F.
   end





   DisableAcceso()



















   oWndBrw := TShell():New( 0, 0, 22, 80, "Facturas rectificativa de proveedores",, oWnd,,, .F.,,, ( dbfRctPrvT ),,,,, {"Número", "Fecha", "Código", "Proveedor", "Número documento", "Pago"}, {||( WinAppRec( oWndBrw:oBrw, bEdtRec, dbfRctPrvT, cCodPrv, cCodArt, cNumFac ) )}, {||( WinEdtRec( oWndBrw:oBrw, bEdtRec, dbfRctPrvT, cCodPrv, cCodArt, cNumFac ) )}, {||( WinDelRec( oWndBrw:oBrw, dbfRctPrvT, {|| QuiRctPrv() } ) )}, {||( WinDupRec( oWndBrw:oBrw, bEdtRec, dbfRctPrvT, cCodPrv, cCodArt, cNumFac ) )}, nil, nLevel, "Document_navigate_cross_16", ( 0 + ( 114 * 256 ) + ( 198 * 65536 ) ),, {||( WinZooRec( oWndBrw:oBrw, bEdtRec, dbfRctPrvT ) )}, .T. )

     oWndBrw:lFechado      := .T.

     oWndBrw:bChgIndex     := {|| if( oUser():lFiltroVentas(), CreateFastFilter( cFiltroUsuario, dbfRctPrvT, .F., , cFiltroUsuario ), CreateFastFilter( "", dbfRctPrvT, .F. ) ) }

      oWndBrw:SetYearComboBoxChange( {|| YearComboBoxChange() } )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Sesión cerrada"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfRctPrvT )->lCloFac }
         :nWidth           := 20
         :lHide            := .T.
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "Zoom16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Envio"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfRctPrvT )->lSndDoc }
         :nWidth           := 20
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "Lbl16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Pagado"
         :nHeadBmpNo       := 4
         :bStrData         := {|| "" }
         :bBmpData         := {|| ChkPagRctPrv( dbfRctPrvT, dbfRctPrvP ) }
         :nWidth           := 20
         :AddResource( "Bullet_Square_Green_16" )
         :AddResource( "Bullet_Square_Yellow_16" )
         :AddResource( "Bullet_Square_Red_16" )
         :AddResource( "ChgPre16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Contabilizado"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfRctPrvT )->lContab }
         :nWidth           := 20
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "BmpConta16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Incidencia"
         :nHeadBmpNo       := 4
         :bStrData         := {|| "" }
         :bBmpData         := {|| nEstadoIncidencia( ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac ) }
         :nWidth           := 20
         :lHide            := .T.
         :AddResource( "Bullet_Square_Red_16" )
         :AddResource( "Bullet_Square_Yellow_16" )
         :AddResource( "Bullet_Square_Green_16" )
         :AddResource( "Informacion_16" )

      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Impreso"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfRctPrvT )->lImprimido }
         :nWidth           := 20
         :lHide            := .T.
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "IMP16" )

      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Número"
         :cSortOrder       := "nNumFac"
         :bEditValue       := {|| ( dbfRctPrvT )->cSerFac + "/" + Alltrim( Str( ( dbfRctPrvT )->nNumFac ) ) + "/" + ( dbfRctPrvT )->cSufFac }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Delegación"
         :bEditValue       := {|| ( dbfRctPrvT )->cCodDlg }
         :nWidth           := 60
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Sesión"
         :bEditValue       := {|| Trans( ( dbfRctPrvT )->cTurFac, "######" ) }
         :nWidth           := 60
         :lHide            := .T.
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Numero documento"
         :cSortOrder       := "cNumDoc"
         :bEditValue       := {|| ( dbfRctPrvT )->cNumDoc }
         :nWidth           := 80
         :lHide            := .T.
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Fecha"
         :cSortOrder       := "dFecFac"
         :bEditValue       := {|| Dtoc( ( dbfRctPrvT )->dFecFac ) }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Caja"
         :bEditValue       := {|| ( dbfRctPrvT )->cCodCaj }
         :nWidth           := 40
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Usuario"
         :bEditValue       := {|| ( dbfRctPrvT )->cCodUsr }
         :nWidth           := 40
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodPrv"
         :bEditValue       := {|| ( dbfRctPrvT )->cCodPrv }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cNomPrv"
         :bEditValue       := {|| ( dbfRctPrvT )->cNomPrv }
         :nWidth           := 180
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Pago"
         :cSortOrder       := "cCodPago"
         :bEditValue       := {|| ( dbfRctPrvT )->cCodPago }
         :nWidth           := 40
         :lHide            := .T.
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Base"
         :bEditValue       := {|| ( dbfRctPrvT )->nTotNet }
         :cEditPicture     := cPirDiv( ( dbfRctPrvT )->cDivFac, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := cImp()
         :bEditValue       := {|| ( dbfRctPrvT )->nTotIva }
         :cEditPicture     := cPirDiv( ( dbfRctPrvT )->cDivFac, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "R.E."
         :bEditValue       := {|| ( dbfRctPrvT )->nTotReq }
         :cEditPicture     := cPirDiv( ( dbfRctPrvT )->cDivFac, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Total"
         :bEditValue       := {|| ( dbfRctPrvT )->nTotFac }
         :cEditPicture     := cPirDiv( ( dbfRctPrvT )->cDivFac, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Div."
         :bEditValue       := {|| cSimDiv( if( lEuro, cDivChg(), ( dbfRctPrvT )->cDivFac ), dbfDiv ) }
         :nWidth           := 30
      end

      oWndBrw:lAutoSeek    := .F.
      oWndBrw:cHtmlHelp    := "Factura rectificativa de proveedor"

      oWndBrw:CreateXFromCode()





   oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

   oWndBrw:AddSeaBar()








   oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







   oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )







   oWndBrw:NewAt( "ZOOM",,, {||( oWndBrw:RecZoom() )}, "(Z)oom", "Z",,, 8,, .F. )







   oDel := oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",, {|This|This:Toggle()}, 16,, .F. )







   oImp := oWndBrw:NewAt( "IMP",,, {||( nGenRctPrv( 1 ) )}, "(I)mprimir", "I",, {|This|This:Toggle()}, 32,, .F. )


      lGenFac( oWndBrw:oBrw, oImp, 1 )





   oWndBrw:NewAt( "SERIE1",,, {||( PrnSerie( oWndBrw:oBrw ) )}, "Imp(r)imir series", "R",,, 32,, .F. )







   oPrv := oWndBrw:NewAt( "PREV1",,, {||( nGenRctPrv( 2 ), oWndBrw:Refresh() )}, "(P)revisualizar", "P",, {|This|This:Toggle()}, 32,, .F. )


      lGenFac( oWndBrw:oBrw, oPrv, 2 )






   oPdf := oWndBrw:NewAt( "DOCLOCK",,, {||( nGenRctPrv( 3 ) )}, "Pd(f)", "F",, {|This|This:Toggle()}, 32,, .F. )


      lGenFac( oWndBrw:oBrw, oPdf, 3 )





   oMail := oWndBrw:NewAt( "Mail",,, {||( nGenRctPrv( 6 ) )}, "Correo electrónico",,, {|This|This:Toggle()}, 32,, .F. )


      lGenFac( oWndBrw:oBrw, oMail, 6 )





   oWndBrw:NewAt( "RemoteControl_",,, {||( TRectificativaProveedorLabelGenerator():Create() )}, "E(t)iquetas", "T",,, 32,, .F. )





   oLiq := oWndBrw:NewAt( "Money2_",,, {||( lLiquida( oWndBrw:oBrw ) )}, "Pagar",,,, 4,, .F. )







      oWndBrw:NewAt( "Money2_",,, {||( aGetSelRec( oWndBrw, {|| lLiquida( oWndBrw:oBrw, ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac ) }, "Liquidar series de facturas", .T., nil, .T., nil ) )}, "Pagar series",,,, 4, oLiq, .F. )






   oWndBrw:NewAt( "BmpConta",,, {||( aGetSelRec( oWndBrw, {|lChk1, lChk2, oTree | CntRctPrv( lChk1, lChk2, .T., oTree, nil, nil, dbfRctPrvT, dbfRctPrvL, dbfRctPrvP, dbfPrv, dbfDiv, dbfArticulo, dbfFPago, dbfIva ) }, "Contabilizar facturas rectificativas", .F., "Simular resultados", .F., "Contabilizar pagos" ) )}, "(C)ontabilizar", "C",,, 4,, .F. )

   if oUser():lAdministrador()






      oWndBrw:NewAt( "ChgState",,, {||( aGetSelRec( oWndBrw, {|lChk1| lCntRctPrv( lChk1, dbfRctPrvT ) }, "Cambiar estado", .F., "Contabilizado", .T., nil ) )}, "Cambiar Es(t)ado", "T",,, 4,, .F. )

   end








   oSnd := oWndBrw:NewAt( "Lbl",, "Seleccionar facturas para ser enviados", {||lSnd( oWndBrw, dbfRctPrvT )}, "En(v)iar", "V",, {|This|This:Toggle()}, 4,, .F. )





   oBtnEur := oWndBrw:NewAt( "BAL_EURO",,, {||( lEuro := !lEuro, oWndBrw:Refresh() )}, "M(o)neda", "O",,,,, .F. )






   oWndBrw:NewAt( "INFO",,, {||( TTrazaDocumento():Activate( "04", ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac ) )}, "I(n)forme documento", "N",,, 4,, .F. )

   if oUser():lAdministrador()






      oRpl := oWndBrw:NewAt( "BMPCHG",,, {||( TDlgFlt():New( aItmRctPrv(), dbfRctPrvT ):ChgFields(), oWndBrw:Refresh() )}, "Cambiar campos",,, {|This|This:Toggle()}, 4,, .F. )







         oWndBrw:NewAt( "BMPCHG",,, {||( TDlgFlt():New( aColRctPrv(), dbfRctPrvL ):ChgFields(), oWndBrw:Refresh() )}, "Lineas",,,, 4, oRpl, .F. )

   end




   oRotor := oWndBrw:NewAt( "ROTOR",,, {||( oRotor:Expand() )}, "Rotor",,,, 4,, .F. )





      oWndBrw:NewAt( "Businessman_",,, {||( EdtPrv( ( dbfRctPrvT )->cCodPrv ) )}, "Modificar proveedor",,,, 4, oRotor, .F. )





      oWndBrw:NewAt( "INFO",,, {||( InfProveedor( ( dbfRctPrvT )->cCodPrv ) )}, "Informe proveedor",,,, 4, oRotor, .F. )





      oWndBrw:NewAt( "Document_plain_businessman_",,, {||( if( !Empty( ( dbfRctPrvT )->cNumFac ), ZooFacPrv( ( dbfRctPrvT )->cNumFac ), MsgStop( "La factura no proviene de un albarán" ) ) )}, "Visualizar factura",,,, 4, oRotor, .F. )






      oWndBrw:NewAt( "Money2_businessman_",,, {||( RecPrv( , , { ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac } ) )}, "Modificar recibo",,,, 4, oRotor, .T. )





   oWndBrw:NewAt( "END",,, {||( oWndBrw:End() )}, "(S)alir", "S",,,,, .T. )

   if !oUser():lFiltroVentas()
      oWndBrw:oActiveFilter:aTField       := aItmRctPrv()
      oWndBrw:oActiveFilter:cDbfFilter    := dbfFlt
      oWndBrw:oActiveFilter:cTipFilter    := "03"
   end

   oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp )

   EnableAcceso()

   if !Empty( cCodPrv ) .OR. !Empty( cCodArt ) .OR. !Empty( cNumFac )
      if !Empty( oWndBrw )
         oWndBrw:RecAdd()
      end
      cCodPrv  := nil
      cCodArt  := nil
      cNumFac  := nil
   end

Return .T.



STATIC FUNCTION EdtRec( aTmp, aGet, dbfRctPrvT, oBrw, cCodPrv, cCodArt, nMode, cNumFac )

   local n
   local oDlg
    local oFld
   local oBtnOk
   local oBrwLin
   local oBrwPgo
   local oBrwInc
   local oBrwDoc
   local cGetRet
   local oGet        := Array( 6 )
   local cGet        := Array( 6 )
   local oSayLabels  := Array( 7 )
   local cTlfPrv
   local oTlfPrv
   local oBmpDiv
   local oBmpEmp
   local nOrd        := ( dbfRctPrvT )->( ordSetFocus( 1 ) )
   local aControl    := Array( 6 )
   local oSayGas     := Array( 16 )
   local oBmpGeneral

   cTlfPrv           := RetFld( aTmp[ 6 ], dbfPrv, "Telefono" )
   cUsr              := RetFld( aTmp[ 46 ], dbfUsr, "cNbrUse" )

   do case
   case nMode == 1

      if !lCajaOpen( oUser():cCaja() ) .AND. !oUser():lAdministrador()
         msgStop( "Esta caja " + oUser():cCaja() + " esta cerrada." )
         Return .F.
      end

      aTmp[ 1 ]  := cNewSer( "nRctPrv", dbfCount )
      aTmp[ 4 ]  := cCurSesion()
      aTmp[ 35 ]  := cDivEmp()
      aTmp[ 7 ]  := oUser():cAlmacen()
      aTmp[ 8 ]  := oUser():cCaja()
      aTmp[ 36 ]  := nChgDiv( aTmp[ 35 ], dbfDiv )
      aTmp[ 3 ]  := RetSufEmp()
      aTmp[ 37 ]  := .T.
      aTmp[ 42 ]  := cProCnt()
      aTmp[ 17 ]  := Ctod( "" )
      aTmp[ 46 ]  := cCurUsr()
      aTmp[ 54 ]  := oUser():cDelegacion()
      aTmp[ 48 ]  := Ctod( "" )

      if !Empty( cCodPrv )
         aTmp[ 6 ]  := cCodPrv
      end

      if !Empty( cNumFac )
         aTmp[ 26 ]  := cNumFac
      end

   case nMode == 4

      if !lCajaOpen( oUser():cCaja() ) .AND. !oUser():lAdministrador()
         msgStop( "Esta caja " + oUser():cCaja() + " esta cerrada." )
         Return .F.
      end

      aTmp[ 4 ]  := cCurSesion()
      aTmp[ 8 ]  := oUser():cCaja()
      aTmp[ 37 ]  := .T.
      aTmp[ 17 ]  := Ctod( "" )
      aTmp[ 48 ]  := Ctod( "" )
      aTmp[ 44 ]  := .F.
      aTmp[ 16 ]  := .F.

   case nMode == 2

      if aTmp[ 16 ] .AND. !ApoloMsgNoYes( "La modificación de esta factura rectificativa puede provocar descuadres contables." + Chr(13)+Chr(10) + "¿ Desea continuar ?", "Factura ya contabilizada" )
         return .F.
      end

      if aTmp[ 43 ]
         MsgStop( "El documento ha sido recibido por internet", "Imposible modificar" )
         return .F.
      end

      if aTmp[ 44 ] .AND. !oUser():lAdministrador()
         msgStop( "Solo puede modificar los facturas rectificativas cerradas los administradores." )
         return .F.
      end

   end

   if Empty( aTmp[ 28 ] )
      aTmp[ 28 ]  := Padr( "General", 50 )
   end

   if Empty( aTmp[ 30 ] )
      aTmp[ 30 ]     := Padr( "Pronto pago", 50 )
   end





   if BeginTrans( aTmp, nMode )
      Return .F.
   end





   cOldCodCli  := aTmp[ 6 ]

   cPicUnd     := MasUnd()
   cPinDiv     := cPinDiv( aTmp[ 35 ], dbfDiv )
   cPirDiv     := cPirDiv( aTmp[ 35 ], dbfDiv )
   nDinDiv     := nDinDiv( aTmp[ 35 ], dbfDiv )
   nRinDiv     := nRinDiv( aTmp[ 35 ], dbfDiv )
   cPouDiv     := cPouDiv( aTmp[ 35 ], dbfDiv )
   cPorDiv     := cPorDiv( aTmp[ 35 ], dbfDiv )





   cGet[ 1 ]   := RetFld( aTmp[ 7 ], dbfAlm )
   cGet[ 2 ]   := RetFld( aTmp[ 6 ], dbfPrv )
   cGet[ 3 ]   := RetFld( aTmp[ 23], dbfFPago )
   cGet[ 5 ]   := RetFld( aTmp[ 8 ], dbfCajT )
   cGet[ 6 ]   := RetFld( cCodEmp() + aTmp[ 54 ], dbfDelega, "cNomDlg" )

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "facturas rectificativas de proveedores", "RECTPRV",, .F.,,,,,, .F.,,,,,, .F., )





      oFld := TFolder():ReDefine( 400, {"&Factura",    "Da&tos",      "&Incidencias",   "D&ocumentos"}, { "RCTPRV_1","RCTPRV_2","PEDCLI_3","PEDCLI_4" }, oDlg,,,,, .F., )





      oBmpGeneral := TBitmap():ReDefine( 990, "factura_rectificatica_proveedor_48_alpha",, oFld:aDialogs[1],,, .F., .F.,,, .F.,,, .T. )





      oBmpGeneral := TBitmap():ReDefine( 990, "folder2_red_alpha_48",, oFld:aDialogs[2],,, .F., .F.,,, .F.,,, .T. )





      oBmpGeneral := TBitmap():ReDefine( 990, "information_48_alpha",, oFld:aDialogs[3],,, .F., .F.,,, .F.,,, .T. )





      oBmpGeneral := TBitmap():ReDefine( 990, "address_book2_alpha_48",, oFld:aDialogs[4],,, .F., .F.,,, .F.,,, .T. )





      aGet[ 46 ] := TGetHlp():ReDefine( 125, { | u | If( PCount()==0, aTmp[ 46 ], aTmp[ 46 ]:= u ) }, oFld:aDialogs[2],,, {||    ( SetUsuario( aGet[ 46 ], oUsr, nil, dbfUsr ) )},,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )




      oUsr := TGetHlp():ReDefine( 126, { | u | If( PCount()==0, cUsr, cUsr:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )













        aGet[ 6 ] := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTmp[ 6 ], aTmp[ 6 ]:= u ) }, oFld:aDialogs[1],, ( RetPicCodPrvEmp() ), {||    ( loaPrv( aGet, aTmp, dbfPrv, nMode, oGet[ 2 ], oTlfPrv ) )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwProvee( aGet[ 6 ], oGet[ 2 ] ) )}, nil, "LUPA",, )





      aGet[ 9 ] := TGetHlp():ReDefine( 141, { | u | If( PCount()==0, aTmp[ 9 ], aTmp[ 9 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 14 ] := TGetHlp():ReDefine( 106, { | u | If( PCount()==0, aTmp[ 14 ], aTmp[ 14 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )




      oTlfPrv := TGetHlp():ReDefine( 107, { | u | If( PCount()==0, cTlfPrv, cTlfPrv:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )






      aGet[ 10 ] := TGetHlp():ReDefine( 103, { | u | If( PCount()==0, aTmp[ 10 ], aTmp[ 10 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|GoogleMaps( aTmp[ 10 ], Rtrim( aTmp[ 11 ] ) + Space( 1 ) + Rtrim( aTmp[ 12 ] ) )}, nil, "Environnment_View_16",, )





      aGet[ 11 ] := TGetHlp():ReDefine( 105, { | u | If( PCount()==0, aTmp[ 11 ], aTmp[ 11 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 12 ] := TGetHlp():ReDefine( 108, { | u | If( PCount()==0, aTmp[ 12 ], aTmp[ 12 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 13 ] := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, aTmp[ 13 ], aTmp[ 13 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )








      aGet[ 7 ] := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, aTmp[ 7 ], aTmp[ 7 ]:= u ) }, oFld:aDialogs[1],,, {||    cAlmacen( aGet[7], dbfAlm, oGet[ 1 ] )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|brwAlmacen( aGet[ 7 ], oGet[ 1 ] )}, nil, "LUPA",, )





      oGet[1] := TGetHlp():ReDefine( 151, { | u | If( PCount()==0, cGet[1], cGet[1]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( .F. )},, .F., .F.,,,,,, nil,,, )









        aGet[23] := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, aTmp[23], aTmp[23]:= u ) }, oFld:aDialogs[1],, "@!", {||    cFPago( aGet[23], dbfFPago, oGet[3] )}, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )},, .F., .F.,,,,, {|Self|BrwFPago( aGet[23 ], oGet[3] )}, nil, "LUPA",, )





      oGet[3] := TGetHlp():ReDefine( 161, { | u | If( PCount()==0, cGet[3], cGet[3]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )










      aGet[ 74 ] := TGetHlp():ReDefine( 300, { | u | If( PCount()==0, aTmp[ 74 ], aTmp[ 74 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )},, .F., .F.,,,,, {|Self|( BrwBncPrv( aGet[ 74 ], aGet[ 75 ], aGet[ 76 ], aGet[ 77 ], aGet[ 78 ], aTmp[ 6 ] ) )}, nil, "LUPA",, )





      aGet[ 75 ] := TGetHlp():ReDefine( 301, { | u | If( PCount()==0, aTmp[ 75 ], aTmp[ 75 ]:= u ) }, oFld:aDialogs[1],,, {||    ( lCalcDC( aTmp[ 75 ], aTmp[ 76 ], aTmp[ 77 ], aTmp[ 78 ], aGet[ 77 ] ) )},,,,,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )},, .F., .F.,,,,,, nil,,, )





      aGet[ 76 ] := TGetHlp():ReDefine( 302, { | u | If( PCount()==0, aTmp[ 76 ], aTmp[ 76 ]:= u ) }, oFld:aDialogs[1],,, {||    ( lCalcDC( aTmp[ 75 ], aTmp[ 76 ], aTmp[ 77 ], aTmp[ 78], aGet[ 77 ] ) )},,,,,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )},, .F., .F.,,,,,, nil,,, )





      aGet[ 77 ] := TGetHlp():ReDefine( 303, { | u | If( PCount()==0, aTmp[ 77 ], aTmp[ 77 ]:= u ) }, oFld:aDialogs[1],,, {||    ( lCalcDC( aTmp[ 75 ], aTmp[ 76 ], aTmp[ 77 ], aTmp[ 78 ], aGet[ 77 ] ) )},,,,,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )},, .F., .F.,,,,,, nil,,, )






      aGet[ 78 ] := TGetHlp():ReDefine( 304, { | u | If( PCount()==0, aTmp[ 78 ], aTmp[ 78 ]:= u ) }, oFld:aDialogs[1],, "9999999999", {||    ( lCalcDC( aTmp[ 75 ], aTmp[ 76 ], aTmp[ 77 ], aTmp[ 78 ], aGet[ 77 ] ) )},,,,,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )},, .F., .F.,,,,,, nil,,, )












      aGet[ 8 ] := TGetHlp():ReDefine( 165, { | u | If( PCount()==0, aTmp[ 8 ], aTmp[ 8 ]:= u ) }, oFld:aDialogs[1],,, {||    cCajas( aGet[ 8 ], dbfCajT, oGet[ 5 ] )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwCajas( aGet[ 8 ], oGet[ 5 ] ) )}, nil, "LUPA",, )





      oGet[ 5 ] := TGetHlp():ReDefine( 166, { | u | If( PCount()==0, cGet[ 5 ], cGet[ 5 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )












        aGet[ 35 ] := TGetHlp():ReDefine( 170, { | u | If( PCount()==0, aTmp[ 35 ], aTmp[ 35 ]:= u ) }, oFld:aDialogs[1],, "@!", {||    ( cDivIn( aGet[ 35 ], oBmpDiv, aGet[ 36 ], @cPinDiv, @nDinDiv, @cPirDiv, @nRinDiv, nil, dbfDiv, oBandera ) )},,,,,, .F., {||     ( nMode == 1 )},, .F., .F.,,,,, {|Self|BrwDiv( aGet[ 35 ], oBmpDiv, aGet[ 36 ], dbfDiv, oBandera )}, nil, "LUPA",, )




        oBmpDiv := TBitmap():ReDefine( 171, "BAN_EURO",, oFld:aDialogs[1],,, .F., .F.,,, .F.,,, .F. )





        aGet[ 36 ] := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, aTmp[ 36 ], aTmp[ 36 ]:= u ) }, oFld:aDialogs[1],, "@E 999,999.9999",,,,,,, .F., {||        ( .F. )},, .F., .F.,,,,,, nil,,, )








      oBmpEmp := TBitmap():ReDefine( 500,, "Bmp\ImgFacPrv.bmp", oDlg,,, .F., .F.,,, .F.,,, .F. )









      aControl[1] := TButton():ReDefine( 500, {||( AppDeta( oBrwLin, bEdtDet, aTmp) )}, oFld:aDialogs[1],,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )},,, .F. )





      aControl[2] := TButton():ReDefine( 501, {||( EdtDeta( oBrwLin, bEdtDet, aTmp ) )}, oFld:aDialogs[1],,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo )  )},,, .F. )





      aControl[3] := TButton():ReDefine( 502, {||( WinDelRec( oBrwLin, dbfTmp, {|| delDeta() }, {|| RecalculaTotal( aTmp ) } ) )}, oFld:aDialogs[1],,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )},,, .F. )




      aControl[4] := TButton():ReDefine( 503, {||( if( !( dbfTmp )->lControl, WinZooRec( oBrwLin, bEdtDet, dbfTmp, aTmp ), ) )}, oFld:aDialogs[1],,, .F.,,,, .F. )













      aControl[5] := TButton():ReDefine( 524, {||( DbSwapUp( dbfTmp, oBrwLin ) )}, oFld:aDialogs[1],,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )},,, .F. )





      aControl[6] := TButton():ReDefine( 525, {||( DbSwapDown( dbfTmp, oBrwLin ) )}, oFld:aDialogs[1],,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )},,, .F. )





      oBrwLin                 := IXBrowse():New( oFld:aDialogs[1] )

      oBrwLin:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwLin:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwLin:cAlias          := dbfTmp

      oBrwLin:nMarqueeStyle   := 6
      oBrwLin:cName           := "Lineas de facturas a proveedor"

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Número"
            :bEditValue       := {|| if( ( dbfTmp )->lKitChl, "", Trans( ( dbfTmp )->nNumLin, "9999" ) ) }
            :nWidth           := 65
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Código"
            :bEditValue       := {|| ( dbfTmp )->cRef }
            :nWidth           := 80
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "C. Barras"
            :bEditValue       := {|| cCodigoBarrasDefecto( ( dbfTmp )->cRef, dbfCodeBar ) }
            :nWidth           := 100
            :lHide            := .T.
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Código proveedor"
            :bEditValue       := {|| ( dbfTmp )->cRefPrv }
            :nWidth           := 80
            :lHide            := .T.
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Descripción"
            :bEditValue       := {|| if( Empty( ( dbfTmp )->cRef ) .AND. !( dbfTmp )->lControl, ( dbfTmp )->mLngDes, ( dbfTmp )->cDetalle ) }
            :nWidth           := 292
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Prop. 1"
            :bEditValue       := {|| ( dbfTmp )->cValPr1 }
            :nWidth           := 60
            :lHide            := .T.
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Prop. 2"
            :bEditValue       := {|| ( dbfTmp )->cValPr2 }
            :nWidth           := 60
            :lHide            := .T.
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Lote"
            :bEditValue       := {|| ( dbfTmp )->cLote }
            :nWidth           := 80
            :lHide            := .T.
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Caducidad"
            :bEditValue       := {|| Dtoc( ( dbfTmp )->dFecCad ) }
            :nWidth           := 60
            :lHide            := .T.
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := cNombreUnidades()
            :bEditValue       := {|| nTotNRctPrv( dbfTmp ) }
            :cEditPicture     := cPicUnd
            :nWidth           := 60
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "UM. Unidad de medición"
            :bEditValue       := {|| ( dbfTmp )->cUnidad }
            :nWidth           := 25
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Almacen"
            :bEditValue       := {|| ( dbfTmp )->cAlmLin }
            :nWidth           := 60
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Importe"
            :bEditValue       := {|| nTotURctPrv( dbfTmp, nDinDiv ) }
            :cEditPicture     := cPinDiv
            :nWidth           := 90
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "% Dto."
            :bEditValue       := {|| ( dbfTmp )->nDtoLin }
            :cEditPicture     := "@E 999.99"
            :nWidth           := 50
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "% Prm."
            :bEditValue       := {|| ( dbfTmp )->nDtoPrm }
            :cEditPicture     := "@E 999.99"
            :nWidth           := 40
            :lHide            := .T.
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "% " + cImp()
            :bEditValue       := {|| ( dbfTmp )->nIva }
            :cEditPicture     := "@E 999.99"
            :nWidth           := 50
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Total"
            :bEditValue       := {|| nTotLRctPrv( dbfTmp, nDinDiv, nRinDiv ) }
            :cEditPicture     := cPirDiv
            :nWidth           := 90
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         if nMode <> 3
            oBrwLin:bLDblClick   := {|| EdtDeta( oBrwLin, bEdtDet, aTmp ) }
         end

      oBrwLin:CreateFromResource( 190 )









      aGet[ 57 ] := TMultiGet():ReDefine( 290, { | u | If( PCount()==0, aTmp[ 57 ], aTmp[ 57 ]:= u ) }, oFld:aDialogs[1],, "N/W*",,,,, .F., {||     ( nMode <> 3 )}, .F.,, )











       aGet[ 58 ] := TGetHlp():ReDefine( 600, { | u | If( PCount()==0, aTmp[ 58 ], aTmp[ 58 ]:= u ) }, oFld:aDialogs[1],, cPirDiv, {||    ( oSayGas[11]:Refresh(), oSayGas[12]:Refresh(), .T. )},,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .F.,,,,,, nil,,, )








       aGet[ 61 ] := TGetHlp():ReDefine( 601, { | u | If( PCount()==0, aTmp[ 61 ], aTmp[ 61 ]:= u ) }, oFld:aDialogs[1],, "@ER 99.99%", {||    ( oSayGas[11]:Refresh(), oSayGas[12]:Refresh(), .T. )},,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )




      oSayGas[11] := TSay():ReDefine( 602, {|| Trans( aTmp[ 58 ] * aTmp[ 61 ] / 100, cPirDiv )}, oFld:aDialogs[1],, "N/W*",, .F.,, .F., .F. )








      aGet[ 64 ] := TGetHlp():ReDefine( 603, { | u | If( PCount()==0, aTmp[ 64 ], aTmp[ 64 ]:= u ) }, oFld:aDialogs[1],, "@ER 99.99%", {||    ( oSayGas[11]:Refresh(), oSayGas[12]:Refresh(), .T. )},,,,,, .F., {||     ( nMode <> 3 .AND. aTmp[ 32 ] )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )




      oSayGas[12] := TSay():ReDefine( 604, {|| Trans( aTmp[ 58 ] * aTmp[ 64 ] / 100, cPirDiv )}, oFld:aDialogs[1],, "N/W*",, .F.,, .F., .F. )











      aGet[ 59 ] := TGetHlp():ReDefine( 610, { | u | If( PCount()==0, aTmp[ 59 ], aTmp[ 59 ]:= u ) }, oFld:aDialogs[1],, cPirDiv, {||    ( oSayGas[13]:Refresh(), oSayGas[14]:Refresh(), .T. )},,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .F.,,,,,, nil,,, )








      aGet[ 62 ] := TGetHlp():ReDefine( 611, { | u | If( PCount()==0, aTmp[ 62 ], aTmp[ 62 ]:= u ) }, oFld:aDialogs[1],, "@ER 99.99%", {||    ( oSayGas[13]:Refresh(), oSayGas[14]:Refresh(), .T. )},,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )




      oSayGas[13] := TSay():ReDefine( 612, {|| Trans( aTmp[ 59 ] * aTmp[ 62 ] / 100, cPirDiv )}, oFld:aDialogs[1],, "N/W*",, .F.,, .F., .F. )








      aGet[ 65 ] := TGetHlp():ReDefine( 613, { | u | If( PCount()==0, aTmp[ 65 ], aTmp[ 65 ]:= u ) }, oFld:aDialogs[1],, "@ER 99.99%", {||    ( oSayGas[13]:Refresh(), oSayGas[14]:Refresh(), .T. )},,,,,, .F., {||     ( nMode <> 3 .AND. aTmp[ 32 ] )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )




      oSayGas[14] := TSay():ReDefine( 614, {|| Trans( aTmp[ 59 ] * aTmp[ 65 ] / 100, cPirDiv )}, oFld:aDialogs[1],, "N/W*",, .F.,, .F., .F. )











      aGet[ 60 ] := TGetHlp():ReDefine( 620, { | u | If( PCount()==0, aTmp[ 60 ], aTmp[ 60 ]:= u ) }, oFld:aDialogs[1],, cPirDiv, {||    ( oSayGas[15]:Refresh(), oSayGas[16]:Refresh(), .T. )},,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .F.,,,,,, nil,,, )








      aGet[ 63 ] := TGetHlp():ReDefine( 621, { | u | If( PCount()==0, aTmp[ 63 ], aTmp[ 63 ]:= u ) }, oFld:aDialogs[1],, "@ER 99.99%", {||    ( oSayGas[15]:Refresh(), oSayGas[16]:Refresh(), .T. )},,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )




      oSayGas[15] := TSay():ReDefine( 622, {|| Trans( aTmp[ 60 ] * aTmp[ 63 ] / 100, cPirDiv )}, oFld:aDialogs[1],, "N/W*",, .F.,, .F., .F. )








      aGet[ 66 ] := TGetHlp():ReDefine( 623, { | u | If( PCount()==0, aTmp[ 66 ], aTmp[ 66 ]:= u ) }, oFld:aDialogs[1],, "@ER 99.99%", {||    ( oSayGas[15]:Refresh(), oSayGas[16]:Refresh(), .T. )},,,,,, .F., {||     ( nMode <> 3 .AND. aTmp[ 32 ] )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )




      oSayGas[16] := TSay():ReDefine( 624, {|| Trans( aTmp[ 60 ] * aTmp[ 66 ] / 100, cPirDiv )}, oFld:aDialogs[1],, "N/W*",, .F.,, .F., .F. )









      aGet[ 28 ] := TGetHlp():ReDefine( 199, { | u | If( PCount()==0, aTmp[ 28 ], aTmp[ 28 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .F.,,,,,, nil,,, )







      aGet[ 29 ] := TGetHlp():ReDefine( 200, { | u | If( PCount()==0, aTmp[ 29 ], aTmp[ 29 ]:= u ) }, oFld:aDialogs[1],, "@E 99.99",,,,,,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )





      aGet[ 30 ] := TGetHlp():ReDefine( 209, { | u | If( PCount()==0, aTmp[ 30 ], aTmp[ 30 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .F.,,,,,, nil,,, )







        aGet[ 31 ] := TGetHlp():ReDefine( 210, { | u | If( PCount()==0, aTmp[ 31 ], aTmp[ 31 ]:= u ) }, oFld:aDialogs[1],, "@E 99.99",,,,,,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )






      aGet[ 38 ] := TGetHlp():ReDefine( 240, { | u | If( PCount()==0, aTmp[ 38 ], aTmp[ 38 ]:= u ) }, oFld:aDialogs[1],, "@!",, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )},, .F., .F.,,,,,, nil,,, )







      aGet[ 39 ] := TGetHlp():ReDefine( 250, { | u | If( PCount()==0, aTmp[ 39 ], aTmp[ 39 ]:= u ) }, oFld:aDialogs[1],, "@E 99.99",,,,,,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )





      aGet[ 40 ] := TGetHlp():ReDefine( 260, { | u | If( PCount()==0, aTmp[ 40 ], aTmp[ 40 ]:= u ) }, oFld:aDialogs[1],, "@!",,,,,,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )},, .F., .F.,,,,,, nil,,, )







      aGet[ 41 ] := TGetHlp():ReDefine( 270, { | u | If( PCount()==0, aTmp[ 41 ], aTmp[ 41 ]:= u ) }, oFld:aDialogs[1],, "@E 99.99",,,,,,, .F., {||     ( nMode <> 3 .AND. !lRecibosPagadosTmp( dbfTmpPgo ) )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )





      oBrwIva                        := TXBrowse():New( oFld:aDialogs[ 1 ] )

      oBrwIva:bClrSel                := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwIva:bClrSelFocus           := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwIva:SetArray( aTotIva )

      oBrwIva:lHScroll               := .F.
      oBrwIva:lVScroll               := .F.
      oBrwIva:nMarqueeStyle          := 5
      oBrwIva:lRecordSelector        := .F.

      oBrwIva:CreateFromResource( 490 )

      with object ( oBrwIva:aCols[ 1 ] )
         :cHeader       := "Bruto"
         :bStrData      := {|| if( !Empty( aTotIva[ oBrwIva:nArrayAt, 1 ] ), Trans( aTotIva[ oBrwIva:nArrayAt, 2 ], cPirDiv ), "" ) }
         :nWidth        := 80
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
         :nFootStrAlign := 1
      end

      with object ( oBrwIva:aCols[ 2 ] )
         :cHeader       := "Base"
         :bStrData      := {|| if( !Empty( aTotIva[ oBrwIva:nArrayAt, 2 ] ), Trans( aTotIva[ oBrwIva:nArrayAt, 2 ], cPirDiv ), "" ) }
         :nWidth        := 80
         :cEditPicture  := cPirDiv
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
         :nFootStrAlign := 1
      end

      with object ( oBrwIva:aCols[ 3 ] )
         :cHeader       := "%" + cImp()
         :bStrData      := {|| if( !IsNil( aTotIva[ oBrwIva:nArrayAt, 3 ] ), aTotIva[ oBrwIva:nArrayAt, 3 ], "" ) }
         :bEditValue    := {|| aTotIva[ oBrwIva:nArrayAt, 3 ] }
         :nWidth        := 45
         :cEditPicture  := "@E 999.99"
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
         :nFootStrAlign := 1
         :nEditType     := 1
         :bEditWhen     := {|| !IsNil( aTotIva[ oBrwIva:nArrayAt, 3 ] ) }
         :bOnPostEdit   := {|o,x| EdtIva( o, x, aTotIva[ oBrwIva:nArrayAt, 3 ], dbfTmp, dbfIva, oBrwLin ), RecalculaTotal( aTmp ) }
      end

      with object ( oBrwIva:aCols[ 4 ] )
         :cHeader       := "%R.E."
         :bStrData      := {|| if( !Empty( aTotIva[ oBrwIva:nArrayAt, 4 ] ) .AND. aTmp[ 32 ], Trans( aTotIva[ oBrwIva:nArrayAt, 4 ], "@E 99.9" ), "" ) }
         :nWidth        := 45
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
         :nFootStrAlign := 1
      end

      with object ( oBrwIva:aCols[ 5 ] )
         :cHeader       := cImp()
         :bStrData      := {|| if( !Empty( aTotIva[ oBrwIva:nArrayAt, 5 ] ), Trans( aTotIva[ oBrwIva:nArrayAt, 5 ], cPirDiv ), "" ) }
         :nWidth        := 80
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
         :nFootStrAlign := 1
      end

      with object ( oBrwIva:aCols[ 6 ] )
         :cHeader       := "R.E."
         :bStrData      := {|| if( !Empty( aTotIva[ oBrwIva:nArrayAt, 6 ] ) .AND. aTmp[ 32 ], Trans( aTotIva[ oBrwIva:nArrayAt, 6 ], cPirDiv ), "" ) }
         :nWidth        := 80
         :cEditPicture  := cPirDiv
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
      end








        oGetNet := TSay():ReDefine( 370, {|| nGetNeto}, oFld:aDialogs[1],,,, .F.,, .F., .F. )



        oGetIva := TSay():ReDefine( 380, {|| nGetIva}, oFld:aDialogs[1],,,, .F.,, .F., .F. )



        oGetReq := TSay():ReDefine( 390, {|| nGetReq}, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )





      aGet[ 32 ] := TCheckBox():ReDefine( 400, { | u | If( PCount()==0, aTmp[ 32 ], aTmp[ 32 ]:= u ) }, oFld:aDialogs[ 1 ],, {||( RecalculaTotal( aTmp ) )},,,,, .F., {||         ( nMode <> 3 )}, .F. )




      oGetTotal := TSay():ReDefine( 410, {|| nTotFac}, oFld:aDialogs[ 1 ],,,, .F., oFntTot, .F., .F. )

















      aGet[1] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[1], aTmp[1]:= u ) }, oFld:aDialogs[1],, "@!", {||    ( aTmp[1] >= "A" .AND. aTmp[1] <= "Z"  )}, "N/W*",,,,, .F., {||     ( nMode == 1 .OR. nMode == 4 )},, .F., .T., {||    ( UpSerie( aGet[1] ) )}, {||  ( DwSerie( aGet[1] ) )},,,, nil,,, )

         aGet[ 1 ]:bLostFocus := {|| aGet[ 42 ]:cText( cProCnt( aTmp[ 1 ] ) ) }





        aGet[2] := TGetHlp():ReDefine( 101, { | u | If( PCount()==0, aTmp[2], aTmp[2]:= u ) }, oFld:aDialogs[1],, "999999999",,,,,,, .F., {||        .F.},, .F., .F.,,,,,, nil,,, )




        aGet[3] := TGetHlp():ReDefine( 102, { | u | If( PCount()==0, aTmp[3], aTmp[3]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )






        aGet[5] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[5], aTmp[5]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





        aGet[18] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[18], aTmp[18]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )








      aGet[ 26 ] := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTmp[ 26 ], aTmp[ 26 ]:= u ) }, oFld:aDialogs[1],, "@R A/#########/##", {||    ( cFacPrv( aGet, oBrwLin, nMode, aTmp ), RecalculaTotal( aTmp ) )},,,,,, .F., {||     ( nMode == 1 )},, .F., .F.,,,,, {|Self|( brwFacPrv( aGet[ 26 ], dbfFacPrvT, dbfFacPrvL, dbfIva, dbfDiv ) )}, nil, "LUPA",, )






      aGet[ 56 ] := TCheckBox():ReDefine( 550, { | u | If( PCount()==0, aTmp[ 56 ], aTmp[ 56 ]:= u ) }, oFld:aDialogs[1],, {||( ShowKitRctPrv( dbfRctPrvT, oBrwLin, cCodPrv, nil, aGet, aTmp, aControl, oSayGas, oSayLabels, oBrwIva ), RecalculaTotal( aTmp ), .T. )},,,,, .F., {||     ( nMode == 1 )}, .F. )







      aGet[ 50 ] := TComboBox():ReDefine( 440, { | u | If( PCount()==0, aTmp[ 50 ], aTmp[ 50 ]:= u ) }, { "Ret. S/Base", "Ret. S/Total" }, oFld:aDialogs[ 1 ],, {||    ( RecalculaTotal( aTmp ) )}, {|Self|( RecalculaTotal( aTmp ) )},,,, .F., {||     ( nMode <> 3 )},,,,, )








      aGet[ 51 ] := TGetHlp():ReDefine( 450, { | u | If( PCount()==0, aTmp[ 51 ], aTmp[ 51 ]:= u ) }, oFld:aDialogs[ 1 ],, "@E 99.9", {||    ( RecalculaTotal( aTmp ) )},,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )



      oGetRet := TSay():ReDefine( 491, {|| cGetRet}, oFld:aDialogs[1],,,, .F.,, .F., .F. )

      oSayLabels[ 1 ] := TGroup():ReDefine( 700,, oFld:aDialogs[ 1 ],,,, .T. )
      oSayLabels[ 2 ] := TSay():ReDefine( 701,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 3 ] := TSay():ReDefine( 702,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 4 ] := TSay():ReDefine( 703,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 5 ] := TSay():ReDefine( 704,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 6 ] := TSay():ReDefine( 705,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 7 ] := TSay():ReDefine( 706,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )

      oSayGas[ 1 ] := TSay():ReDefine( 707,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayGas[ 2 ] := TSay():ReDefine( 708,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayGas[ 3 ] := TSay():ReDefine( 709,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayGas[ 4 ] := TSay():ReDefine( 710,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayGas[ 5 ] := TSay():ReDefine( 711,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayGas[ 6 ] := TSay():ReDefine( 712,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayGas[ 7 ] := TSay():ReDefine( 713,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayGas[ 8 ] := TSay():ReDefine( 714,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayGas[ 9 ] := TSay():ReDefine( 715,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayGas[ 10] := TSay():ReDefine( 716,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )










      aGet[ 67 ] := TComboBox():ReDefine( 100, { | u | If( PCount()==0, aTmp[ 67 ], aTmp[ 67 ]:= u ) }, {       "01. Número factura", "02. Serie factura", "03. Fecha expedición", "04. Nombre y apellidos / Razón social del emisor", "05. Nombre y apellidos / Razón social del receptor", "06. Identificación fiscal del emisor obligatoria", "07. Identificación fiscal del receptor", "08. Domicilio emisor obligatorio", "09. Domicilio receptor", "10. Detalle operación", "11. Porcentaje impositivo a aplicar", "12. Cuota tributaria a aplicar", "13. Fecha / Periodo a aplicar", "14. Clase de factura", "15. Literales legales", "16. Base imponible", "80. Cálculo de cuotas repercutidas", "81. Cálculo de cuotas retenidas", "82. Base imponible modificada por devolución de envases / embalajes", "83. Base imponible modificada por descuentos y bonificaciones", "84. Base imponible modificada por resolución firme, judicial o administrativa", "85. Base imponible modificada cuotas repercutidas no satisfechas. Auto de declaración de concurso" }, oFld:aDialogs[ 2 ],,,,,,, .F., {||     ( nMode <> 3 )},,,,, )





      aGet[ 68 ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ 68 ], aTmp[ 68 ]:= u ) }, oFld:aDialogs[ 2 ],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





      aGet[ 17 ] := TGetHlp():ReDefine( 131, { | u | If( PCount()==0, aTmp[ 17 ], aTmp[ 17 ]:= u ) }, oFld:aDialogs[ 2 ],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )




      aGet[ 45 ] := TGetHlp():ReDefine( 142, { | u | If( PCount()==0, aTmp[ 45 ], aTmp[ 45 ]:= u ) }, oFld:aDialogs[ 2 ],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )








      aGet[ 55 ] := TRadMenu():Redefine( { | u | If( PCount()==0, aTmp[ 55 ], aTmp[ 55 ]:= u ) }, oFld:aDialogs[2],, { 270, 271, 272, 273 },,,,, .F., {||     ( .F. )}, )




      aGet[ 54 ] := TGetHlp():ReDefine( 300, { | u | If( PCount()==0, aTmp[ 54 ], aTmp[ 54 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )




      oGet[ 6 ] := TGetHlp():ReDefine( 301, { | u | If( PCount()==0, cGet[ 6 ], cGet[ 6 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )










      aGet[ 42 ] := TGetHlp():ReDefine( 170, { | u | If( PCount()==0, aTmp[ 42 ], aTmp[ 42 ]:= u ) }, oFld:aDialogs[2],, "@R ###.######", {||    ( ChkProyecto( aTmp[ 42 ], oGet[ 4 ] ), .T. )}, "N/W*",,,,, .F., {||     ( nLenCuentaContaplus() <> 0 .AND. nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwProyecto( aGet[ 42 ], oGet[ 4 ] ) )}, nil, "LUPA",, )





      oGet[ 4 ] := TGetHlp():ReDefine( 171, { | u | If( PCount()==0, cGet[ 4 ], cGet[ 4 ]:= u ) }, oFld:aDialogs[2],,,, "N/W*",,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )






      aGet[ 24 ] := TGetHlp():ReDefine( 132, { | u | If( PCount()==0, aTmp[ 24 ], aTmp[ 24 ]:= u ) }, oFld:aDialogs[2],, "999999",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )










      aGet[20] := TMultiGet():ReDefine( 210, { | u | If( PCount()==0, aTmp[20], aTmp[20]:= u ) }, oFld:aDialogs[2],, "N/W*",,,,, .F., {||         ( nMode <> 3 )}, .F.,, )





      oBrwPgo                 := IXBrowse():New( oFld:aDialogs[2] )

      oBrwPgo:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwPgo:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwPgo:cAlias          := dbfTmpPgo

      oBrwPgo:nMarqueeStyle   := 5
      oBrwPgo:cName           := "Pagos de facturas rectifiactivas de proveedor"

         with object ( oBrwPgo:AddCol() )
            :cHeader          := "Pg. Pagado"
            :bStrData         := {|| "" }
            :bBmpData         := {|| nEstadoRecibo( dbfTmpPgo ) }
            :nWidth           := 22
            :AddResource( "Cnt16" )
            :AddResource( "Sel16" )
            :AddResource( "UndoRed16" )
         end

         with object ( oBrwPgo:AddCol() )
            :cHeader          := "Cn. Contabilizado"
            :bStrData         := {|| "" }
            :bEditValue       := {|| ( dbfTmpPgo )->lConPgo }
            :nWidth           := 22
            :SetCheck( { "Sel16", "Nil16" } )
         end

         with object ( oBrwPgo:AddCol() )
            :cHeader          := "Sesión"
            :bEditValue       := {|| Trans( ( dbfTmpPgo )->cTurRec, "######" ) }
            :nWidth           := 40
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwPgo:AddCol() )
            :cHeader          := "Fecha"
            :bEditValue       := {|| Dtoc( ( dbfTmpPgo )->dPreCob ) }
            :nWidth           := 75
         end

         with object ( oBrwPgo:AddCol() )
            :cHeader          := "Vencimiento"
            :bEditValue       := {|| Dtoc( ( dbfTmpPgo )->dFecVto ) }
            :lHide            := .T.
            :nWidth           := 70
         end

         with object ( oBrwPgo:AddCol() )
            :cHeader          := "Cobro"
            :bEditValue       := {|| Dtoc( ( dbfTmpPgo )->dEntrada ) }
            :nWidth           := 75
         end

         with object ( oBrwPgo:AddCol() )
            :cHeader          := "Descripción"
            :bEditValue       := {|| ( dbfTmpPgo )->cDescrip }
            :nWidth           := 175
         end

         with object ( oBrwPgo:AddCol() )
            :cHeader          := "Importe"
            :bEditValue       := {|| nTotRecPrv( dbfTmpPgo, dbfDiv, nil, .T. ) }
            :nWidth           := 85
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwPgo:AddCol() )
            :cHeader          := "Divisa"
            :bEditValue       := {|| cSimDiv( ( dbfTmpPgo )->cDivPgo, dbfDiv ) }
            :nWidth           := 60
         end

         if nMode <> 3
            oBrwPgo:bLDblClick   := {|| ExtEdtRecPrv( dbfTmpPgo, dbfFacPrvT, dbfFacPrvL, dbfFPago, dbfIva, dbfDiv, oBanco, oBandera ), oBrwPgo:Refresh(), RecalculaTotal( aTmp ) }
         end

      oBrwPgo:CreateFromResource( 220 )





      TButton():ReDefine( 501, {||( ExtEdtRecPrv( dbfTmpPgo, dbfFacPrvT, dbfFacPrvL, dbfFPago, dbfIva, dbfDiv, oBanco, oBandera ), oBrwPgo:Refresh(), RecalculaTotal( aTmp ) )}, oFld:aDialogs[2],,, .F., {||         ( nMode == 2 )},,, .F. )





        TButton():ReDefine( 502, {||( ExtDelRecPrv( dbfTmpPgo ), oBrwPgo:Refresh(), RecalculaTotal( aTmp ) )}, oFld:aDialogs[2],,, .F., {||         ( nMode == 2 )},,, .F. )





      TButton():ReDefine( 505, {||( PrnRecPrv( ( dbfTmpPgo )->cSerFac + Str( ( dbfTmpPgo )->nNumFac ) + ( dbfTmpPgo )->cSufFac + Str( ( dbfTmpPgo )->nNumRec ), .F. ) )}, oFld:aDialogs[2],,, .F., {||     ( nMode == 2 )},,, .F. )





      TButton():ReDefine( 506, {||( VisRecPrv( ( dbfTmpPgo )->cSerFac + Str( ( dbfTmpPgo )->nNumFac ) + ( dbfTmpPgo )->cSufFac + Str( ( dbfTmpPgo )->nNumRec ), .F. ) )}, oFld:aDialogs[2],,, .F., {||     ( nMode == 2 )},,, .F. )



      oGetTotPg := TSay():ReDefine( 405, {|| nTotFac}, oFld:aDialogs[2],,,, .F.,, .F., .F. )



        oGetPgd := TSay():ReDefine( 400, {|| nGetPgd}, oFld:aDialogs[2],,,, .F.,, .F., .F. )



      oGetPdt := TSay():ReDefine( 410, {|| ( nTotFac - nGetPgd )}, oFld:aDialogs[2],,,, .F.,, .F., .F. )






      aGet[ 47 ] := TCheckBox():ReDefine( 120, { | u | If( PCount()==0, aTmp[ 47 ], aTmp[ 47 ]:= u ) }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )}, .F. )




      aGet[ 48 ] := TGetHlp():ReDefine( 121, { | u | If( PCount()==0, aTmp[ 48 ], aTmp[ 48 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )},, .F., .F.,,,,,, nil,,, )




      aGet[ 49 ] := TGetHlp():ReDefine( 122, { | u | If( PCount()==0, aTmp[ 49 ], aTmp[ 49 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )},, .F., .F.,,,,,, nil,,, )





      oBrwInc                 := IXBrowse():New( oFld:aDialogs[ 3 ] )

      oBrwInc:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwInc:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwInc:cAlias          := dbfTmpInc

      oBrwInc:nMarqueeStyle   := 5
      oBrwInc:cName           := "Incidencias de facturas rectificativas de proveedor"

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Resuelta"
            :bStrData         := {|| "" }
            :bEditValue       := {|| ( dbfTmpInc )->lListo }
            :nWidth           := 60
            :SetCheck( { "Sel16", "Cnt16" } )
         end

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Código"
            :bEditValue       := {|| ( dbfTmpInc )->cCodTip }
            :nWidth           := 80
         end

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Incidencia"
            :bEditValue       := {|| cNomInci( ( dbfTmpInc )->cCodTip, dbfInci ) }
            :nWidth           := 220
         end

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Fecha"
            :bEditValue       := {|| Dtoc( ( dbfTmpInc )->dFecInc ) }
            :nWidth           := 90
         end

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Descripción"
            :bEditValue       := {|| ( dbfTmpInc )->mDesInc }
            :nWidth           := 425
         end

         if nMode <> 3
            oBrwInc:bLDblClick   := {|| WinEdtRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) }
         end

         oBrwInc:CreateFromResource( 210 )





      TButton():ReDefine( 500, {||( WinAppRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) )}, oFld:aDialogs[ 3 ],,, .F., {||         ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 501, {||( WinEdtRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) )}, oFld:aDialogs[ 3 ],,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 502, {||( DbDelRec( oBrwInc, dbfTmpInc, nil, nil, .T. ) )}, oFld:aDialogs[ 3 ],,, .F., {||         ( nMode <> 3 )},,, .F. )




        TButton():ReDefine( 503, {||( WinZooRec( oBrwInc, bEdtInc, dbfTmpInc ) )}, oFld:aDialogs[ 3 ],,, .F.,,,, .F. )





      oBrwDoc                 := TXBrowse():New( oFld:aDialogs[ 4 ] )

      oBrwDoc:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwDoc:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwDoc:cAlias          := dbfTmpDoc

      oBrwDoc:nMarqueeStyle   := 5
      oBrwDoc:nRowHeight      := 40
      oBrwDoc:nDataLines      := 2

         with object ( oBrwDoc:AddCol() )
            :cHeader          := "Documento"
            :bEditValue       := {|| Rtrim( ( dbfTmpDoc )->cNombre ) + Chr(13)+Chr(10) + Space( 5 ) + Rtrim( ( dbfTmpDoc )->cRuta ) }
            :nWidth           := 885
         end

         if nMode <> 3
            oBrwDoc:bLDblClick   := {|| ShellExecute( oDlg:hWnd, "open", Rtrim( ( dbfTmpDoc )->cRuta ) ) }
         end

         oBrwDoc:CreateFromResource( 210 )





      TButton():ReDefine( 500, {||( WinAppRec( oBrwDoc, bEdtDoc, dbfTmpDoc, nil, nil, aTmp ) )}, oFld:aDialogs[ 4 ],,, .F., {||         ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 501, {||( WinEdtRec( oBrwDoc, bEdtDoc, dbfTmpDoc, nil, nil, aTmp ) )}, oFld:aDialogs[ 4 ],,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 502, {||( DbDelRec( oBrwDoc, dbfTmpDoc, nil, nil, .F. ) )}, oFld:aDialogs[ 4 ],,, .F., {||         ( nMode <> 3 )},,, .F. )




        TButton():ReDefine( 503, {||( WinZooRec( oBrwDoc, bEdtDoc, dbfTmpDoc ) )}, oFld:aDialogs[ 4 ],,, .F.,,,, .F. )




      TButton():ReDefine( 504, {||( ShellExecute( oDlg:hWnd, "open", rTrim( ( dbfTmpDoc )->cRuta ) ) )}, oFld:aDialogs[ 4 ],,, .F.,,,, .F. )





     TButton():ReDefine( 10, {||( RecalculaFacturaRectificativas( aTmp, oDlg ), ( oBrwLin:Refresh() ), RecalculaTotal( aTmp ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      oBtnOk := TButton():ReDefine( 1, {||( EndTrans( aTmp, aGet, oBrw, oBrwLin, nMode, nDinDiv, oDlg, oFld ) )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 3, {||( if( EndTrans( aTmp, aGet, oBrw, oBrwLin, nMode, nDinDiv, oDlg, oFld ), GenRctPrv( 1 ), ) )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( If( ExitNoSave( nMode, dbfTmp ), ( oDlg:end() ), ) )}, oDlg,,, .F.,,,, .T. )

   if nMode <> 3
      oFld:aDialogs[1]:AddFastKey( 113, {|| AppDeta( oBrwLin, bEdtDet, aTmp) } )
      oFld:aDialogs[1]:AddFastKey( 114, {|| EdtDeta( oBrwLin, bEdtDet, aTmp ) } )
      oFld:aDialogs[1]:AddFastKey( 115, {|| WinDelRec( oBrwLin, dbfTmp, {|| delDeta() }, {|| RecalculaTotal( aTmp ) } ) } )

      oFld:aDialogs[2]:AddFastKey( 114, {|| ExtEdtRecPrv( dbfTmpPgo, dbfFacPrvT, dbfFacPrvL, dbfFPago, dbfIva, dbfDiv, oBanco, oBandera ), oBrwPgo:Refresh(), RecalculaTotal( aTmp ) } )
      oFld:aDialogs[2]:AddFastKey( 115, {|| ExtDelRecPrv( dbfTmpPgo ), oBrwPgo:Refresh(), RecalculaTotal( aTmp ) } )

      oFld:aDialogs[3]:AddFastKey( 113, {|| WinAppRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) } )
      oFld:aDialogs[3]:AddFastKey( 114, {|| WinEdtRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) } )
      oFld:aDialogs[3]:AddFastKey( 115, {|| DbDelRec( oBrwInc, dbfTmpInc, nil, nil, .T. ) } )

      oFld:aDialogs[4]:AddFastKey( 113, {|| WinAppRec( oBrwDoc, bEdtDoc, dbfTmpDoc, nil, nil, aTmp ) } )
      oFld:aDialogs[4]:AddFastKey( 114, {|| WinEdtRec( oBrwDoc, bEdtDoc, dbfTmpDoc, nil, nil, aTmp ) } )
      oFld:aDialogs[4]:AddFastKey( 115, {|| DbDelRec( oBrwDoc, dbfTmpDoc, nil, nil, .F. ) } )

      oDlg:AddFastKey( 116,             {|| EndTrans( aTmp, aGet, oBrw, oBrwLin, nMode, nDinDiv, oDlg, oFld ) } )
      oDlg:AddFastKey( 117,             {|| if( EndTrans( aTmp, aGet, oBrw, oBrwLin, nMode, nDinDiv, oDlg, oFld ), GenRctPrv( 1 ), ) } )
      oDlg:AddFastKey( 65,                {|| if( GetKeyState( 17 ), CreateInfoArticulo(), ) } )
   end

   oDlg:AddFastKey ( 112, {|| GoHelp() } )

   do case
      case nMode == 1 .AND. lRecogerUsuario() .AND. Empty( cCodArt )
         oDlg:bStart := {|| if( lGetUsuario( aGet[ 46 ], dbfUsr ), , oDlg:end() ) }

      case nMode == 1 .AND. lRecogerUsuario() .AND. !Empty( cCodArt )
         oDlg:bStart := {|| if( lGetUsuario( aGet[ 46 ], dbfUsr ), AppDeta( oBrwLin, bEdtDet, aTmp, cCodArt ), oDlg:end() ) }

      case nMode == 1 .AND. !lRecogerUsuario() .AND. !Empty( cCodArt )
         oDlg:bStart := {|| AppDeta( oBrwLin, bEdtDet, aTmp, cCodArt ) }

   end









    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted := {|hDC,cPS|(  RecalculaTotal( aTmp ) )}, .T.,,, {|Self|(  if( !Empty( cNumFac ), aGet[ 26 ]:lValid(), ), EdtRecMenu( aTmp, oDlg ), ShowKitRctPrv( dbfRctPrvT, oBrwLin, cCodPrv, dbfTmpInc, aGet, aTmp, aControl, oSayGas, oSayLabels, oBrwIva ), oBrwLin:Load(), oBrwPgo:Load(), oBrwInc:Load() )}, oDlg:bRClicked,,, )

   oBmpEmp:End()
   oBmpGeneral:End()

   ( dbfRctPrvT )->( OrdSetFocus( nOrd ) )





   ChkLqdRctPrv( nil, dbfRctPrvT, dbfRctPrvL, dbfRctPrvP, dbfIva, dbfDiv )





   KillTrans( oBrwLin )

RETURN ( oDlg:nResult == 1 )



Static Function RecalculaFacturaRectificativas( aTmp, oDlg )

   local nRecNum
   local nPreCom




   if !ApoloMsgNoYes( "¡Atención!,"                                      + Chr(13)+Chr(10) +  "todos los precios se recalcularán en función de"  + Chr(13)+Chr(10) +  "los valores en las bases de datos.", "¿ Desea proceder ?" )
      return nil
   end

   oDlg:Disable()

   ( dbfArticulo )->( ordSetFocus( "Codigo" ) )

   nRecNum                          := ( dbfTmp )->( RecNo() )

   ( dbfTmp )->( dbGotop() )
   while !( dbfTmp )->( eof() )





      nPreCom                       := nComPro( ( dbfTmp )->cRef, ( dbfTmp )->cCodPr1, ( dbfTmp )->cValPr1, ( dbfTmp )->cCodPr2, ( dbfTmp )->cValPr2, dbfArtCom )

      if nPrecom  <> 0

         ( dbfTmp )->nPreUnit       := nPreCom

      else

         if uFieldEmpresa( "lCosPrv", .F. )
            nPreCom                 := nPreArtPrv( aTmp[ 6 ], ( dbfTmp )->cRef, dbfArtPrv )
         end

         if nPreCom <> 0
            ( dbfTmp )->nPreUnit    := nPreCom
         else

            ( dbfTmp )->nPreUnit    := nCosto( ( dbfTmp )->cRef, dbfArticulo, dbfKit, .F., aTmp[ 35 ], dbfDiv )
         end

      end

      ( dbfTmp )->( dbSkip() )

   end

   ( dbfTmp )->( dbGoTo( nRecNum ) )

   oDlg:Enable()

return nil



Static Function EdtPgo( aTmp, aGet, dbfTmpPgo, oBrw, dbfDiv, oBandera, nMode, aTmpFac )

    local oDlg
   local oGetPrv
   local cGetPrv        := RetProvee( aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODPRV" ) ) ], dbfPrv )
   local oSay
   local cSay           := Num2Text( aTmp[ ( dbfTmpPgo )->( FieldPos( "NIMPORTE" ) ) ] )
   local oBmpDiv
   local oGetSubCta
   local cGetSubCta
   local cPirDiv        := cPirDiv( aTmp[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ], dbfDiv )
   local nDinDiv        := nRinDiv( aTmp[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ], dbfDiv )
   local nImpOld        := Abs( aTmp[ ( dbfTmpPgo )->( FieldPos( "NIMPORTE" ) ) ] )

   if Empty( aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODCAJ" ) ) ] )
      aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODCAJ" ) ) ]   := oUser():cCaja()
   end

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "recibos de proveedores", "PGO_PRV",, .F.,,,,,, .F.,,,,,, .F., )








      aGet[ ( dbfTmpPgo )->( FieldPos( "DPRECOB" ) ) ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "DPRECOB" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "DPRECOB" ) ) ]:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,, {|Self|aGet[ ( dbfTmpPgo )->( FieldPos( "DPRECOB" ) ) ]:cText( Calendario( aTmp[ ( dbfTmpPgo )->( FieldPos( "DPRECOB" ) ) ] ) )}, nil,,, )








      aGet[ ( dbfTmpPgo )->( FieldPos( "DFECVTO" ) ) ] := TGetHlp():ReDefine( 250, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "DFECVTO" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "DFECVTO" ) ) ]:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,, {|Self|aGet[ ( dbfTmpPgo )->( FieldPos( "DFECVTO" ) ) ]:cText( Calendario( aTmp[ ( dbfTmpPgo )->( FieldPos( "DFECVTO" ) ) ] ) )}, nil,,, )








      aGet[ ( dbfTmpPgo )->( FieldPos( "DENTRADA" ) ) ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "DENTRADA" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "DENTRADA" ) ) ]:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,, {|Self|aGet[ ( dbfTmpPgo )->( FieldPos( "DENTRADA" ) ) ]:cText( Calendario( aTmp[ ( dbfTmpPgo )->( FieldPos( "DENTRADA" ) ) ] ) )}, nil,,, )





      aGet[ ( dbfTmpPgo )->( FieldPos( "CCODPRV" ) ) ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODPRV" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODPRV" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )




      oGetPrv := TGetHlp():ReDefine( 121, { | u | If( PCount()==0, cGetPrv, cGetPrv:= u ) }, oDlg,,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )










      aGet[ ( dbfTmpPgo )->( FieldPos( "CCODPGO" ) ) ] := TGetHlp():ReDefine( 310, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODPGO" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODPGO" ) ) ]:= u ) }, oDlg,, "@!", {||    ( cFPago( aGet[ ( dbfTmpPgo )->( FieldPos( "CCODPGO" ) ) ], dbfFPago, aGet[ ( dbfTmpPgo )->( FieldPos( "CCODPGO" ) ) ]:oHelpText ) )},,,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwFPago( aGet[ ( dbfTmpPgo )->( FieldPos( "CCODPGO" ) ) ], aGet[ ( dbfTmpPgo )->( FieldPos( "CCODPGO" ) ) ]:oHelpText ) )}, nil, "LUPA",, 311 )









      aGet[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ] := TGetHlp():ReDefine( 320, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ]:= u ) }, oDlg,,, {||    ( oBanco:Existe( aGet[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ], aGet[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ]:oHelpText, "cNomBnc", .T., .T., "0" ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oBanco:Buscar( aGet[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ] ) )}, nil, "LUPA",, 321 )






      aGet[ ( dbfTmpPgo )->( FieldPos( "CDESCRIP" ) ) ] := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CDESCRIP" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CDESCRIP" ) ) ]:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      aGet[ ( dbfTmpPgo )->( FieldPos( "CPGDOPOR" ) ) ] := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CPGDOPOR" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CPGDOPOR" ) ) ]:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )








      aGet[ ( dbfTmpPgo )->( FieldPos( "NIMPORTE" ) ) ] := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "NIMPORTE" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "NIMPORTE" ) ) ]:= u ) }, oDlg,, ( cPirDiv ), {||    ( oSay:SetText( Num2Text( aTmp[ ( dbfTmpPgo )->( FieldPos( "NIMPORTE" ) ) ] ) ), .T. )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ ( dbfTmpPgo )->( FieldPos( "LRECIMP" ) ) ] := TCheckBox():ReDefine( 160, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "LRECIMP" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "LRECIMP" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||         ( nMode <> 3 )}, .F. )










      aGet[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ] := TGetHlp():ReDefine( 170, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ]:= u ) }, oDlg,, "@!", {||    ( cDivOut( aGet[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ], oBmpDiv, aGet[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ], @cPirDiv, @nDinDiv, nil, nil, nil, nil, nil, dbfDiv, oBandera ) )}, "N/W*",,,,, .F., {||     ( .F. )},, .F., .F.,,,,, {|Self|BrwDiv( aGet[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ], oBmpDiv, aGet[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ], dbfDiv, oBandera )}, nil, "LUPA",, )



        oBmpDiv := TBitmap():ReDefine( 171,,, oDlg,,, .F., .F.,,, .F.,,, .F. )








      aGet[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ] := TGetHlp():ReDefine( 172, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ]:= u ) }, oDlg,, "@E 999,999.9999", {||    ( aTmp[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ] > 0 )}, "N/W*",,,,, .F., {||        ( .F. )},, .F., .F.,,,,,, nil,,, )






      aGet[ ( dbfTmpPgo )->( FieldPos( "LCOBRADO" ) ) ] := TCheckBox():ReDefine( 220, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "LCOBRADO" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "LCOBRADO" ) ) ]:= u ) }, oDlg,, {||( aGet[ ( dbfTmpPgo )->( FieldPos( "DENTRADA" ) ) ]:cText( if( aTmp[ ( dbfTmpPgo )->( FieldPos( "LCOBRADO" ) ) ], date(), ctod("") ) ) )},,,,, .F., {||         ( nMode <> 3 )}, .F. )





      aGet[ ( dbfTmpPgo )->( FieldPos( "LNOTARQUEO" ) ) ] := TCheckBox():ReDefine( 330, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "LNOTARQUEO" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "LNOTARQUEO" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||         ( nMode <> 3 )}, .F. )




      oSay := TSay():ReDefine( 190, {|| cSay}, oDlg,, "N/W*",, .F.,, .F., .F. )










      aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ] := TGetHlp():ReDefine( 240, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ]:= u ) }, oDlg,, ( Replicate( "X", nLenSubcuentaContaplus() ) ), {||    ( MkSubCta( aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ], { aTmp[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ] }, oGetSubCta ) )}, "N/W*",,,,, .F., {||     ( nLenCuentaContaplus() <> 0 .AND. nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwChkSubCta( aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ], oGetSubCta ) )}, nil, "LUPA",, )





        oGetSubCta := TGetHlp():ReDefine( 241, { | u | If( PCount()==0, cGetSubCta, cGetSubCta:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )









      TButton():ReDefine( 1, {||( EndPgo( nImpOld, aTmp, aGet, dbfTmpPgo, oBrw, nMode, oDlg ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )




      TButton():ReDefine( 998, {||( GoHelp() )}, oDlg,,, .F.,,,, .F. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| EndPgo( nImpOld, aTmp, aGet, dbfTmpPgo, oBrw, nMode, oDlg ) } )
   end

   oDlg:AddFastKey( 112, {|| GoHelp() } )




   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( EdtRecPgoMenu( aTmp, aGet, oDlg ), aGet[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ]:lValid(), aGet[ ( dbfTmpPgo )->( FieldPos( "CCODPGO" ) ) ]:lValid() )}, oDlg:bRClicked,,, )

   oMnuPgo:End()
   oBmpDiv:End()

RETURN ( oDlg:nResult == 1 )



Static Function EdtRecPgoMenu( aTmp, aGet, oDlg )

   local cCodPrv  := aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODPRV" ) ) ]

   oMnuPgo := MenuBegin( .F.,,, .F., .F. )

      MenuAddItem( "&1. Rotor",, .F.,,,,,,,,, .F.,,, .F. )

         MenuBegin( .F.,,, .F., .F. )




            MenuAddItem( "&1. Modificar proveedor", "Modifica el proveedor de la factura rectificativa", .F.,, {|oMenuItem|( EdtPrv( cCodPrv ) )},, "Businessman_16",,,,, .F.,,, .F. )




            MenuAddItem( "&2. Informe proveedor", "Informe del proveedor de la factura", .F.,, {|oMenuItem|( InfProveedor( cCodPrv ) )},, "Info16",,,,, .F.,,, .F. )

         MenuEnd()

   MenuEnd()

   oDlg:SetMenu( oMnuPgo )

   aGet[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ]:lValid()
   aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ]:lValid()

   aGet[ ( dbfTmpPgo )->( FieldPos( "DPRECOB" ) ) ]:SetFocus()

Return ( oMnuPgo )



Static Function EndPgo( nImpOld, aTmp, aGet, dbfTmpPgo, oBrw, nMode, oDlg )

   local nCon
   local nImp
   local nRec        := ( dbfTmpPgo )->( Recno() )
   local lImpNeg     := aTmp[ ( dbfTmpPgo )->( FieldPos( "nImporte" ) ) ] < 0
   local nImpAct     := Abs( aTmp[ ( dbfTmpPgo )->( FieldPos( "nImporte" ) ) ] )

   if nImpAct > nImpOld
      msgStop( "El importe no puede ser superior al actual." )
      return nil
   end

   aTmp[ ( dbfTmpPgo )->( FieldPos( "DFECCHG" ) ) ]  := GetSysDate()
   aTmp[ ( dbfTmpPgo )->( FieldPos( "CTIMCHG" ) ) ]  := Time()





   if nImpAct <> nImpOld





      nImp                       := ( nImpOld - nImpAct ) * if( lImpNeg, - 1 , 1 )





      ( dbfTmpPgo )->( dbAppend() )

      nCon                       := ( dbfTmpPgo )->( LastRec() )


      ( dbfTmpPgo )->cTurRec     := cCurSesion()


      ( dbfTmpPgo )->cSerFac     := aTmp[ ( dbfTmpPgo )->( FieldPos( "cSerFac"  ) ) ]
      ( dbfTmpPgo )->nNumFac     := aTmp[ ( dbfTmpPgo )->( FieldPos( "nNumFac" ) ) ]
      ( dbfTmpPgo )->cSufFac     := aTmp[ ( dbfTmpPgo )->( FieldPos( "cSufFac" ) ) ]
      ( dbfTmpPgo )->nNumRec     := nCon
      ( dbfTmpPgo )->cTipRec     := "R"
      ( dbfTmpPgo )->cCodCaj     := aTmp[ ( dbfTmpPgo )->( FieldPos( "cCodCaj" ) ) ]
      ( dbfTmpPgo )->cCodPrv     := aTmp[ ( dbfTmpPgo )->( FieldPos( "cCodPrv" ) ) ]
      ( dbfTmpPgo )->dEntrada    := Ctod( "" )
      ( dbfTmpPgo )->nImporte    := nImp
      ( dbfTmpPgo )->cDescrip    := "Recibo nº" + AllTrim( Str( nCon ) ) + " de factura rectificativa " + aTmp[ ( dbfTmpPgo )->( FieldPos( "cSerFac" ) ) ] + "/" + AllTrim( Str( aTmp[ ( dbfTmpPgo )->( FieldPos( "nNumFac" ) ) ] ) ) + "/" + aTmp[ ( dbfTmpPgo )->( FieldPos( "cSufFac" ) ) ]
      ( dbfTmpPgo )->dPreCob     := dFecRctPrv( aTmp[ ( dbfTmpPgo )->( FieldPos( "cSerFac" ) ) ] + Str( aTmp[ ( dbfTmpPgo )->( FieldPos( "nNumFac" ) ) ] ) + aTmp[ ( dbfTmpPgo )->( FieldPos( "cSufFac" ) ) ], dbfRctPrvT )
      ( dbfTmpPgo )->dFecVto     := dFecRctPrv( aTmp[ ( dbfTmpPgo )->( FieldPos( "cSerFac" ) ) ] + Str( aTmp[ ( dbfTmpPgo )->( FieldPos( "nNumFac" ) ) ] ) + aTmp[ ( dbfTmpPgo )->( FieldPos( "cSufFac" ) ) ], dbfRctPrvT )
      ( dbfTmpPgo )->cPgdoPor    := ""
      ( dbfTmpPgo )->lCobrado    := .F.
      ( dbfTmpPgo )->cDivPgo     := aTmp[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ]
      ( dbfTmpPgo )->nVdvPgo     := aTmp[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ]
      ( dbfTmpPgo )->lConPgo     := .F.

      ( dbfTmpPgo )->( dbUnLock() )

   end

   ( dbfTmpPgo )->( dbGoTo( nRec ) )

   WinGather( aTmp, aGet, dbfTmpPgo, oBrw, nMode )

   oDlg:End( 1 )

Return nil



Static Function DelCobPrv( oBrw, dbfRctPrvP )

   if ( dbfRctPrvP )->lCobrado .AND. !oUser():lAdministrador()
      msgStop( "Este recibo está cobrado.", "Imposible eliminar" )
      return .F.
   end

   if oUser():lNotConfirmDelete() .OR. ApoloMsgNoYes("¿ Desea eliminar definitivamente este registro ?", "Confirme supersión" )
      DelRecno( dbfRctPrvP, oBrw, .F. )
   end

return .T.



Static Function EdtRecMenu( aTmp, oDlg )

   oMnuRec := MenuBegin( .F.,,, .F., .F. )

      MenuAddItem( "&1. Rotor",, .F.,,,,,,,,, .F.,,, .F. )

         MenuBegin( .F.,,, .F., .F. )

            if !lExternal




            MenuAddItem( "&1. Visualizar albarán", "Visualiza la factura del la que proviene", .F.,, {|oMenuItem|( if( !Empty( ( dbfRctPrvT )->cNumFac ), ZooFacPrv( ( dbfRctPrvT )->cNumFac ), MsgStop( "La factura rectificativa no proviene de una factura" ) ))},, "Document_plain_businessman_16",,,,, .F.,,, .F. )

            MenuAddItem()




            MenuAddItem( "&2. Modificar proveedor", "Modificar la ficha del proveedor", .F.,, {|oMenuItem|( EdtPrv( aTmp[ 6 ] ) )},, "Businessman_16",,,,, .F.,,, .F. )





            MenuAddItem( "&3. Informe de proveedor", "Abrir el informe del proveedor", .F.,, {|oMenuItem|( InfProveedor( aTmp[ 6 ] ) )},, "Info16",,,,, .F.,,, .F. )
            MenuAddItem()

            end




            MenuAddItem( "&4. Informe del documento", "Abrir el informe del documento", .F.,, {|oMenuItem|( TTrazaDocumento():Activate( "03", ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac ) )},, "Info16",,,,, .F.,,, .F. )

         MenuEnd()

   MenuEnd()

   oDlg:SetMenu( oMnuRec )

Return ( oMnuRec )



Static Function EdtInc( aTmp, aGet, dbfRctPrvI, oBrw, bWhen, bValid, nMode, aTmpFac )

   local oDlg
   local oNomInci
   local cNomInci       := RetFld( aTmp[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ], dbfInci )

   if nMode == 1

      aTmp[ 1  ] := aTmpFac[ 1  ]
      aTmp[ 2  ] := aTmpFac[ 2 ]
      aTmp[ 3  ] := aTmpFac[ 3 ]

      if IsMuebles()
         aTmp[ ( dbfTmpInc )->( FieldPos( "lAviso" ) ) ]  := .T.
      end

   end

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "incidencias de facturas rectificativas de proveedores", "INCIDENCIA",, .F.,,,,,, .F.,,,,,, .F., )








      aGet[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ]:= u ) }, oDlg,,, {||    ( cTipInci( aGet[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ], dbfInci, oNomInci ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwIncidencia( dbfInci, aGet[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ], oNomInci ) )}, nil, "LUPA",, )




      oNomInci := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, cNomInci, cNomInci:= u ) }, oDlg,,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )





      TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "dFecInc" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "dFecInc" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





      TMultiGet():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "mDesInc" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "mDesInc" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||     ( nMode <> 3 )}, .F.,, )




      TCheckBox():ReDefine( 140, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "lListo" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "lListo" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||         ( nMode <> 3 )}, .F. )




      TCheckBox():ReDefine( 150, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "lAviso" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "lAviso" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||         ( nMode <> 3 )}, .F. )





      TButton():ReDefine( 1, {||( WinGather( aTmp, nil, dbfTmpInc, oBrw, nMode ), oDlg:end( 1 ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| WinGather( aTmp, nil, dbfTmpInc, oBrw, nMode ), oDlg:end( 1 ) } )
   end

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

Return ( oDlg:nResult == 1 )



Static Function EdtDoc( aTmp, aGet, dbfAlbPrvD, oBrw, bWhen, bValid, nMode, aTmpLin )

   local oDlg
   local oRuta
   local oNombre
   local oObservacion

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "documento de facturas a proveedor", "DOCUMENTOS",, .F.,,,,,, .F.,,,,,, .F., )




      oNombre := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ ( dbfTmpDoc )->( FieldPos( "cNombre" ) ) ], aTmp[ ( dbfTmpDoc )->( FieldPos( "cNombre" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      oRuta := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfTmpDoc )->( FieldPos( "cRuta" ) ) ], aTmp[ ( dbfTmpDoc )->( FieldPos( "cRuta" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oRuta:cText( cGetFile( "Doc ( *.* ) | " + "*.*", "Seleccione el nombre del fichero" ) ) )}, nil, "FOLDER",, )





      oObservacion := TMultiGet():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( dbfTmpDoc )->( FieldPos( "mObsDoc" ) ) ], aTmp[ ( dbfTmpDoc )->( FieldPos( "mObsDoc" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||     ( nMode <> 3 )}, .F.,, )





      TButton():ReDefine( 1, {||( WinGather( aTmp, nil, dbfTmpDoc, oBrw, nMode ), oDlg:end( 1 ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| WinGather( aTmp, nil, dbfTmpDoc, oBrw, nMode ), oDlg:end( 1 ) } )
   end

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

Return ( oDlg:nResult == 1 )








STATIC FUNCTION EdtDet( aTmp, aGet, dbfRctPrvL, oBrw, aTmpFac, cCodArt, nMode )

    local oDlg
    local oFld
   local oBtn
    local oTotal
   local cSay2
   local oSay2
   local oBmp
   local cGetIra           := Space( 50 )
   local oGetIra
   local oBrwPrp
   local oSayPr1
   local oSayPr2
   local oSayVp1
   local oSayVp2
   local cSayVp1           := ""
   local cSayVp2           := ""
   local cSayPr1           := ""
   local cSayPr2           := ""
   local nTotal            := 0
   local nStkAct           := 0
   local oStkAct
   local oBtnSer





   cOldCodArt              := aTmp[ 4 ]
   cOldPrpArt              := aTmp[ 52 ] + aTmp[ 53 ] + aTmp[ 54 ] + aTmp[ 55 ]
   cOldUndMed              := aTmp[ 12 ]

   do case
   case nMode == 1

      aTmp[ 13 ]    := 1
      aTmp[ 57  ]    := aTmpFac[ 7 ]
      aTmp[ 63  ]    := nLastNum( dbfTmp )
      aTmp[ 62  ]    := Ctod( "" )

      if !Empty( cCodArt )
         aTmp[ 4 ]     := cCodArt
      end

   case nMode == 2

      if !Empty( aTmp[ 4 ] )
         ( dbfArticulo )->( dbSeek( aTmp[ 4 ] ) )
      end

   end





   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "lineas a facturas de proveedores", "LALBPRV",, .F.,,,,,, .F.,,,,,, .F., )









      oFld := TFolder():ReDefine( 400, {"&General", "&Stock", "&Observaciones"}, { "LFACPRV_7","LALBPRV_3","LFACPRV_5" }, oDlg,,,,, .F., )








      aGet[ 4 ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ 4 ], aTmp[ 4 ]:= u ) }, oFld:aDialogs[1],,, {||    ( LoaArt( aGet, aTmp, aTmpFac, oFld, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oBmp, oBrwPrp, oGetIra, oDlg, oStkAct, oTotal ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwArticulo( aGet[4], aGet[6] ) )}, nil, "LUPA",, )










      aGet[ 61 ] := TGetHlp():ReDefine( 112, { | u | If( PCount()==0, aTmp[ 61 ], aTmp[ 61 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,, 111, )

      aGet[ 61 ]:bValid   := {|| oStock:nPutStockActual( aTmp[ 4 ], aTmp[ 57 ], aTmp[ 54 ], aTmp[ 55 ], aTmp[ 61 ], aTmp[ 65 ], aTmp[ 58 ], oStkAct ), .T. }







      aGet[ 62 ] := TGetHlp():ReDefine( 113, { | u | If( PCount()==0, aTmp[ 62 ], aTmp[ 62 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .T.,,,,,, nil,, 114, )





        aGet[6] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[6], aTmp[6]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( ( lModDes() .OR. Empty( aTmp[ 6 ] ) ) .AND. nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






        aGet[15] := TMultiGet():ReDefine( 121, { | u | If( PCount()==0, aTmp[15], aTmp[15]:= u ) }, oFld:aDialogs[1],, "N/W*",,,,, .F., {||         ( nMode <> 3 )}, .F.,, )










      aGet[ 9 ] := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTmp[ 9 ], aTmp[ 9 ]:= u ) }, oFld:aDialogs[1],, "@E 99.99", {||    ( lTiva( dbfIva, aTmp[ 9 ], @aTmp[ 81 ] ) )}, "N/W*",,,,, .F., {||     ( lModIva() .AND. nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) ) }, .F., .F.,,,,, {|Self|( BrwIva( aGet[ 9 ], dbfIva, , .T. ) )}, nil, "LUPA",, )















      aGet[54] := TGetHlp():ReDefine( 220, { | u | If( PCount()==0, aTmp[54], aTmp[54]:= u ) }, oFld:aDialogs[1],,, {||    ( if( lPrpAct( aGet[ 54 ], oSayVp1, aTmp[52 ], dbfTblPro ), LoaArt( aGet, aTmp, aTmpFac, oFld, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oBmp, oBrwPrp, oGetIra, oDlg, oStkAct, oTotal ), .F. ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( brwPrpAct( aGet[ 54 ], oSayVp1, aTmp[ 52 ] ) )}, nil, "LUPA",, )

         aGet[ 54 ]:bChange   := {|| aGet[ 54 ]:Assign(), oStock:nPutStockActual( aTmp[ 4 ], aTmp[ 57 ], aTmp[ 54 ], aTmp[ 55 ], aTmp[ 61 ], aTmp[ 65 ], aTmp[ 58 ], oStkAct ) }



      oSayPr1 := TSay():ReDefine( 221, {|| cSayPr1}, oFld:aDialogs[1],,,, .F.,, .F., .F. )





      oSayVp1 := TGetHlp():ReDefine( 222, { | u | If( PCount()==0, cSayVp1, cSayVp1:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )










      aGet[ 55 ] := TGetHlp():ReDefine( 230, { | u | If( PCount()==0, aTmp[ 55 ], aTmp[ 55 ]:= u ) }, oFld:aDialogs[1],,, {||    ( if( lPrpAct( aGet[ 55 ], oSayVp2, aTmp[ 53 ], dbfTblPro ), LoaArt( aGet, aTmp, aTmpFac, oFld, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oBmp, oBrwPrp, oGetIra, oDlg, oStkAct, oTotal ), .F. ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( brwPrpAct( aGet[ 55 ], oSayVp2, aTmp[ 53 ] ) )}, nil, "LUPA",, )

         aGet[ 55 ]:bChange   := {|| aGet[ 55 ]:Assign(), oStock:nPutStockActual( aTmp[ 4 ], aTmp[ 57 ], aTmp[ 54 ], aTmp[ 55 ], aTmp[ 61 ], aTmp[ 65 ], aTmp[ 58 ], oStkAct ) }



      oSayPr2 := TSay():ReDefine( 231, {|| cSayPr2}, oFld:aDialogs[1],,,, .F.,, .F., .F. )





      oSayVp2 := TGetHlp():ReDefine( 232, { | u | If( PCount()==0, cSayVp2, cSayVp2:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )





      oBrwPrp := TWBrowse():ReDefine( 100, {|| { "" } }, oFld:aDialogs[1], {""},,,,,,,,,,,,, .F.,,,,, )













      aGet[12] := TGetHlp():ReDefine( 152, { | u | If( PCount()==0, aTmp[12], aTmp[12]:= u ) }, oFld:aDialogs[1],,, {||    ( oUndMedicion:Existe( aGet[ 12 ], aGet[ 12 ]:oHelpText, "cNombre" ), ValidaMedicion( aTmp, aGet) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oUndMedicion:Buscar( aGet[ 12 ] ), ValidaMedicion( aTmp, aGet ) )}, nil, "LUPA",, 153 )











      aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ] := TGetHlp():ReDefine( 420, { | u | If( PCount()==0, aTmp[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ], aTmp[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]:= u ) }, oFld:aDialogs[1],, MasUnd(),,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) ) }, .F., .T.,,,,,, nil,, 421, )

      aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]:oSay:SetColor( 8388608 )









      aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ] := TGetHlp():ReDefine( 430, { | u | If( PCount()==0, aTmp[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ], aTmp[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]:= u ) }, oFld:aDialogs[1],, MasUnd(),,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) ) }, .F., .T.,,,,,, nil,, 431, )

      aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]:oSay:SetColor( 8388608 )









      aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ] := TGetHlp():ReDefine( 440, { | u | If( PCount()==0, aTmp[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ], aTmp[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]:= u ) }, oFld:aDialogs[1],, MasUnd(),,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) ) }, .F., .T.,,,,,, nil,, 441, )

      aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]:oSay:SetColor( 8388608 )









        aGet[10] := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTmp[10], aTmp[10]:= u ) }, oFld:aDialogs[1],, cPicUnd, {||    ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) )},,,,,, .F., {||     ( lUseCaj() .AND. nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) ) }, .F., .T.,,,,,, nil,, 141, )









        aGet[13] := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, aTmp[13], aTmp[13]:= u ) }, oFld:aDialogs[1],, cPicUnd, {||    ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) )},,,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) ) }, .F., .T.,,,,,, nil,, 151, )









        aGet[7] := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, aTmp[7], aTmp[7]:= u ) }, oFld:aDialogs[1],, cPinDiv, {||    ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) ) }, .F., .T.,,,,,, nil,,, )









      aGet[16] := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, aTmp[16], aTmp[16]:= u ) }, oFld:aDialogs[1],, "@E 999.99", {||    ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) ) }, .F., .T.,,,,,, nil,,, )









      aGet[17] := TGetHlp():ReDefine( 250, { | u | If( PCount()==0, aTmp[17], aTmp[17]:= u ) }, oFld:aDialogs[1],, "@E 99.99", {||    ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac, aGet, oTotal ) ) }, .F., .T.,,,,,, nil,,, )







      aGet[18] := TGetHlp():ReDefine( 260, { | u | If( PCount()==0, aTmp[18], aTmp[18]:= u ) }, oFld:aDialogs[1],, "@E 99.99",, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )




      aGet[ 88 ] := TCheckBox():ReDefine( 460, { | u | If( PCount()==0, aTmp[ 88 ], aTmp[ 88 ]:= u ) }, oFld:aDialogs[1],,,,,,, .F., {||     ( nMode <> 3 )}, .F. )

      aGet[ 88 ]:bChange   := {|| if( aTmp[ 88 ], ( aGet[ 9 ]:cText( 0 ), aGet[ 9 ]:HardDisable() ), ( aGet[ 9 ]:HardEnable() ) ) }





      oStkAct := TGetHlp():ReDefine( 190, { | u | If( PCount()==0, nStkAct, nStkAct:= u ) }, oFld:aDialogs[1],, MasUnd(),,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )




      aGet[ 5 ] := TGetHlp():ReDefine( 400, { | u | If( PCount()==0, aTmp[ 5 ], aTmp[ 5 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





        oTotal := TGetHlp():ReDefine( 210, { | u | If( PCount()==0, nTotal, nTotal:= u ) }, oFld:aDialogs[1],, cPirDiv,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )








      aGet[57] := TGetHlp():ReDefine( 240, { | u | If( PCount()==0, aTmp[57], aTmp[57]:= u ) }, oFld:aDialogs[1],,, {||    ( cNomUbica( aTmp, aGet, dbfAlm ), cAlmacen( aGet[57], dbfAlm, oSay2 ), oStock:lPutStockActual( aTmp[ 4 ], aTmp[ 57 ], aTmp[ 54 ], aTmp[ 55 ], aTmp[ 61 ], aTmp[ 65 ], aTmp[ 58 ], oStkAct ) )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwAlmacen( Self, oSay2 ) )}, nil, "LUPA",, )




        oSay2 := TGetHlp():ReDefine( 241, { | u | If( PCount()==0, cSay2, cSay2:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )



      aGet[70] := TSay():ReDefine( 300, {|| aTmp[70]}, oFld:aDialogs[1],,,, .F.,, .F., .F. )






      aGet[73] := TGetHlp():ReDefine( 270, { | u | If( PCount()==0, aTmp[73], aTmp[73]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwUbiLin( aGet[73], aGet[76], aTmp[70], dbfUbicaL ) )}, nil, "LUPA",, )




      aGet[76] := TGetHlp():ReDefine( 271, { | u | If( PCount()==0, aTmp[76], aTmp[76]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )



      aGet[71] := TSay():ReDefine( 310, {|| aTmp[71]}, oFld:aDialogs[1],,,, .F.,, .F., .F. )






      aGet[74] := TGetHlp():ReDefine( 280, { | u | If( PCount()==0, aTmp[74], aTmp[74]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwUbiLin( aGet[74], aGet[77], aTmp[71], dbfUbicaL ) )}, nil, "LUPA",, )




      aGet[77] := TGetHlp():ReDefine( 281, { | u | If( PCount()==0, aTmp[77], aTmp[77]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )



      aGet[72] := TSay():ReDefine( 320, {|| aTmp[72]}, oFld:aDialogs[1],,,, .F.,, .F., .F. )






      aGet[75] := TGetHlp():ReDefine( 290, { | u | If( PCount()==0, aTmp[75], aTmp[75]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwUbiLin( aGet[75], aGet[78], aTmp[72], dbfUbicaL ) )}, nil, "LUPA",, )




      aGet[78] := TGetHlp():ReDefine( 291, { | u | If( PCount()==0, aTmp[78], aTmp[78]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )







      oGetIra := TGetHlp():ReDefine( 410, { | u | If( PCount()==0, cGetIra, cGetIra:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( SearchProperty( oGetIra, oBrwPrp ) )}, nil, "Lupa", 411, )









      aGet[ 58 ] := TRadMenu():Redefine( { | u | If( PCount()==0, aTmp[ 58 ], aTmp[ 58 ]:= u ) }, oFld:aDialogs[ 2 ],, { 350, 351, 352 },,,,, .F., {||     ( nMode <> 3 )}, )





      aGet[82] := TMultiGet():ReDefine( 100, { | u | If( PCount()==0, aTmp[82], aTmp[82]:= u ) }, oFld:aDialogs[3],,,,,,, .F., {||     ( nMode <> 3 )}, .F.,, )





      oBtn := TButton():ReDefine( 1, {||( SaveDeta( aTmp, aGet, oBrw, oDlg, nMode, oTotal, oFld, aTmpFac, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oStkAct, oBrwPrp, oGetIra, oBtn, oBtnSer ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )




      TButton():ReDefine( 9, {||( GoHelp() )}, oDlg,,, .F.,,,, .F. )




      oBtnSer := TButton():ReDefine( 552, {||( EditarNumeroSerie( aTmp, nMode ) )}, oDlg,,, .F.,,,, .F. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| oBtn:SetFocus(), oBtn:Click() } )
   end

   oDlg:AddFastKey( 117, {|| oBtnSer:Click() } )
   oDlg:AddFastKey( 112, {|| GoHelp() } )


   oDlg:bStart    := {|| SetDlgMode( aGet, aTmp, oFld, aTmpFac, nMode, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oTotal, oBrwPrp, oGetIra ), aGet[ 12 ]:lValid() }



    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( EdtDetMenu( aGet[ 4 ], oDlg ) )}, oDlg:bRClicked,,, )

   EndDetMenu()

RETURN ( oDlg:nResult == 1 )



static Function cNomUbica( aTmp, aGet, dbfAlm )

   aTmp[70]      := cGetUbica( aTmp[57], dbfAlm, 1 )
   aTmp[71]      := cGetUbica( aTmp[57], dbfAlm, 2 )
   aTmp[72]      := cGetUbica( aTmp[57], dbfAlm, 3 )

   if Empty( aTmp[70] )
      aGet[70]:Hide()
      aGet[73]:Hide()
      aGet[76]:Hide()
   else
      aGet[70]:Show()
      aGet[73]:Show()
      aGet[76]:Show()
   end

   if Empty( aTmp[71] )
      aGet[71]:Hide()
      aGet[74]:Hide()
      aGet[77]:Hide()
   else
      aGet[71]:Show()
      aGet[74]:Show()
      aGet[77]:Show()
   end

   if Empty( aTmp[72] )
      aGet[72]:Hide()
      aGet[75]:Hide()
      aGet[78]:Hide()
   else
      aGet[72]:Show()
      aGet[75]:Show()
      aGet[78]:Show()
   end

   aGet[70]:Refresh()
   aGet[73]:Refresh()
   aGet[76]:Refresh()
   aGet[71]:Refresh()
   aGet[74]:Refresh()
   aGet[78]:Refresh()
   aGet[72]:Refresh()
   aGet[75]:Refresh()
   aGet[78]:Refresh()

return .T.



STATIC FUNCTION SetDlgMode( aGet, aTmp, oFld, aTmpFac, nMode, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oTotal, oBrwPrp, oGetIra )

   local cCodArt  := aGet[ 4 ]:VarGet()

   if !lUseCaj()
      aGet[ 10 ]:Hide()
   else
      aGet[ 10 ]:SetText( cNombreCajas() )
   end

   aGet[ 13 ]:SetText( cNombreUnidades() )

   oBrwPrp:Hide()
   oGetIra:Hide()

   oSayPr1:SetText( "" )
   oSayVp1:SetText( "" )

   oSayPr2:SetText( "" )
   oSayVp2:SetText( "" )





   oFld:aEnable   := { .T., !Empty( aTmp[ 4 ] ), .T. }
   oFld:SetOption( 1 )

   do case
   case nMode == 1

      aGet[4    ]:show()
      aGet[6]:show()
      aGet[15 ]:hide()
      aGet[61   ]:hide()
      aGet[62 ]:hide()
      aGet[10 ]:cText( 1 )
      aGet[13]:cText( 1 )
      aGet[57 ]:cText( aTmpFac[ 7 ] )
      aGet[9    ]:cText( nIva( dbfIva, cDefIva() ) )

   case nMode <> 1 .AND. empty( cCodArt )

      aGet[4    ]:hide()
        aGet[6]:hide()
        aGet[15 ]:show()
      aGet[61   ]:hide()
      aGet[62 ]:hide()

   case nMode <> 1 .AND. !empty( cCodArt )

      aGet[4    ]:show()
        aGet[6]:show()
        aGet[15 ]:hide()

      if aTmp[ 59 ]
         aGet[ 61   ]:Show()
         aGet[ 5 ]:Show()
      else
         aGet[ 61   ]:Hide()
         aGet[ 62 ]:Hide()
      end

   end

   lCalcDeta( aTmp, aTmpFac, aGet, oTotal )

   if !Empty( aTmp[ 52 ] )
      aGet[ 54 ]:Show()
      aGet[ 54 ]:lValid()
      oSayPr1:Show()
      oSayVp1:Show()
      oSayPr1:SetText( retProp( aTmp[52], dbfPro ) )
   else
      aGet[ 54 ]:hide()
      oSayPr1:Hide()
      oSayVp1:Hide()
   end

   if !Empty( aTmp[53 ] )
      aGet[ 55 ]:Show()
      aGet[ 55 ]:lValid()
      oSayPr2:Show()
      oSayVp2:Show()
      oSayPr2:SetText( retProp(  aTmp[53], dbfPro ) )
   else
      aGet[ 55 ]:hide()
      oSayPr2:hide()
      oSayVp2:hide()
   end



   aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]:Hide()
   aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]:Hide()
   aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]:Hide()

   if oUndMedicion:oDbf:Seek(  aTmp[ 12 ] )

      if oUndMedicion:oDbf:nDimension >= 1 .AND. !Empty( oUndMedicion:oDbf:cTextoDim1 )
         aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim1 )
         aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]:Show()
      end

      if oUndMedicion:oDbf:nDimension >= 2 .AND. !Empty( oUndMedicion:oDbf:cTextoDim2 )
         aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim2 )
         aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]:Show()
      end

      if oUndMedicion:oDbf:nDimension >= 3 .AND. !Empty( oUndMedicion:oDbf:cTextoDim3 )
         aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim3 )
         aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]:Show()
      end

   end

   aGet[ 57 ]:lValid()
   aGet[ 4    ]:SetFocus()

Return Nil



STATIC FUNCTION SaveDeta( aTmp, aGet, oBrw, oDlg2, nMode, oTotal, oFld, aTmpFac, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oStkAct, oBrwPrp, oGetIra, oBtn, oBtnSer )

   local n
   local i

   oBtn:SetFocus()

   if Empty( aTmp[ 4 ] ) .AND. lRetCodArt()
      MsgStop( "No se pueden añadir lineas sin codificar" )
      return .F.
   end

   if !lMoreIva( aTmp[9] )
      return nil
   end

   if Empty( aTmp[ 57 ] )
      MsgStop( "Código de almacen no puede estar vacio" )
      aGet[ 57 ]:SetFocus()
      Return nil
   end

   if !cAlmacen( aGet[ 57 ], dbfAlm )
      MsgStop( "Código de almacen no encontrado" )
      Return nil
   end





   if nMode == 1 .AND. RetFld( aTmp[ 4 ], dbfArticulo, "lNumSer" ) .AND. !( dbfTmpSer )->( dbSeek( Str( aTmp[ 63 ], 4 ) + aTmp[ 4 ] ) )

      MsgStop( "Tiene que introducir números de serie para este artículo." )

      oBtnSer:Click()

      Return .F.

   end





   cOldCodArt     := ""
   cOldUndMed     := ""

   if nMode == 1

      if aTmp[ 59 ]
         GraLotArt( aTmp[ 4 ], dbfArticulo, aTmp[ 61 ] )
      end

      if !Empty( oBrwPrp:Cargo )

         for n := 1 to len( oBrwPrp:Cargo )

            for i := 1 to len( oBrwPrp:Cargo[ n ] )

               if IsNum( oBrwPrp:Cargo[ n, i ]:Value ) .AND. oBrwPrp:Cargo[ n, i ]:Value <> 0

                  aTmp[ 13]  := oBrwPrp:Cargo[ n, i ]:Value
                  aTmp[ 52 ]  := oBrwPrp:Cargo[ n, i ]:cCodigoPropiedad1
                  aTmp[ 54 ]  := oBrwPrp:Cargo[ n, i ]:cValorPropiedad1
                  aTmp[ 53 ]  := oBrwPrp:Cargo[ n, i ]:cCodigoPropiedad2
                  aTmp[ 55 ]  := oBrwPrp:Cargo[ n, i ]:cValorPropiedad2
                  aTmp[ 7]  := oBrwPrp:Cargo[ n, i ]:nPrecioCompra

                  WinGather( aTmp, aGet, dbfTmp, oBrw, nMode, nil, .F. )

               end

            next

         next

         aCopy( dbBlankRec( dbfTmp ), aTmp )

         aEval( aGet, {| o, i | if( "GET" $ o:ClassName(), o:cText( aTmp[ i ] ), ) } )

      else

         WinGather( aTmp, aGet, dbfTmp, oBrw, nMode )

      end

      if lEntCon()
         RecalculaTotal( aTmpFac )
         SetDlgMode( aGet, aTmp, oFld, aTmpFac, nMode, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oTotal, oBrwPrp, oGetIra )
      else
         oDlg2:End( 1 )
      end

   else

      WinGather( aTmp, aGet, dbfTmp, oBrw, nMode )

      oDlg2:end( 1 )

   end

   if !Empty( aGet[ 12 ] )
      aGet[ 12 ]:lValid()
   end

   if !Empty( oBrwPrp )
      oBrwPrp:Cargo  := nil
   end

RETURN NIL







STATIC FUNCTION AppDeta( oBrwLin, bEdtDet, aTmp, cCodArt )









   if lRecibosPagadosTmp( dbfTmpPgo )
      MsgStop( "No se pueden modificar registros de una factura con pagos" )
      return .F.
   end

   WinAppRec( oBrwLin, bEdtDet, dbfTmp, aTmp, cCodArt )

RETURN ( RecalculaTotal( aTmp ) )







STATIC FUNCTION EdtDeta( oBrwLin, bEdtDet, aTmp, cLoop )

   if lRecibosPagadosTmp( dbfTmpPgo )
      MsgStop( "No se pueden modificar registros de una factura con pagos" )
      return .F.
   end

   if !( dbfTmp )->lControl
      WinEdtRec( oBrwLin, bEdtDet, dbfTmp, aTmp )
   end

RETURN ( RecalculaTotal( aTmp ) )






STATIC FUNCTION DelDeta()

   if lRecibosPagadosTmp( dbfTmpPgo )
      MsgStop( "No se pueden eliminar registros de una factura con pagos" )
      return .F.
   end

   CursorWait()

   while ( dbfTmpSer )->( dbSeek( Str( ( dbfTmp )->nNumLin, 4 ) ) )
      ( dbfTmpSer )->( dbDelete() )
   end

   if ( dbfTmp )->lKitArt
      dbDelKit( , dbfTmp, ( dbfTmp )->nNumLin )
   end

   CursorWE()

RETURN ( .T. )






FUNCTION nPagRctPrv( cFactura, cFacPrvP, cDivRet, dbfDiv, lOnlyCob, aTmp )

   local nRec
   local nOrd
   local nRinDiv
   local cCodDiv
   local nTotalPagado   := 0

   IIF( cFacPrvP == nil, cFacPrvP := dbfRctPrvP, ) ;
   IIF( cDivRet == nil, cDivRet := cDivEmp(), ) ;
   IIF( lOnlyCob == nil, lOnlyCob := .T., ) ;

   nRinDiv              := nRinDiv( cDivRet, dbfDiv )





   nRec                    := ( cFacPrvP )->( Recno() )

   if !Empty( aTmp )

      cCodDiv              := ( cFacPrvP )->cDivPgo

      ( cFacPrvP )->( dbGoTop() )
      while !( cFacPrvP )->( Eof() )

         if ( lOnlyCob .AND. ( cFacPrvP )->lCobrado .AND. !( cFacPrvP )->lDevuelto ) .OR. ( !lOnlyCob .AND. !( cFacPrvP )->lDevuelto )

            nTotalPagado   += ( cFacPrvP )->nImporte

         end

         ( cFacPrvP )->( dbSkip() )

      end

      ( cFacPrvP )->( dbGoTo( nRec ) )

   else

      nOrd                 := ( cFacPrvP )->( OrdSetFocus( "rNumFac" ) )

      if ( cFacPrvP )->( dbSeek( cFactura, .T. ) )

         cCodDiv           := ( cFacPrvP )->cDivPgo

         while ( ( cFacPrvP )->cSerFac + Str( ( cFacPrvP )->nNumFac ) + ( cFacPrvP )->cSufFac = cFactura )

            if ( lOnlyCob .AND. ( cFacPrvP )->lCobrado .AND. !( cFacPrvP )->lDevuelto ) .OR. ( !lOnlyCob .AND. !( cFacPrvP )->lDevuelto )

               nTotalPagado   += ( cFacPrvP )->nImporte

            end

            ( cFacPrvP )->( dbSkip() )

         end

      end

      ( cFacPrvP )->( OrdSetFocus( nOrd ) )

   end

   ( cFacPrvP )->( dbGoTo( nRec ) )

   if cDivRet <> nil .AND. cCodDiv <> cDivRet
      nTotalPagado   := nCnv2Div( nTotalPagado, cCodDiv, cDivRet, dbfDiv )
   else
      nTotalPagado   := Round( nTotalPagado, nRinDiv )
   end

RETURN ( nTotalPagado )



FUNCTION ChkPagRctPrv( dbfRctPrvT, dbfRctPrvP )

    local nBitmap

   do case
   case ( dbfRctPrvT )->lLiquidada
        nBitmap    := 1
   case lRecibosPagados( dbfRctPrvT, dbfRctPrvP )
      nBitmap  := 2
   otherwise
      nBitmap  := 3
   end

RETURN nBitmap






FUNCTION ChkLqdRctPrv( aTmp, dbfRctPrvT, dbfRctPrvL, dbfRctPrvP, dbfIva, dbfDiv )

    local cFactura
    local nPagFacPrv
    local nTotal
   local cDivFac

    IF aTmp <> NIL
      cFactura := aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ]
      cDivFac  := aTmp[ 35 ]
    ELSE
      cFactura := (dbfRctPrvT)->CSERFAC + Str( (dbfRctPrvT)->NNUMFAC ) + (dbfRctPrvT)->CSUFFAC
      cDivFac  := (dbfRctPrvT)->CDIVFAC
   end

   nPagFacPrv  := abs( nPagRctPrv( cFactura, dbfRctPrvP, cDivFac, dbfDiv ) )
   nTotal      := abs( nTotRctPrv( cFactura, dbfRctPrvT, dbfRctPrvL, dbfIva, dbfDiv, dbfRctPrvP, nil, nil, .F. ) )

   if aTmp <> NIL

      if nPagFacPrv == nTotal
         aTmp[ 15 ] := .T.
      elseif nPagFacPrv > nTotal

         aTmp[ 15 ] := .T.
      else
         aTmp[ 15 ] := .F.
      end

   else

      if dbLock( dbfRctPrvT )
         if nPagFacPrv == nTotal
            ( dbfRctPrvT )->lLiquidada := .T.
         elseif  nPagFacPrv > nTotal

            ( dbfRctPrvT )->lLiquidada := .T.
         else
            ( dbfRctPrvt )->lliquidada := .F.
         end
         ( dbfRctPrvT )->( dbRUnLock() )
      end

    end

RETURN NIL



STATIC FUNCTION PrnSerie( oBrw )

    local oDlg
   local oFmtDoc
   local cFmtDoc     := cFormatoDocumento( ( dbfRctPrvT )->cSerFac, "nRctPrv", dbfCount )
   local oSayFmt
   local cSayFmt
   local oSerIni
   local oSerFin
   local nRecno      := ( dbfRctPrvT )->( Recno() )
   local nOrdAnt     := ( dbfRctPrvT )->( OrdSetFocus( 1 ) )
   local cSerIni     := ( dbfRctPrvT )->cSerFac
   local cSerFin     := ( dbfRctPrvT )->cSerFac
   local nDocIni     := ( dbfRctPrvT )->nNumFac
   local nDocFin     := ( dbfRctPrvT )->nNumFac
   local cSufIni     := ( dbfRctPrvT )->cSufFac
   local cSufFin     := ( dbfRctPrvT )->cSufFac
   local oPrinter
   local cPrinter    := PrnGetName()
   local lCopiasPre  := .T.
   local lInvOrden   := .F.
   local oNumCop
   local nNumCop     := if( nCopiasDocumento( ( dbfRctPrvT )->cSerFac, "nRctPrv", dbfCount ) == 0, Max( Retfld( ( dbfRctPrvT )->cCodPrv, dbfPrv, "nCopiasF" ), 1 ), nCopiasDocumento( ( dbfRctPrvT )->cSerFac, "nRctPrv", dbfCount ) )

   if Empty( cFmtDoc )
      cFmtDoc        := cSelPrimerDoc( "TP" )
   end

   cSayFmt           := cNombreDoc( cFmtDoc )

   oDlg = TDialog():New(,,,, "Imprimir series de facturas", "IMPSERDOC",, .F.,,,,,, .F.,,,,,, .F., )









   oSerIni := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, cSerIni, cSerIni:= u ) }, oDlg,, "@!", {||    ( cSerIni >= "A" .AND. cSerIni <= "Z"  )},,,,,, .T.,,, .F., .T., {||    ( UpSerie( oSerIni ) )}, {||  ( DwSerie( oSerIni ) )},,,, nil,,, )









   oSerFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cSerFin, cSerFin:= u ) }, oDlg,, "@!", {||    ( cSerFin >= "A" .AND. cSerFin <= "Z"  )},,,,,, .T.,,, .F., .T., {||    ( UpSerie( oSerFin ) )}, {||  ( DwSerie( oSerFin ) )},,,, nil,,, )









   TGetHlp():ReDefine( 120, { | u | If( PCount()==0, nDocIni, nDocIni:= u ) }, oDlg,, "999999999", {||    ( If ( !( dbfRctPrvT )->( dbSeek( cSerIni + Str( nDocIni, 9 ) + cSufIni ) ),    ( msgStop( "Documento no valido" ), .F. ),    ( .T. ) ) )}, "N/W*",,,,, .F.,,, .F., .T.,,,,,, nil,,, )









   TGetHlp():ReDefine( 130, { | u | If( PCount()==0, nDocFin, nDocFin:= u ) }, oDlg,, "999999999", {||    ( If ( !( dbfRctPrvT )->( dbSeek( cSerFin  + Str( nDocFin, 9 ) + cSufFin ) ),    ( msgStop( "Documento no valido" ), .F. ),    ( .T. ) ) )}, "N/W*",,,,, .F.,,, .F., .T.,,,,,, nil,,, )








   TGetHlp():ReDefine( 140, { | u | If( PCount()==0, cSufIni, cSufIni:= u ) }, oDlg,, "##", {||    ( If ( !( dbfRctPrvT )->( dbSeek( cSerIni  + Str( nDocIni, 9 ) + cSufIni ) ),    ( msgStop( "Documento no valido" ), .F. ),    ( .T. ) ) )}, "N/W*",,,,, .F.,,, .F., .F.,,,,,, nil,,, )








   TGetHlp():ReDefine( 150, { | u | If( PCount()==0, cSufFin, cSufFin:= u ) }, oDlg,, "##", {||    ( If ( !( dbfRctPrvT )->( dbSeek( cSerFin  + Str( nDocFin, 9 ) + cSufFin ) ),    ( msgStop( "Documento no valido" ), .F. ),    ( .T. ) ) )}, "N/W*",,,,, .F.,,, .F., .F.,,,,,, nil,,, )



   TCheckBox():ReDefine( 500, { | u | If( PCount()==0, lInvOrden, lInvOrden:= u ) }, oDlg,,,,,,, .F.,, .F. )



   TCheckBox():ReDefine( 170, { | u | If( PCount()==0, lCopiasPre, lCopiasPre:= u ) }, oDlg,,,,,,, .F.,, .F. )









   oNumCop := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, nNumCop, nNumCop:= u ) }, oDlg,, "999999999", {||    nNumCop > 0},,,,,, .F., {||     !lCopiasPre},, .F., .T.,,, {||      1}, {||      99999},, nil,,, )







   oFmtDoc := TGetHlp():ReDefine( 90, { | u | If( PCount()==0, cFmtDoc, cFmtDoc:= u ) }, oDlg,,, {||    ( cDocumento( oFmtDoc, oSayFmt, dbfDoc ) )}, "N/W*",,,,, .F.,,, .F., .F.,,,,, {|Self|( BrwDocumento( oFmtDoc, oSayFmt, "TP" ) )}, nil, "LUPA",, )





   oSayFmt := TGetHlp():ReDefine( 91, { | u | If( PCount()==0, cSayFmt, cSayFmt:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )

   TBtnBmp():ReDefine( 92, "Printer_pencil_16",,,,,{|| EdtDocumento( cFmtDoc ) }, oDlg, .F., , .F.,  )




   oPrinter := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, cPrinter, cPrinter:= u ) }, oDlg,,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )

   TBtnBmp():ReDefine( 161, "Printer_preferences_16",,,,,{|| PrinterPreferences( oPrinter ) }, oDlg, .F., , .F.,  )





   TButton():ReDefine( 1, {||(  StartPrint( SubStr( cFmtDoc, 1, 3 ), cSerIni + Str( nDocIni, 9 ) + cSufIni, cSerFin + Str( nDocFin, 9 ) + cSufFin, oDlg, cPrinter, lCopiasPre, nNumCop, lInvOrden ), oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )





   TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   oDlg:AddFastKey( 116, {|| StartPrint( SubStr( cFmtDoc, 1, 3 ), cSerIni + Str( nDocIni, 9 ) + cSufIni, cSerFin + Str( nDocFin, 9 ) + cSufFin, oDlg, cPrinter, lCopiasPre, nNumCop, lInvOrden ), oDlg:end( 1 ) } )

   oDlg:bStart := { || oSerIni:SetFocus() }

    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   ( dbfRctPrvT )->( ordSetFocus( nOrdAnt ) )
   ( dbfRctPrvT )->( dbGoTo( nRecNo ) )

    oBrw:refresh()

RETURN NIL



STATIC FUNCTION StartPrint( cFmtDoc, cDocIni, cDocFin, oDlg, cPrinter, lCopiasPre, nNumCop, lInvOrden )

   local nCopyProvee

   oDlg:disable()

   if !lInvOrden

      ( dbfRctPrvT )->( dbSeek( cDocIni, .T. ) )


      while ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + (dbfRctPrvT)->cSufFac >= cDocIni .AND.  ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + (dbfRctPrvT)->cSufFac <= cDocFin

            lChgImpDoc( dbfRctPrvT )

         if lCopiasPre

            nCopyProvee    := if( nCopiasDocumento( ( dbfRctPrvT )->cSerFac, "nRctPrv", dbfCount ) == 0, Max( Retfld( ( dbfRctPrvT )->cCodPrv, dbfPrv, "nCopiasF" ), 1 ), nCopiasDocumento( ( dbfRctPrvT )->cSerFac, "nRctPrv", dbfCount ) )

            GenRctPrv( 1, "Imprimiendo documento : " + ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + (dbfRctPrvT)->cSufFac, cFmtDoc, cPrinter, nCopyProvee )

         else

            GenRctPrv( 1, "Imprimiendo documento : " + ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + (dbfRctPrvT)->cSufFac, cFmtDoc, cPrinter, nNumCop )

         end

      (dbfRctPrvT)->( dbSkip() )

      end

   else

      ( dbfRctPrvT )->( dbSeek( cDocFin ) )



      while ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac >= cDocIni .AND.  ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac <= cDocFin .AND. !( dbfRctPrvT )->( Bof() )

            lChgImpDoc( dbfRctPrvT )

         if lCopiasPre

            nCopyProvee    := if( nCopiasDocumento( ( dbfRctPrvT )->cSerFac, "nRctPrv", dbfCount ) == 0, Max( Retfld( ( dbfRctPrvT )->cCodPrv, dbfPrv, "nCopiasF" ), 1 ), nCopiasDocumento( ( dbfRctPrvT )->cSerFac, "nRctPrv", dbfCount ) )

            GenRctPrv( 1, "Imprimiendo documento : " + ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + (dbfRctPrvT)->cSufFac, cFmtDoc, cPrinter, nCopyProvee )

         else

            GenRctPrv( 1, "Imprimiendo documento : " + ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + (dbfRctPrvT)->cSufFac, cFmtDoc, cPrinter, nNumCop )

         end

      ( dbfRctPrvT )->( dbSkip( -1 ) )

      end

   end

   oDlg:Enable()

RETURN NIL







STATIC FUNCTION lCalcDeta( aTmp, aTmpFac, aGet, oTotal )

   oTotal:cText( nTotLRctPrv( aTmp, nDinDiv, nRinDiv ) )

RETURN .T.



FUNCTION nNetURctPrv( uFacPrvL, uFacPrvT, nDec, nRec, nVdv, cPinDiv )

   local nDtoEsp
    local nDtoPP
   local nDtoUno
    local nDtoDos
   local nCalculo
   local nDtoLin
   local nDtoPrm
   local nPorte

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nRec == nil, nRec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo       := nTotURctPrv( uFacPrvL, nDec, nVdv )

   if ValType( uFacPrvL ) == "A"
      nDtoLin     := uFacPrvL[ 16 ]
      nDtoPrm     := uFacPrvL[ 17 ]
   else
      nDtoLin     := ( uFacPrvL )->nDtoLin
      nDtoPrm     := ( uFacPrvL )->nDtoPrm
   end

   if nDtoLin <> 0
      nCalculo    -= nCalculo * nDtoLin / 100
   end

   if nDtoPrm <> 0
      nCalculo    -= nCalculo * nDtoPrm / 100
   end





   if ValType( uFacPrvT ) == "A"
      nDtoEsp     := uFacPrvT[ 29 ]
      nDtoPP      := uFacPrvT[ 31    ]
      nDtoUno     := uFacPrvT[ 39 ]
      nDtoDos     := uFacPrvT[ 41 ]
      nPorte      := uFacPrvT[ 25 ]
   else
      nDtoEsp     := (uFacPrvT)->NDTOESP
      nDtoPP      := (uFacPrvT)->NDPP
      nDtoUno     := (uFacPrvT)->NDTOUNO
      nDtoDos     := (uFacPrvT)->NDTODOS
      nPorte      := (uFacPrvT)->NPORTES
   end

   if nDtoEsp <> 0
      nCalculo    -= Round( nCalculo * nDtoEsp / 100, nDec )
   end

   if nDtoPP <> 0
      nCalculo    -= Round( nCalculo * nDtoPP  / 100, nDec )
   end

   if nDtoUno <> 0
      nCalculo    -= Round( nCalculo * nDtoUno / 100, nDec )
   end

   if nDtoDos <> 0
      nCalculo    -= Round( nCalculo * nDtoDos / 100, nDec )
   end

   nCalculo       := Round( nCalculo, nDec )

RETURN ( if( cPinDiv <> NIL, Trans( nCalculo, cPinDiv ), nCalculo ) )



FUNCTION nImpURctPrv( uFacPrvT, dbfRctPrvL, nDec, nVdv, lIva, cPouDiv )

   local nCalculo

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;
   IIF( lIva == nil, lIva := .F., ) ;

   nCalculo       := nTotURctPrv( dbfRctPrvL, nDec, nVdv )

   if ValType( uFacPrvT ) == "A"
      nCalculo    -= Round( nCalculo * uFacPrvT[ 29 ]  / 100, nDec )
      nCalculo    -= Round( nCalculo * uFacPrvT[ 31    ]  / 100, nDec )
      nCalculo    -= Round( nCalculo * uFacPrvT[ 39 ]  / 100, nDec )
      nCalculo    -= Round( nCalculo * uFacPrvT[ 41 ]  / 100, nDec )
   else
      nCalculo    -= Round( nCalculo * ( uFacPrvT )->nDtoEsp / 100, nDec )
      nCalculo    -= Round( nCalculo * ( uFacPrvT )->nDpp    / 100, nDec )
      nCalculo    -= Round( nCalculo * ( uFacPrvT )->nDtoUno / 100, nDec )
      nCalculo    -= Round( nCalculo * ( uFacPrvT )->nDtoDos / 100, nDec )
   end

   if lIva .AND. ( dbfRctPrvL )->nIva <> 0
      nCalculo    += nCalculo * ( dbfRctPrvL )->nIva / 100
   end

RETURN ( if( cPouDiv <> nil, Trans( nCalculo, cPouDiv ), nCalculo ) )



FUNCTION nImpLRctPrv( uFacPrvT, dbfRctPrvL, nDec, nRou, nVdv, lIva, cPouDiv )

   local nCalculo

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nRou == nil, nRou := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;
   IIF( lIva == nil, lIva := .F., ) ;

   nCalculo       := nTotLRctPrv( dbfRctPrvL, nDec, nRou, nVdv )

   if ValType( uFacPrvT ) == "A"
      nCalculo    -= Round( nCalculo * uFacPrvT[ 29 ]  / 100, nRou )
      nCalculo    -= Round( nCalculo * uFacPrvT[ 31    ]  / 100, nRou )
      nCalculo    -= Round( nCalculo * uFacPrvT[ 39 ]  / 100, nRou )
      nCalculo    -= Round( nCalculo * uFacPrvT[ 41 ]  / 100, nRou )
   else
      nCalculo    -= Round( nCalculo * ( uFacPrvT )->nDtoEsp / 100, nRou )
      nCalculo    -= Round( nCalculo * ( uFacPrvT )->nDpp    / 100, nRou )
      nCalculo    -= Round( nCalculo * ( uFacPrvT )->nDtoUno / 100, nRou )
      nCalculo    -= Round( nCalculo * ( uFacPrvT )->nDtoDos / 100, nRou )
   end

   if lIva .AND. ( dbfRctPrvL )->nIva <> 0
      nCalculo    += nCalculo * ( dbfRctPrvL )->nIva / 100
   end

RETURN ( if( cPouDiv <> nil, Trans( nCalculo, cPouDiv ), nCalculo ) )



FUNCTION nTotRctPrv( cFactura, cFacPrvT, cFacPrvL, cDbfIva, cDbfDiv, cFacPrvP, aTmp, cDivRet, lPic )

    local bCondition
    local nTotalArt
   local lRecargo
   local dFecFac
    local nDtoEsp
    local nDtoPP
   local nDtoUno
   local nDtoDos
    local nPorte
   local nPctRet
   local nRecno
    local cCodDiv
    local cCodPgo
   local nRegIva
   local lFacGas     := .F.
   local aTotalUno   := { 0, 0, 0 }
      local aTotalDos   := { 0, 0, 0 }
   local aTotalDto   := { 0, 0, 0 }
    local aTotalDPP    := { 0, 0, 0 }
   local aNetGas     := { 0, 0, 0 }
   local aPIvGas     := { 0, 0, 0 }
   local aPReGas     := { 0, 0, 0 }

   IIF( cFacPrvT == nil, cFacPrvT := dbfRctPrvT, ) ;
   IIF( cFacPrvL == nil, cFacPrvL := dbfRctPrvL, ) ;
   IIF( cFacPrvP == nil, cFacPrvP := dbfRctPrvP, ) ;
   IIF( cDbfIva == nil, cDbfIva := dbfIva, ) ;
   IIF( cDbfDiv == nil, cDbfDiv := dbfDiv, ) ;
   IIF( cFactura == nil, cFactura := ( cFacPrvT )->cSerFac + Str( ( cFacPrvT )->nNumFac ) + ( cFacPrvT )->cSufFac, ) ;
   IIF( lPic == nil, lPic := .F., ) ;

   public nTotBrt    := 0
   public nTotNet    := 0
   public nTotSup    := 0
   public nTotIva    := 0
   public nTotReq    := 0
   public nTotRet    := 0
   public nTotFac    := 0
   public nTotDto    := 0
   public nTotDpp    := 0
   public nTotUno    := 0
   public nTotDos    := 0
   public nTotImp    := 0
   public nTotUnd    := 0
   public nPagFac    := 0
   public nTipRet    := 0
   public aTotIva    := { { 0,0,nil,0,0,0 }, { 0,0,nil,0,0,0 }, { 0,0,nil,0,0,0 } }
   public aIvaUno    := aTotIva[ 1 ]
   public aIvaDos    := aTotIva[ 2 ]
   public aIvaTre    := aTotIva[ 3 ]

   nRecno            := ( cFacPrvL )->( recno() )

   if aTmp <> nil
      dFecFac        := aTmp[ 5 ]
      lRecargo       := aTmp[ 32]
      nDtoEsp        := aTmp[ 29 ]
      nDtoPP         := aTmp[ 31    ]
      nDtoUno        := aTmp[ 39 ]
      nDtoDos        := aTmp[ 41 ]
      nPorte         := aTmp[ 25 ]
      cCodDiv        := aTmp[ 35 ]
      cCodPgo        := aTmp[ 23]
      nTipRet        := aTmp[ 50 ]
      nPctRet        := aTmp[ 51 ]
      nRegIva        := aTmp[ 55 ]
      lFacGas        := aTmp[ 56 ]
      aNetGas        := { aTmp[ 58 ], aTmp[ 59 ], aTmp[ 60 ] }
      aPIvGas        := { aTmp[ 61 ], aTmp[ 62 ], aTmp[ 63 ] }
      aPReGas        := { aTmp[ 64  ], aTmp[ 65  ], aTmp[ 66  ] }
      bCondition     := {|| ( cFacPrvL )->( !eof() ) }
      ( cFacPrvL )->( dbGoTop() )
   else
      dFecFac        := ( cFacPrvT )->dFecFac
      lRecargo       := ( cFacPrvT )->lRecargo
      nDtoEsp        := ( cFacPrvT )->nDtoEsp
      nDtoPP         := ( cFacPrvT )->nDpp
      nDtoUno        := ( cFacPrvT )->nDtoUno
      nDtoDos        := ( cFacPrvT )->nDtoDos
      nPorte         := ( cFacPrvT )->nPortes
      cCodDiv        := ( cFacPrvT )->cDivFac
      cCodPgo        := ( cFacPrvT )->cCodPago
      nTipRet        := ( cFacPrvT )->nTipRet
      nPctRet        := ( cFacPrvT )->nPctRet
      nRegIva        := ( cFacPrvT )->nRegIva
      lFacGas        := ( cFacPrvT )->lFacGas
      aNetGas        := { ( cFacPrvT )->nNetGas1, ( cFacPrvT )->nNetGas2, ( cFacPrvT )->nNetGas3 }
      aPIvGas        := { ( cFacPrvT )->nIvaGas1, ( cFacPrvT )->nIvaGas2, ( cFacPrvT )->nIvaGas3 }
      aPReGas        := { ( cFacPrvT )->nReGas1,  ( cFacPrvT )->nReGas2,  ( cFacPrvT )->nReGas3  }
      bCondition     := {|| ( cFacPrvL )->cSerFac + Str( ( cFacPrvL )->nNumFac ) + ( cFacPrvL )->cSufFac == cFactura .AND. ( cFacPrvL )->( !eof() ) }
      ( cFacPrvL )->( dbSeek( cFactura ) )
   end





   cPinDiv           := cPinDiv( cCodDiv, cDbfDiv )
   cPirDiv           := cPirDiv( cCodDiv, cDbfDiv )
   nDinDiv           := nDinDiv( cCodDiv, cDbfDiv )
   nRinDiv           := nRinDiv( cCodDiv, cDbfDiv )

   if !lFacGas

      while Eval( bCondition )

         if lValLine( cFacPrvL )

            nTotalArt   := nTotLRctPrv( cFacPrvL, nDinDiv, nRinDiv )
            if nTotalArt <> 0

               if ( cFacPrvL )->lGasSup
                  nTotSup        += nTotalArt
               end





               do case
               case aTotIva[ 1, 3 ] == NIL .OR. aTotIva[ 1, 3 ] == (cFacPrvL)->NIVA
                  aTotIva[ 1, 3 ]   := (cFacPrvL)->nIva
                  aTotIva[ 1, 4 ]   := (cFacPrvL)->nReq
                  aTotIva[ 1, 1 ]   += nTotalArt

               case aTotIva[ 2, 3 ] == NIL .OR. aTotIva[ 2, 3 ] == (cFacPrvL)->NIVA
                  aTotIva[ 2, 3 ]   := (cFacPrvL)->nIva
                  aTotIva[ 2, 4 ]   := (cFacPrvL)->nReq
                  aTotIva[ 2, 1 ]   += nTotalArt

               case aTotIva[ 3, 3 ] == NIL .OR. aTotIva[ 3, 3 ] == (cFacPrvL)->NIVA
                  aTotIva[ 3, 3 ]   := (cFacPrvL)->nIva
                  aTotIva[ 3, 4 ]   := (cFacPrvL)->nReq
                  aTotIva[ 3, 1 ]   += nTotalArt

               end

            end

            nTotUnd         += nTotNRctPrv( cFacPrvL )

         end

         ( cFacPrvL )->( dbSkip() )

      end

      ( cFacPrvL )->( dbGoto( nRecno ) )

   else

      aTotIva[ 1, 1 ]   := aNetGas[1]
      aTotIva[ 1, 3 ]   := aPIvGas[1]
      aTotIva[ 1, 4 ]   := aPReGas[1]

      aTotIva[ 2, 1 ]   := aNetGas[2]
      aTotIva[ 2, 3 ]   := aPIvGas[2]
      aTotIva[ 2, 4 ]   := aPReGas[2]

      aTotIva[ 3, 1 ]   := aNetGas[3]
      aTotIva[ 3, 3 ]   := aPIvGas[3]
      aTotIva[ 3, 4 ]   := aPReGas[3]

   end





   aTotIva              := aSort( aTotIva,,, {|x,y| abs( x[1] ) > abs( y[1] ) } )

   aTotIva[ 1, 2 ]            := Round( aTotIva[ 1, 1 ], nRinDiv )
   aTotIva[ 2, 2 ]            := Round( aTotIva[ 2, 1 ], nRinDiv )
   aTotIva[ 3, 2 ]            := Round( aTotIva[ 3, 1 ], nRinDiv )

   nTotBrt              := aTotIva[ 1, 2 ] + aTotIva[ 2, 2 ] + aTotIva[ 3, 2 ]





   nTotBrt              += nPorte





   if !lFacGas

      IF nDtoEsp <> 0

         aTotalDto[1]   := Round( aTotIva[ 1, 2 ] * nDtoEsp / 100, nRinDiv )
         aTotalDto[2]   := Round( aTotIva[ 2, 2 ] * nDtoEsp / 100, nRinDiv )
         aTotalDto[3]   := Round( aTotIva[ 3, 2 ] * nDtoEsp / 100, nRinDiv )

         nTotDto      := aTotalDto[1] + aTotalDto[2] + aTotalDto[3]

         aTotIva[ 1, 2 ]      -= aTotalDto[1]
         aTotIva[ 2, 2 ]      -= aTotalDto[2]
         aTotIva[ 3, 2 ]      -= aTotalDto[3]

      end

      IF nDtoPP <> 0

         aTotalDPP[1]   := Round( aTotIva[ 1, 2 ] * nDtoPP / 100, nRinDiv )
         aTotalDPP[2]   := Round( aTotIva[ 2, 2 ] * nDtoPP / 100, nRinDiv )
         aTotalDPP[3]   := Round( aTotIva[ 3, 2 ] * nDtoPP / 100, nRinDiv )

         nTotDPP      := aTotalDPP[1] + aTotalDPP[2] + aTotalDPP[3]

         aTotIva[ 1, 2 ]      -= aTotalDPP[1]
         aTotIva[ 2, 2 ]      -= aTotalDPP[2]
         aTotIva[ 3, 2 ]      -= aTotalDPP[3]

      end

      IF nDtoUno <> 0

         aTotalUno[1]   := Round( aTotIva[ 1, 2 ] * nDtoUno / 100, nRinDiv )
         aTotalUno[2]   := Round( aTotIva[ 2, 2 ] * nDtoUno / 100, nRinDiv )
         aTotalUno[3]   := Round( aTotIva[ 3, 2 ] * nDtoUno / 100, nRinDiv )

         nTotUno        := aTotalUno[1] + aTotalUno[2] + aTotalUno[3]

         aTotIva[ 1, 2 ]      -= aTotalUno[1]
         aTotIva[ 2, 2 ]      -= aTotalUno[2]
         aTotIva[ 3, 2 ]      -= aTotalUno[3]

      end

      IF nDtoDos <> 0

         aTotalDos[1]   := Round( aTotIva[ 1, 2 ] * nDtoDos / 100, nRinDiv )
         aTotalDos[2]   := Round( aTotIva[ 2, 2 ] * nDtoDos / 100, nRinDiv )
         aTotalDos[3]   := Round( aTotIva[ 3, 2 ] * nDtoDos / 100, nRinDiv )

         nTotDos        := aTotalDos[1] + aTotalDos[2] + aTotalDos[3]

         aTotIva[ 1, 2 ]      -= aTotalDos[1]
         aTotIva[ 2, 2 ]      -= aTotalDos[2]
         aTotIva[ 3, 2 ]      -= aTotalDos[3]

      end

   end





   if nRegIva <= 1

      aTotIva[ 1, 5 ]         := if( aTotIva[ 1, 3 ] <> NIL, Round( aTotIva[ 1, 2 ] * aTotIva[ 1, 3 ] / 100, nRinDiv ), 0 )
      aTotIva[ 2, 5 ]         := if( aTotIva[ 2, 3 ] <> NIL, Round( aTotIva[ 2, 2 ] * aTotIva[ 2, 3 ] / 100, nRinDiv ), 0 )
      aTotIva[ 3, 5 ]         := if( aTotIva[ 3, 3 ] <> NIL, Round( aTotIva[ 3, 2 ] * aTotIva[ 3, 3 ] / 100, nRinDiv ), 0 )





      if lRecargo
         aTotIva[ 1, 6 ]   := if( aTotIva[ 1, 3 ] <> NIL, Round( aTotIva[ 1, 2 ] * aTotIva[ 1, 4 ] / 100, nRinDiv ), 0 )
         aTotIva[ 2, 6 ]   := if( aTotIva[ 2, 3 ] <> NIL, Round( aTotIva[ 2, 2 ] * aTotIva[ 2, 4 ] / 100, nRinDiv ), 0 )
         aTotIva[ 3, 6 ]   := if( aTotIva[ 3, 3 ] <> NIL, Round( aTotIva[ 3, 2 ] * aTotIva[ 3, 4 ] / 100, nRinDiv ), 0 )
      end

   end





   nTotIva           := Round( aTotIva[ 1, 5 ] + aTotIva[ 2, 5 ] + aTotIva[ 3, 5 ], nRinDiv )





   nTotReq           := Round( aTotIva[ 1, 6 ] + aTotIva[ 2, 6 ] + aTotIva[ 3, 6 ], nRinDiv )





   nTotNet           := Round( aTotIva[ 1, 2 ] + aTotIva[ 2, 2 ] + aTotIva[ 3, 2 ], nRinDiv )





   nTotImp           := Round( nTotIva + nTotReq, nRinDiv )





   if isNum( nTipRet )
      if nTipRet <= 1
         nTotRet     := Round( ( nTotNet - nTotSup ) * nPctRet / 100, nRinDiv )
      else
         nTotRet     := Round( ( nTotNet - nTotSup + nTotIva ) * nPctRet / 100, nRinDiv )
      end
   end





   nTotFac           := Round( nTotNet + nTotImp - nTotRet, nRinDiv )





   if cFacPrvP <> nil
      nPagFac        := nPagRctPrv( cFactura, cFacPrvP, cCodDiv, cDbfDiv, .T., aTmp )
   end

   aTotIva           := aSort( aTotIva,,, {|x,y| abs( x[1] ) > abs( y[1] ) } )





   if cDivRet <> nil .AND. cDivRet <> cCodDiv
      nTotNet     := nCnv2Div( nTotNet, cCodDiv, cDivRet, cDbfDiv )
      nTotIva     := nCnv2Div( nTotIva, cCodDiv, cDivRet, cDbfDiv )
      nTotReq     := nCnv2Div( nTotReq, cCodDiv, cDivRet, cDbfDiv )
      nTotFac     := nCnv2Div( nTotFac, cCodDiv, cDivRet, cDbfDiv )
      cPirDiv     := cPirDiv( cDivRet, cDbfDiv )
   end

RETURN ( if( lPic, Trans( nTotFac, cPirDiv ), nTotFac ) )



Static Function RecalculaTotal( aTmp )

   nTotRctPrv( nil, dbfRctPrvT, dbfTmp, dbfIva, dbfDiv, dbfTmpPgo, aTmp )

   if oBrwIva <> nil
      oBrwIva:refresh()
   end

   if oGetNet <> nil
      oGetNet:SetText( Trans( nTotNet, cPirDiv ) )
   end

   if oGetIva <> nil
      oGetIva:SetText( Trans( nTotIva, cPirDiv ) )
   end

   if oGetReq <> nil
      oGetReq:SetText( Trans( nTotReq, cPirDiv ) )
   end

   if oGetTotal <> nil
      oGetTotal:SetText( Trans( nTotFac, cPirDiv ) )
   end

   if oGetRet <> nil
      oGetRet:SetText( Trans( nTotRet, cPirDiv ) )
   end

   if oGetTotPg <> nil
      oGetTotPg:SetText( Trans( nTotFac, cPirDiv ) )
   end

   if oGetPgd <> nil
      oGetPgd:SetText( Trans( nPagFac, cPirDiv ) )
   end

   if oGetPdt <> nil
      oGetPdt:SetText( Trans( nTotFac - nPagFac, cPirDiv ) )
   end

Return .T.



function nVtaRctPrv( cCodPrv, dDesde, dHasta, dbfRctPrvT, dbfRctPrvL, dbfIva, dbfDiv, nYear )

   local nCon     := 0
   local nRec     := ( dbfRctPrvT )->( Recno() )





   if ( dbfRctPrvT )->( dbSeek( cCodPrv ) )

      while ( dbfRctPrvT )->cCodPrv == cCodPrv .AND. !( dbfRctPrvT )->( Eof() )



         if ( dDesde == nil .OR. ( dbfRctPrvT )->dFecFac >= dDesde )    .AND. ( dHasta == nil .OR. ( dbfRctPrvT )->dFecFac <= dHasta )    .AND. ( nYear == nil .OR. Year( ( dbfRctPrvT )->dFecFac ) == nYear )

            nCon  += nTotRctPrv( ( dbfRctPrvT )->cSerFac + Str( (dbfRctPrvT)->nNumFac ) + (dbfRctPrvT)->cSufFac, dbfRctPrvT, dbfRctPrvL, dbfIva, dbfDiv, nil, nil, cDivEmp(), .F. )

         end

         ( dbfRctPrvT )->( dbSkip() )

      end

   end

   ( dbfRctPrvT )->( dbGoTo( nRec ) )

return nCon






function nCobRctPrv( cCodPrv, dDesde, dHasta, dbfRctPrvT, dbfRctPrvP, dbfIva, dbfDiv, lOnlyCob, nYear )

   local nCob        := 0
   local nOrd        := ( dbfRctPrvT )->( OrdSetFocus( "cCodPrv" ) )
   local nRec        := ( dbfRctPrvT )->( Recno() )

   IIF( lOnlyCob == nil, lOnlyCob := .T., ) ;





   if ( dbfRctPrvT )->( dbSeek( cCodPrv ) )

      while ( dbfRctPrvT )->cCodPrv = cCodPrv .AND. !( dbfRctPrvT )->( Eof() )



         if ( dDesde == nil .OR. ( dbfRctPrvT )->DFECFAC >= dDesde ) .AND. ( dHasta == nil .OR. ( dbfRctPrvT )->DFECFAC <= dHasta ) .AND. ( nYear == nil .OR. Year( ( dbfRctPrvT )->dFecFac ) == nYear )

            nCob  += nPagRctPrv( ( dbfRctPrvT )->cSerFac + Str( (dbfRctPrvT)->nNumFac ) + (dbfRctPrvT)->cSufFac, dbfRctPrvP, cDivEmp(), dbfDiv, lOnlyCob )

         end

         ( dbfRctPrvT )->( dbSkip() )

      end

   end

   ( dbfRctPrvT )->( OrdSetFocus( nOrd ) )
   ( dbfRctPrvT )->( dbGoTo( nRec ) )

return nCob



Static Function nGenRctPrv( nDevice, cCaption, cCodDoc, cPrinter, nCopies )

   local nFac

   CursorWait()

   for each nFac in ( oWndBrw:oBrw:aSelected )

      ( dbfRctPrvT )->( dbGoTo( nFac ) )

      GenRctPrv( nDevice, cCaption, cCodDoc, cPrinter, nCopies )

   next

   CursorWE()

Return ( nil )



Static Function GenRctPrv( nDevice, cCaption, cCodDoc, cPrinter, nCopies )

   local oDevice
   local nFactura

   if ( dbfRctPrvT )->( Lastrec() ) == 0
      Return nil
   end

   nFactura             := ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac

   IIF( nDevice == nil, nDevice := 1, ) ;
   IIF( cCaption == nil, cCaption := "Imprimiendo facturas rectificativas de proveedores", ) ;
   IIF( cCodDoc == nil, cCodDoc := cFormatoDocumento( ( dbfRctPrvT )->cSerFac, "nRctPrv", dbfCount ), ) ;
   IIF( nCopies == nil, nCopies := if( nCopiasDocumento( ( dbfRctPrvT )->cSerFac, "nRctPrv", dbfCount ) == 0, Max( Retfld( ( dbfRctPrvT )->cCodPrv, dbfPrv, "nCopiasF" ), 1 ), nCopiasDocumento( ( dbfRctPrvT )->cSerFac, "nRctPrv", dbfCount ) ), ) ;

   if Empty( cCodDoc )
      cCodDoc           := cFirstDoc( "TP", dbfDoc )
   end

   if !lExisteDocumento( cCodDoc, dbfDoc )
      return nil
   end





   if lVisualDocumento( cCodDoc, dbfDoc )

      PrintReportRctPrv( nDevice, nCopies, cPrinter, dbfDoc )

   else





      nTotRctPrv( nFactura, dbfRctPrvT, dbfRctPrvL, dbfIva, dbfDiv, dbfRctPrvP )





      ( dbfRctPrvL )->( dbSeek( nFactura ) )
      ( dbfRctPrvP )->( dbSeek( nFactura ) )





      ( dbfPrv   )->( dbSeek( ( dbfRctPrvT )->cCodPrv ) )
      ( dbfAlm   )->( dbSeek( ( dbfRctPrvT )->cCodAlm ) )
      ( dbfFPago )->( dbSeek( ( dbfRctPrvT )->cCodPago) )
      ( dbfDiv   )->( DbSeek( ( dbfRctPrvT )->cDivFac ) )

      private cDbf         := dbfRctPrvT
      private cDbfCol      := dbfRctPrvL
      private cDbfRec      := dbfRctPrvP
      private cDbfAlm      := dbfAlm
      private cDbfPrv      := dbfPrv
      private cDbfPgo      := dbfFPago
      private cDbfIva      := dbfIva
      private cDbfDiv      := dbfDiv
      private cDbfArt      := dbfArticulo
      private cDbfKit      := dbfKit
      private cDbfPro      := dbfPro
      private cDbfTblPro   := dbfTblPro
      private nTotPage     := nTotLRctPrv( dbfRctPrvL )
      private cPinDivFac   := cPinDiv
      private cPirDivFac   := cPirDiv
      private cPicEurFac   := cPicEur
      private nDinDivFac   := nDinDiv
      private nDirDivFac   := nRinDiv
      private nVdvDivFac   := ( dbfRctPrvT )->nVdvFac

      if !Empty( cPrinter )
         oDevice           := TPrinter():New( cCaption, .F., .T., cPrinter )
         oInf := RptBegin({}, {}, {}, {}, {}, .F.,,,, .F.,, oDevice, cCaption,,, )
      else
         oInf := RptBegin({}, {}, {}, {}, {}, .F.,,,, .T.,,, cCaption,,, )
      end





      if !Empty( oInf ) .AND. oInf:lCreated
         oInf:lAutoLand          := .F.
         oInf:lFinish            := .F.
         oInf:lNoCancel          := .T.
         oInf:bSkip              := {|| FacPrvReportSkipper( dbfRctPrvL ) }

         oInf:oDevice:lPrvModal  := .T.

         do case
            case nDevice == 1
               oInf:bPreview  := {| oDevice | PrintPreview( oDevice ) }

            case nDevice == 3
               oInf:bPreview  := {| oDevice | PrintPdf( oDevice ) }

         end

         SetMargin(  cCodDoc, oInf )
         PrintColum( cCodDoc, oInf )
      end

      RptEnd()

      if !Empty( oInf )



         oInf:Activate(, {||       ( ( dbfRctPrvL )->cSerFac + Str( ( dbfRctPrvL )->nNumFac ) + ( dbfRctPrvL )->cSufFac = nFactura )},,,, {||  ( Epage( oInf, cCodDoc ) )},,,,,,,, )

         if nDevice == 1
            oInf:oDevice:end()
         end

      end

      oInf                 := nil

   end

   lChgImpDoc( dbfRctPrvT )

RETURN NIL



Static Function FacPrvReportSkipper( dbfRctPrvL )

   ( dbfRctPrvL )->( dbSkip() )

   nTotPage              += nTotLRctPrv( dbfRctPrvL )

Return nil



STATIC FUNCTION lMoreIva( nCodIva )





    IF aTotIva[ 1, 3 ] == NIL .OR. aTotIva[ 2, 3 ] == NIL .OR. aTotIva[ 3, 3 ] == NIL
        RETURN .T.
    end

    IF aTotIva[ 1, 3 ] == nCodIva .OR. aTotIva[ 2, 3 ] == nCodIva .OR. aTotIva[ 3, 3 ] == nCodIva
        RETURN .T.
    end

   MsgStop( "Factura con mas de 3 tipos de " + cImp(), "Imposible añadir" )

RETURN .F.



STATIC FUNCTION ChgFactu( dbfRctPrvT, oBrw )

   if dbLock( dbfRctPrvT )
      ( dbfRctPrvT )->lLiquidada := !( dbfRctPrvT )->lLiquidada
      ( dbfRctPrvT )->( dbUnLock() )
   end

    oBrw:refresh()

RETURN NIL



STATIC FUNCTION loaPrv( aGet, aTmp, dbfPrv, nMode, oSay, oTlfPrv )

   local lValid      := .F.
   local cNewCodCli  := aGet[ 6 ]:VarGet()
   local lChgCodCli  := ( Empty( cOldCodCli ) .OR. cOldCodCli <> cNewCodCli )

   if Empty( cNewCodCli )
      Return .T.
   elseif At( ".", cNewCodCli ) <> 0
      cNewCodCli := PntReplace( aGet[6], "0", RetNumCodPrvEmp() )
   else
      cNewCodCli := Rjust( cNewCodCli, "0", RetNumCodPrvEmp() )
   end

   if ( dbfPrv )->( dbSeek( cNewCodCli ) )

      if ( dbfPrv )->lBlqPrv
         msgStop( "Proveedor bloqueado, no se pueden realizar operaciones de compra" )
         return .F.
      end

      aGet[6 ]:cText( ( dbfPrv )->Cod )

      if Empty( aGet[9]:varGet() ) .OR. lChgCodCli
         aGet[9]:cText( ( dbfPrv )->Titulo )
      end

      if oTlfPrv <> nil
         oTlfPrv:SetText( ( dbfPrv )->Telefono )
      end

      if Empty( aGet[10]:varGet() ) .OR. lChgCodCli
         aGet[10]:cText( ( dbfPrv )->Domicilio )
      endif

      if Empty( aGet[11]:varGet() ) .OR. lChgCodCli
         aGet[11]:cText( (dbfPrv)->POBLACION )
      endif

      if Empty( aGet[12]:varGet() ) .OR. lChgCodCli
         aGet[12]:cText( (dbfPrv)->PROVINCIA )
      endif

      if Empty( aGet[13]:varGet() ) .OR. lChgCodCli
         aGet[13]:cText( (dbfPrv)->CODPOSTAL )
      endif

      if Empty( aGet[14]:varGet() ) .OR. lChgCodCli
         aGet[14]:cText( (dbfPrv)->NIF )
      endif

      if lChgCodCli
         aGet[ 28 ]:cText( ( dbfPrv )->cDtoEsp )
         aGet[ 29 ]:cText( ( dbfPrv )->nDtoEsp )
         aGet[ 30    ]:cText( ( dbfPrv )->cDtoPP )
         aGet[ 31    ]:cText( ( dbfPrv )->DtoPP )
      end

      if Empty( aGet[ 23 ]:VarGet() ) .OR. lChgCodCli

         aGet[ 23 ]:cText( ( dbfPrv )->fPago )
         aGet[ 23 ]:lValid()





         if RetFld( aTmp[ 23 ], dbfFPago, "LUTLBNC" )

            if dbSeekInOrd( ( dbfPrv )->Cod, "CCODDEF", dbfPrvBnc )

               if !Empty( aGet[ 74 ] )
                  aGet[ 74 ]:cText( ( dbfPrvBnc )->cCodBnc )
                  aGet[ 74 ]:lValid()
               end

               if !Empty( aGet[ 75 ] )
                  aGet[ 75 ]:cText( ( dbfPrvBnc )->cEntBnc )
                  aGet[ 75 ]:lValid()
               end

               if !Empty( aGet[ 76 ] )
                  aGet[ 76 ]:cText( ( dbfPrvBnc )->cSucBnc )
                  aGet[ 76 ]:lValid()
               end

               if !Empty( aGet[ 77 ] )
                  aGet[ 77 ]:cText( ( dbfPrvBnc )->cDigBnc )
                  aGet[ 77 ]:lValid()
               end

               if !Empty( aGet[ 78 ] )
                  aGet[ 78 ]:cText( ( dbfPrvBnc )->cCtaBnc )
                  aGet[ 78 ]:lValid()
               end

            end

         end

      end

      if Empty( aGet[ 50 ]:VarGet() ) .OR. lChgCodCli
         aGet[ 50 ]:oGet:cText(  ( dbfPrv )->nTipRet )
         aGet[ 50 ]:Select(      ( dbfPrv )->nTipRet )
      end

      if Empty( aGet[ 51 ]:VarGet() ) .OR. lChgCodCli
         aGet[ 51 ]:cText( ( dbfPrv )->nPctRet )
      end

      if nMode == 1
         aGet[ 55 ]:nOption( Max( ( dbfPrv )->nRegIva, 1 ) )
         aGet[ 55 ]:Refresh()

         if Empty( aTmp[ 1 ] )

            if !Empty( ( dbfPrv )->Serie )
               aGet[ 1 ]:cText( ( dbfPrv )->Serie )
            end

         else

            if !Empty( ( dbfPrv )->Serie ) .AND. aTmp[ 1 ] <> ( dbfPrv )->Serie .AND. ApoloMsgNoYes( "La serie del proveedor seleccionado es distinta a la anterior.", "¿Desea cambiar la serie?" )
               aGet[ 1 ]:cText( ( dbfPrv )->Serie )
            end

         end

      end

      if lChgCodCli
         aTmp[ 32 ] := ( dbfPrv )->lReq
         aGet[ 32 ]:Refresh()
      end

      if ( dbfPrv )->lMosCom .AND. !Empty( ( dbfPrv )->mComent ) .AND. lChgCodCli
         MsgStop( AllTrim( ( dbfPrv )->mComent ) )
      end

      cOldCodCli  := ( dbfPrv )->Cod
      lValid      := .T.

    ELSE

        msgStop( "Proveedor no encontrado" )

    end

RETURN lValid







STATIC FUNCTION LoaArt( aGet, aTmp, aTmpFac, oFld, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oBmp, oBrwPrp, oGetIra, oDlg, oStkAct, oTotal )

   local nIva
   local nOrdAnt
   local nPreUnt
   local nPreCom
   local cCodFam
   local cPrpArt
   local cCodPrv
   local cCodArt
   local lChgCodArt
   local lSeek       := .F.

   nIva              := 0
   cCodPrv           := aTmpFac[ 6 ]
   cCodArt           := aGet[ 4    ]:VarGet()
   cPrpArt           := aTmp[ 52 ] + aTmp[ 53 ] + aTmp[ 54 ] + aTmp[ 55 ]
   lChgCodArt        := ( Rtrim( cOldCodArt ) <> Rtrim( cCodArt ) .OR. Rtrim( cOldPrpArt ) <> Rtrim( cPrpArt ) )

   if Empty( cCodArt )

      if lRetCodArt()
         MsgStop( "No se pueden añadir lineas sin codificar" )
         return .F.
      end

        aGet[9    ]:bWhen    := {|| .T. }

      aGet[6]:Hide()

      aGet[15 ]:Show()
      aGet[15 ]:SetFocus()

      if !Empty( oBrwPrp )
         oBrwPrp:Hide()
      end

   else

      if lModIva()
            aGet[9 ]:bWhen    := {|| .T. }
      else
            aGet[9 ]:bWhen    := {|| .F. }
      end

        aGet[4    ]:show()
        aGet[6]:show()
        aGet[15 ]:hide()

      if !( ( dbfArticulo )->( dbSeek( cCodArt ) ) .OR. ( dbfArticulo )->( dbSeek( Upper( cCodArt ) ) ) )





         nOrdAnt                 := ( dbfArtPrv )->( OrdSetFocus( "cRefPrv" ) )

         if ( dbfArtPrv )->( dbSeek( cCodPrv + cCodArt ) )
            cCodArt              := ( dbfArtPrv )->cCodArt
         end

         ( dbfArtPrv )->( ordSetFocus( nOrdAnt ) )





         cCodArt                 := cSeekCodebar( cCodArt, dbfCodebar, dbfArticulo )

         lSeek                   := ( ( dbfArticulo )->( dbSeek( cCodArt ) ) .OR. ( dbfArticulo )->( dbSeek( Upper( cCodArt ) ) ) )

      else

         lSeek                   := .T.

      end







      if lSeek

         if ( lChgCodArt )

            if ( dbfArticulo )->lObs
               MsgStop( "Artículo catalogado como obsoleto" )
               return .F.
            end






            aTmp[ 59  ]         := ( dbfArticulo )->lLote

            if ( dbfArticulo )->lLote
               aGet[ 61   ]:show()
               aGet[ 61   ]:cText( ( dbfArticulo )->cLote )
               aGet[ 62 ]:show()
               aGet[ 62 ]:cText( dFechaCaducidad( aTmpFac[ 5 ], ( dbfArticulo )->nDuracion, ( dbfArticulo )->nTipDur ) )
            else
               aGet[ 61   ]:hide()
               aGet[ 62 ]:hide()
            end





            cCodFam              := ( dbfArticulo )->Familia
            if !Empty( cCodFam )
               aTmp[79]    := cCodFam
               aTmp[80]    := cGruFam( cCodFam, dbfFamilia )
            end





            if ( dbfArticulo )->lKitArt
               aTmp[ 65 ]     := ( dbfArticulo )->lKitArt
               aTmp[ 68 ]     := lImprimirCompuesto( ( dbfArticulo )->Codigo, dbfArticulo )
               aTmp[ 67 ]     := lPreciosCompuestos( ( dbfArticulo )->Codigo, dbfArticulo )
               if lStockCompuestos( ( dbfArticulo )->Codigo, dbfArticulo )
                  aTmp[ 58 ]  := ( dbfArticulo )->nCtlStock
               else
                  aTmp[ 58 ]  := 3
               end
            else
               aTmp[ 68 ]     := .F.
               aTmp[ 58 ]     := ( dbfArticulo )->nCtlStock
            end





            if oStkAct <> nil .AND. aTmp[ 58 ] <= 1
               oStock:nPutStockActual( cCodArt, aTmpFac[ 7 ], , , , aTmp[ 65 ], aTmp[ 58 ], oStkAct )
            end





            nPreUnt  := aGet[ 7 ]:VarGet()





            oFld:aEnable := { .T., .T., .T. }
            oFld:refresh()

            aGet[4    ]:cText( ( dbfArticulo )->Codigo )
            aGet[6]:cText( ( dbfArticulo )->Nombre )

            if ( dbfArticulo )->lMosCom .AND. !Empty( ( dbfArticulo )->mComent )
               MsgStop( Trim( ( dbfArticulo )->mComent ) )
            end





            nIva           := nIva( dbfIva, ( dbfArticulo )->TipoIva )
            aGet[ 9    ]:cText( nIva )

            aTmp[ 81 ]  := nReq( dbfIva, ( dbfArticulo )->TipoIva )

            if ( dbfArticulo )->nCajEnt <> 0
               aGet[10]:cText( ( dbfArticulo )->nCajEnt )
            end

            if ( dbfArticulo )->nUniCaja <> 0
               aGet[13]:cText( ( dbfArticulo )->nUniCaja )
            end





            nOrdAnt                 := ( dbfArtPrv )->( OrdSetFocus( "cCodPrv" ) )

            if ( dbfArtPrv )->( dbSeek( cCodPrv + cCodArt ) )

               if !Empty( aGet[ 5 ] )
                  aGet[ 5 ]:cText( ( dbfArtPrv )->cRefPrv )
               end

            else

               if !Empty( aGet[ 5 ] )
                  aGet[ 5 ]:cText( Space( 20 ) )
               end

            end

            ( dbfArtPrv )->( ordSetFocus( nOrdAnt ) )





            aTmp[ 83 ]     := ( dbfArticulo )->PvpRec





            aTmp[ 52 ]     := ( dbfArticulo )->cCodPrp1
            aTmp[ 53 ]     := ( dbfArticulo )->cCodPrp2

            if ( !Empty( aTmp[ 52 ] ) .OR. !Empty( aTmp[ 53 ] ) ) .AND. uFieldEmpresa( "lUseTbl" )

               nPreCom           := nCosto( nil, dbfArticulo, dbfKit, .F., aTmpFac[ 35 ], dbfDiv )

               LoadPropertiesTable( cCodArt, nPreCom, aTmp[ 52 ], aTmp[ 53 ], dbfPro, dbfTblPro, dbfArtCom, oBrwPrp, aGet[ 13 ], aGet[ 7 ] )

               oGetIra:Show()

            else

               oBrwPrp:Hide()
               oGetIra:Hide()

               if !Empty( aTmp[ 52 ] )

                  if aGet[ 54 ] <> nil
                     aGet[ 54 ]:Show()
                     aGet[ 54 ]:SetFocus()
                  end

                  if oSayPr1 <> nil
                     oSayPr1:SetText( retProp( ( dbfArticulo )->cCodPrp1, dbfPro ) )
                     oSayPr1:Show()
                  end

                  if oSayVp1 <> nil
                     oSayVp1:Show()
                  end

               else

                  if aGet[ 54 ] <>  nil
                     aGet[ 54 ]:Hide()
                  end

                  if oSayPr1 <> nil
                     oSayPr1:Hide()
                  end

                  if oSayVp1 <> nil
                     oSayVp1:Hide()
                  end

               end

               if !Empty( aTmp[53 ] )

                  if aGet[ 55 ] <> nil
                     aGet[ 55 ]:Show()
                  end

                  if oSayPr2 <> nil
                     oSayPr2:SetText( retProp( ( dbfArticulo )->cCodPrp2, dbfPro ) )
                     oSayPr2:Show()
                  end

                  if oSayVp2 <> nil
                     oSayVp2:Show()
                  end

               else

                  if aGet[ 55 ] <> nil
                     aGet[ 55 ]:Hide()
                  end

                  if oSayPr2 <> nil
                     oSayPr2:Hide()
                  end

                  if oSayVp2 <> nil
                     oSayVp2:Hide()
                  end

               end

            end





            if !Empty( aGet[ 12 ] )
               aGet[ 12 ]:cText( ( dbfArticulo )->cUnidad )
               aGet[ 12 ]:lValid()
            else
               aTmp[ 12 ]  := ( dbfArticulo )->cUnidad
            end

            ValidaMedicion( aTmp, aGet)

         end

         cPrpArt                 := aTmp[ 52 ] + aTmp[ 53 ] + aTmp[ 54 ] + aTmp[ 55 ]

         if ( lChgCodArt ) .OR. ( cPrpArt <> cOldPrpArt )





            nPreCom              := nComPro( aTmp[ 4 ], aTmp[ 52 ], aTmp[ 54 ], aTmp[ 53 ], aTmp[ 55 ], dbfArtCom )
            if nPrecom  <> 0

               aGet[ 7 ]:cText( nPreCom )

            else

               if uFieldEmpresa( "lCosPrv", .F. )
                  nPreCom     := nPreArtPrv( cCodPrv, cCodArt, dbfArtPrv )
               end

               if nPreCom <> 0
                  aGet[ 7 ]:cText( nPreCom )
               else
                  aGet[ 7 ]:cText( nCosto( nil, dbfArticulo, dbfKit, .F., aTmpFac[ 35 ], dbfDiv ) )
               end

            end

         end





         lCalcDeta( aTmp, aTmpFac, aGet, oTotal )

      else

         MsgStop( "Artículo no encontrado" )
         Return .F.

      end

   end

   cOldCodArt                    := cCodArt
   cOldPrpArt                    := cPrpArt

Return .T.



STATIC FUNCTION LoadPreCosto( aGet, oGet )

    local xValor   := aGet[4]:varGet()

    IF Empty( xValor )
        RETURN .F.
    end

   if oGet == nil
      return .F.
   end

   IF ( dbfArticulo )->( dbSeek( xValor ) )
      oGet:cText( ( dbfArticulo )->pCosto )
    end

    aGet[4]:bWhen := {|| .F. }

RETURN .F.



STATIC FUNCTION LoadArtPed( aGet )

   local lValid               := .F.
   local xValor               := aGet[4]:varGet()

    IF Empty( xValor )

        aGet[9]:cText( 0 )
      aGet[9]:bWhen       := {|| .T. }

        aGet[6]:cText( Space( 50 ) )
      aGet[6]:bWhen   := {|| .T. }

        RETURN .T.

    end

   if ( dbfArticulo )->( dbSeek( xValor ) )

      aGet[4    ]:cText( ( dbfArticulo )->Codigo )
      aGet[4    ]:bWhen   := {|| .T. }

      aGet[6]:cText( ( dbfArticulo )->Nombre )
      aGet[7]:cText( ( dbfArticulo )->pCosto )

      lValid                  := .T.

   else

      MsgStop( "Artículo no encontrado" )

   end

RETURN lValid



STATIC FUNCTION GetArtPrv( cRefPrv, cCodPrv, aGet )

    local nOrdAnt

   if Empty( cRefPrv )

      return .T.

   else

        nOrdAnt  := ( dbfArtPrv )->( ordSetFocus( 3 ) )

      if ( dbfArtPrv )->( dbSeek( cCodPrv + cRefPrv ) )

         aGet[ 4 ]:cText( ( dbfArtPrv )->cCodArt )
            aGet[ 4 ]:lValid()

      else

         msgStop( "Referencia de proveedor no encontrada" )

      end

        ( dbfArtPrv )->( ordSetFocus( nOrdAnt ) )

   end

return .T.



STATIC FUNCTION SearchFact( oBrw )

    local oDlg
    local xToSearch
    local nNumFac    := 0
   local cCodCli  := (dbfRctPrvT)->CCODPRV
    local dFactura    := date()
   local nIndex   := (dbfRctPrvT)->(OrdNumber())

    oDlg = TDialog():New(,,,,, "FINFACPRV",, .F.,,,,,, .F.,,,,,, .F., )







        TGetHlp():ReDefine( 130, { | u | If( PCount()==0, nNumFac, nNumFac:= u ) }, oDlg,, "999999999", {||     ( xToSearch := nNumFac, .T. )}, "N/W*",,,,, .F., {||         ( nIndex == 1 )},, .F., .F.,,,,,, nil,,, )






        TGetHlp():ReDefine( 140, { | u | If( PCount()==0, dFactura, dFactura:= u ) }, oDlg,,, {||     ( xToSearch := dFactura, .T. )}, "N/W*",,,,, .F., {||         ( nIndex == 2 )},, .F., .F.,,,,,, nil,,, )






        TGetHlp():ReDefine( 150, { | u | If( PCount()==0, cCodCli, cCodCli:= u ) }, oDlg,,, {||    ( xToSearch := cCodCli, .T. )}, "N/W*",,,,, .F., {||         ( nIndex == 3 )},, .F., .F.,,,,,, nil,,, )




        TButton():ReDefine( 504, {||( (dbfRctPrvT)->( dbSeek( xToSearch ) ), oBrw:Refresh() )}, oDlg,,, .F.,,,, .F. )





        TButton():ReDefine( 510, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN NIL



STATIC FUNCTION EPage( oInf, cCodDoc )

   private nPagina      := oInf:nPage
    private lEnd            := oInf:lFinish





   PrintItems( cCodDoc, oInf )

RETURN NIL



STATIC FUNCTION aGetSelRec( oBrw, bAction, cTitle, lHide1, cTitle1, lHide2, cTitle2, bPreAction, bPostAction )

   local oDlg
   local oRad
   local nRad        := 1
   local aRet        := {}
   local oTree
   local oChk1
   local oChk2
   local lChk1       := .T.
   local lChk2       := .T.
   local nRecno      := ( dbfRctPrvT )->( Recno() )
   local nOrdAnt     := ( dbfRctPrvT )->( OrdSetFocus( 1 ) )
   local oSerIni
   local oSerFin
   local cSerIni     := ( dbfRctPrvT )->cSerFac
   local cSerFin     := ( dbfRctPrvT )->cSerFac
   local oDocIni
   local oDocFin
   local nDocIni     := ( dbfRctPrvT )->nNumFac
   local nDocFin     := ( dbfRctPrvT )->nNumFac
   local oSufIni
   local oSufFin
   local cSufIni     := ( dbfRctPrvT )->cSufFac
   local cSufFin     := ( dbfRctPrvT )->cSufFac
   local oMtrInf
   local nMtrInf
   local lFechas     := .T.
   local dDesde      := CtoD( "01/01/" + Str( Year( Date() ) ) )
   local dHasta      := Date()
   local oImageList
   local oBtnCancel

   IIF( cTitle == nil, cTitle := "", ) ;
   IIF( lHide1 == nil, lHide1 := .F., ) ;
   IIF( cTitle1 == nil, cTitle1 := "", ) ;
   IIF( lHide2 == nil, lHide2 := .F., ) ;
   IIF( cTitle2 == nil, cTitle2 := "", ) ;

   oImageList        := TImageList():New( 16, 16 )
   oImageList:AddMasked( TBitmap():Define( "Bullet_Square_Red_16" ),    ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )
   oImageList:AddMasked( TBitmap():Define( "Bullet_Square_Green_16" ),  ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )

   oDlg = TDialog():New(,,,, cTitle, "SelectRango",, .F.,,,,,, .F.,,,,,, .F., )



   oRad := TRadMenu():Redefine( { | u | If( PCount()==0, nRad, nRad:= u ) }, oDlg,, { 80, 81 },,,,, .F.,, )










   oSerIni := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, cSerIni, cSerIni:= u ) }, oDlg,, "@!", {||    ( cSerIni >= "A" .AND. cSerIni <= "Z" )},,,,,, .T., {||     ( oRad:nOption == 2 )},, .F., .T., {||    ( UpSerie( oSerIni ) )}, {||  ( DwSerie( oSerIni ) )},,,, nil,,, )






   TBtnBmp():ReDefine( 101, "Up16",,,,, {|Self|( dbFirst( dbfRctPrvT, "nNumFac", oDocIni, cSerIni, "nNumFac" ) )}, oDlg, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F. )










   oSerFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cSerFin, cSerFin:= u ) }, oDlg,, "@!", {||    ( cSerFin >= "A" .AND. cSerFin <= "Z" )},,,,,, .T., {||     ( oRad:nOption == 2 )},, .F., .T., {||    ( UpSerie( oSerFin ) )}, {||  ( DwSerie( oSerFin ) )},,,, nil,,, )






   TBtnBmp():ReDefine( 111, "Down16",,,,, {|Self|( dbLast( dbfRctPrvT, "nNumFac", oDocFin, cSerFin, "nNumFAc" ) )}, oDlg, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F. )






   oDocIni := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, nDocIni, nDocIni:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( nRad == 2 )},, .F., .T.,,,,,, nil,,, )






   oDocFin := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, nDocFin, nDocFin:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( nRad == 2 )},, .F., .T.,,,,,, nil,,, )





   oSufIni := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, cSufIni, cSufIni:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )





   oSufFin := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, cSufFin, cSufFin:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )



   oChk1 := TCheckBox():ReDefine( 160, { | u | If( PCount()==0, lChk1, lChk1:= u ) }, oDlg,,,,,,, .F.,, .F. )



   oChk2 := TCheckBox():ReDefine( 180, { | u | If( PCount()==0, lChk2, lChk2:= u ) }, oDlg,,,,,,, .F.,, .F. )







   TCheckBox():ReDefine( 300, { | u | If( PCount()==0, lFechas, lFechas:= u ) }, oDlg,,,,,,, .F.,, .F. )





   TGetHlp():ReDefine( 310, { | u | If( PCount()==0, dDesde, dDesde:= u ) }, oDlg,,,,,,,,, .F., {||     ( !lFechas )},, .F., .T.,,,,,, nil,,, )





    TGetHlp():ReDefine( 320, { | u | If( PCount()==0, dHasta, dHasta:= u ) }, oDlg,,,,,,,,, .F., {||     ( !lFechas )},, .F., .T.,,,,,, nil,,, )





   oTree             := TTreeView():Redefine( 170, oDlg )
   oTree:bLDblClick  := {|| TreeChanged( oTree ) }





   oMtrInf := TMeter():ReDefine( 200, { | u | If( PCount()==0, nMtrInf, nMtrInf:= u ) },, oDlg, .F.,,, .T.,,,, )

   oMtrInf:SetTotal( ( dbfRctPrvT )->( OrdKeyCount() ) )




   TButton():ReDefine( 1, {||( MakSelRec( bAction, bPreAction, bPostAction, cSerIni + Str( nDocIni, 9 ) + cSufIni, cSerFin + Str( nDocFin, 9 ) + cSufFin, nRad, lChk1, lChk2, lFechas, dDesde, dHasta, oDlg, oTree, oBrw, oMtrInf, oBtnCancel ) )}, oDlg,,, .F.,,,, .F. )





   oBtnCancel := TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   oDlg:bStart := {|| StartGetSelRec( oBrw, oRad, oChk1, oChk2, oSerIni, oSerFin, oDocIni, oDocFin, oSufIni, oSufFin, lHide1, lHide2, cTitle1, cTitle2 ) }

   oDlg:AddFastKey( 116, {|| MakSelRec( bAction, bPreAction, bPostAction, cSerIni + Str( nDocIni, 9 ) + cSufIni, cSerFin + Str( nDocFin, 9 ) + cSufFin, nRad, lChk1, lChk2, lFechas, dDesde, dHasta, oDlg, oTree, oBrw, oMtrInf, oBtnCancel ) } )



   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( oTree:SetImageList( oImageList ) )}, oDlg:bRClicked,,, )

   ( dbfRctPrvT )->( ordSetFocus( nOrdAnt ) )
   ( dbfRctPrvT )->( dbGoTo( nRecNo ) )

   oImageList:End()

   oTree:Destroy()

   oBrw:SetFocus()
   oBrw:Refresh()

RETURN ( aRet )



Static Function StartGetSelRec( oBrw, oRad, oChk1, oChk2, oSerIni, oSerFin, oDocIni, oDocFin, oSufIni, oSufFin, lHide1, lHide2, cTitle1, cTitle2 )

   if !Empty( oBrw ) .AND. ( len( oBrw:oBrw:aSelected ) > 1 )

      oRad:SetOption( 1 )

   else

      oRad:SetOption( 2 )

      oSerIni:Enable()
      oSerFin:Enable()
      oDocIni:Enable()
      oDocFin:Enable()
      oSufIni:Enable()
      oSufFin:Enable()

   end

   if lHide1
      oChk1:Hide()
   else
      SetWindowText( oChk1:hWnd, cTitle1 )
      oChk1:Refresh()
   end

   if lHide2
      oChk2:Hide()
   else
      SetWindowText( oChk2:hWnd, cTitle2 )
      oChk2:Refresh()
   end

Return ( nil )



Static Function TreeChanged( oTree )

   local oItemTree   := oTree:GetItem()

   if !Empty( oItemTree ) .AND. !Empty( oItemTree:bAction )
      Eval( oItemTree:bAction )
   end

RETURN NIL



Static Function MakSelRec( bAction, bPreAction, bPostAction, cDocIni, cDocFin, nRad, lChk1, lChk2, lFechas, dDesde, dHasta, oDlg, oTree, oBrw, oMtrInf, oBtnCancel )

   local n        := 0
   local nPos     := 0
   local nRec     := ( dbfRctPrvT )->( Recno() )
   local aPos
   local lRet
   local lPre
   local lWhile   := .T.





   if lChk1
      aPos        := { 0, 0 }
      ClientToScreen( oDlg:hWnd, aPos )
      oDlg:Move( aPos[ 1 ] - 22, aPos[ 2 ] - 510 )
   end





   oDlg:Disable()

   oTree:Enable()
   oTree:DeleteAll()

   oBtnCancel:bAction   := {|| lWhile := .F. }
   oBtnCancel:Enable()

   if !Empty( bPreAction )
      lPre              := Eval( bPreAction )
   end

   if !IsLogic( lPre ) .OR. lPre

      if nRad == 1

         for each nPos in ( oBrw:oBrw:aSelected )

            ( dbfRctPrvT )->( dbGoTo( nPos ) )

            if lFechas .OR.( ( dbfRctPrvT )->dFecFac >= dDesde .AND. ( dbfRctPrvT )->dFecFac <= dHasta )

               lRet  := Eval( bAction, lChk1, lChk2, oTree, dbfRctPrvT, dbfRctPrvL )

               if IsFalse( lRet )
                  exit
               end

            end

            oMtrInf:Set( ++n )

            SysRefresh()

            if !lWhile
               exit
            end

         next

      else

         ( dbfRctPrvT )->( dbSeek( cDocIni, .T. ) )




         while ( lWhile )                                                                                      .AND.  ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac, 9 ) + ( dbfRctPrvT )->cSufFac >= cDocIni .AND.  ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac, 9 ) + ( dbfRctPrvT )->cSufFac <= cDocFin .AND.  !( dbfRctPrvT )->( eof() )

            if lFechas .OR.( ( dbfRctPrvT )->dFecFac >= dDesde .AND. ( dbfRctPrvT )->dFecFac <= dHasta )

               lRet  := Eval( bAction, lChk1, lChk2, oTree, dbfRctPrvT, dbfRctPrvL )

               if IsFalse( lRet )
                  exit
               end

            end

            oMtrInf:Set( ++n )

            ( dbfRctPrvT )->( dbSkip() )

            SysRefresh()

         end

      end

      if !Empty( bPostAction )
         Eval( bPostAction )
      end

   end

   oMtrInf:Set( ( dbfRctPrvT )->( OrdKeyCount() ) )

   ( dbfRctPrvT )->( dbGoTo( nRec ) )

   if lChk1
      WndCenter( oDlg:hWnd )
   end

   oBtnCancel:bAction   := {|| oDlg:End() }

   oDlg:Enable()

   if oBrw <> nil
      oBrw:Refresh()
   end

RETURN ( nil )






STATIC FUNCTION ContabilizaRectificativa( lSimula, lPago, oTree )

    local n
   local nAsiento    := 0
    local cCtaVent
    local nPosicion
    local nPosIva
    local dFecha
   local aTotFac
   local nTotFac
   local nTotRet
    local cConcepto
   local cConCompr
    local cSubCtaIva
    local cSubCtaReq
   local cRuta
   local cCodEmp
   local nImpDeta
   local nDinDiv     := nDinDiv( ( dbfRctPrvT )->cDivFac, dbfDiv )
   local nRinDiv     := nRinDiv( ( dbfRctPrvT )->cDivFac, dbfDiv )
    local aSimula        := {}
    local aIva            := {}
    local aVentas        := {}
   local cCodDiv     := ( dbfRctPrvT )->cDivFac
   local cCtaPrv     := cPrvCta( ( dbfRctPrvT )->cCodPrv, dbfPrv )
   local cCtaPrvVta  := cPrvCtaVta( ( dbfRctPrvT )->cCodPrv, dbfPrv )
   local nFactura    := ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac
   local cFactura    := ( dbfRctPrvT )->cSerFac + "/" + Ltrim( Str( ( dbfRctPrvT )->nNumFac ) ) + "/" + ( dbfRctPrvT )->cSufFac
   local nNumFac     := ( dbfRctPrvT )->nNumFac
   local cCodPro     := Left( ( dbfRctPrvT )->cCodPro, 3 )
   local cClave      := Right( ( dbfRctPrvT )->cCodPro, 6 )
   local lErrorFound := .F.
   local cTerNif     := ( dbfRctPrvT )->cDniPrv
   local cTerNom     := ( dbfRctPrvT )->cNomPrv
   local lReturn





   IF ( dbfRctPrvT )->lContab
      oTree:Add( "Factura rectificativa : " + Rtrim( cFactura ) + " ya contabilizada.", 0 )
      lErrorFound    := .T.
   end

   IF !ChkRuta( cRutCnt() )
      oTree:Add( "Factura rectificativa : " + rtrim( cFactura ) + " ruta no valida.", 0 )
      lErrorFound    := .T.
   end





   cRuta             := cRutCnt()
   cCodEmp           := cCodEmpCnt( ( dbfRctPrvT )->cSerFac )

   if Empty( cCtaPrvVta )
      cCtaPrvVta     := cCtaPrv()
   end

   if !ChkSubCta( cRutCnt(), cCodEmp, cCtaPrv, , .F., .F. )
      oTree:Add( "Factura rectificativa : " + rtrim( cFactura ) + " subcuenta " + cCtaPrv + " no encontada.", 0 )
      lErrorFound    := .T.
   end





   aTotFac           := aTotRctPrv( nFactura, dbfRctPrvT, dbfRctPrvL, dbfIva, dbfDiv, dbfRctPrvP )
   nTotFac           := aTotFac[ 4 ]
   nTotRet           := aTotFac[ 6 ]





   if ( dbfRctPrvL )->( dbSeek( nFactura ) )

      while ( ( dbfRctPrvL )->cSerFac + Str( ( dbfRctPrvL )->nNumFac ) + ( dbfRctPrvL )->cSufFac == nFactura .AND. !( dbfRctPrvL )->( eof() ) )

         nImpDeta    := nTotLRctPrv( dbfRctPrvL, nDinDiv, nRinDiv, ( dbfRctPrvT )->nVdvFac )

         if nImpDeta <> 0

            cCtaVent    := RetCtaCom( ( dbfRctPrvL )->cRef, dbfArticulo )
            if Empty( cCtaVent )
               cCtaVent := cCtaPrvVta + RetGrpVta( ( dbfRctPrvL )->cRef, cRuta, cCodEmp, dbfArticulo, ( dbfRctPrvL )->nIva )
            end

            nPosicion   := aScan( aVentas, {|x| x[1] == cCtaVent } )
            if nPosicion == 0
               aadd( aVentas, { cCtaVent, nImpDeta } )
            else
               aVentas[ nPosicion, 2 ] += nImpDeta
            end





            if ( dbfRctPrvT )->nRegIva == 2
               cSubCtaIva  := uFieldEmpresa( "cCtaCeeRpt" )
               cSubCtaReq  := uFieldEmpresa( "cCtaCeeSpt" )
            else
               cSubCtaIva  := cSubCuentaIva( ( dbfRctPrvL )->nIva, ( dbfRctPrvT )->lRecargo, cRuta, cCodEmp, dbfIva, .F. )
               cSubCtaReq  := cSubCuentaRecargo( ( dbfRctPrvL )->nIva, ( dbfRctPrvT )->lRecargo, cRuta, cCodEmp, dbfIva )
            end

            nPosIva     := aScan( aIva, {|x| x[1] == ( dbfRctPrvL )->nIva } )
            if nPosIva == 0
               aadd( aIva, { ( dbfRctPrvL )->nIva, cSubCtaIva, cSubCtaReq, nImpDeta } )
            else
               aIva[ nPosIva, 4 ]   += nImpDeta
            end

         end

         ( dbfRctPrvL )->( dbSkip() )

      end

   else

      oTree:Add( "Factura rectificativa : " + rtrim( cFactura ) + " factura sin artículos.", 0 )
      lErrorFound    := .T.

   end





   for n := 1 TO Len( aVentas )

      if ( dbfRctPrvT )->nDtoEsp <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfRctPrvT )->nDtoEsp / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDpp <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfRctPrvT )->nDpp / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDtoUno <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfRctPrvT )->nDtoUno / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDtoDos <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfRctPrvT )->nDtoDos / 100, nRinDiv )
      end

   next





   for n := 1 TO Len( aIva )

      if ( dbfRctPrvT )->nDtoEsp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfRctPrvT )->nDtoEsp / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDpp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfRctPrvT )->nDpp / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDtoUno <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfRctPrvT )->nDtoUno / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDtoDos <> 0
         aIva[ n, 2 ] -= Round( aIva[ n, 4 ] * ( dbfRctPrvT )->nDtoDos / 100, nRinDiv )
      end

   next





   for n := 1 TO len( aVentas )

      if !ChkSubCta( cRutCnt(), cCodEmp, aVentas[ n, 1 ], , .F., .F. )

         oTree:Add( "Factura rectificativa : " + rtrim( cFactura ) + " subcuenta " + aVentas[ n, 1 ] + " no encontada.", 0 )
         lErrorFound    := .T.

      end

   next





   for n := 1 to len( aIva )

      if !ChkSubCta( cRuta, cCodEmp, aIva[ n, 2 ], , .F., .F. )
         oTree:Add( "Factura rectificativa : " + Rtrim( cFactura ) + " subcuenta " + aIva[ n, 2 ] + " no encontada.", 0 )
         lErrorFound    := .T.
      end

      if !ChkSubCta( cRuta, cCodEmp, aIva[ n, 3 ], , .F., .F. )
         oTree:Add( "Factura rectificativa : " + Rtrim( cFactura ) + " subcuenta " + aIva[ n, 3 ] + " no encontada.", 0 )
         lErrorFound    := .T.
      end

   next

   if nTotRet <> 0

      if !ChkSubCta( cRuta, cCodEmp, cCtaRet(), , .F., .F. )
         oTree:Add( "Factura rectificativa : " + Rtrim( cFactura ) + " subcuenta " + cCtaRet() + " no encontada.", 0 )
         lErrorFound    := .T.
      end

   end





   if !ChkFecha( , , ( dbfRctPrvT )->dFecFac, .F., oTree )
      lErrorFound    := .T.
   end





   if lSimula .OR. !lErrorFound

      if Empty( ( dbfRctPrvT )->dFecEnt )
         dFecha      := ( dbfRctPrvT )->dFecFac
      else
         dFecha      := ( dbfRctPrvT )->dFecEnt
      end

      cConCompr      := "S/Rect."
      if !Empty( ( dbfRctPrvT )->cSuPed )
         nNumFac     := Val( ( dbfRctPrvT )->cSuPed )
         cConCompr   += " N." + Rtrim( ( dbfRctPrvT )->cSuPed )
      elseif !Empty( ( dbfRctPrvT )->cNumDoc )
         cConCompr   += " Doc. " + Rtrim( ( dbfRctPrvT )->cNumDoc )
      else
         cConCompr   += " N." + Rtrim( cFactura )
      end
      cConcepto      := cConCompr + Space( 1 ) + DtoC( ( dbfRctPrvT )->dFecFac )
      cConCompr      += Space( 1 ) + Rtrim( ( dbfRctPrvT )->cNomPrv )





      if OpenDiario( , cCodEmp )
         nAsiento := RetLastAsi()
      else
         oTree:Add( "Factura rectificativa : " + Rtrim( cFactura ) + " imposible abrir ficheros de contaplus.", 0 )
         return .F.
      end

























      aAdd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaPrv, , , cConcepto, nTotFac, nNumFac, , , , ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )





      for n := 1 TO len( aVentas )





















         aAdd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aVentas[ n, 1 ], , aVentas[ n, 2 ], cConCompr, , nNumFac, , , , ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next

      if ( dbfRctPrvT )->nRegIva == 2

      for n := 1 to len( aIva )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha,  aIva[ n, 3 ], aIva[ n, 2 ], Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), nNumFac, aIva[ n, 4 ], aIva[ n, 1 ], If( ( dbfRctPrvT )->lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), 0 ), ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next

      else





      for n := 1 TO len( aIva )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha,  aIva[ n, 2 ], cCtaPrv, Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, , nNumFac, aIva[ n, 4 ], aIva[ n, 1 ], If( ( dbfRctPrvT )->lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), 0 ), ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next





      if ( dbfRctPrvT )->lRecargo

         for n := 1 TO len( aIva )





















            aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aIva[ n, 3 ], , Round( nPReq( dbfIva, aIva[ n, 1 ] ) * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, , nNumFac, , , , ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

         next

      end

      end





      if nTotRet <> 0





















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaRet(), , , cConCompr, nTotRet, nNumFac, , , , ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end






      if lPago .AND. ( dbfRctPrvP )->( dbSeek( nFactura ) )


         while ( ( dbfRctPrvP )->cSerFac + Str( ( dbfRctPrvP )->nNumFac ) + ( dbfRctPrvP )->cSufFac == nFactura ) .AND. !( dbfRctPrvP )->( eof() )

            lReturn  := CntRecPrv( lSimula, oTree, nAsiento, aSimula, .T., dbfRctPrvT, dbfRctPrvP, dbfPrv, dbfFPago, dbfDiv )

            if IsFalse( lReturn )
               exit
            end

            ( dbfRctPrvP )->( dbSkip() )

         end

      end





      if !lSimula .AND. !lErrorFound

         lReturn  := ChgContabilizado( .T., cFactura, nAsiento, oTree )

      else

         lReturn  := msgTblCon( aSimula, cCodDiv, dbfDiv, !lErrorFound, cFactura, {|| aWriteAsiento( aSimula, cCodDiv, .T., oTree, cFactura, nAsiento ), ChgContabilizado( .T., cFactura, nAsiento, oTree ) } )

      end

      CloseDiario()

   end

Return ( lReturn )






STATIC FUNCTION cFacPrv( aGet, oBrw, nMode, aTmp )

   local lValid   := .F.
   local cFactura := aGet[ 26 ]:varGet()
   local nOption  := 0

   if nMode <> 1 .OR. Empty( cFactura )
      return .T.
   end

   if ( dbfFacPrvT )->( dbSeek( cFactura ) )

      if Empty( aTmp[ 6 ] )
         aGet[ 6 ]:cText( ( dbfFacPrvT )->cCodPrv )
         aGet[ 6 ]:lValid()
      end

      if Empty( aTmp[ 7 ] )
         aGet[ 7 ]:cText( ( dbfFacPrvT )->cCodAlm )
         aGet[ 7 ]:lValid()
      end

      if Empty( aTmp[ 8 ] )
         aGet[ 8 ]:cText( ( dbfFacPrvT )->cCodCaj )
         aGet[ 8 ]:lValid()
      end

      if Empty( aTmp[ 23 ] )
         aGet[ 23 ]:cText( ( dbfFacPrvT )->cCodPago )
         aGet[ 23 ]:lValid()
      end

      if Empty( aTmp[ 28 ] )
         aGet[ 28 ]:cText( ( dbfFacPrvT )->cDtoEsp )
      end

      if Empty( aTmp[ 29 ] )
         aGet[ 29 ]:cText( ( dbfFacPrvT )->nDtoEsp )
      end

      if Empty( aTmp[ 30 ] )
         aGet[ 30    ]:cText( ( dbfFacPrvT )->cDpp )
      end

      if Empty( aTmp[ 31 ] )
         aGet[ 31    ]:cText( ( dbfFacPrvT )->nDpp )
      end

      if Empty( aTmp[ 38 ] )
         aGet[ 38 ]:cText( ( dbfFacPrvT )->cDtoUno )
      end

      if Empty( aTmp[ 39 ] )
         aGet[ 39 ]:cText( ( dbfFacPrvT )->nDtoUno )
      end

      if Empty( aTmp[ 40 ] )
         aGet[ 40 ]:cText( ( dbfFacPrvT )->cDtoDos )
      end

      if Empty( aTmp[ 41 ] )
         aGet[ 41 ]:cText( ( dbfFacPrvT )->nDtoDos )
      end

      if Empty( aTmp[ 20 ] )
         aGet[ 20 ]:cText( ( dbfFacPrvT )->cObserv )
      end

      aGet[ 55 ]:nOption( Max( ( dbfPrv )->nRegIva, 1 ) )
      aGet[ 55 ]:Refresh()


      if !Empty( nTipRet )
         aGet[ 51 ]:Select( ( dbfFacPrvT )->nTipRet )
         aGet[ 51 ]:Refresh()
      end

      if Empty( aTmp[ 20 ] )
         aGet[ 51 ]:cText( ( dbfFacPrvT )->nPctRet )
      end





      nOption           := nImportaLineas()


      if nOption >= 1                              .AND. ( dbfFacPrvL )->( dbSeek( cFactura ) )

         while ( ( dbfFacPrvL )->cSerFac + Str( ( dbfFacPrvL )->nNumFac ) + ( dbfFacPrvL )->cSufFac == cFactura )

            ( dbfTmp )->( dbAppend() )

            ( dbfTmp )->cRef     := ( dbfFacPrvL )->cRef
            ( dbfTmp )->cDetalle := ( dbfFacPrvL )->cDetalle
            ( dbfTmp )->mLngDes  := ( dbfFacPrvL )->mLngDes
            ( dbfTmp )->mNumSer  := ( dbfFacPrvL )->mNumSer
            ( dbfTmp )->nIva     := ( dbfFacPrvL )->nIva
            ( dbfTmp )->nReq     := ( dbfFacPrvL )->nReq
            ( dbfTmp )->nPreUnit := ( dbfFacPrvL )->nPreUnit
            ( dbfTmp )->nUniCaja := if( nOption == 2, ( ( dbfFacPrvL )->nUniCaja * -1 ), ( dbfFacPrvL )->nUniCaja )
            ( dbfTmp )->nCanEnt  := ( dbfFacPrvL )->nCanEnt
            ( dbfTmp )->nDtoLin  := ( dbfFacPrvL )->nDtoLin
            ( dbfTmp )->nDtoPrm  := ( dbfFacPrvL )->nDtoPrm
            ( dbfTmp )->nDtoRap  := ( dbfFacPrvL )->nDtoRap
            ( dbfTmp )->cAlmLin  := ( dbfFacPrvL )->cAlmLin
            ( dbfTmp )->nNumLin  := ( dbfFacPrvL )->nNumLin
            ( dbfTmp )->nUndKit  := ( dbfFacPrvL )->nUndKit
            ( dbfTmp )->lKitChl  := ( dbfFacPrvL )->lKitChl
            ( dbfTmp )->lKitArt  := ( dbfFacPrvL )->lKitArt
            ( dbfTmp )->lKitPrc  := ( dbfFacPrvL )->lKitPrc
            ( dbfTmp )->cCodPr1  := ( dbfFacPrvL )->cCodPr1
            ( dbfTmp )->cCodPr2  := ( dbfFacPrvL )->cCodPr2
            ( dbfTmp )->cValPr1  := ( dbfFacPrvL )->cValPr1
            ( dbfTmp )->cValPr2  := ( dbfFacPrvL )->cValPr2
            ( dbfTmp )->lLote    := ( dbfFacPrvL )->lLote
            ( dbfTmp )->nLote    := ( dbfFacPrvL )->nLote
            ( dbfTmp )->cLote    := ( dbfFacPrvL )->cLote
            ( dbfTmp )->mObsLin  := ( dbfFacPrvL )->mObsLin
            ( dbfTmp )->cRefPrv  := ( dbfFacPrvL )->cRefPrv
            ( dbfTmp )->cUnidad  := ( dbfFacPrvL )->cUnidad
            ( dbfTmp )->nNumMed  := ( dbfFacPrvL )->nNumMed
            ( dbfTmp )->nMedUno  := ( dbfFacPrvL )->nMedUno
            ( dbfTmp )->nMedDos  := ( dbfFacPrvL )->nMedDos
            ( dbfTmp )->nMedTre  := ( dbfFacPrvL )->nMedTre
            ( dbfTmp )->dFecCad  := ( dbfFacPrvL )->dFecCad
            ( dbfTmp )->lGasSup  := ( dbfFacPrvL )->lGasSup

            ( dbfFacPrvL )->( dbSkip() )

         end

         ( dbfTmp )->( dbGoTop() )

         oBrw:Refresh()

      end

      aGet[ 26 ]:bWhen     := {|| .F. }

   else

      MsgStop( "Factura no encontrada." )

   end

   nTotRctPrv( nil, dbfRctPrvT, dbfTmp, dbfIva, dbfDiv, dbfRctPrvP, aTmp )

RETURN lValid



FUNCTION mkRctPrv( cPath, oMeter )

   if oMeter <> nil
        oMeter:cText    := "Generando Bases"
        sysrefresh()
   end

   CreateFiles( cPath )

   rxRctPrv( cPath, oMeter )

RETURN NIL



FUNCTION rxRctPrv( cPath, oMeter )

   local dbfRctPrvT
   local dbfRctPrvL

   IIF( cPath == nil, cPath := cPatEmp(), ) ;





   if !lExistTable( cPath + "RctPrvT.Dbf" ) .OR.  !lExistTable( cPath + "RctPrvL.Dbf" ) .OR.  !lExistTable( cPath + "RctPrvI.Dbf" ) .OR.  !lExistTable( cPath + "RctPrvD.Dbf" ) .OR.  !lExistTable( cPath + "RctPrvS.Dbf" )
      CreateFiles( cPath )
   end





   fEraseIndex( cPath + "RctPrvT.Cdx" )
   fEraseIndex( cPath + "RctPrvL.Cdx" )
   fEraseIndex( cPath + "RctPrvI.Cdx" )
   fEraseIndex( cPath + "RctPrvD.Cdx" )
   fEraseIndex( cPath + "RctPrvS.Cdx" )

   dbUseArea( .T., cDriver(), cPath + "RctPrvT.DBF", cCheckArea( "FACPRVT", @dbfRctPrvT ), .F. )

   if !( dbfRctPrvT )->( neterr() )

      ( dbfRctPrvT )->( __dbPack() )

      ( dbfRctPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvT.CDX", "NNUMFAC", "CSERFAC + STR( NNUMFAC ) + CSUFFAC", {|| Field->CSERFAC + STR( Field->NNUMFAC ) + Field->CSUFFAC } ) )

      ( dbfRctPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvT.CDX", "DFECFAC", "DFECFAC", {|| Field->DFECFAC } ) )

      ( dbfRctPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvT.CDX", "CCODPRV", "CCODPRV", {|| Field->CCODPRV } ) )

      ( dbfRctPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvT.CDX", "CNOMPRV", "Upper( CNOMPRV )", {|| Upper( Field->CNOMPRV ) } ) )

      ( dbfRctPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvT.CDX", "cNumDoc", "Upper( cNumDoc )", {|| Upper( Field->cNumDoc ) } ) )

      ( dbfRctPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvT.CDX", "cTurFac", "cTurFac + cSufFac + cCodCaj", {|| Field->CTURFAC + Field->CSUFFAC + Field->cCodCaj } ) )

      ( dbfRctPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvT.Cdx", "cCodUsr", "Field->cCodUsr + Dtos( Field->dFecChg ) + Field->cTimChg", {|| Field->cCodUsr + Dtos( Field->dFecChg ) + Field->cTimChg } ) )

      ( dbfRctPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvT.Cdx", "cCodPago", "cCodPago", {|| Field->cCodPago } ) )

      ( dbfRctPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvT.Cdx", "cNumFac", "cNumFac", {|| Field->cNumFac } ) )

      ( dbfRctPrvT )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de facturas rectificativas de proveedores" )
   end





   dbUseArea( .T., cDriver(), cPath + "RctPrvL.DBF", cCheckArea( "FACPRVL", @dbfRctPrvL ), .F. )
   if !( dbfRctPrvL )->( neterr() )
      ( dbfRctPrvL )->( __dbPack() )

      ( dbfRctPrvL )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvL )->( ordCreate( cPath + "RctPrvL.CDX", "NNUMFAC", "CSERFAC + STR( NNUMFAC ) + CSUFFAC", {|| Field->CSERFAC + STR( Field->NNUMFAC ) + Field->CSUFFAC } ) )

      ( dbfRctPrvL )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvL )->( ordCreate( cPath + "RctPrvL.CDX", "cRef", "cRef + cValPr1 + cValPr2", {|| Field->cRef + Field->cValPr1 + Field->cValPr2 }, ) )

      ( dbfRctPrvL )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvL )->( ordCreate( cPath + "RctPrvL.CDX", "Lote", "cLote", {|| Field->cLote }, ) )

      ( dbfRctPrvL )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de facturas rectificativas de proveedores" )
   end

   dbUseArea( .T., cDriver(), cPath + "RctPrvI.DBF", cCheckArea( "FacPrvI", @dbfRctPrvT ), .F. )
   if !( dbfRctPrvT )->( neterr() )
      ( dbfRctPrvT )->( __dbPack() )

      ( dbfRctPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvI.CDX", "nNumFac", "cSerFac + Str( nNumFac ) + cSufFac", {|| Field->cSerFac + STR( Field->nNumFac ) + Field->cSufFac } ) )

      ( dbfRctPrvT )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de facturas rectificativas de proveedores" )
   end

   dbUseArea( .T., cDriver(), cPath + "RctPrvD.DBF", cCheckArea( "FacPrvD", @dbfRctPrvT ), .F. )
   if !( dbfRctPrvT )->( neterr() )
      ( dbfRctPrvT )->( __dbPack() )

      ( dbfRctPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvD.CDX", "nNumFac", "cSerFac + STR( nNumFac ) + cSufFac", {|| Field->cSerFac + STR( Field->nNumFac ) + Field->cSufFac } ) )

      ( dbfRctPrvT )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de facturas rectificativas de proveedores" )
   end

   dbUseArea( .T., cDriver(), cPath + "RctPrvS.DBF", cCheckArea( "RctPrvS", @dbfRctPrvT ), .F. )
   if !( dbfRctPrvT )->( neterr() )
      ( dbfRctPrvT )->( __dbPack() )

      ( dbfRctPrvT )->( ordCondSet( "!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvS.CDX", "nNumFac", "cSerFac + Str( nNumFac ) + cSufFac + Str( nNumLin )", {|| Field->cSerFac + Str( Field->nNumFac ) + Field->cSufFac + Str( Field->nNumLin ) } ) )

      ( dbfRctPrvT )->( ordCondSet( "!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvS.CDX", "cRefSer", "cRef + cAlmLin + cNumSer", {|| Field->cRef + Field->cAlmLin + Field->cNumSer } ) )

      ( dbfRctPrvT )->( ordCondSet( "!Deleted()", {||!Deleted()}  ) )
      ( dbfRctPrvT )->( ordCreate( cPath + "RctPrvS.CDX", "cNumSer", "cNumSer", {|| Field->cNumSer } ) )

      ( dbfRctPrvT )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de numeros de series de facturas rectificativas de proveedores" )
   end

RETURN NIL



STATIC FUNCTION BeginTrans( aTmp, nMode )

   local oError
   local oBlock
   local lErrors     := .F.
   local cDbf        := "FPrvL"
   local cDbfInc     := "FPrvI"
   local cDbfDoc     := "FPrvD"
   local cDbfPgo     := "FPrvP"
   local cDbfSer     := "FPrvS"
   local nFactura    := aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ]

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      aNumAlb        := {}

      cNewFile       := cGetNewFileName( cPatTmp() + cDbf )
      cTmpInc        := cGetNewFileName( cPatTmp() + cDbfInc )
      cTmpDoc        := cGetNewFileName( cPatTmp() + cDbfDoc )
      cTmpPgo        := cGetNewFileName( cPatTmp() + cDbfPgo )
      cTmpSer        := cGetNewFileName( cPatTmp() + cDbfSer )





      dbCreate( cNewFile, aSqlStruct( aColRctPrv() ), cLocalDriver() )
      dbUseArea( .T., cLocalDriver(), cNewFile, cCheckArea( cDbf, @dbfTmp ), .F. )

      if !( dbfTmp )->( neterr() )

         ( dbfTmp )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
         ( dbfTmp )->( OrdCreate( cNewFile, "nNumLin", "Str( nNumLin, 4 )", {|| Str( Field->nNumLin ) } ) )

         ( dbfTmp )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
         ( dbfTmp )->( OrdCreate( cNewFile, "Recno", "Str( Recno() )", {|| Str( Recno() ) } ) )

      end





      if ( dbfRctPrvL )->( dbSeek( nFactura ) )

         while ( ( dbfRctPrvL )->CSERFAC + Str( ( dbfRctPrvL )->NNUMFAC ) + ( dbfRctPrvL )->CSUFFAC == nFactura .AND. !( dbfRctPrvL )->( eof() ) )

            dbPass( dbfRctPrvL, dbfTmp, .T. )
            ( dbfRctPrvL )->( dbSkip() )

         end

      end

      ( dbfTmp )->( dbGoTop() )





      dbCreate( cTmpInc, aSqlStruct( aIncRctPrv() ), cLocalDriver() )
      dbUseArea( .T., cLocalDriver(), cTmpInc, cCheckArea( cDbfInc, @dbfTmpInc ), .F. )
      if !( dbfTmpInc )->( neterr() )
         ( dbfTmpInc )->( ordCondSet( "!Deleted()", {||!Deleted() } ) )
         ( dbfTmpInc )->( ordCreate( cTmpInc, "Recno", "Recno()", {|| Recno() } ) )
      end





      if ( dbfRctPrvI )->( dbSeek( nFactura ) )

         while ( ( dbfRctPrvI )->cSerFac + Str( ( dbfRctPrvI )->nNumFac ) + ( dbfRctPrvI )->cSufFac == nFactura ) .AND. ( dbfRctPrvI )->( !eof() )

            dbPass( dbfRctPrvI, dbfTmpInc, .T. )
            ( dbfRctPrvI )->( dbSkip() )

         end

      end

      ( dbfTmpInc )->( dbGoTop() )





      dbCreate( cTmpDoc, aSqlStruct( aFacPrvDoc() ), cLocalDriver() )
      dbUseArea( .T., cLocalDriver(), cTmpDoc, cCheckArea( cDbfDoc, @dbfTmpDoc ), .F. )
      if !( dbfTmpDoc )->( neterr() )
         ( dbfTmpDoc )->( ordCondSet( "!Deleted()", {||!Deleted() } ) )
         ( dbfTmpDoc )->( ordCreate( cTmpDoc, "Recno", "Recno()", {|| Recno() } ) )
      end





      if ( dbfRctPrvD )->( dbSeek( nFactura ) )
         while ( ( dbfRctPrvD )->cSerFac + Str( ( dbfRctPrvD )->nNumFac ) + ( dbfRctPrvD )->cSufFac == nFactura ) .AND. ( dbfRctPrvD )->( !eof() )
            dbPass( dbfRctPrvD, dbfTmpDoc, .T. )
            ( dbfRctPrvD )->( dbSkip() )
         end
      end

      ( dbfTmpDoc )->( dbGoTop() )





      dbCreate( cTmpSer, aSqlStruct( aSerRctPrv() ), cLocalDriver() )
      dbUseArea( .T., cLocalDriver(), cTmpSer, cCheckArea( cDbf, @dbfTmpSer ), .F. )

      if !( dbfTmpSer )->( neterr() )
         ( dbfTmpSer )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
         ( dbfTmpSer )->( OrdCreate( cTmpSer, "nNumLin", "Str( nNumLin, 4 ) + cRef", {|| Str( Field->nNumLin, 4 ) + Field->cRef } ) )
      end





      if ( dbfRctPrvS )->( dbSeek( nFactura ) )
         while ( ( dbfRctPrvS )->cSerFac + Str( ( dbfRctPrvS )->nNumFac ) + ( dbfRctPrvS )->cSufFac == nFactura .AND. !( dbfRctPrvS )->( eof() ) )
            dbPass( dbfRctPrvS, dbfTmpSer, .T. )
            ( dbfRctPrvS )->( dbSkip() )
         end
      end

      ( dbfTmpSer )->( dbGoTop() )





      dbCreate( cTmpPgo, aSqlStruct( aItmRecPrv() ), cLocalDriver() )
      dbUseArea( .T., cLocalDriver(), cTmpPgo, cCheckArea( cDbfPgo, @dbfTmpPgo ), .F. )
      if !( dbfTmpPgo )->( neterr() )

         ( dbfTmpPgo )->( ordCondSet( "!Deleted() .and. !Empty( cTipRec )", {|| !Deleted() .AND. !Empty( Field->cTipRec ) } ) )
         ( dbfTmpPgo )->( ordCreate( cTmpPgo, "rNumFac", "cSerFac + Str( nNumFac ) + cSufFac + Str( nNumRec )", {|| Field->cSerFac + Str( Field->nNumFac ) + Field->cSufFac + Str( Field->nNumRec ) }, ) )

         ( dbfTmpPgo )->( ordCondSet( "!Deleted()", {|| !Deleted() } ) )
         ( dbfTmpPgo )->( ordCreate( cTmpPgo, "cRecDev", "CRECDEV", {|| Field->CRECDEV } ) )

         ( dbfTmpPgo )->( ordCondSet( "!Deleted()", {|| !Deleted() } ) )
         ( dbfTmpPgo )->( ordCreate( cTmpPgo, "nNumFac", "cSerFac + Str( nNumFac ) + cSufFac + Str( nNumRec )", {|| Field->cSerFac + Str( Field->nNumFac ) + Field->cSufFac + Str( Field->nNumRec ) }, ) )

         ( dbfTmpPgo )->( ordCondSet( "!Deleted()", {||!Deleted() } ) )
         ( dbfTmpPgo )->( ordCreate( cTmpPgo, "Recno", "Recno()", {|| Recno() } ) )

      end





      if ( dbfRctPrvP )->( dbSeek( nFactura ) ) .AND. nMode <> 4

         while ( ( dbfRctPrvP )->cSerFac + Str( ( dbfRctPrvP )->nNumFac ) + ( dbfRctPrvP )->cSufFac == nFactura ) .AND. ( dbfRctPrvP )->( !eof() )

            dbPass( dbfRctPrvP, dbfTmpPgo, .T. )

            ( dbfRctPrvP )->( dbSkip() )

         end

      end

      ( dbfTmpPgo )->( dbGoTop() )

   RECOVER USING oError

      msgStop( "Imposible crear tablas temporales." + Chr(13)+Chr(10) + ErrorMessage( oError ) )

      KillTrans()

      lErrors     := .T.

   end

   ErrorBlock( oBlock )

RETURN ( lErrors )



Function aIncRctPrv()

   local aIncFacPrv  := {}

   aAdd( aIncFacPrv, { "cSerFac", "C",    1,  0, "Serie de factura" ,              "",                   "", "( cDbfCol )" } )
   aAdd( aIncFacPrv, { "nNumFac", "N",    9,  0, "Número de factura" ,             "'999999999'",        "", "( cDbfCol )" } )
   aAdd( aIncFacPrv, { "cSufFac", "C",    2,  0, "Sufijo de factura" ,             "",                   "", "( cDbfCol )" } )
   aAdd( aIncFacPrv, { "cCodTip", "C",    3,  0, "Tipo de incidencia" ,            "",                   "", "( cDbfCol )" } )
   aAdd( aIncFacPrv, { "dFecInc", "D",    8,  0, "Fecha de la incidencia" ,        "",                   "", "( cDbfCol )" } )
   aAdd( aIncFacPrv, { "mDesInc", "M",   10,  0, "Descripción de la incidencia" ,  "",                   "", "( cDbfCol )" } )
   aAdd( aIncFacPrv, { "lListo",  "L",    1,  0, "Lógico de listo" ,               "",                   "", "( cDbfCol )" } )
   aAdd( aIncFacPrv, { "lAviso",  "L",    1,  0, "Lógico de aviso" ,               "",                   "", "( cDbfCol )" } )

Return ( aIncFacPrv )



Function aRctPrvDoc()

   local aFacPrvDoc  := {}

   aAdd( aFacPrvDoc, { "cSerFac", "C",    1,  0, "Serie de facturas" ,               "",                   "", "( cDbfCol )" } )
   aAdd( aFacPrvDoc, { "nNumFac", "N",    9,  0, "Número de facturas" ,              "'999999999'",        "", "( cDbfCol )" } )
   aAdd( aFacPrvDoc, { "cSufFac", "C",    2,  0, "Sufijo de facturas" ,              "",                   "", "( cDbfCol )" } )
   aAdd( aFacPrvDoc, { "cNombre", "C",  250,  0, "Nombre del documento" ,            "",                   "", "( cDbfCol )" } )
   aAdd( aFacPrvDoc, { "cRuta",   "C",  250,  0, "Ruta del documento" ,              "",                   "", "( cDbfCol )" } )
   aAdd( aFacPrvDoc, { "mObsDoc", "M",   10,  0, "Observaciones del documento" ,     "",                   "", "( cDbfCol )" } )

Return ( aFacPrvDoc )



Function aSerRctPrv()

   local aColFacPrv  := {}

   aAdd( aColFacPrv,  { "cSerFac", "C",  1,   0, "",                                 "",                  "", "( cDbfCol )" } )
   aAdd( aColFacPrv,  { "nNumFac", "N",  9,   0, "",                                 "",                  "", "( cDbfCol )" } )
   aAdd( aColFacPrv,  { "cSufFac", "C",  2,   0, "",                                 "",                  "", "( cDbfCol )" } )
   aAdd( aColFacPrv,  { "nNumLin", "N",  4,   0, "Número de la línea",               "'9999'",            "", "( cDbfCol )" } )
   aAdd( aColFacPrv,  { "cRef",    "C", 18,   0, "Referencia del artículo",          "",                  "", "( cDbfCol )" } )
   aAdd( aColFacPrv,  { "cAlmLin", "C",  3,   0, "Código de almacen",                "",                  "", "( cDbfCol )" } )
   aAdd( aColFacPrv,  { "lUndNeg", "L",  1,   0, "Lógico de unidades en negativo",   "",                  "", "( cDbfCol )" } )
   aAdd( aColFacPrv,  { "cNumSer", "C", 30,   0, "Numero de serie",                  "",                  "", "( cDbfCol )" } )

Return ( aColFacPrv )




STATIC FUNCTION EndTrans( aTmp, aGet, oBrw, oBrwLin, nMode, nDec, oDlg, oFld )

   local aTbl
   local nItem
   local nNumLin
   local cSerFac
   local nNumFac
   local cSufFac
   local oError
   local oBlock

   if Empty( aTmp[ 1 ] )
      aTmp[ 1 ]  := "A"
   end

   nNumLin              := 1
   cSerFac              := aTmp[ 1 ]
   nNumFac              := aTmp[ 2 ]
   cSufFac              := aTmp[ 3 ]





   if !lValidaOperacion( aTmp[ 5 ] )
      Return .F.
   end





   if Empty( aTmp[ 6 ] )
      msgStop( "Proveedor no puede estar vacío." )
      aGet[ 6 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 7 ] )
      msgStop( "Almacen no puede estar vacío." )
      aGet[ 7 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 8 ] )
      msgStop( "Caja no puede estar vacía." )
      aGet[ 8 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 23 ] )
      msgStop( "Forma de pago no puede estar vacía." )
      aGet[ 23 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 26 ] )
      msgStop( "Número de factura no puede estar vacia." )
      aGet[ 26 ]:SetFocus()
      return .F.
   end

   if !aTmp[ 56 ] .AND. ( dbfTmp )->( lastrec() ) == 0
      MsgStop( "No puede almacenar un documento sin líneas." )
      return .F.
   end

   if Empty( aTmp[ 67 ] )
      MsgStop( "Debe indicar un motivo para la factura rectificativa." )
      oFld:SetOption( 2 )
      aGet[ 67 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 68 ] )
      MsgStop( "Debe indicar una causa por la que se emite la factura rectificativa." )
      oFld:SetOption( 2 )
      aGet[ 68 ]:SetFocus()
      return .F.
   end





   CursorWait()

   oDlg:Disable()

   oMsgText( "Archivando" )

   oBlock      := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE







   aTmp[ 52 ]  := GetSysDate()
   aTmp[ 53 ]  := Time()





   do case
   case nMode == 1 .OR. nMode == 4



      nNumFac           := nNewDoc( cSerFac, dbfRctPrvT, "nRctPrv", , dbfCount )
      aTmp[ 2 ]  := nNumFac

   case nMode == 2



      while ( dbfRctPrvL )->( dbSeek( cSerFac + str( nNumFac ) + cSufFac ) .AND. !( dbfRctPrvL )->( eof() ) )
         if dbLock( dbfRctPrvL )
            ( dbfRctPrvL )->( dbDelete() )
            ( dbfRctPrvL )->( dbUnLock() )
         end
      end

      while ( dbfRctPrvI )->( dbSeek( cSerFac + str( nNumFac ) + cSufFac ) .AND. !( dbfRctPrvI )->( eof() ) )
         if dbLock( dbfRctPrvI )
            ( dbfRctPrvI )->( dbDelete() )
            ( dbfRctPrvI )->( dbUnLock() )
         end
      end

      while ( dbfRctPrvD )->( dbSeek( cSerFac + str( nNumFac ) + cSufFac ) .AND. !( dbfRctPrvD )->( eof() ) )
         if dbLock( dbfRctPrvD )
            ( dbfRctPrvD )->( dbDelete() )
            ( dbfRctPrvD )->( dbUnLock() )
         end
      end

      while ( dbfRctPrvP )->( dbSeek( cSerFac + str( nNumFac ) + cSufFac ) .AND. !( dbfRctPrvP )->( eof() ) )
         if dbLock( dbfRctPrvP )
            ( dbfRctPrvP )->( dbDelete() )
            ( dbfRctPrvP )->( dbUnLock() )
         end
      end

      while ( dbfRctPrvS )->( dbSeek( cSerFac + Str( nNumFac ) + cSufFac ) )
         if dbLock( dbfRctPrvS )
            ( dbfRctPrvS )->( dbDelete() )
            ( dbfRctPrvS )->( dbUnLock() )
         end
      end

   end





   ( dbfTmp )->( dbClearFilter() )

   oMsgProgress()
   oMsgProgress():SetRange( 0, ( dbfTmp )->( LastRec() ) )





   ( dbfTmp )->( dbGoTop() )
   while !( dbfTmp )->( eof() )

      aTbl                                               := dbScatter( dbfTmp )
      aTbl[ 1 ]                                   := cSerFac
      aTbl[ 2 ]                                   := nNumFac
      aTbl[ 3 ]                                   := cSufFac
      aTbl[ ( dbfRctPrvL )->( FieldPos( "dFecFac" ) ) ]  := aTmp[ 5 ]

      dbGather( aTbl, dbfRctPrvL, .T. )

      ( dbfTmp )->( dbSkip() )

      oMsgProgress():Deltapos( 1 )

   end





   ( dbfTmpInc )->( dbGoTop() )
   while ( dbfTmpInc )->( !eof() )
      dbPass( dbfTmpInc, dbfRctPrvI, .T., cSerFac, nNumFac, cSufFac )
      ( dbfTmpInc )->( dbSkip() )
   end





   ( dbfTmpDoc )->( dbGoTop() )
   while ( dbfTmpDoc )->( !eof() )
      dbPass( dbfTmpDoc, dbfRctPrvD, .T., cSerFac, nNumFac, cSufFac )
      ( dbfTmpDoc )->( dbSkip() )
   end





   ( dbfTmpSer )->( dbGoTop() )
   while ( dbfTmpSer )->( !eof() )
      dbPass( dbfTmpSer, dbfRctPrvS, .T., cSerFac, nNumFac, cSufFac )
      ( dbfTmpSer )->( dbSkip() )
   end





   ( dbfTmpPgo )->( dbGoTop() )

   while ( dbfTmpPgo )->( !eof() )

      if ( dbfTmpPgo )->cCodPrv <> aTmp[ 6 ]
         ( dbfTmpPgo )->cCodPrv := aTmp[ 6 ]
      end

      if ( dbfTmpPgo )->cNomPrv <> aTmp[ 9 ]
         ( dbfTmpPgo )->cNomPrv := aTmp[ 9 ]
      end

      ( dbfTmpPgo )->( dbSkip() )

   end





   ( dbfTmpPgo )->( dbGoTop() )
   while ( dbfTmpPgo )->( !eof() )
      dbPass( dbfTmpPgo, dbfRctPrvP, .T., cSerFac, nNumFac, cSufFac )
      ( dbfTmpPgo )->( dbSkip() )
   end





   aTmp[ 69 ]   := nTotNet
   aTmp[ 73 ]   := nTotSup
   aTmp[ 70 ]   := nTotIva
   aTmp[ 71 ]   := nTotReq
   aTmp[ 72 ]   := nTotFac





   WinGather( aTmp, , dbfRctPrvT, , nMode )





   GenPgoRctPrv( cSerFac + Str( nNumFac ) + cSufFac, dbfRctPrvT, dbfRctPrvL, dbfRctPrvP, dbfPrv, dbfFPago, dbfDiv )





   dbCommitAll()

   RECOVER USING oError

      RollBackTransaction()
      msgStop( "Imposible almacenar documentos" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   oMsgText()
   EndProgress()

   oDlg:Enable()
   oDlg:End( 1 )

   CursorWE()

RETURN .T.



STATIC FUNCTION KillTrans( oBrwLin )





   if !Empty( dbfTmp ) .AND. ( dbfTmp )->( Used() )
      ( dbfTmp )->( dbCloseArea() )
   end

   if !Empty( dbfTmpInc ) .AND. ( dbfTmpInc )->( Used() )
      ( dbfTmpInc )->( dbCloseArea() )
   end

   if !Empty( dbfTmpDoc ) .AND. ( dbfTmpDoc )->( Used() )
      ( dbfTmpDoc )->( dbCloseArea() )
   end

   if !Empty( dbfTmpPgo ) .AND. ( dbfTmpPgo )->( Used() )
      ( dbfTmpPgo )->( dbCloseArea() )
   end

   if !Empty( dbfTmpSer ) .AND. ( dbfTmpSer )->( Used() )
      ( dbfTmpSer )->( dbCloseArea() )
   end

   dbfTmp            := nil
   dbfTmpInc         := nil
   dbfTmpDoc         := nil
   dbfTmpPgo         := nil
   dbfTmpSer         := nil

   dbfErase( cNewFile )
   dbfErase( cTmpInc  )
   dbfErase( cTmpDoc  )
   dbfErase( cTmpPgo  )
   dbfErase( cTmpSer  )

   if !Empty( oMnuRec )
      oMnuRec:End()
   end

   memory( -1 )

   if oBrwLin <> nil
      oBrwLin:CloseData()
   end

RETURN NIL



STATIC FUNCTION CreateFiles( cPath )

   if !lExistTable( cPath + "RctPrvT.DBF" )
      dbCreate( cPath + "RctPrvT.DBF", aSqlStruct( aItmRctPrv() ), cDriver() )
   end
   if !lExistTable( cPath + "RctPrvL.DBF" )
      dbCreate( cPath + "RctPrvL.DBF", aSqlStruct( aColRctPrv() ), cDriver() )
   end
   if !lExistTable( cPath + "RctPrvI.DBF" )
      dbCreate( cPath + "RctPrvI.DBF", aSqlStruct( aIncRctPrv() ), cDriver() )
   end
   if !lExistTable( cPath + "RctPrvD.DBF" )
      dbCreate( cPath + "RctPrvD.DBF", aSqlStruct( aFacPrvDoc() ), cDriver() )
   end
   if !lExistTable( cPath + "RctPrvS.Dbf" )
      dbCreate( cPath + "RctPrvS.Dbf", aSqlStruct( aSerRctPrv() ), cDriver() )
   end

RETURN NIL







FUNCTION dFecRctPrv( cFacPrv, dbfRctPrvT )

    local dFecFac    := Ctod("")

   IF (dbfRctPrvT)->( dbSeek( cFacPrv ) )
      dFecFac  := (dbfRctPrvT)->DFECFAC
    end

RETURN ( dFecFac )






FUNCTION cPrvRctPrv( cFacPrv, dbfRctPrvT )

    local cCodPrv    := ""

   IF (dbfRctPrvT)->( dbSeek( cFacPrv ) )
      cCodPrv  := (dbfRctPrvT)->CCODPRV
    end

RETURN ( cCodPrv )






FUNCTION cNbrRctPrv( cFacPrv, dbfRctPrvT )

    local cNomPrv    := ""

   IF (dbfRctPrvT)->( dbSeek( cFacPrv ) )
      cNomPrv  := (dbfRctPrvT)->CNOMPRV
    end

RETURN ( cNomPrv )



FUNCTION nEstRctPrv( cFacPrv, dbfRctPrvT, dbfRctPrvP )

   local nBitmap  := 3

   if ( dbfRctPrvT )->( dbSeek( cFacPrv ) )
      nBitmap     := ChkPagRctPrv( dbfRctPrvT, dbfRctPrvP )
   end

RETURN nBitmap






STATIC FUNCTION ChgContabilizado( lContabilizado, cFactura, nAsiento, oTree )

   if dbDialogLock( dbfRctPrvT )
      ( dbfRctPrvT )->lContab := lContabilizado
      ( dbfRctPrvT )->( dbUnlock() )
   end

   if !Empty( oTree )
      oTree:Add( "Factura rectificativa : " + Rtrim( cFactura ) + " asiento generado num. " + Alltrim( Str( nAsiento ) ), 1 )
   end

RETURN NIL



STATIC FUNCTION ImpFactura( oBrw, aGet, aTmp )

    local oDlg
    local oBrwFac
    local oGetDes
    local cGetDes
    local cSelFac    := ""
    local aLinFac    := {}

    local nChgDiv    := aTmp[ 36 ]

    IF Empty( aGet[ 6 ]:varGet() )
        msgStop( "Es necesario codificar un proveedor" )
        RETURN .T.
    end

    oDlg = TDialog():New(,,,,, "IMPFACPRV",, .F.,,,,,, .F.,,,,,, .F., )







        oGetDes := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cGetDes, cGetDes:= u ) }, oDlg,,, {||        ( loadFac( cGetDes, oBrwFac, @aLinFac ) )}, "N/W*",,,,, .F.,,, .F., .F.,,,,, {|Self|( oGetDes:cText( cGetFile( "*.dat", "Seleccione el fichero de la factura" ) ) )}, nil, "LUPA",, )





        oBrwFac := TListBox():ReDefine( 120, { | u | If( PCount()==0, cSelFac, cSelFac:= u ) }, {},, oDlg,,,,,,,,, .F.,, )





        TButton():ReDefine( 1, {||(  appdFac( aGet, cSelFac, oBrwFac:aItems, aLinFac, nChgDiv ), oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

        oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN NIL







STATIC FUNCTION loadFac( cGetDes, oBrwFac, aLinFac )

    local    a1
    local a2
   local cIni
    local cSep
    local oText
    local nCont        := 0

    IF empty( cGetDes )
        RETURN .T.
    end

    CursorWait()

    IF    file( cGetDes )

        oText             := TTxtFile():New( cGetDes )
        oText:Open()





        aLinFac            := {}
        oBrwFac:reset()





        WHILE !oText:lEof()

            a1    := oText:cGetStr( 6 )
                    oText:cGetStr( 1 )
            a2    := oText:cGetStr( 6 )
                    oText:cGetStr( 1 )

            ++nCont
            aadd( aLinFac, {} )

            oBrwFac:Add( a1 + space( 1 ) + substr( a2, 1, 2 ) + "/" + substr( a2, 3, 2 ) + "/" + substr( a2, 5, 2 ) )

            WHILE !oText:lEof()





                cIni    := oText:cGetStr( 1 )

                IF cIni == chr( 255 )
                    EXIT
                end











                aadd( aLinFac[ nCont ], {  cIni + oText:cGetStr( 5 ), oText:cGetStr( 13 ),    oText:cGetStr( 30 ),    oText:cGetStr(  7 ),    oText:cGetStr(  7 ), oText:cGetStr(  1 ) } )





                cSep    := oText:cGetStr( 1 )

                IF cSep == chr( 254 )
                    LOOP
                end

            end

        end

      oText:Close()

    ELSE

        msgAlert( "Fichero no encontrado" )

    end

    oBrwFac:setFocus()

    CursorWe()

RETURN .T.







STATIC FUNCTION appdFac( aGet, cSelFac, aSelFac, aLinFac, nChgDiv )

   local n
    local nIva


    local nSelFac := AScan( aSelFac, { | cItem | Upper( AllTrim( cItem ) ) ==  Upper( AllTrim( cSelFac ) ) } )

    IF nSelFac    <> 0

        aGet[18]:cText( substr( cSelFac, 1, 6 ) )

        FOR n := 1 TO len( aLinFac[ nSelFac ] )

            (dbfTmp)->( dbAppend() )

            (dbfTmp)->CREF            := aLinFac[ nSelFac, n, 1 ]
            (dbfTmp)->CDETALLE     := aLinFac[ nSelFac, n, 3 ]
            (dbfTmp)->NUNICAJA    := val( aLinFac[ nSelFac, n, 4 ] ) / 100
            (dbfTmp)->NPREUNIT     := val( aLinFac[ nSelFac, n, 5 ] ) / 100





            DO CASE
            CASE aLinFac[ nSelFac, n, 6 ] == "1"
                nIva    := 7
            CASE aLinFac[ nSelFac, n, 6 ] == "2"
                nIva    := 16
            CASE aLinFac[ nSelFac, n, 6 ] == "3"
                nIva    := 4
            end

            (dbfTmp)->NIVA            := nIva

        NEXT

        (dbfTmp)->( dbGoTop() )

    end

RETURN NIL







FUNCTION GenPgoRctPrv( cNumFac, dbfRctPrvT, dbfRctPrvL, dbfRctPrvP, dbfPrv, dbfFPago, dbfDiv, aTmp )

   local nCobro
   local cCodPgo
   local cSerFac
   local nNumFac
   local cSufFac
   local cDivFac
   local nVdvFac
   local dFecFac
   local cCodPrv
   local cNomPrv
   local cCodUsr
   local cCodCaj
   local nTotal
   local nTotCob
   local nDec
   local nInc        := 0
   local n           := 0
   local nTotAcu     := 0
   local nPlazos     := 0
   local cBanco
   local cEntidad
   local cSucursal
   local cControl
   local cCuenta

   if aTmp <> nil
      cSerFac        := aTmp[ 1 ]
      nNumFac        := aTmp[ 2 ]
      cSufFac        := aTmp[ 3 ]
      cDivFac        := aTmp[ 35 ]
      nVdvFac        := aTmp[ 36 ]
      dFecFac        := aTmp[ 5 ]
      cCodPgo        := aTmp[ 23]
      cCodPrv        := aTmp[ 6 ]
      cNomPrv        := aTmp[ 9 ]
      cCodUsr        := aTmp[ 46 ]
      cCodCaj        := aTmp[ 8 ]
   else
      cSerFac        := ( dbfRctPrvT )->cSerFac
      nNumFac        := ( dbfRctPrvT )->nNumFac
      cSufFac        := ( dbfRctPrvT )->cSufFac
      cDivFac        := ( dbfRctPrvT )->cDivFac
      nVdvFac        := ( dbfRctPrvT )->nVdvFac
      dFecFac        := ( dbfRctPrvT )->dFecFac
      cCodPgo        := ( dbfRctPrvT )->cCodPago
      cCodPrv        := ( dbfRctPrvT )->cCodPrv
      cNomPrv        := ( dbfRctPrvT )->cNomPrv
      cCodUsr        := ( dbfRctPrvT )->cCodUsr
      cCodCaj        := ( dbfRctPrvT )->cCodCaj
      cBanco         := ( dbfRctPrvT )->cBanco
      cEntidad       := ( dbfRctPrvT )->cEntBnc
      cSucursal      := ( dbfRctPrvT )->cSucBnc
      cControl       := ( dbfRctPrvT )->cDigBnc
      cCuenta        := ( dbfRctPrvT )->cCtaBnc
   end





   nTotal            := nTotRctPrv( cNumFac, dbfRctPrvT, dbfRctPrvL, dbfIva, dbfDiv, dbfRctPrvP, nil, nil, .F. )
   nTotCob           := nPagRctPrv( cNumFac, dbfRctPrvP, nil, dbfDiv, .F. )
   nDec              := nRouDiv( cDivFac, dbfDiv )

   if nTotal <> nTotCob





      if ( dbfRctPrvP )->( dbSeek( cNumFac ) )

         while cNumFac == ( dbfRctPrvP )->cSerFac + Str( ( dbfRctPrvP )->nNumFac ) + ( dbfRctPrvP )->cSufFac .AND. !( dbfRctPrvP )->( eof() )

            if !( dbfRctPrvP )->lCobrado .AND. dbLock( dbfRctPrvP )
               ( dbfRctPrvP )->( dbDelete() )
               ( dbfRctPrvP )->( dbUnLock() )
            end

            ( dbfRctPrvP )->( dbSkip() )

         end

      end

      nTotal            -= nPagRctPrv( cNumFac, dbfRctPrvP, nil, dbfDiv, .F. )





      if ( dbfFPago )->( dbSeek( cCodPgo ) )

         nTotAcu        := nTotal
         nPlazos        := Max( ( dbfFPago )->nPlazos, 1 )

         for n := 1 to nPlazos

            if n <> nPlazos
               nTotAcu  -= Round( nTotal / nPlazos, nDec )
            end

            nInc        := nNewReciboProveedor( cSerFac + Str( nNumFac ) + cSufFac, "R", dbfRctPrvP )

            ( dbfRctPrvP)->( dbAppend() )

            ( dbfRctPrvP )->cSerFac    := cSerFac
            ( dbfRctPrvP )->nNumFac    := nNumFac
            ( dbfRctPrvP )->cSufFac    := cSufFac
            ( dbfRctPrvP )->cCodPrv    := cCodPrv
            ( dbfRctPrvP )->cNomPrv    := cNomPrv
            ( dbfRctPrvP )->nNumRec    := nInc
            ( dbfRctPrvP )->cTipRec    := "R"
            ( dbfRctPrvP )->nImporte   := if( n <> nPlazos, Round( nTotal / nPlazos, nDec ), Round( nTotAcu, nDec ) )
            ( dbfRctPrvP )->cTurRec    := cCurSesion()
            ( dbfRctPrvP )->cDescrip   := "Recibo nº" + AllTrim( Str( nInc ) ) + " de factura rectificativa " + cSerFac  + "/" + allTrim( Str( nNumFac ) ) + "/" + cSufFac
            ( dbfRctPrvP )->cDivPgo    := cDivFac
            ( dbfRctPrvP )->nVdvPgo    := nVdvFac
            ( dbfRctPrvP )->lCobRado   := ( ( dbfFPago )->nCobRec == 1 )
            ( dbfRctPrvP )->dPreCob    := dFecFac
            ( dbfRctPrvP )->dFecVto    := dNexDay( dFecFac + ( dbfFPago )->nPlaUno + ( ( dbfFPago )->nDiaPla * ( n - 1 ) ), dbfPrv )
            ( dbfRctPrvP )->cCtaRec    := ( dbfFPago )->cCtaCobro
            ( dbfRctPrvP )->dFecChg    := GetSysDate()
            ( dbfRctPrvP )->cTimChg    := Time()
            ( dbfRctPrvP )->cCodPgo    := cCodPgo
            ( dbfRctPrvP )->lNotArqueo := .F.
            ( dbfRctPrvP )->cCodCaj    := cCodCaj
            ( dbfRctPrvP )->cCodUsr    := cCodUsr

            if ( dbfFPago )->lUtlBnc
               ( dbfRctPrvP )->cBncEmp    := ( dbfFPago )->cBanco
               ( dbfRctPrvP )->cEntEmp    := ( dbfFPago )->cEntBnc
               ( dbfRctPrvP )->cSucEmp    := ( dbfFPago )->cSucBnc
               ( dbfRctPrvP )->cDigEmp    := ( dbfFPago )->cDigBnc
               ( dbfRctPrvP )->cCtaEmp    := ( dbfFPago )->cCtaBnc
            end

            ( dbfRctPrvP )->cBncPrv       := cBanco
            ( dbfRctPrvP )->cEntPrv       := cEntidad
            ( dbfRctPrvP )->cSucPrv       := cSucursal
            ( dbfRctPrvP )->cDigPrv       := cControl
            ( dbfRctPrvP )->cCtaPrv       := cCuenta

            if ( dbfFPago )->nCobRec == 1
               ( dbfRctPrvP )->dEntrada:= dNexDay( dFecFac + ( dbfFPago )->nPlaUno + ( ( dbfFPago )->nDiaPla * ( n - 1 ) ), dbfPrv )
            end

            ( dbfRctPrvP )->( dbUnLock() )

         next

      end

   end

RETURN NIL






function nTotVRctPrv( cCodArt, dbfRctPrvL, nDinDiv, nDirDiv )

   local nTotVta  := 0
   local nRecno   := ( dbfRctPrvL )->( Recno() )

   if ( dbfRctPrvL )->( dbSeek( cCodArt ) )

      while ( dbfRctPrvL )->CREF == cCodArt .AND. !( dbfRctPrvL )->( eof() )

         nTotVta  += nTotLRctPrv( dbfRctPrvL, nDinDiv, nDirDiv )
         ( dbfRctPrvL )->( dbSkip() )

      end

   end

   ( dbfRctPrvL )->( dbGoTo( nRecno ) )

return ( nTotVta )






function nTotDRctPrv( cCodArt, dbfRctPrvL, cCodAlm )

   local nTotVta  := 0
   local nRecno   := ( dbfRctPrvL )->( Recno() )

   if ( dbfRctPrvL )->( dbSeek( cCodArt ) )

      while ( dbfRctPrvL )->CREF == cCodArt .AND. !( dbfRctPrvL )->( eof() )

         if cCodAlm <> nil
            if cCodAlm == ( dbfRctPrvL )->cAlmLin
               nTotVta  += nTotNRctPrv( dbfRctPrvL )
            end
         else
            nTotVta     += nTotNRctPrv( dbfRctPrvL )
         end

         ( dbfRctPrvL )->( dbSkip() )

      end

   end

   ( dbfRctPrvL )->( dbGoTo( nRecno ) )

return ( nTotVta )



static function lNotOpen()

   if NetErr()
      msgAlert( "Imposible abrir ficheros." )
      CloseFiles()
      return .T.
   end

return .F.






FUNCTION lConRctPrv( cFacPrv, dbfRctPrvT )

   local lConFac  := .F.

   IF ( dbfRctPrvT )->( dbSeek( cFacPrv ) )
      lConFac     := ( dbfRctPrvT )->LCONTAB
    end

RETURN ( lConFac )







FUNCTION dPrvRctPrv( cFacPrv, dbfRctPrvT )

   local cCodPrv  := ""

   IF ( dbfRctPrvT )->( dbSeek( cFacPrv ) )
      cCodPrv     := (dbfRctPrvT)->cCodPrv
    end

RETURN ( cCodPrv )







FUNCTION cPgoRctPrv( cFacPrv, dbfRctPrvT )

   local cCodPgo  := ""

   IF ( dbfRctPrvT )->( dbSeek( cFacPrv ) )
      cCodPgo     := ( dbfRctPrvT )->cCodPago
   end

RETURN ( cCodPgo )



FUNCTION cNomRctPrv( cFacPrv, dbfRctPrvT )

   local cNomPrv := ""

   IF ( dbfRctPrvT )->( dbSeek( cFacPrv ) )
      cNomPrv  := ( dbfRctPrvT )->cNomPrv
    end

RETURN ( cNomPrv )



FUNCTION cCodRctPrv( cFacPrv, uFacPrvT )

   local cCodPrv := ""

   if ValType( uFacPrvT ) == "O"

      if uFacPrvT:Seek( cFacPrv )
         cCodPrv  := uFacPrvT:cCodPrv
      end

   else

      if ( uFacPrvT )->( dbSeek( cFacPrv ) )
         cCodPrv  := ( uFacPrvT )->cCodPrv
      end

   end

RETURN ( cCodPrv )






Static Function lRecibosPagados( uFacPrv, dbfRctPrvP )

   local cNumFac
   local lRecPgd  := .F.
   local nRecAct  := ( dbfRctPrvP )->( Recno() )
   local nOrdAct  := ( dbfRctPrvP )->( OrdSetFocus( "NNUMFAC" ) )

   if ValType( uFacPrv ) == "A"
      cNumFac     := uFacPrv[ 1 ] + Str( uFacPrv[ 2 ], 9 ) + uFacPrv[ 3 ]
   else
      cNumFac     := ( uFacPrv )->CSERFAC + Str( ( uFacPrv )->NNUMFAC ) + ( uFacPrv )->CSUFFAC
   end

   if ( dbfRctPrvP )->( dbSeek( cNumFac ) )
      while cNumFac == ( dbfRctPrvP )->cSerFac + Str( ( dbfRctPrvP )->nNumFac ) + ( dbfRctPrvP )->cSufFac .AND. !( dbfRctPrvP )->( eof() )
         if ( dbfRctPrvP )->lCobrado .AND. !( dbfRctPrvP )->lDevuelto
            lRecPgd   := .T.
            exit
         end
         ( dbfRctPrvP )->( dbSkip() )
      end
   end

   ( dbfRctPrvP )->( OrdSetFocus( nOrdAct ) )
   ( dbfRctPrvP )->( dbGoTo( nRecAct) )

return ( lRecPgd )



function dFecVtoRct( nVto )

   local dVto     := Ctod( "  /  /  " )

   IIF( nVto == nil, nVto := 1, ) ;

   if nVto <= len( aDatVcto )
      dVto        := aDatVcto[ nVto ]
   end

return ( dVto )



function nImpVtoRct( nVto )

   local nImp     := 0

   IIF( nVto == nil, nVto := 1, ) ;

   if nVto <= len( aImpVcto )
      nImp        := aImpVcto[ nVto ]
   end

return ( nImp )



static function lGenFac( oBrw, oBtn, nDevice )

   local bAction

   IIF( nDevice == nil, nDevice := 1, ) ;

   if Empty( oBtn )
      return nil
   end

   IF !( dbfDoc )->( dbSeek( "TP" ) )








         oWndBrw:NewAt( "DOCUMENT",,, {||( msgStop( "No hay facturas de proveedores predefinidos" ) )}, "No hay documentos", "N",,, 4, oBtn, .F. )

   ELSE

      WHILE ( dbfDoc )->cTipo == "TP" .AND. !( dbfDoc )->( eof() )

         bAction  := bGenFac( nDevice, "Imprimiendo facturas de proveedores", ( dbfDoc )->CODIGO )

         oWndBrw:NewAt( "Document", , , bAction, Rtrim( ( dbfDoc )->cDescrip ) , , , , , oBtn )

         ( dbfDoc )->( dbSkip() )

      end

   end

   SysRefresh()

return nil



static function bGenFac( nDevice, cTitle, cCodDoc )

   local bGen
   local nDev  := by( nDevice )
   local cTit  := by( cTitle  )
   local cCod  := by( cCodDoc )

   if nDev == 1
      bGen     := {|| nGenRctPrv( nDevice, cTit, cCod ) }
   else
      bGen     := {|| nGenRctPrv( nDevice, cTit, cCod ) }
   end

return bGen






FUNCTION nNetLFacRct( uFacPrvL, uFacPrvT, nDec, nRec, nVdv, cPirDiv )

   local nCalculo

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nRec == nil, nRec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo       := nNetURctPrv( uFacPrvL, nDec, nRec, nVdv )

   nCalculo       *= nTotNRctPrv( uFacPrvL )





   if ValType( uFacPrvL ) == "A"

      if uFacPrvL[ 8 ]<> 0
         nCalculo    -= nCalculo * uFacPrvL[ 8 ] / 100
      end

   else

      if ( uFacPrvL )->nDto <> 0
         nCalculo    -= nCalculo * ( uFacPrvL )->nDto / 100
      end

   end

   nCalculo          := Round( nCalculo, nRec )

RETURN ( if( cPirDiv <> NIL, Trans( nCalculo, cPirDiv ), nCalculo ) )



FUNCTION nBrtLRctPrv( uTmpLin, nDec, nRec, nVdv, cPorDiv )

   local nCalculo := 0

   IIF( nDec == nil, nDec := 2, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo       := nTotURctPrv( uTmpLin, nDec, nVdv, cPorDiv )
   nCalculo       *= nTotNRctPrv( uTmpLin )

   nCalculo       := Round( nCalculo / nVdv, nRec )

Return ( if( cPorDiv <> nil, Trans( nCalculo, cPorDiv ), nCalculo ) )



FUNCTION cProFacRct( cFacPro, dbfRctPrvT )

   local cCodPro := ""

   IF ( dbfRctPrvT )->( dbSeek( cFacPro ) )
      cCodPro  := ( dbfRctPrvT )->CCODPRO
    end

RETURN ( cCodPro )



FUNCTION nTotNRctPrv( uDbf )

   local nTotUnd

   IIF( uDbf == nil, uDbf := dbfRctPrvL, ) ;

   do case
      case ValType( uDbf ) == "A"
         nTotUnd  := uDbf[ 13 ]
         nTotUnd  *= NotCaja( uDbf[ 10 ] )
         nTotUnd  *= NotCero( uDbf[ 64 ] )
         nTotUnd  *= NotCero( uDbf[ 85 ] )
         nTotUnd  *= NotCero( uDbf[ 86 ] )
         nTotUnd  *= NotCero( uDbf[ 87 ] )

      case ValType( uDbf ) == "O"
         nTotUnd  := uDbf:nUniCaja
         nTotUnd  *= NotCaja( uDbf:nCanEnt )
         nTotUnd  *= NotCero( uDbf:nUndKit )
         nTotUnd  *= NotCero( uDbf:nMedUno )
         nTotUnd  *= NotCero( uDbf:nMedDos )
         nTotUnd  *= NotCero( uDbf:nMedTre )

      otherwise
         nTotUnd  := ( uDbf )->nUniCaja
         nTotUnd  *= NotCaja( ( uDbf )->nCanEnt )
         nTotUnd  *= NotCero( ( uDbf )->nUndKit )
         nTotUnd  *= NotCero( ( uDbf )->nMedUno )
         nTotUnd  *= NotCero( ( uDbf )->nMedDos )
         nTotUnd  *= NotCero( ( uDbf )->nMedTre )

   end

RETURN ( nTotUnd )



FUNCTION nIvaURctPrv( dbfTmp, nDec, nVdv )

   local nCalculo

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo       := nTotURctPrv( dbfTmp, nDec, nVdv )

   if !( dbfTmp )->lIvaLin
      nCalculo    += nCalculo * ( dbfTmp )->nIva / 100
   end

   if nVdv <> 0
      nCalculo    := nCalculo / nVdv
   end

RETURN ( Round( nCalculo, nDec ) )



FUNCTION nIvaLRctPrv( dbfLin, nDec, nRouDec, nVdv, lDto, lPntVer, cPorDiv )

   local nCalculo := nTotLRctPrv( dbfLin, nDec, nRouDec, nVdv )

   if !( dbfLin )->lIvaLin
      nCalculo    := nCalculo * ( dbfLin )->nIva / 100
   end

RETURN ( if( cPorDiv <> NIL, Trans( nCalculo, cPorDiv ), nCalculo ) )







FUNCTION aTotRctPrv( cFactura, dbfRctPrvT, dbfRctPrvL, dbfIva, dbfDiv, dbfRctPrvP, cDivRet )

   nTotRctPrv( cFactura, dbfRctPrvT, dbfRctPrvL, dbfIva, dbfDiv, dbfRctPrvP, nil, cDivRet )

RETURN ( { nTotNet, nTotIva, nTotReq, nTotFac, aTotIva, nTotRet } )



static function QuiRctPrv( lDetail, lSetCnt )

   local nOrdAnt

   IIF( lDetail == nil, lDetail := .T., ) ;
   IIF( lSetCnt == nil, lSetCnt := .T., ) ;

   if ( dbfRctPrvT )->lCloFac .AND. !oUser():lAdministrador()
      msgStop( "Solo puede eliminar facturas cerradas los administradores." )
      Return .F.
   end

   CursorWait()

   if lDetail
      DelDetalle()
   end

   nOrdAnt        := ( dbfAlbPrvT )->( OrdSetFocus( "cNumFac" ) )

   while ( dbfAlbPrvT )->( dbSeek( ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac ) )
      SetFacturadoAlbaranProveedor( .F., , , dbfAlbPrvT, dbfAlbPrvL )
   end

   ( dbfAlbPrvT )->( OrdSetFocus( nOrdAnt ) )

   if lSetCnt
      nPutDoc( ( dbfRctPrvT )->cSerFac, ( dbfRctPrvT )->nNumFac, ( dbfRctPrvT )->cSufFac, dbfRctPrvT, "nRctPrv" )
   end

   CursorWE()

return .T.



STATIC FUNCTION DelDetalle( cFactura )

   local nOrdAnt

   IIF( cFactura == nil, cFactura := ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac, ) ;

   CursorWait()





   while ( dbfRctPrvL )->( dbSeek( cFactura ) ) .AND. !( dbfRctPrvL )->( eof() )
      if dbLock( dbfRctPrvL )
         ( dbfRctPrvL )->( dbDelete() )
         ( dbfRctPrvL )->( dbUnLock() )
      end
   end





   while ( dbfRctPrvP )->( dbSeek( cFactura ) ) .AND. !( dbfRctPrvP )->( eof() )
      if dbLock( dbfRctPrvP )
         ( dbfRctPrvP )->( dbDelete() )
         ( dbfRctPrvP )->( dbUnLock() )
      end
   end

   while ( dbfRctPrvI )->( dbSeek( cFactura ) .AND. !( dbfRctPrvI )->( eof() ) )
      if dbLock( dbfRctPrvI )
         ( dbfRctPrvI )->( dbDelete() )
         ( dbfRctPrvI )->( dbUnLock() )
      end
   end

   while ( dbfRctPrvD )->( dbSeek( cFactura ) .AND. !( dbfRctPrvD )->( eof() ) )
      if dbLock( dbfRctPrvD )
         ( dbfRctPrvD )->( dbDelete() )
         ( dbfRctPrvD )->( dbUnLock() )
      end
   end

   while ( dbfRctPrvS )->( dbSeek( cFactura ) .AND. !( dbfRctPrvS )->( eof() ) )
      if dbLock( dbfRctPrvS )
         ( dbfRctPrvS )->( dbDelete() )
         ( dbfRctPrvS )->( dbUnLock() )
      end
   end





   nOrdAnt           := ( dbfAlbPrvT )->( OrdSetFocus( "cNumFac" ) )

   if ( dbfAlbPrvT )->( dbSeek( cFactura ) )

      while ( dbfAlbPrvT )->cNumFac == cFactura .AND. !( dbfAlbPrvT )->( eof() )

         SetFacturadoAlbaranProveedor( .F., oStock, , dbfAlbPrvT, dbfAlbPrvL )

         ( dbfAlbPrvT )->( dbSkip() )

      end

   end

   ( dbfAlbPrvT )->( OrdSetFocus( nOrdAnt ) )

   CursorWe()

RETURN NIL



function aItmRctPrv()

   local aItmFacPrv  := {}

   aAdd( aItmFacPrv, { "CSERFAC"    ,"C",  1, 0, "Serie de factura"                         ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "NNUMFAC"    ,"N",  9, 0, "Número de factura"                        ,            "'999999999'",        "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CSUFFAC"    ,"C",  2, 0, "Sufijo de factura"                        ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CTURFAC"    ,"C",  6, 0, "Sesión del factura"                       ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "DFECFAC"    ,"D",  8, 0, "Fecha de la factura"                      ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CCODPRV"    ,"C", 12, 0, "Código del proveedor"                     ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CCODALM"    ,"C",  3, 0, "Código de almacen"                        ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CCODCAJ"    ,"C",  3, 0, "Código de caja"                           ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CNOMPRV"    ,"C", 35, 0, "Nombre del proveedor"                     ,            "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CDIRPRV"    ,"C", 35, 0, "Domicilio del proveedor"                  ,            "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CPOBPRV"    ,"C", 25, 0, "Población del proveedor"                  ,            "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CPROVPROV"  ,"C", 20, 0, "Provincia del proveedor"                  ,            "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CPOSPRV"    ,"C",  5, 0, "Código postal del proveedor"              ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CDNIPRV"    ,"C", 30, 0, "DNI/CIF del proveedor"                    ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "LLIQUIDADA" ,"L",  1, 0, "Lógico de la liquidación"                 ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "LCONTAB"    ,"L",  1, 0, "Lógico de la contabilización"             ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "DFECENT"    ,"D",  8, 0, "Fecha de entrada"                         ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CSUPED"     ,"C", 10, 0, "Su pedido"                                ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CCONDENT"   ,"C", 20, 0, "Condición de entrada"                     ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "MCOMENT"    ,"M", 10, 0, "Comentarios"                              ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CEXPED"     ,"C", 20, 0, "Expedición"                               ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "COBSERV"    ,"C", 20, 0, "Observaciones"                            ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CCODPAGO"   ,"C",  2, 0, "Codigo del tipo de pago"                  ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "NBULTOS"    ,"N",  3, 0, "Número de bultos"                         ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "NPORTES"    ,"N",  6, 0, "Valor de los portes"                      ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "cNumFac"    ,"C", 12, 0, "Número de la factura"                     ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "LIMPALB"    ,"L",  1, 0, "Factura importada desde albaranes"        ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CDTOESP"    ,"C", 50, 0, "Descripción de descuento especial"        ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "NDTOESP"    ,"N",  5, 2, "Porcentaje de descuento especial"         ,            "'@EZ 99.99'",        "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CDPP"       ,"C", 50, 0, "Descripción descuento por pronto pago"    ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "NDPP"       ,"N",  5, 2, "Porcentaje de descuento por pronto pago"  ,            "'@EZ 99.99'",        "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "LRECARGO"   ,"L",  1, 0, "Lógico para recargo"                      ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "NIRPF"      ,"N",  4, 1, "Porcentaje de IRPF"                       ,            "'@EZ 99.99'",        "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CCODAGE"    ,"C",  3, 0, "Código del agente"                        ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CDIVFAC"    ,"C",  3, 0, "Código de divisa"                         ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "NVDVFAC"    ,"N", 13, 6, "Valor del cambio de la divisa"            ,            "'@E 999,999.999999'","", "( cDbf )"} )
   aAdd( aItmFacPrv, { "LSNDDOC"    ,"L",  1, 0, "Enviar documento por internet"            ,            "",                   "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CDTOUNO"    ,"C", 25, 0, "Descripción de primer descuento personalizado",        "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "NDTOUNO"    ,"N",  5, 2, "Porcentaje de primer descuento personalizado",         "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CDTODOS"    ,"C", 25, 0, "Descripción de segundo descuento personalizado",       "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "NDTODOS"    ,"N",  5, 2, "Porcentaje de segundo descuento personalizado",        "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CCODPRO"    ,"C",  9, 0, "Código de proyecto en contabilidad",                   "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "LRECDOC"    ,"L",  1, 0, "Documento recibido por internet"          ,            "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "LCLOFAC"    ,"L",  1, 0, ""                                         ,            "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "CNUMDOC"    ,"C", 20, 0, "Número de documento"                      ,            "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "cCodUsr"    ,"C",  3, 0, "Código de usuario",                                    "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "lImprimido" ,"L",  1, 0, "Lógico de imprimido del documento",                    "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "dFecImp"    ,"D",  8, 0, "Última fecha de impresión del documento",              "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "cHorImp"    ,"C",  5, 0, "Hora de la última impresión del documento",            "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nTipRet"    ,"N",  1, 0, "Tipo de retención ( 1. Base / 2. Base+IVA )",          "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nPctRet"    ,"N",  6, 2, "Porcentaje de retención",                              "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "dFecChg"    ,"D",  8, 0, "Fecha de modificación del documento",                  "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "cTimChg"    ,"C",  5, 0, "Hora de modificación del documento",                   "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "cCodDlg"    ,"C",  2, 0, "Código delegación",                                    "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nRegIva"    ,"N",  1, 0, "Régimen de " + cImp(),                                 "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "lFacGas"    ,"L",  1, 0, "Lógico factura de gastos",                             "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "mComGas"    ,"M", 10, 0, "Comentario de gastos",                                 "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nNetGas1"   ,"N", 16, 6, "Neto de fac. de gastos 1",                             "cPirDivFac",     "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nNetGas2"   ,"N", 16, 6, "Neto de fac. de gastos 2",                             "cPirDivFac",     "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nNetGas3"   ,"N", 16, 6, "Neto de fac. de gastos 3",                             "cPirDivFac",     "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nIvaGas1"   ,"N",  6, 2, "Porcentaje " + cImp() + " 1 de gastos",                "'@EZ 99.99'",    "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nIvaGas2"   ,"N",  6, 2, "Porcentaje " + cImp() + " 2 de gastos",                "'@EZ 99.99'",    "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nIvaGas3"   ,"N",  6, 2, "Porcentaje " + cImp() + " 3 de gastos",                "'@EZ 99.99'",    "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nReGas1"    ,"N",  6, 2, "Porcentaje R.E. 1 de gastos",                          "'@EZ 99.99'",    "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nReGas2"    ,"N",  6, 2, "Porcentaje R.E. 2 de gastos",                          "'@EZ 99.99'",    "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nReGas3"    ,"N",  6, 2, "Porcentaje R.E. 3 de gastos",                          "'@EZ 99.99'",    "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "cMotRec"    ,"C",250, 0, "Motivo de la factura rectificativa",                   "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "cCauRec"    ,"C",250, 0, "Causa de la factura rectificativa",                    "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nTotNet"    ,"N", 16, 6, "Total neto",                                           "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nTotIva"    ,"N", 16, 6, "Total " + cImp(),                                      "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nTotReq"    ,"N", 16, 6, "Total recargo",                                        "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nTotFac"    ,"N", 16, 6, "Total factura rectificativa",                          "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "nTotSup"    ,"N", 16, 6, "Total gastos suplidos",                                "",               "", "( cDbf )"} )
   aAdd( aItmFacPrv, { "cBanco"     ,"C", 50, 0, "Nombre del banco del proveedor" ,                      "",               "", "( cDbf )", nil } )
   aAdd( aItmFacPrv, { "cEntBnc"    ,"C",  4, 0, "Entidad de la cuenta bancaria del proveedor" ,         "",               "", "( cDbf )", nil } )
   aAdd( aItmFacPrv, { "cSucBnc"    ,"C",  4, 0, "Sucursal de la cuenta bancaria del proveedor" ,        "",               "", "( cDbf )", nil } )
   aAdd( aItmFacPrv, { "cDigBnc"    ,"C",  2, 0, "Dígito de control de la cuenta bancaria del proveedor","",               "", "( cDbf )", nil } )
   aAdd( aItmFacPrv, { "cCtaBnc"    ,"C", 10, 0, "Cuenta bancaria del proveedor" ,                       "",               "", "( cDbf )", nil } )

return ( aItmFacPrv )



function aColRctPrv()

   local aColFacPrv  := {}

   aAdd( aColFacPrv, { "CSERFAC"    ,"C",  1, 0, "Serie de factura"            ,"",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NNUMFAC"    ,"N",  9, 0, "Número de factura"           ,"'999999999'",         "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CSUFFAC"    ,"C",  2, 0, "Sufijo de factura"           ,"",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CREF"       ,"C", 18, 0, "Referencia artículo"         ,"",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CREFPRV"    ,"C", 20, 0, "Referencia del proveedor"    ,"",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CDETALLE"   ,"C",250, 0, "Detalle de articulo"         ,"",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NPREUNIT"   ,"N", 16, 6, "Precio unitario"             ,"cPinDivFac",          "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NDTO"       ,"N",  6, 2, ""                            ,"'@E 99,99'",          "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NIVA"       ,"N",  6, 2, "Porcentaje de " + cImp()     ,"'@E 99,99'",          "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NCANENT"    ,"N", 16, 6, "Cantidad recibida"           ,"MasUnd()",            "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "LCONTROL"   ,"L",  1, 0, "Control reservado"           ,"",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CUNIDAD"    ,"C",  2, 0, "Unidad de venta"             ,"",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NUNICAJA"   ,"N", 16, 6, "Unidades por caja"           ,"MasUnd()",            "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "LCHGLIN"    ,"L",  1, 0, "Cambio de precio"            ,"",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "MLNGDES"    ,"M", 10, 0, ""                            ,""          ,          "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NDTOLIN"    ,"N",  6, 2, "Descuento lineal"            ,"'@E 999,99'",         "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NDTOPRM"    ,"N",  6, 2, "Descuento por promoción"     ,"'@E 999,99'",         "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NDTORAP"    ,"N",  6, 2, "Descuento por rappels"       ,"'@E 999,99'",         "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NPRECOM"    ,"N", 16, 6, "Precio de compra"            ,"cPinDivFac",          "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "LBNFLIN1"   ,"L",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "LBNFLIN2"   ,"L",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "LBNFLIN3"   ,"L",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "LBNFLIN4"   ,"L",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "LBNFLIN5"   ,"L",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "LBNFLIN6"   ,"L",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "NBNFLIN1"   ,"N",  6, 2, "" }                                                                      )
   aAdd( aColFacPrv, { "NBNFLIN2"   ,"N",  6, 2, "" }                                                                      )
   aAdd( aColFacPrv, { "NBNFLIN3"   ,"N",  6, 2, "" }                                                                      )
   aAdd( aColFacPrv, { "NBNFLIN4"   ,"N",  6, 2, "" }                                                                      )
   aAdd( aColFacPrv, { "NBNFLIN5"   ,"N",  6, 2, "" }                                                                      )
   aAdd( aColFacPrv, { "NBNFLIN6"   ,"N",  6, 2, "" }                                                                      )
   aAdd( aColFacPrv, { "NBNFSBR1"   ,"N",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "NBNFSBR2"   ,"N",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "NBNFSBR3"   ,"N",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "NBNFSBR4"   ,"N",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "NBNFSBR5"   ,"N",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "NBNFSBR6"   ,"N",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "NPVPLIN1"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aColFacPrv, { "NPVPLIN2"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aColFacPrv, { "NPVPLIN3"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aColFacPrv, { "NPVPLIN4"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aColFacPrv, { "NPVPLIN5"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aColFacPrv, { "NPVPLIN6"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aColFacPrv, { "NIVALIN1"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aColFacPrv, { "NIVALIN2"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aColFacPrv, { "NIVALIN3"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aColFacPrv, { "NIVALIN4"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aColFacPrv, { "NIVALIN5"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aColFacPrv, { "NIVALIN6"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aColFacPrv, { "NIVALIN"    ,"N",  6, 2, "" }                                                                      )
   aAdd( aColFacPrv, { "LIVALIN"    ,"L",  1, 0, "" }                                                                      )
   aAdd( aColFacPrv, { "CCODPR1"    ,"C", 10, 0, "Código de la propiedad 1",     "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CCODPR2"    ,"C", 10, 0, "Código de la propiedad 2",     "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CVALPR1"    ,"C", 10, 0, "Valor de la propiedad 1" ,     "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CVALPR2"    ,"C", 10, 0, "Valor de la propiedad 2" ,     "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NFACCNV"    ,"N", 16, 6, "Factor de conversión de la compra", "",               "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CALMLIN"    ,"C",  3, 0, "Código del almacen" ,          "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NCTLSTK"    ,"N",  1, 0, "Tipo de stock de la línea",    "'9'",                 "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "LLOTE"      ,"L",  1, 0, "",                             "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NLOTE"      ,"N",  9, 0, "",                             "'999999999'",         "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CLOTE"      ,"C", 12, 0, "Número de lote",               "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "dFecCad"    ,"D",  8, 0, "Fecha de caducidad",           "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NNUMLIN"    ,"N",  4, 0, "Número de la línea",           "9999",                "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NUNDKIT"    ,"N", 16, 6, "Unidades del producto kit",    "MasUnd()",            "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "LKITART"    ,"L",  1, 0, "Línea con escandallo",         "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "LKITCHL"    ,"L",  1, 0, "Línea pertenciente a escandallo", "",                 "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "LKITPRC"    ,"L",  1, 0, "",                             "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "LIMPLIN"    ,"L",  1, 0, "Imprimir linea",               "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "MNUMSER"    ,"M", 10, 0, "" ,                            "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CCODUBI1"   ,"C",  5, 0, "",                             "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CCODUBI2"   ,"C",  5, 0, "",                             "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CCODUBI3"   ,"C",  5, 0, "",                             "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CVALUBI1"   ,"C",  5, 0, "",                             "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CVALUBI2"   ,"C",  5, 0, "",                             "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CVALUBI3"   ,"C",  5, 0, "",                             "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CNOMUBI1"   ,"C", 30, 0, "",                             "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CNOMUBI2"   ,"C", 30, 0, "",                             "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CNOMUBI3"   ,"C", 30, 0, "",                             "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CCODFAM"    ,"C", 16, 0, "Código de familia",            "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "CGRPFAM"    ,"C",  3, 0, "Código del grupo de familia",  "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "NREQ"       ,"N", 16, 6, "Recargo de equivalencia",      "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "MOBSLIN"    ,"M", 10, 0, "Observacion de línea",         "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "nPvpRec"    ,"N", 16, 6, "Precio de venta recomendado",  "cPinDivFac",          "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "nNumMed"    ,"N",  1, 0, "Número de mediciones",         "MasUnd()",            "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "nMedUno"    ,"N", 16, 6, "Primera unidad de medición",   "MasUnd()",            "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "nMedDos"    ,"N", 16, 6, "Segunda unidad de medición",   "MasUnd()",            "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "nMedTre"    ,"N", 16, 6, "Tercera unidad de medición",   "MasUnd()",            "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "lGasSup"    ,"L",  1, 0, "Linea de gastos suplidos",     "",                    "", "( cDbfCol )" } )
   aAdd( aColFacPrv, { "dFecFac"    ,"D",  8, 0, "Fecha de la factura",          "",                    "", "( cDbfCol )" } )

Return ( aColFacPrv )



Static Function lLiquida( oBrw, cFactura, cDivFac )

   IIF( cFactura == nil, cFactura := ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac, ) ;
   IIF( cDivFac == nil, cDivFac := ( dbfRctPrvT )->cDivFac, ) ;

   if ( dbfRctPrvT )->lLiquidada
      MsgStop( "Factura ya pagada" )
      return .F.
   end





   ( dbfRctPrvP )->( dbGoTop() )

   if ( dbfRctPrvP )->( dbSeek( cFactura ) )

      while ( dbfRctPrvP )->cSerFac + Str( ( dbfRctPrvP )->nNumFac ) + ( dbfRctPrvP )->cSufFac == cFactura .AND. !( dbfRctPrvP )->( eof() )

         if !Empty( ( dbfRctPrvP )->cTipRec ) .AND. !( dbfRctPrvP )->lCobrado

            EdtRecPrv( ( dbfRctPrvP )->cSerFac + Str( ( dbfRctPrvP )->nNumFac ) + ( dbfRctPrvP )->cSufFac, .F. )

            exit

         end

         ( dbfRctPrvP )->( dbSkip() )

      end





      ChkLqdRctPrv( nil, dbfRctPrvT, dbfRctPrvL, dbfRctPrvP, dbfIva, dbfDiv )

   end

   oBrw:Refresh()
   oBrw:SetFocus()

Return .T.



Function SynRctPrv( cPath )

   local aTotFac

   if OpenFiles()

      while !( dbfRctPrvP )->( eof() )

         if Empty( ( dbfRctPrvP )->cCodCaj )
            if dbLock( dbfRctPrvP )
               ( dbfRctPrvP )->cCodCaj := "000"
               ( dbfRctPrvP )->( dbUnLock() )
            end
         end

         if !( ( dbfRctPrvP )->cSerFac >= "A" .AND. ( dbfRctPrvP )->cSerFac <= "Z" )
            if dbLock( dbfRctPrvP )
               ( dbfRctPrvP )->( dbDelete() )
               ( dbfRctPrvP )->( dbUnLock() )
            end
         end

         ( dbfRctPrvP )->( dbSkip() )

         SysRefresh()

      end

      while !( dbfRctPrvT )->( eof() )

         if Empty( ( dbfRctPrvT )->cCodCaj )
            if dbLock( dbfRctPrvT )
               ( dbfRctPrvT )->cCodCaj := "000"
               ( dbfRctPrvT )->( dbUnLock() )
            end
         end

         if !( ( dbfRctPrvT )->cSerFac >= "A" .AND. ( dbfRctPrvT )->cSerFac <= "Z" )
            if dbLock( dbfRctPrvT )
               ( dbfRctPrvT )->( dbDelete() )
               ( dbfRctPrvT )->( dbUnLock() )
            end
         end





         if ( dbfRctPrvT )->nTotFac == 0 .AND. dbLock( dbfRctPrvT )

            aTotFac                 := aTotRctPrv( ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac, dbfRctPrvT, dbfRctPrvL, dbfIva, dbfDiv, dbfRctPrvP, ( dbfRctPrvT )->cDivFac )

            ( dbfRctPrvT )->nTotNet := aTotFac[1]
            ( dbfRctPrvT )->nTotIva := aTotFac[2]
            ( dbfRctPrvT )->nTotReq := aTotFac[3]
            ( dbfRctPrvT )->nTotFac := aTotFac[4]

            ( dbfRctPrvT )->( dbUnLock() )

         end

         ( dbfRctPrvT )->( dbSkip() )

         SysRefresh()

      end

      while !( dbfRctPrvL )->( eof() )

         if !( dbfRctPrvT )->( dbSeek( ( dbfRctPrvL )->cSerFac + Str( ( dbfRctPrvL )->nNumFac ) + ( dbfRctPrvL )->cSufFac ) )

            if dbLock( dbfRctPrvL )
               ( dbfRctPrvL )->( dbDelete() )
               ( dbfRctPrvL )->( dbUnLock() )
            end

         else

            if Empty( ( dbfRctPrvL )->cLote ) .AND. !Empty( ( dbfRctPrvL )->nLote )
               if dbLock( dbfRctPrvL )
                  ( dbfRctPrvL )->cLote   := AllTrim( Str( ( dbfRctPrvL )->nLote ) )
                  ( dbfRctPrvL )->( dbUnLock() )
               end
            end

            if !Empty( ( dbfRctPrvL )->cRef ) .AND. Empty( ( dbfRctPrvL )->cCodFam )
               if dbLock( dbfRctPrvL )
                  ( dbfRctPrvL )->cCodFam := RetFamArt( ( dbfRctPrvL )->cRef, dbfArticulo )
                  ( dbfRctPrvL )->( dbUnLock() )
               end
            end

            if !Empty( ( dbfRctPrvL )->cRef ) .AND. !Empty( ( dbfRctPrvL )->cCodFam )
               if dbLock( dbfRctPrvL )
                  ( dbfRctPrvL )->cGrpFam := cGruFam( ( dbfRctPrvL )->cCodFam, dbfFamilia )
                  ( dbfRctPrvL )->( dbUnLock() )
               end
            end

            if Empty( ( dbfRctPrvL )->nReq )
               if dbLock( dbfRctPrvL )
                  ( dbfRctPrvL )->nReq    := nPReq( dbfIva, ( dbfRctPrvL )->nIva )
                  ( dbfRctPrvL )->( dbUnLock() )
               end
            end

            if ( dbfRctPrvL )->dFecFac <> ( dbfRctPrvT )->dFecFac
               if dbLock( dbfRctPrvL )
                  ( dbfRctPrvL )->dFecFac := ( dbfRctPrvT )->dFecFac
                  ( dbfRctPrvL )->( dbUnLock() )
               end
            end

         end

         ( dbfRctPrvL )->( dbSkip() )

         SysRefresh()

      end

      while !( dbfRctPrvI )->( eof() )

         if !( dbfRctPrvT )->( dbSeek( ( dbfRctPrvI )->cSerFac + Str( ( dbfRctPrvI )->nNumFac ) + ( dbfRctPrvI )->cSufFac ) )
            if dbLock( dbfRctPrvI )
               ( dbfRctPrvI )->( dbDelete() )
               ( dbfRctPrvI )->( dbUnLock() )
            end
         end

         ( dbfRctPrvI )->( dbSkip() )

         SysRefresh()

      end

      CloseFiles()

   end

return nil



_HB_CLASS TRectificativasProveedorSenderReciver ; UTILITY FUNCTION TRectificativasProveedorSenderReciver(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TRectificativasProveedorSenderReciver" , {TSenderReciverItem():classh} ) ) ; ;

   _HB_MEMBER CreateData(); IIF( .F., s_oClass:ModMethod( "CreateData", @TRectificativasProveedorSenderReciver_CreateData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateData", @TRectificativasProveedorSenderReciver_CreateData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER RestoreData(); IIF( .F., s_oClass:ModMethod( "RestoreData", @TRectificativasProveedorSenderReciver_RestoreData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RestoreData", @TRectificativasProveedorSenderReciver_RestoreData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SendData(); IIF( .F., s_oClass:ModMethod( "SendData", @TRectificativasProveedorSenderReciver_SendData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SendData", @TRectificativasProveedorSenderReciver_SendData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ReciveData(); IIF( .F., s_oClass:ModMethod( "ReciveData", @TRectificativasProveedorSenderReciver_ReciveData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReciveData", @TRectificativasProveedorSenderReciver_ReciveData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Process(); IIF( .F., s_oClass:ModMethod( "Process", @TRectificativasProveedorSenderReciver_Process(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Process", @TRectificativasProveedorSenderReciver_Process(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TRectificativasProveedorSenderReciver ;



UTILITY STATIC function TRectificativasProveedorSenderReciver_CreateData() ; local Self AS CLASS TRectificativasProveedorSenderReciver := QSelf() AS CLASS TRectificativasProveedorSenderReciver

   local oBlock
   local oError
   local lSnd        := .F.
   local dbfRctPrvT
   local dbfRctPrvL
   local dbfRctPrvI
   local dbfRctPrvP
   local cFileName   := "FacPrv" + StrZero( ::nGetNumberToSend(), 6 ) + "." + RetSufEmp()

   ::oSender:SetText( "Enviando facturas a proveedores" )

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvT.DBF" ), ( cCheckArea( "FACPRVT", @dbfRctPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvL.DBF" ), ( cCheckArea( "FACPRVL", @dbfRctPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvI.DBF" ), ( cCheckArea( "FacPrvI", @dbfRctPrvI ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvI.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacPrvP.DBF" ), ( cCheckArea( "FacPrvP", @dbfRctPrvP ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "FacPrvP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end





   rxRctPrv( cPatSnd() )
   rxRecPrv( cPatSnd() )

   dbUseArea( .T., ( cDriver() ), ( cPatSnd() + "RctPrvT.DBF" ), ( cCheckArea( "FACPRVT", @tmpRctPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatSnd() + "RctPrvT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., ( cDriver() ), ( cPatSnd() + "RctPrvL.DBF" ), ( cCheckArea( "FACPRVL", @tmpRctPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatSnd() + "RctPrvL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., ( cDriver() ), ( cPatSnd() + "RctPrvI.DBF" ), ( cCheckArea( "FacPrvI", @tmpRctPrvI ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatSnd() + "RctPrvI.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., ( cDriver() ), ( cPatSnd() + "FacPrvP.DBF" ), ( cCheckArea( "FacPrvP", @tmpRctPrvP ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatSnd() + "FacPrvP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if !Empty( ::oSender:oMtr )
      ::oSender:oMtr:nTotal := ( dbfRctPrvT )->( LastRec() )
   end

   while !( dbfRctPrvT )->( eof() )

      if ( dbfRctPrvT )->lSndDoc

         lSnd  := .T.

         dbPass( dbfRctPrvT, tmpRctPrvT, .T. )
         ::oSender:SetText( ( dbfRctPrvT )->cSerFac + "/" + AllTrim( Str( ( dbfRctPrvT )->nNumFac ) ) + "/" + AllTrim( ( dbfRctPrvT )->cSufFac ) + "; " + Dtoc( ( dbfRctPrvT )->dFecFac ) + "; " + AllTrim( ( dbfRctPrvT )->cCodPrv ) + "; " + ( dbfRctPrvT )->cNomPrv )

         if ( dbfRctPrvL )->( dbSeek( ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac ) )
            while ( dbfRctPrvL )->cSerFac + Str( ( dbfRctPrvL )->nNumFac ) + ( dbfRctPrvL )->cSufFac == ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac .AND. !( dbfRctPrvL )->( eof() )
               dbPass( dbfRctPrvL, tmpRctPrvL, .T. )
               ( dbfRctPrvL )->( dbSkip() )
            end
         end

         if ( dbfRctPrvI )->( dbSeek( ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac ) )
            while ( dbfRctPrvI )->cSerFac + Str( ( dbfRctPrvI )->nNumFac ) + ( dbfRctPrvI )->cSufFac == ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac .AND. !( dbfRctPrvI )->( eof() )
               dbPass( dbfRctPrvI, tmpRctPrvI, .T. )
               ( dbfRctPrvI )->( dbSkip() )
            end
         end

         if ( dbfRctPrvP )->( dbSeek( ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac ) )
            while ( dbfRctPrvP )->cSerFac + Str( ( dbfRctPrvL )->nNumFac ) + ( dbfRctPrvL )->cSufFac == ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac .AND. !( dbfRctPrvP )->( eof() )
               dbPass( dbfRctPrvP, tmpRctPrvP, .T. )
               ( dbfRctPrvP )->( dbSkip() )
            end
         end

      end

      ( dbfRctPrvT )->( dbSkip() )

      if !Empty( ::oSender:oMtr )
         ::oSender:oMtr:Set( ( dbfRctPrvT )->( OrdKeyNo() ) )
      end

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfRctPrvT )->( dbCloseArea() )
   ( dbfRctPrvL )->( dbCloseArea() )
   ( dbfRctPrvI )->( dbCloseArea() )
   ( dbfRctPrvP )->( dbCloseArea() )
   ( tmpRctPrvT )->( dbCloseArea() )
   ( tmpRctPrvL )->( dbCloseArea() )
   ( tmpRctPrvI )->( dbCloseArea() )
   ( tmpRctPrvP )->( dbCloseArea() )

   if lSnd





      ::oSender:SetText( "Comprimiendo facturas de proveedores" )

      if ::oSender:lZipData( cFileName )
         ::oSender:SetText( "Ficheros comprimidos" )
      else
         ::oSender:SetText( "ERROR al crear fichero comprimido" )
      end

   else

      ::oSender:SetText( "No hay facturas de proveedores para enviar" )

   end

Return ( Self )



UTILITY STATIC function TRectificativasProveedorSenderReciver_RestoreData() ; local Self AS CLASS TRectificativasProveedorSenderReciver := QSelf() AS CLASS TRectificativasProveedorSenderReciver

   local oBlock
   local oError
   local dbfRctPrvT

   if ::lSuccesfullSend





      oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
      BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvT.DBF" ), ( cCheckArea( "FacPrvT", @dbfRctPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

         lSelectAll( oWndBrw, dbfRctPrvT, "lSndDoc", .F., .T., .T. )

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

      ( dbfRctPrvT )->( dbCloseArea() )

   end

Return ( Self )



UTILITY STATIC function TRectificativasProveedorSenderReciver_SendData() ; local Self AS CLASS TRectificativasProveedorSenderReciver := QSelf() AS CLASS TRectificativasProveedorSenderReciver

   local cFileName         := "FacPrv" + StrZero( ::nGetNumberToSend(), 6 ) + "." + RetSufEmp()

   if File( cPatOut() + cFileName )





      if ftpSndFile( cPatOut() + cFileName, cFileName, 2000, ::oSender )
         ::lSuccesfullSend := .T.
         ::IncNumberToSend()
         ::oSender:SetText( "Fichero enviado " + cFileName )
      else
         ::oSender:SetText( "ERROR al enviar fichero" )
      end

   end

Return ( Self )



UTILITY STATIC function TRectificativasProveedorSenderReciver_ReciveData() ; local Self AS CLASS TRectificativasProveedorSenderReciver := QSelf() AS CLASS TRectificativasProveedorSenderReciver

   local n
   local aExt        := aRetDlgEmp()





   ::oSender:SetText( "Recibiendo facturas de proveedores" )

   for n := 1 to len( aExt )
      ftpGetFiles( "FacPrv*." + aExt[ n ], cPatIn(), 2000, ::oSender )
   next

   ::oSender:SetText( "Facturas rectificativas de proveedores recibidas" )

Return Self



UTILITY STATIC function TRectificativasProveedorSenderReciver_Process() ; local Self AS CLASS TRectificativasProveedorSenderReciver := QSelf() AS CLASS TRectificativasProveedorSenderReciver

   local m
   local oStock
   local dbfRctPrvT
   local dbfRctPrvL
   local dbfRctPrvP
   local aFiles      := Directory( cPatIn() + "RctPrv*.*" )
   local oBlock
   local oError





   ::oSender:SetText( "Recibiendo facturas rectificativas de proveedores" )

   for m := 1 to len( aFiles )

      ::oSender:SetText( "Procesando fichero : " + aFiles[ m, 1 ] )

      oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )

      BEGIN SEQUENCE





      if ::oSender:lUnZipData( cPatIn() + aFiles[ m, 1 ] )







         if lExistTable( cPatSnd() + "RctPrvT.DBF" ) .AND. lExistTable( cPatSnd() + "RctPrvL.DBF" ) .AND. lExistTable( cPatSnd() + "FacPrvP.DBF" )

            dbUseArea( .T., ( cDriver() ), ( cPatSnd() + "RctPrvT.DBF" ), ( cCheckArea( "FacPrvT", @tmpRctPrvT ) ), if(.F. .OR. .F., !.F., NIL), .T.,, )
            if !lAIS() ; ordListAdd( ( cPatSnd() + "RctPrvT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cDriver() ), ( cPatSnd() + "RctPrvL.DBF" ), ( cCheckArea( "FacPrvL", @tmpRctPrvL ) ), if(.F. .OR. .F., !.F., NIL), .T.,, )
            if !lAIS() ; ordListAdd( ( cPatSnd() + "RctPrvL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cDriver() ), ( cPatSnd() + "FacPrvP.Dbf" ), ( cCheckArea( "FacPrvP", @tmpRctPrvP ) ), if(.F. .OR. .F., !.F., NIL), .T.,, )
            if !lAIS() ; ordListAdd( ( cPatSnd() + "FacPrvP.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvT.DBF" ), ( cCheckArea( "FacPrvT", @dbfRctPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvL.DBF" ), ( cCheckArea( "FacPrvL", @dbfRctPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacPrvP.DBF" ), ( cCheckArea( "FacPrvP", @dbfRctPrvP ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatEmp() + "FacPrvP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            oStock            := TStock():New()
            oStock:cFacPrvT   := dbfRctPrvT
            oStock:cFacPrvL   := dbfRctPrvL

            while ( tmpRctPrvT )->( !eof() )






               if lValidaOperacion( ( tmpRctPrvT )->dFecFac, .F. ) .AND.  !( dbfRctPrvT )->( dbSeek( ( tmpRctPrvT )->cSerFac + Str( ( tmpRctPrvT )->nNumFac ) + ( tmpRctPrvT )->cSufFac ) )

                  dbPass( tmpRctPrvT, dbfRctPrvT, .T. )
                  ::oSender:SetText( "Añadido     : " + ( tmpRctPrvT )->cSerFac + "/" + AllTrim( Str( ( tmpRctPrvT )->nNumFac ) ) +"/" + AllTrim( ( tmpRctPrvT )->cSufFac ) + "; " + Dtoc( ( tmpRctPrvT )->dFecFac ) + "; " + AllTrim( ( tmpRctPrvT )->cCodPrv ) + ( tmpRctPrvT )->cNomPrv )

                  if ( tmpRctPrvL )->( dbSeek( ( tmpRctPrvT )->cSerFac + Str( ( tmpRctPrvT )->nNumFac ) + ( tmpRctPrvT )->cSufFac ) )
                     while ( tmpRctPrvL )->cSerFac + Str( ( tmpRctPrvL )->nNumFac ) + ( tmpRctPrvL )->cSufFac == ( tmpRctPrvT )->cSerFac + Str( ( tmpRctPrvT )->nNumFac ) + ( tmpRctPrvT )->cSufFac .AND. !( tmpRctPrvL )->( eof() )
                        dbPass( tmpRctPrvL, dbfRctPrvL, .T. )
                        ( tmpRctPrvL )->( dbSkip() )
                     end
                  end





                  if ( tmpRctPrvP )->( dbSeek( ( tmpRctPrvT )->cSerFac + Str( ( tmpRctPrvT )->nNumFac ) + ( tmpRctPrvT )->cSufFac ) )
                     while ( tmpRctPrvP )->cSerFac + Str( ( tmpRctPrvP )->nNumFac ) + ( tmpRctPrvP )->cSufFac == ( tmpRctPrvT )->cSerFac + Str( ( tmpRctPrvT )->nNumFac ) + ( tmpRctPrvT )->cSufFac .AND. !( tmpRctPrvP )->( eof() )
                        dbPass( tmpRctPrvP, dbfRctPrvP, .T. )
                        ( tmpRctPrvP )->( dbSkip() )
                     end
                  end







               else

                  ::oSender:SetText( "Desestimado : " + ( tmpRctPrvT )->cSerFac + "/" + AllTrim( Str( ( tmpRctPrvT )->nNumFac ) ) +"/" + AllTrim( ( tmpRctPrvT )->cSufFac ) + "; " + Dtoc( ( tmpRctPrvT )->dFecFac ) + "; " + AllTrim( ( tmpRctPrvT )->cCodPrv ) + ( tmpRctPrvT )->cNomPrv )

               end

               ( tmpRctPrvT )->( dbSkip() )

            end

            ( dbfRctPrvT )->( dbCloseArea() )
            ( dbfRctPrvL )->( dbCloseArea() )
            ( dbfRctPrvP )->( dbCloseArea() )
            ( tmpRctPrvT )->( dbCloseArea() )
            ( tmpRctPrvL )->( dbCloseArea() )
            ( tmpRctPrvP )->( dbCloseArea() )

            oStock:end()

         end

      end

      ::oSender:AppendFileRecive( aFiles[ m, 1 ] )

      RECOVER USING oError

         ( dbfRctPrvT )->( dbCloseArea() )
         ( dbfRctPrvL )->( dbCloseArea() )
         ( dbfRctPrvP )->( dbCloseArea() )
         ( tmpRctPrvT )->( dbCloseArea() )
         ( tmpRctPrvL )->( dbCloseArea() )
         ( tmpRctPrvP )->( dbCloseArea() )

         ::oSender:SetText( "Error procesando fichero " + aFiles[ m, 1 ] )
         ::oSender:SetText( ErrorMessage( oError ) )

      end

      ErrorBlock( oBlock )

   next

Return Self



Static Function nEstadoIncidencia( cNumFac )

   local nEstado  := 0

   if ( dbfRctPrvI )->( dbSeek( cNumFac ) )

      while ( dbfRctPrvI )->cSerFac + Str( ( dbfRctPrvI )->nNumFac ) + ( dbfRctPrvI )->cSufFac == cNumFac .AND. !( dbfRctPrvI )->( Eof() )

         if ( dbfRctPrvI )->lListo
            do case
               case nEstado == 0 .OR. nEstado == 3
                    nEstado := 3
               case nEstado == 1
                    nEstado := 2
            end
         else
            do case
               case nEstado == 0
                    nEstado := 1
               case nEstado == 3
                    nEstado := 2
            end
         end

         ( dbfRctPrvI )->( dbSkip() )

      end

   end

Return ( nEstado )



Function AppRctPrv( cCodPrv, cCodArt, lOpenBrowse )

   local nLevel         := nLevelUsr( "01099" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 2 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if RctPrv( nil, nil, cCodPrv, cCodArt )
         oWndBrw:RecAdd()
      end

   else

      if OpenFiles( .T. )
         WinAppRec( nil, bEdtRec, dbfRctPrvT, cCodPrv, cCodArt )
         CloseFiles()
      end

   end

RETURN .T.



FUNCTION EdtRctPrv( nNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01099" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 4 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if RctPrv()
         if dbSeekInOrd( nNumFac, "nNumFac", dbfRctPrvT )
            oWndBrw:RecEdit()
         else
            MsgStop( "No se encuentra factura" )
         end
      end

   else

      if OpenFiles( .T. )
         if dbSeekInOrd( nNumFac, "nNumFac", dbfRctPrvT )
            nTotRctPrv()
            WinEdtRec( nil, bEdtRec, dbfRctPrvT )
         else
            MsgStop( "No se encuentra factura" )
         end
         CloseFiles()
      end

   end

RETURN NIL



FUNCTION ZooRctPrv( nNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01099" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 8 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if RctPrv()
         if dbSeekInOrd( nNumFac, "nNumFac", dbfRctPrvT )
            oWndBrw:RecZoom()
         else
            MsgStop( "No se encuentra factura" )
         end
      end

   else

      if OpenFiles( .T. )
         if dbSeekInOrd( nNumFac, "nNumFac", dbfRctPrvT )
            nTotRctPrv()
            WinZooRec( nil, bEdtRec, dbfRctPrvT )
         else
            MsgStop( "No se encuentra factura" )
         end
         CloseFiles()
      end

   end

RETURN NIL



FUNCTION DelRctPrv( nNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01099" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 8 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if RctPrv()
         if dbSeekInOrd( nNumFac, "nNumFac", dbfRctPrvT )
            WinDelRec( nil, dbfRctPrvT, {|| QuiRctPrv() } )
         else
            MsgStop( "No se encuentra factura" )
         end
      end

   else

      if OpenFiles( .T. )
         if dbSeekInOrd( nNumFac, "nNumFac", dbfRctPrvT )
            WinDelRec( nil, dbfRctPrvT, {|| QuiRctPrv() } )
         else
            MsgStop( "No se encuentra factura" )
         end
         CloseFiles()
      end

   end

Return nil



FUNCTION PrnRctPrv( nNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01099" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 8 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if RctPrv()
         if dbSeekInOrd( nNumFac, "nNumFac", dbfRctPrvT )
            GenRctPrv( 1 )
         else
            MsgStop( "No se encuentra factura" )
         end
      end

   else

      if OpenFiles( .T. )
         if dbSeekInOrd( nNumFac, "nNumFac", dbfRctPrvT )
            nTotRctPrv()
            GenRctPrv( 1 )
         else
            MsgStop( "No se encuentra factura" )
         end
         CloseFiles()
      end

   end

RETURN NIL



FUNCTION VisRctPrv( nNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01099" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 8 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if RctPrv()
         if dbSeekInOrd( nNumFac, "nNumFac", dbfRctPrvT )
            GenRctPrv( 2 )
         else
            MsgStop( "No se encuentra factura" )
         end
      end

   else

      if OpenFiles( .T. )
         if dbSeekInOrd( nNumFac, "nNumFac", dbfRctPrvT )
            nTotRctPrv()
            GenRctPrv( 2 )
         else
            MsgStop( "No se encuentra factura" )
         end
         CloseFiles()
      end

   end

Return nil



Static Function lRecibosPagadosTmp( dbfTmpPgo )

   local lRecPgd  := .F.
   local nRecAct  := ( dbfTmpPgo )->( Recno() )

   while !( dbfTmpPgo )->( eof() )
      if ( dbfTmpPgo )->lCobrado .AND. !( dbfTmpPgo )->lDevuelto
         lRecPgd  := .T.
         exit
      end
      ( dbfTmpPgo )->( dbSkip() )
   end

   ( dbfTmpPgo )->( dbGoTo( nRecAct) )

return ( lRecPgd )



static function ShowKitRctPrv( dbfMaster, oBrw, cCodPrv, dbfTmpInc, aGet, aTmp, aControl, oSayGas, oSayLabels, oBrwIva )

   if !Empty( aGet )

      if lUsrMaster() .OR. oUser():lCambiarPrecio()
         aGet[ ( dbfMaster )->( FieldPos( "lRecargo" ) ) ]:HardEnable()
      else
         aGet[ ( dbfMaster )->( FieldPos( "lRecargo" ) ) ]:HardDisable()
      end

      if !Empty( cCodPrv )
         aGet[ ( dbfMaster )->( FieldPos( "cCodPrv" ) ) ]:cText( cCodPrv )
         aGet[ ( dbfMaster )->( FieldPos( "cCodPrv" ) ) ]:lValid()
      end

      aGet[ ( dbfMaster )->( FieldPos( "cCodPrv" ) ) ]:SetFocus()

      if !Empty( aTmp ) .AND. aTmp[ 56 ]

         oBrw:Hide()
         oBrwIva:Hide()
         aEval( aControl, {| o | o:Hide() } )
         oSayLabels[1]:Hide()
         oSayLabels[2]:Hide()
         oSayLabels[3]:Hide()
         oSayLabels[4]:Hide()
         oSayLabels[5]:Hide()
         aGet[ 28 ]:Hide()
         aGet[ 30    ]:Hide()
         aGet[ 29 ]:Hide()
         aGet[ 31    ]:Hide()
         aGet[ 38 ]:Hide()
         aGet[ 39 ]:Hide()
         aGet[ 40 ]:Hide()
         aGet[ 41 ]:Hide()

         aEval( oSayGas, {| o | o:Show() } )
         aGet[ 57  ]:Show()
         aGet[ 58 ]:Show()
         aGet[ 59 ]:Show()
         aGet[ 60 ]:Show()
         aGet[ 61 ]:Show()
         aGet[ 62 ]:Show()
         aGet[ 63 ]:Show()
         aGet[ 64  ]:Show()
         aGet[ 65  ]:Show()
         aGet[ 66  ]:Show()

      else

         oBrw:Show()
         oBrwIva:Show()
         aEval( aControl, {| o | o:Show() } )
         oSayLabels[1]:Show()
         oSayLabels[2]:Show()
         oSayLabels[3]:Show()
         oSayLabels[4]:Show()
         oSayLabels[5]:Show()
         aGet[ 28 ]:Show()
         aGet[ 30    ]:Show()
         aGet[ 29 ]:Show()
         aGet[ 31    ]:Show()
         aGet[ 38 ]:Show()
         aGet[ 39 ]:Show()
         aGet[ 40 ]:Show()
         aGet[ 41 ]:Show()

         aEval( oSayGas, {| o | o:Hide() } )
         aGet[ 57  ]:Hide()
         aGet[ 57  ]:Hide()
         aGet[ 58 ]:Hide()
         aGet[ 59 ]:Hide()
         aGet[ 60 ]:Hide()
         aGet[ 61 ]:Hide()
         aGet[ 62 ]:Hide()
         aGet[ 63 ]:Hide()
         aGet[ 64  ]:Hide()
         aGet[ 65  ]:Hide()
         aGet[ 66  ]:Hide()

      end

   end





   if !Empty( dbfTmpInc )

      while !( dbfTmpInc )->( Eof() )
         if ( dbfTmpInc )->lAviso .AND. !( dbfTmpInc )->lListo
            MsgInfo( Trim( ( dbfTmpInc )->mDesInc ), "¡Incidencia!" )
         end
         ( dbfTmpInc )->( dbSkip() )
      end

      ( dbfTmpInc )->( dbGoTop() )

   end

   oBrw:Refresh()

return nil



STATIC FUNCTION ValidaMedicion( aTmp, aGet )

   local cNewUndMed  := aGet[ 12 ]:VarGet





   if ( Empty( cOldUndMed ) .OR. cOldUndMed <> cNewUndMed )

      if oUndMedicion:oDbf:Seek( aTmp[ 12 ] )

         if oUndMedicion:oDbf:nDimension >= 1 .AND. !Empty( oUndMedicion:oDbf:cTextoDim1 )
            if !Empty( aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ] )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim1 )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]:cText( ( dbfArticulo )->nLngArt )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]:Show()
            else
               aTmp[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]  := ( dbfArticulo )->nLngArt
            end
         else
            if !Empty( aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ] )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]:cText( 0 )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]:Hide()
            else
               aTmp[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]  := 0
            end
         end

         if oUndMedicion:oDbf:nDimension >= 1 .AND. !Empty( oUndMedicion:oDbf:cTextoDim2 )
            if !Empty( aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ] )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim2 )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]:cText( ( dbfArticulo )->nAltArt )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]:Show()
            else
               aTmp[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]  := ( dbfArticulo )->nAltArt
            end

         else
            if !Empty( aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ] )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]:cText( 0 )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]:Hide()
            else
                 aTmp[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]  := 0
            end
         end

         if oUndMedicion:oDbf:nDimension >= 1 .AND. !Empty( oUndMedicion:oDbf:cTextoDim3 )
            if !Empty( aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ] )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim3 )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]:cText( ( dbfArticulo ) ->nAncArt )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]:Show()
            else
               aTmp[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]  := ( dbfArticulo )->nAncArt
            end
         else
            if !Empty( aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ] )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]:cText( 0 )
               aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]:Hide()
            else
               aTmp[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]  := 0
            end
         end

      else

         if !Empty( aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ] )
            aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]:Hide()
            aGet[ ( dbfRctPrvL )->( fieldpos( "nMedUno" ) ) ]:cText( 0 )
         end

         if !Empty( aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ] )
            aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]:Hide()
            aGet[ ( dbfRctPrvL )->( fieldpos( "nMedDos" ) ) ]:cText( 0 )
         end

         if !Empty( aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ] )
            aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]:Hide()
            aGet[ ( dbfRctPrvL )->( fieldpos( "nMedTre" ) ) ]:cText( 0 )
         end

      end

      cOldUndMed := cNewUndMed

   end

RETURN .T.



Function IsRctPrv( cPath )

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "RctPrvT.Dbf" )
      dbCreate( cPath + "RctPrvT.Dbf", aSqlStruct( aItmRctPrv() ), cDriver() )
   end

   if !lExistTable( cPath + "RctPrvL.Dbf" )
      dbCreate( cPath + "RctPrvL.Dbf", aSqlStruct( aColRctPrv() ), cDriver() )
   end

   if !lExistTable( cPath + "RctPrvI.Dbf" )
      dbCreate( cPath + "RctPrvI.Dbf", aSqlStruct( aIncRctPrv() ), cDriver() )
   end

   if !lExistTable( cPath + "RctPrvD.Dbf" )
      dbCreate( cPath + "RctPrvD.Dbf", aSqlStruct( aFacPrvDoc() ), cDriver() )
   end




   if !lExistIndex( cPath + "RctPrvT.Cdx" ) .OR.  !lExistIndex( cPath + "RctPrvL.Cdx" ) .OR.  !lExistIndex( cPath + "RctPrvI.Cdx" ) .OR.  !lExistIndex( cPath + "RctPrvD.Cdx" )

      rxRctPrv( cPath )

   end

Return ( nil )



FUNCTION cPrpRctPrv( cFacPrvL )

   local cReturn     := ""

   IIF( cFacPrvL == nil, cFacPrvL := if( !Empty( tmpRctPrvL ), tmpRctPrvL, dbfRctPrvL ), ) ;

   cReturn           += Alltrim( ( cFacPrvL )->cRef )

   if !Empty( ( cFacPrvL )->cValPr1 )
      cReturn        += "."
      cReturn        += Alltrim( ( cFacPrvL )->cValPr1 )
   end

   if !Empty( ( cFacPrvL )->cValPr2 )
      cReturn        += "."
      cReturn        += Alltrim( ( cFacPrvL )->cValPr2 )
   end

RETURN ( cReturn )







FUNCTION cDesRctPrv( cFacPrvL, cFacPrvS )

   IIF( cFacPrvL == nil, cFacPrvL := dbfRctPrvL, ) ;
   IIF( cFacPrvS == nil, cFacPrvS := dbfRctPrvS, ) ;

RETURN ( Descrip( cFacPrvL, cFacPrvS ) )



Function cCtaRctPrv( cRctPrvT, cRctPrvP, cBncPrv )

   local cCtaRctPrv  := ""

   IIF( cRctPrvT == nil, cRctPrvT := dbfRctPrvT, ) ;
   IIF( cRctPrvP == nil, cRctPrvP := dbfRctPrvP, ) ;
   IIF( cBncPrv == nil, cBncPrv := dbfPrvBnc, ) ;

   cCtaRctPrv        := Rtrim( ( cRctPrvT )->cEntBnc + ( cRctPrvT )->cSucBnc + ( cRctPrvT )->cDigBnc + ( cRctPrvT )->cCtaBnc )

   if Empty( cCtaRctPrv )
      if dbSeekInOrd( ( cRctPrvT )->cSerFac + Str( ( cRctPrvT )->nNumFac ) + ( cRctPrvT )->cSufFac, "nNumFac", cRctPrvP )
         cCtaRctPrv  := cProveeCuenta( ( cRctPrvP )->cCodPrv, cBncPrv )
      end
   end

Return ( cCtaRctPrv )













FUNCTION nTotLRctPrv( uFacPrvL, nDec, nRec, nVdv, cPirDiv )

   local nCalculo
   local nDtoLin
   local nDtoPrm

   IIF( uFacPrvL == nil, uFacPrvL := dbfRctPrvL, ) ;
   IIF( nDec == nil, nDec := nDinDiv(), ) ;
   IIF( nRec == nil, nRec := nRinDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo       := nTotURctPrv( uFacPrvL, nDec, nVdv )

   do case
   case ValType( uFacPrvL ) == "A"
      nDtoLin     := uFacPrvL[ 16 ]
      nDtoPrm     := uFacPrvL[ 17 ]
   case ValType( uFacPrvL ) == "C"
      nDtoLin     := ( uFacPrvL )->nDtoLin
      nDtoPrm     := ( uFacPrvL )->nDtoPrm
   case ValType( uFacPrvL ) == "O"
      nDtoLin     := uFacPrvL:nDtoLin
      nDtoPrm     := uFacPrvL:nDtoPrm
   end

   if nDtoLin <> 0
      nCalculo    -= nCalculo * nDtoLin / 100
   end

   if nDtoPrm <> 0
      nCalculo    -= nCalculo * nDtoPrm / 100
   end

   nCalculo       *= nTotNRctPrv( uFacPrvL )

   if nRec <> nil
      nCalculo       := Round( nCalculo, nRec )
   end

RETURN ( if( cPirDiv <> NIL, Trans( nCalculo, cPirDiv ), nCalculo ) )



FUNCTION nTotURctPrv( uFacPrvL, nDec, nVdv, cPinDiv )

    local nCalculo

   IIF( uFacPrvL == nil, uFacPrvL := dbfRctPrvL, ) ;
   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   do case
   case ValType( uFacPrvL ) == "O"
      nCalculo    := uFacPrvL:nPreUnit / nVdv
   case ValType( uFacPrvL ) == "A"
      nCalculo    := uFacPrvL[ 7 ] / nVdv
   case ValType( uFacPrvL ) == "C"
      nCalculo    := ( uFacPrvL )->nPreUnit / nVdv
   end

   nCalculo       := Round( nCalculo, nDec )

RETURN ( ( if( cPinDiv <> nil, Trans( nCalculo, cPinDiv ), nCalculo ) )  )





_HB_CLASS TRectificativaProveedorLabelGenerator ; UTILITY FUNCTION TRectificativaProveedorLabelGenerator(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TRectificativaProveedorLabelGenerator" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { oDlg} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDlg" }, .F., .F. ), )
   _HB_MEMBER { oFld} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFld" }, .F., .F. ), )

   _HB_MEMBER { oSerieInicio} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oSerieInicio" }, .F., .F. ), )
   _HB_MEMBER { cSerieInicio} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSerieInicio" }, .F., .F. ), )

   _HB_MEMBER { oSerieFin} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oSerieFin" }, .F., .F. ), )
   _HB_MEMBER { cSerieFin} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSerieFin" }, .F., .F. ), )

   _HB_MEMBER { nDocumentoInicio} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDocumentoInicio" }, .F., .F. ), )
   _HB_MEMBER { nDocumentoFin} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nDocumentoFin" }, .F., .F. ), )

   _HB_MEMBER { cSufijoInicio} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSufijoInicio" }, .F., .F. ), )
   _HB_MEMBER { cSufijoFin} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSufijoFin" }, .F., .F. ), )

   _HB_MEMBER { oFormatoLabel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFormatoLabel" }, .F., .F. ), )
   _HB_MEMBER { cFormatoLabel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFormatoLabel" }, .F., .F. ), )

   _HB_MEMBER { nFilaInicio} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nFilaInicio" }, .F., .F. ), )
   _HB_MEMBER { nColumnaInicio} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nColumnaInicio" }, .F., .F. ), )

   _HB_MEMBER { nRecno} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nRecno" }, .F., .F. ), )

   _HB_MEMBER { oBrwLabel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBrwLabel" }, .F., .F. ), )

   _HB_MEMBER { nCantidadLabels} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nCantidadLabels" }, .F., .F. ), )
   _HB_MEMBER { nUnidadesLabels} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nUnidadesLabels" }, .F., .F. ), )

   _HB_MEMBER { oMtrLabel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oMtrLabel" }, .F., .F. ), )
   _HB_MEMBER { nMtrLabel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nMtrLabel" }, .F., .F. ), )

   _HB_MEMBER { oFilter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFilter" }, .F., .F. ), )

   _HB_MEMBER { lClose} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lClose" }, .F., .F. ), )

   _HB_MEMBER { lErrorOnCreate} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lErrorOnCreate" }, .F., .F. ), )

   _HB_MEMBER { oBtnFilter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBtnFilter" }, .F., .F. ), )
   _HB_MEMBER { oBtnSiguiente} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBtnSiguiente" }, .F., .F. ), )
   _HB_MEMBER { oBtnAnterior} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBtnAnterior" }, .F., .F. ), )
   _HB_MEMBER { oBtnCancel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBtnCancel" }, .F., .F. ), )

   _HB_MEMBER { aSearch} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aSearch" }, .F., .F. ), )

   _HB_MEMBER { cFileTmpLabel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFileTmpLabel" }, .F., .F. ), )
   _HB_MEMBER { cAreaTmpLabel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAreaTmpLabel" }, .F., .F. ), )

   _HB_MEMBER New(); IIF( .F., s_oClass:ModMethod( "New", @TRectificativaProveedorLabelGenerator_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TRectificativaProveedorLabelGenerator_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Init(); IIF( .F., s_oClass:ModMethod( "Init", @TRectificativaProveedorLabelGenerator_Init(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Init", @TRectificativaProveedorLabelGenerator_Init(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Create(); IIF( .F., s_oClass:ModMethod( "Create", @TRectificativaProveedorLabelGenerator_Create(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Create", @TRectificativaProveedorLabelGenerator_Create(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER lCreateAuxiliar(); IIF( .F., s_oClass:ModMethod( "lCreateAuxiliar", @TRectificativaProveedorLabelGenerator_lCreateAuxiliar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lCreateAuxiliar", @TRectificativaProveedorLabelGenerator_lCreateAuxiliar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lCreateTemporal(); IIF( .F., s_oClass:ModMethod( "lCreateTemporal", @TRectificativaProveedorLabelGenerator_lCreateTemporal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lCreateTemporal", @TRectificativaProveedorLabelGenerator_lCreateTemporal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PrepareTemporal( oFr); IIF( .F., s_oClass:ModMethod( "PrepareTemporal", @TRectificativaProveedorLabelGenerator_PrepareTemporal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PrepareTemporal", @TRectificativaProveedorLabelGenerator_PrepareTemporal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DestroyTemporal(); IIF( .F., s_oClass:ModMethod( "DestroyTemporal", @TRectificativaProveedorLabelGenerator_DestroyTemporal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DestroyTemporal", @TRectificativaProveedorLabelGenerator_DestroyTemporal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER End(); IIF( .F., s_oClass:ModMethod( "End", @TRectificativaProveedorLabelGenerator_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @TRectificativaProveedorLabelGenerator_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER BotonAnterior(); IIF( .F., s_oClass:ModMethod( "BotonAnterior", @TRectificativaProveedorLabelGenerator_BotonAnterior(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "BotonAnterior", @TRectificativaProveedorLabelGenerator_BotonAnterior(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER BotonSiguiente(); IIF( .F., s_oClass:ModMethod( "BotonSiguiente", @TRectificativaProveedorLabelGenerator_BotonSiguiente(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "BotonSiguiente", @TRectificativaProveedorLabelGenerator_BotonSiguiente(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER PutLabel(); IIF( .F., s_oClass:ModMethod( "PutLabel", @TRectificativaProveedorLabelGenerator_PutLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PutLabel", @TRectificativaProveedorLabelGenerator_PutLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SelectAllLabels(); IIF( .F., s_oClass:ModMethod( "SelectAllLabels", @TRectificativaProveedorLabelGenerator_SelectAllLabels(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SelectAllLabels", @TRectificativaProveedorLabelGenerator_SelectAllLabels(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AddLabel(); IIF( .F., s_oClass:ModMethod( "AddLabel", @TRectificativaProveedorLabelGenerator_AddLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddLabel", @TRectificativaProveedorLabelGenerator_AddLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DelLabel(); IIF( .F., s_oClass:ModMethod( "DelLabel", @TRectificativaProveedorLabelGenerator_DelLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DelLabel", @TRectificativaProveedorLabelGenerator_DelLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER EditLabel(); IIF( .F., s_oClass:ModMethod( "EditLabel", @TRectificativaProveedorLabelGenerator_EditLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EditLabel", @TRectificativaProveedorLabelGenerator_EditLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER FilterLabel(); IIF( .F., s_oClass:ModMethod( "FilterLabel", @TRectificativaProveedorLabelGenerator_FilterLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FilterLabel", @TRectificativaProveedorLabelGenerator_FilterLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER LoadAuxiliar(); IIF( .F., s_oClass:ModMethod( "LoadAuxiliar", @TRectificativaProveedorLabelGenerator_LoadAuxiliar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LoadAuxiliar", @TRectificativaProveedorLabelGenerator_LoadAuxiliar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lPrintLabels(); IIF( .F., s_oClass:ModMethod( "lPrintLabels", @TRectificativaProveedorLabelGenerator_lPrintLabels(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lPrintLabels", @TRectificativaProveedorLabelGenerator_lPrintLabels(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER InitLabel( oLabel); IIF( .F., s_oClass:ModMethod( "InitLabel", @TRectificativaProveedorLabelGenerator_InitLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "InitLabel", @TRectificativaProveedorLabelGenerator_InitLabel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SelectColumn( oCombo); IIF( .F., s_oClass:ModMethod( "SelectColumn", @TRectificativaProveedorLabelGenerator_SelectColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SelectColumn", @TRectificativaProveedorLabelGenerator_SelectColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TRectificativaProveedorLabelGenerator ;



UTILITY STATIC function TRectificativaProveedorLabelGenerator_New() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   local oError
   local oBlock

   oBlock                  := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      ::cSerieInicio       := ( dbfRctPrvT )->cSerFac
      ::cSerieFin          := ( dbfRctPrvT )->cSerFac

      ::nDocumentoInicio   := ( dbfRctPrvT )->nNumFac
      ::nDocumentoFin      := ( dbfRctPrvT )->nNumFac

      ::cSufijoInicio      := ( dbfRctPrvT )->cSufFac
      ::cSufijoFin         := ( dbfRctPrvT )->cSufFac

      ::nRecno             := ( dbfRctPrvT )->( Recno() )

      ::cFormatoLabel      := GetPvProfString( "Etiquetas", "Factura proveedor", Space( 3 ), cPatEmp() + "Empresa.Ini" )
      if len( ::cFormatoLabel ) < 3
         ::cFormatoLabel   := Space( 3 )
      end

      ::nMtrLabel          := 0

      ::nFilaInicio        := 1
      ::nColumnaInicio     := 1

      ::nCantidadLabels    := 1
      ::nUnidadesLabels    := 1

      ::aSearch            := { "Código", "Nombre" }

      ::lErrorOnCreate     := .F.

   RECOVER USING oError

      ::lErrorOnCreate     := .T.

      msgStop( "Error en la creación de generador de etiquetas" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end
   ErrorBlock( oBlock )

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_Init() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   local oError
   local oBlock
   local lError            := .F.

   oBlock                  := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      if !lOpenFiles
         OpenFiles()
         ::lClose          := .T.
      end

      ::cSerieInicio       := ( dbfRctPrvT )->cSerFac
      ::cSerieFin          := ( dbfRctPrvT )->cSerFac

      ::nDocumentoInicio   := ( dbfRctPrvT )->nNumFac
      ::nDocumentoFin      := ( dbfRctPrvT )->nNumFac

      ::cSufijoInicio      := ( dbfRctPrvT )->cSufFac
      ::cSufijoFin         := ( dbfRctPrvT )->cSufFac

      ::nCantidadLabels    := 1
      ::nUnidadesLabels    := 1

      ::lErrorOnCreate     := .F.

   RECOVER USING oError

      ::lErrorOnCreate     := .T.

      msgStop( "Error en la creación de generador de etiquetas" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end
   ErrorBlock( oBlock )

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_Create() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   local oBtnPrp
   local oBtnMod
   local oBtnZoo
   local oGetOrd
   local cGetOrd     := Space( 100 )
    local oCbxOrd
   local cCbxOrd     := "Código"
   local aCbxOrd     := { "Código", "Nombre" }

   ::New()

   if !::lErrorOnCreate .AND. ::lCreateAuxiliar()

      ::oDlg = TDialog():New(,,,,, "SelectLabels_0",, .F.,,,,,, .F.,,,,,, .F., )





         ::oFld := TPages():Redefine( 10, ::oDlg, {"SelectLabels_1", "SelectLabels_2"},,,, )









         TBitmap():ReDefine( 500, "EnvioEtiquetas",, ::oDlg,,, .F., .F.,,, .F.,,, .F. )








         ::oSerieInicio := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, ::cSerieInicio, ::cSerieInicio:= u ) }, ::oFld:aDialogs[ 1 ],, "@!", {||    ( ::cSerieInicio >= "A" .AND. ::cSerieInicio <= "Z" )},,,,,, .T.,,, .F., .T., {||    ( UpSerie( ::oSerieInicio ) )}, {||  ( DwSerie( ::oSerieInicio ) )},,,, nil,,, )









         ::oSerieFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, ::cSerieFin, ::cSerieFin:= u ) }, ::oFld:aDialogs[ 1 ],, "@!", {||    ( ::cSerieFin >= "A" .AND. ::cSerieFin <= "Z" )},,,,,, .T.,,, .F., .T., {||    ( UpSerie( ::oSerieFin ) )}, {||  ( DwSerie( ::oSerieFin ) )},,,, nil,,, )





         TGetHlp():ReDefine( 120, { | u | If( PCount()==0, ::nDocumentoInicio, ::nDocumentoInicio:= u ) }, ::oFld:aDialogs[ 1 ],, "999999999",,,,,,, .F.,,, .F., .T.,,,,,, nil,,, )





         TGetHlp():ReDefine( 130, { | u | If( PCount()==0, ::nDocumentoFin, ::nDocumentoFin:= u ) }, ::oFld:aDialogs[ 1 ],, "999999999",,,,,,, .F.,,, .F., .T.,,,,,, nil,,, )




         TGetHlp():ReDefine( 140, { | u | If( PCount()==0, ::cSufijoInicio, ::cSufijoInicio:= u ) }, ::oFld:aDialogs[ 1 ],, "##",,,,,,, .F.,,, .F., .F.,,,,,, nil,,, )




         TGetHlp():ReDefine( 150, { | u | If( PCount()==0, ::cSufijoFin, ::cSufijoFin:= u ) }, ::oFld:aDialogs[ 1 ],, "##",,,,,,, .F.,,, .F., .F.,,,,,, nil,,, )





         TGetHlp():ReDefine( 180, { | u | If( PCount()==0, ::nFilaInicio, ::nFilaInicio:= u ) }, ::oFld:aDialogs[ 1 ],, "999",,,,,,, .F.,,, .F., .T.,,,,,, nil,,, )





         TGetHlp():ReDefine( 190, { | u | If( PCount()==0, ::nColumnaInicio, ::nColumnaInicio:= u ) }, ::oFld:aDialogs[ 1 ],, "999",,,,,,, .F.,,, .F., .T.,,,,,, nil,,, )





         ::oFormatoLabel := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, ::cFormatoLabel, ::cFormatoLabel:= u ) }, ::oFld:aDialogs[ 1 ],,,,,,,,, .F.,,, .F., .F.,,,,,, nil, "LUPA",, 161 )

            ::oFormatoLabel:bValid  := {|| cDocumento( ::oFormatoLabel, ::oFormatoLabel:oHelpText, dbfDoc, "RL" ) }
            ::oFormatoLabel:bHelp   := {|| BrwDocumento( ::oFormatoLabel, ::oFormatoLabel:oHelpText, "RL" ) }

         TBtnBmp():ReDefine( 220, "Printer_pencil_16",,,,,{|| EdtDocumento( ::cFormatoLabel ) }, ::oFld:aDialogs[ 1 ], .F., , .F., "Modificar formato de etiquetas" )



         TRadMenu():Redefine( { | u | If( PCount()==0, ::nCantidadLabels, ::nCantidadLabels:= u ) }, ::oFld:aDialogs[ 1 ],, { 200, 201 },,,,, .F.,, )








         TGetHlp():ReDefine( 210, { | u | If( PCount()==0, ::nUnidadesLabels, ::nUnidadesLabels:= u ) }, ::oFld:aDialogs[ 1 ],, "99999",,,,,,, .F., {||     ( ::nCantidadLabels == 2 )},, .F., .T.,,, {||      1}, {||      99999},, nil,,, )









         oGetOrd := TGetHlp():ReDefine( 200, { | u | If( PCount()==0, cGetOrd, cGetOrd:= u ) }, ::oFld:aDialogs[ 2 ],,,,,,,,, .F.,,, .F., .F.,,,,,, nil, "FIND",, )

         oGetOrd:bChange   := {| nKey, nFlags, oGet | AutoSeek( nKey, nFlags, oGet, ::oBrwLabel, ::cAreaTmpLabel ) }
         oGetOrd:bValid    := {|| ( ::cAreaTmpLabel )->( OrdScope( 0, nil ) ), ( ::cAreaTmpLabel )->( OrdScope( 1, nil ) ), ::oBrwLabel:Refresh(), .T. }





         oCbxOrd := TComboBox():ReDefine( 210, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, ::oFld:aDialogs[ 2 ],,,,,,, .F.,,,,,, )

         oCbxOrd:bChange   := {|| ::SelectColumn( oCbxOrd ) }




         TButton():ReDefine( 100, {||( ::PutLabel() )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )




         TButton():ReDefine( 110, {||( ::SelectAllLabels( .T. ) )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )




         TButton():ReDefine( 120, {||( ::SelectAllLabels( .F. ) )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )




         TButton():ReDefine( 130, {||( ::AddLabel() )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )




         TButton():ReDefine( 140, {||( ::DelLabel() )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )




         TButton():ReDefine( 150, {||( ::EditLabel() )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )




         oBtnMod := TButton():ReDefine( 160, {||( nil )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )




         oBtnZoo := TButton():ReDefine( 165, {||( nil )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )




         ::oBtnFilter := TButton():ReDefine( 170, {||( ::FilterLabel() )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )




         oBtnPrp := TButton():ReDefine( 220, {||( nil )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )

         ::oBrwLabel                 := TXBrowse():New( ::oFld:aDialogs[ 2 ] )

         ::oBrwLabel:nMarqueeStyle   := 5
         ::oBrwLabel:nColSel         := 2

         ::oBrwLabel:lHScroll        := .F.
         ::oBrwLabel:cAlias          := ::cAreaTmpLabel

         ::oBrwLabel:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
         ::oBrwLabel:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }
         ::oBrwLabel:bLDblClick      := {|| ::PutLabel() }

         ::oBrwLabel:CreateFromResource( 180 )

         with object ( ::oBrwLabel:AddCol() )
            :cHeader          := "Sl. Seleccionada"
            :bEditValue       := {|| ( ::cAreaTmpLabel )->lLabel }
            :nWidth           := 20
            :SetCheck( { "Sel16", "Nil16" } )
         end

         with object ( ::oBrwLabel:AddCol() )
            :cHeader          := "Código"
            :bEditValue       := {|| ( ::cAreaTmpLabel )->cRef }
            :nWidth           := 80
            :cSortOrder       := "cRef"
            :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

         with object ( ::oBrwLabel:AddCol() )
            :cHeader          := "Nombre"
            :bEditValue       := {|| ( ::cAreaTmpLabel )->cDetalle }
            :nWidth           := 250
            :cSortOrder       := "cDetalle"
            :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

         with object ( ::oBrwLabel:AddCol() )
            :cHeader          := "Prp. 1"
            :bEditValue       := {|| ( ::cAreaTmpLabel )->cValPr1 }
            :nWidth           := 40
         end

         with object ( ::oBrwLabel:AddCol() )
            :cHeader          := "Prp. 2"
            :bEditValue       := {|| ( ::cAreaTmpLabel )->cValPr2 }
            :nWidth           := 40
         end

         with object ( ::oBrwLabel:AddCol() )
            :cHeader          := "N. etiquetas"
            :bEditValue       := {|| ( ::cAreaTmpLabel )->nLabel }
            :cEditPicture     := "@E 99,999"
            :nWidth           := 80
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
            :nEditType        := 1
            :bOnPostEdit      := {|o,x| if( dbDialogLock( ::cAreaTmpLabel ), ( ( ::cAreaTmpLabel )->nLabel := x, ( ::cAreaTmpLabel )->( dbUnlock() ) ), ) }
         end






         ::oMtrLabel := TMeter():ReDefine( 190, { | u | If( PCount()==0, ::nMtrLabel, ::nMtrLabel:= u ) }, ( ::cAreaTmpLabel  )->( lastrec() ), ::oFld:aDialogs[ 2 ], .F.,, "", .F.,,,, )

         ::oMtrLabel:nClrText   := ( 128 + ( 255 * 256 ) + ( 0 * 65536 ) )
         ::oMtrLabel:nClrBar    := ( 128 + ( 255 * 256 ) + ( 0 * 65536 ) )
         ::oMtrLabel:nClrBText  := ( 128 + ( 255 * 256 ) + ( 0 * 65536 ) )








         ::oBtnAnterior := TButton():ReDefine( 20, {||( ::BotonAnterior() )}, ::oDlg,,, .F.,,,, .F. )




         ::oBtnSiguiente := TButton():ReDefine( 30, {||( ::BotonSiguiente() )}, ::oDlg,,, .F.,,,, .F. )




         ::oBtnCancel := TButton():ReDefine( 2, {||( ::oDlg:End() )}, ::oDlg,,, .F.,,,, .F. )

      ::oDlg:bStart  := {|| ::oBtnAnterior:Hide(), ::oFormatoLabel:lValid(), oBtnMod:Hide(), oBtnZoo:Hide(), oBtnPrp:Hide() }

      ::oDlg:Activate( ::oDlg:bLClicked, ::oDlg:bMoved, ::oDlg:bPainted, .T.,,,, ::oDlg:bRClicked,,, )

      ::End()

   end

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_lCreateAuxiliar() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   local oBlock
   local oError
   local lCreateAuxiliar   := .T.

   oBlock                  := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      ::cAreaTmpLabel      := "Lbl" + cCurUsr()
      ::cFileTmpLabel      := cGetNewFileName( cPatTmp() + "Lbl" )

      dbCreate( ::cFileTmpLabel, aSqlStruct( aLblRctPrv() ), cLocalDriver() )
      dbUseArea( .T., cLocalDriver(), ::cFileTmpLabel, ::cAreaTmpLabel, .F. )

      if!( ::cAreaTmpLabel )->( neterr() )
         ( ::cAreaTmpLabel )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
         ( ::cAreaTmpLabel )->( OrdCreate( ::cFileTmpLabel, "cRef", "cRef", {|| Field->cRef } ) )

         ( ::cAreaTmpLabel )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
         ( ::cAreaTmpLabel )->( OrdCreate( ::cFileTmpLabel, "cDetalle", "Upper( cDetalle )", {|| Upper( Field->cDetalle ) } ) )
      end

      ( ::cAreaTmpLabel )->( OrdsetFocus( "cRef" ) )

   RECOVER USING oError

      lCreateAuxiliar      := .F.

      MsgStop( "Imposible crear fichero temporal" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

Return ( lCreateAuxiliar )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_BotonAnterior() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   ::oFld:GoPrev()

   ::oBtnAnterior:Hide()

   SetWindowText( ::oBtnSiguiente:hWnd, "Siguien&te >" )

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_BotonSiguiente() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   do case
      case ::oFld:nOption == 1

         if Empty( ::cFormatoLabel )

            MsgStop( "Debe cumplimentar un formato de etiquetas" )

         else

            ::LoadAuxiliar()

            ::oFld:GoNext()
            ::oBtnAnterior:Show()
            SetWindowText( ::oBtnSiguiente:hWnd, "&Terminar" )

         end

      case ::oFld:nOption == 2

         if ::lPrintLabels()

            SetWindowText( ::oBtnCancel:hWnd, "&Cerrar" )

         end

   end

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_lCreateTemporal() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   local n
   local nRec
   local oBlock
   local oError
   local nBlancos
   local lCreateTemporal   := .T.

   oBlock                  := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      tmpRctPrvL           := "LblFac"
      filRctPrvL           := cGetNewFileName( cPatTmp() + "LblFac" )

      dbCreate( filRctPrvL, aSqlStruct( aLblRctPrv() ), cLocalDriver() )
      dbUseArea( .T., cLocalDriver(), filRctPrvL, tmpRctPrvL, .F. )

      ( tmpRctPrvL )->( OrdCondSet( "!Deleted()", {||!Deleted()} ) )
      ( tmpRctPrvL )->( OrdCreate( filRctPrvL, "nNumFac", "cSerFac + Str( nNumFac ) + cSufFac", {|| Field->cSerFac + Str( Field->nNumFac ) + Field->cSufFac } ) )

      nRec                 := ( ::cAreaTmpLabel )->( Recno() )

      ( ::cAreaTmpLabel )->( dbGoTop() )
      while !( ::cAreaTmpLabel )->( eof() )

         if ( ::cAreaTmpLabel )->lLabel
            for n := 1 to ( ::cAreaTmpLabel )->nLabel
               dbPass( ::cAreaTmpLabel, tmpRctPrvL, .T. )
            next
         end

         ( ::cAreaTmpLabel )->( dbSkip() )

      end
      ( tmpRctPrvL )->( dbGoTop() )

      ( ::cAreaTmpLabel )->( dbGoTo( nRec ) )

   RECOVER USING oError

      lCreateTemporal      := .F.

      MsgStop( "Imposible abrir ficheros de artículos" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

Return ( lCreateTemporal )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_DestroyTemporal() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   if ( tmpRctPrvL )->( Used() )
      ( tmpRctPrvL )->( dbCloseArea() )
   end

   dbfErase( filRctPrvL )

   tmpRctPrvL           := nil

   SysRefresh()

Return ( .T. )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_PrepareTemporal( oFr) ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   local n
   local nBlancos       := 0
   local nPaperHeight   := oFr:GetProperty( "MainPage", "PaperHeight" ) * 3.77953
   local nHeight        := oFr:GetProperty( "CabeceraColumnas", "Height" )
   local nColumns       := oFr:GetProperty( "MainPage", "Columns" )
   local nItemsInColumn := int( nPaperHeight / nHeight )

   nBlancos             := ( ::nColumnaInicio - 1 ) * nItemsInColumn
   nBlancos             += ( ::nFilaInicio - 1 )

   for n := 1 to nBlancos
      dbPass( dbBlankRec( dbfRctPrvL ), tmpRctPrvL, .T. )
   next

   ( tmpRctPrvL )->( dbGoTop() )

Return ( .T. )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_lPrintLabels() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   local oFr

   local nCopies      := 1
   local nDevice      := 2
   local cPrinter     := PrnGetName()

   if ::lCreateTemporal()

      SysRefresh()

      oFr                  := frReportManager():New()

      oFr:LoadLangRes(     "Spanish.Xml" )

      oFr:SetIcon( 1 )

      oFr:SetTitle(        "Diseñador de documentos" )






      oFr:SetEventHandler( "Designer", "OnSaveReport", {|| oFr:SaveToBlob( ( dbfDoc )->( Select() ), "mReport" ) } )





      DataLabel( oFr, .T. )





      if !Empty( ( dbfDoc )->mReport )

         oFr:LoadFromBlob( ( dbfDoc )->( Select() ), "mReport")





         ::PrepareTemporal( oFr )





         oFr:PrepareReport()





         do case
            case nDevice == 2
               oFr:ShowPreparedReport()

            case nDevice == 1
               oFr:PrintOptions:SetPrinter( cPrinter )
               oFr:PrintOptions:SetCopies( nCopies )
               oFr:PrintOptions:SetShowDialog( .F. )
               oFr:Print()

            case nDevice == 3
               oFr:DoExport( "PDFExport" )

         end

      end





      oFr:DestroyFr()





      ::DestroyTemporal()

   end

Return .T.



UTILITY STATIC function TRectificativaProveedorLabelGenerator_End() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   if !Empty( ::nRecno )
      ( dbfRctPrvT )->( dbGoTo( ::nRecno ) )
   end

   if IsTrue( ::lClose )
      CloseFiles()
   end

   if !Empty( ::cAreaTmpLabel ) .AND. ( ::cAreaTmpLabel )->( Used() )
      ( ::cAreaTmpLabel )->( dbCloseArea() )
   end

   dbfErase( ::cFileTmpLabel )

   WritePProString( "Etiquetas", "Factura proveedor", ::cFormatoLabel, cPatEmp() + "Empresa.Ini" )

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_PutLabel() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   ( ::cAreaTmpLabel )->lLabel   := !( ::cAreaTmpLabel )->lLabel

   ::oBrwLabel:Refresh()
   ::oBrwLabel:Select()

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_SelectAllLabels( lSelect) ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

    local n            := 0
   local nRecno   := ( ::cAreaTmpLabel )->( Recno() )

    CursorWait()

   ( ::cAreaTmpLabel )->( dbGoTop() )
   while !( ::cAreaTmpLabel )->( eof() )

      ( ::cAreaTmpLabel )->lLabel := lSelect

      ( ::cAreaTmpLabel )->( dbSkip() )

      ::oMtrLabel:Set( ++n )

   end

   ( ::cAreaTmpLabel )->( dbGoTo( nRecno ) )

   ::oBrwLabel:Refresh()

   ::oMtrLabel:Set( 0 )
   ::oMtrLabel:Refresh()

    CursorArrow()

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_AddLabel() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   ( ::cAreaTmpLabel )->nLabel++

   ::oBrwLabel:Refresh()
   ::oBrwLabel:SetFocus()

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_DelLabel() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   if ( ::cAreaTmpLabel )->nLabel > 1
      ( ::cAreaTmpLabel )->nLabel--
   end

   ::oBrwLabel:Refresh()
   ::oBrwLabel:SetFocus()

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_EditLabel() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   ::oBrwLabel:aCols[ 6 ]:Edit()

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_FilterLabel() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   if Empty( ::oFilter )
      ::oFilter      := TDlgFlt():New( aLblRctPrv(), ::cAreaTmpLabel )
   end

   if !Empty( ::oFilter )

      ::oFilter:Resource()

      if ::oFilter:cExpFilter <> nil
         SetWindowText( ::oBtnFilter:hWnd, "Filtro activo" )
      else
         SetWindowText( ::oBtnFilter:hWnd, "Filtrar" )
      end

   end

   ::oBrwLabel:Refresh()
   ::oBrwLabel:SetFocus()

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_LoadAuxiliar() ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   local nRec
   local nOrd





   ( ::cAreaTmpLabel )->( __dbZap() )





   nRec           := ( dbfRctPrvT )->( Recno() )
   nOrd           := ( dbfRctPrvT )->( OrdSetFocus( "nNumFac" ) )

   if ( dbfRctPrvT )->( dbSeek( ::cSerieInicio + Str( ::nDocumentoInicio, 9 ) + ::cSufijoInicio, .T. ) )



      while ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac >= ::cSerieInicio + Str( ::nDocumentoInicio, 9 ) + ::cSufijoInicio .AND.  ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac <= ::cSerieFin + Str( ::nDocumentoFin, 9 ) + ::cSufijoFin          .AND.  !( dbfRctPrvT )->( eof() )

         if ( dbfRctPrvL )->( dbSeek( ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac ) )

            while ( ( dbfRctPrvL )->cSerFac + Str( ( dbfRctPrvL )->nNumFac ) + ( dbfRctPrvL )->cSufFac == ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac ) .AND. ( dbfRctPrvL )->( !eof() )

               if !Empty( ( dbfRctPrvL )->cRef )

                  ( ::cAreaTmpLabel )->( dbAppend() )

                  ( ::cAreaTmpLabel )->cSerFac  := ( dbfRctPrvL )->cSerFac
                  ( ::cAreaTmpLabel )->nNumFac  := ( dbfRctPrvL )->nNumFac
                  ( ::cAreaTmpLabel )->cSufFac  := ( dbfRctPrvL )->cSufFac
                  ( ::cAreaTmpLabel )->cRef     := ( dbfRctPrvL )->cRef
                  ( ::cAreaTmpLabel )->cRefPrv  := ( dbfRctPrvL )->cRefPrv
                  ( ::cAreaTmpLabel )->cDetalle := ( dbfRctPrvL )->cDetalle
                  ( ::cAreaTmpLabel )->nPreUnit := ( dbfRctPrvL )->nPreUnit
                  ( ::cAreaTmpLabel )->nIva     := ( dbfRctPrvL )->nIva
                  ( ::cAreaTmpLabel )->nReq     := ( dbfRctPrvL )->nReq
                  ( ::cAreaTmpLabel )->nCanEnt  := ( dbfRctPrvL )->nCanEnt
                  ( ::cAreaTmpLabel )->lControl := ( dbfRctPrvL )->lControl
                  ( ::cAreaTmpLabel )->cUnidad  := ( dbfRctPrvL )->cUnidad
                  ( ::cAreaTmpLabel )->nUniCaja := ( dbfRctPrvL )->nUniCaja
                  ( ::cAreaTmpLabel )->mLngDes  := ( dbfRctPrvL )->mLngDes
                  ( ::cAreaTmpLabel )->nDtoLin  := ( dbfRctPrvL )->nDtoLin
                  ( ::cAreaTmpLabel )->nDtoPrm  := ( dbfRctPrvL )->nDtoPrm
                  ( ::cAreaTmpLabel )->nDtoRap  := ( dbfRctPrvL )->nDtoRap
                  ( ::cAreaTmpLabel )->cCodPr1  := ( dbfRctPrvL )->cCodPr1
                  ( ::cAreaTmpLabel )->cCodPr2  := ( dbfRctPrvL )->cCodPr2
                  ( ::cAreaTmpLabel )->cValPr1  := ( dbfRctPrvL )->cValPr1
                  ( ::cAreaTmpLabel )->cValPr2  := ( dbfRctPrvL )->cValPr2
                  ( ::cAreaTmpLabel )->nFacCnv  := ( dbfRctPrvL )->nFacCnv
                  ( ::cAreaTmpLabel )->cAlmLin  := ( dbfRctPrvL )->cAlmLin
                  ( ::cAreaTmpLabel )->nCtlStk  := ( dbfRctPrvL )->nCtlStk
                  ( ::cAreaTmpLabel )->lLote    := ( dbfRctPrvL )->lLote
                  ( ::cAreaTmpLabel )->nLote    := ( dbfRctPrvL )->nLote
                  ( ::cAreaTmpLabel )->cLote    := ( dbfRctPrvL )->cLote
                  ( ::cAreaTmpLabel )->nNumLin  := ( dbfRctPrvL )->nNumLin
                  ( ::cAreaTmpLabel )->nUndKit  := ( dbfRctPrvL )->nUndKit
                  ( ::cAreaTmpLabel )->lKitArt  := ( dbfRctPrvL )->lKitArt
                  ( ::cAreaTmpLabel )->lKitChl  := ( dbfRctPrvL )->lKitChl
                  ( ::cAreaTmpLabel )->lKitPrc  := ( dbfRctPrvL )->lKitPrc
                  ( ::cAreaTmpLabel )->lImpLin  := ( dbfRctPrvL )->lImpLin
                  ( ::cAreaTmpLabel )->mNumSer  := ( dbfRctPrvL )->mNumSer
                  ( ::cAreaTmpLabel )->cCodUbi1 := ( dbfRctPrvL )->cCodUbi1
                  ( ::cAreaTmpLabel )->cCodUbi2 := ( dbfRctPrvL )->cCodUbi2
                  ( ::cAreaTmpLabel )->cCodUbi3 := ( dbfRctPrvL )->cCodUbi3
                  ( ::cAreaTmpLabel )->cValUbi1 := ( dbfRctPrvL )->cValUbi1
                  ( ::cAreaTmpLabel )->cValUbi2 := ( dbfRctPrvL )->cValUbi2
                  ( ::cAreaTmpLabel )->cValUbi3 := ( dbfRctPrvL )->cValUbi3
                  ( ::cAreaTmpLabel )->cNomUbi1 := ( dbfRctPrvL )->cNomUbi1
                  ( ::cAreaTmpLabel )->cNomUbi2 := ( dbfRctPrvL )->cNomUbi2
                  ( ::cAreaTmpLabel )->cNomUbi3 := ( dbfRctPrvL )->cNomUbi3
                  ( ::cAreaTmpLabel )->cCodFam  := ( dbfRctPrvL )->cCodFam
                  ( ::cAreaTmpLabel )->cGrpFam  := ( dbfRctPrvL )->cGrpFam
                  ( ::cAreaTmpLabel )->mObsLin  := ( dbfRctPrvL )->mObsLin
                  ( ::cAreaTmpLabel )->nPvpRec  := ( dbfRctPrvL )->nPvpRec
                  ( ::cAreaTmpLabel )->nUndLin  := nTotNRctPrv( dbfRctPrvL )
                  ( ::cAreaTmpLabel )->lLabel   := .T.

                  if ::nCantidadLabels == 1
                  ( ::cAreaTmpLabel )->nLabel   := nTotNRctPrv( dbfRctPrvL )
                  else
                  ( ::cAreaTmpLabel )->nLabel   := ::nUnidadesLabels
                  end

               end

               ( dbfRctPrvL )->( dbSkip() )

            end

         end

         ( dbfRctPrvT )->( dbSkip() )

      end

   end

   ( dbfRctPrvT )->( OrdSetFocus( nOrd ) )
   ( dbfRctPrvT )->( dbGoTo( nRec ) )

   ( ::cAreaTmpLabel )->( dbGoTop() )

   ::oBrwLabel:Refresh()

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_InitLabel( oLabel) ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   local nStartRow

   if ::nFilaInicio > 1
      nStartRow            := oLabel:nStartRow
      nStartRow            += ( ::nFilaInicio - 1 ) * ( oLabel:nLblHeight + oLabel:nVSeparator )

      if nStartRow < oLabel:nBottomRow
         oLabel:nStartRow  := nStartRow
      end
   end

   if ::nColumnaInicio > 1 .AND. ::nColumnaInicio <= oLabel:nLblOnLine
      oLabel:nLblCurrent   := ::nColumnaInicio
   end

Return ( Self )



UTILITY STATIC function TRectificativaProveedorLabelGenerator_SelectColumn( oCombo) ; local Self AS CLASS TRectificativaProveedorLabelGenerator := QSelf() AS CLASS TRectificativaProveedorLabelGenerator

   local oCol
   local cOrd                    := oCombo:VarGet()

   if ::oBrwLabel <> nil

      with object ::oBrwLabel

         for each oCol in :aCols

            if Eq( cOrd, oCol:cHeader )
               oCol:cOrder       := "A"
               oCol:SetOrder()
            else
               oCol:cOrder       := " "
            end

         next

      end

      ::oBrwLabel:Refresh()

   end

Return ( Self )



Static Function DataLabel( oFr, lTemporal )





   oFr:ClearDataSets()

   if lTemporal
      oFr:SetWorkArea(  "Lineas de facturas rectificativas", ( tmpRctPrvL )->( Select() ), .F., { 0, 0, 0 } )
   else
      oFr:SetWorkArea(  "Lineas de facturas rectificativas", ( dbfRctPrvL )->( Select() ), .F., { 0, 2, 20 } )
   end
   oFr:SetFieldAliases( "Lineas de facturas rectificativas", cItemsToReport( aColRctPrv() ) )

   oFr:SetWorkArea(     "Facturas rectificativas", ( dbfRctPrvT )->( Select() ) )
   oFr:SetFieldAliases( "Facturas rectificativas", cItemsToReport( aItmRctPrv() ) )

   oFr:SetWorkArea(     "Artículos", ( dbfArticulo )->( Select() ) )
   oFr:SetFieldAliases( "Artículos", cItemsToReport( aItmArt() ) )

   oFr:SetWorkArea(     "Precios por propiedades", ( dbfArtCom )->( Select() ) )
   oFr:SetFieldAliases( "Precios por propiedades", cItemsToReport( aItmVta() ) )

   if lTemporal
      oFr:SetMasterDetail( "Lineas de facturas rectificativas", "Facturas rectificativas", {|| ( tmpRctPrvL )->cSerFac + Str( ( tmpRctPrvL )->nNumFac ) + ( tmpRctPrvL )->cSufFac } )
      oFr:SetMasterDetail( "Lineas de facturas rectificativas", "Artículos", {|| ( tmpRctPrvL )->cRef } )
      oFr:SetMasterDetail( "Lineas de facturas rectificativas", "Precios por propiedades", {|| ( tmpRctPrvL )->cRef + ( tmpRctPrvL )->cCodPr1 + ( tmpRctPrvL )->cCodPr2 + ( tmpRctPrvL )->cValPr1 + ( tmpRctPrvL )->cValPr2 } )
   else
      oFr:SetMasterDetail( "Lineas de facturas rectificativas", "Facturas rectificativas", {|| ( dbfRctPrvL )->cSerFac + Str( ( dbfRctPrvL )->nNumFac ) + ( dbfRctPrvL )->cSufFac } )
      oFr:SetMasterDetail( "Lineas de facturas rectificativas", "Artículos", {|| ( dbfRctPrvL )->cRef } )
      oFr:SetMasterDetail( "Lineas de facturas rectificativas", "Precios por propiedades", {|| ( dbfRctPrvL )->cRef + ( dbfRctPrvL )->cCodPr1 + ( dbfRctPrvL )->cCodPr2 + ( dbfRctPrvL )->cValPr1 + ( dbfRctPrvL )->cValPr2 } )
   end

   oFr:SetResyncPair(      "Lineas de facturas rectificativas", "Facturas rectificativas" )
   oFr:SetResyncPair(      "Lineas de facturas rectificativas", "Artículos" )
   oFr:SetResyncPair(      "Lineas de facturas rectificativas", "Precios por propiedades" )

Return nil



Function DesignLabelRctPrv( oFr, dbfDoc )

   local oLabel   := TRectificativaProveedorLabelGenerator():Init()

   if !oLabel:lErrorOnCreate





      DataLabel( oFr, .F. )





      if !Empty( ( dbfDoc )->mReport )

         oFr:LoadFromBlob( ( dbfDoc )->( Select() ), "mReport")

      else

         oFr:AddPage(         "MainPage" )

         oFr:AddBand(         "CabeceraColumnas",  "MainPage",       6 )
         oFr:SetProperty(     "CabeceraColumnas",  "Top",            200 )
         oFr:SetProperty(     "CabeceraColumnas",  "Height",         100 )
         oFr:SetObjProperty(  "CabeceraColumnas",  "DataSet",        "Lineas de facturas rectificativas" )

      end





      VariableReport( oFr )





      oFr:DesignReport()





      oFr:DestroyFr()





      oLabel:DestroyTemporal()





      oLabel:End()

   else

      Return .F.

   end

Return .T.






Function aLblRctPrv()

   local aLblFacPrv  := {}

   aAdd( aLblFacPrv, { "CSERFAC"    ,"C",  1, 0, "Serie de factura"            ,"",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NNUMFAC"    ,"N",  9, 0, "Número de factura"           ,"'999999999'",         "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CSUFFAC"    ,"C",  2, 0, "Sufijo de factura"           ,"",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CREF"       ,"C", 18, 0, "Referencia artículo"         ,"",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CREFPRV"    ,"C", 20, 0, "Referencia del proveedor"    ,"",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CDETALLE"   ,"C",100, 0, "Detalle de articulo"         ,"",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NPREUNIT"   ,"N", 16, 6, "Precio unitario"             ,"cPinDivFac",          "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NDTO"       ,"N",  6, 2, ""                            ,"'@E 99,99'",          "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NIVA"       ,"N",  6, 2, "Porcentaje de " + cImp()           ,"'@E 99,99'",          "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NCANENT"    ,"N", 16, 6, "Cantidad recibida"           ,"cMasUnd()",           "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "LCONTROL"   ,"L",  1, 0, "Control reservado"           ,"",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CUNIDAD"    ,"C",  2, 0, "Unidad de venta"             ,"",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NUNICAJA"   ,"N", 16, 6, "Unidades por caja"           ,"cMasUnd()",           "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "LCHGLIN"    ,"L",  1, 0, "Cambio de precio"            ,"",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "MLNGDES"    ,"M", 10, 0, ""                            ,""          ,          "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NDTOLIN"    ,"N",  6, 2, "Descuento lineal"            ,"'@E 999,99'",         "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NDTOPRM"    ,"N",  6, 2, "Descuento por promoción"     ,"'@E 999,99'",         "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NDTORAP"    ,"N",  6, 2, "Descuento por rappel"        ,"'@E 999,99'",         "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NPRECOM"    ,"N", 16, 6, "Precio de compra"            ,"cPinDivFac",          "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "LBNFLIN1"   ,"L",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "LBNFLIN2"   ,"L",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "LBNFLIN3"   ,"L",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "LBNFLIN4"   ,"L",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "LBNFLIN5"   ,"L",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "LBNFLIN6"   ,"L",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "NBNFLIN1"   ,"N",  6, 2, "" }                                                                      )
   aAdd( aLblFacPrv, { "NBNFLIN2"   ,"N",  6, 2, "" }                                                                      )
   aAdd( aLblFacPrv, { "NBNFLIN3"   ,"N",  6, 2, "" }                                                                      )
   aAdd( aLblFacPrv, { "NBNFLIN4"   ,"N",  6, 2, "" }                                                                      )
   aAdd( aLblFacPrv, { "NBNFLIN5"   ,"N",  6, 2, "" }                                                                      )
   aAdd( aLblFacPrv, { "NBNFLIN6"   ,"N",  6, 2, "" }                                                                      )
   aAdd( aLblFacPrv, { "NBNFSBR1"   ,"N",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "NBNFSBR2"   ,"N",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "NBNFSBR3"   ,"N",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "NBNFSBR4"   ,"N",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "NBNFSBR5"   ,"N",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "NBNFSBR6"   ,"N",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "NPVPLIN1"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aLblFacPrv, { "NPVPLIN2"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aLblFacPrv, { "NPVPLIN3"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aLblFacPrv, { "NPVPLIN4"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aLblFacPrv, { "NPVPLIN5"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aLblFacPrv, { "NPVPLIN6"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aLblFacPrv, { "NIVALIN1"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aLblFacPrv, { "NIVALIN2"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aLblFacPrv, { "NIVALIN3"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aLblFacPrv, { "NIVALIN4"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aLblFacPrv, { "NIVALIN5"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aLblFacPrv, { "NIVALIN6"   ,"N", 16, 6, "" }                                                                      )
   aAdd( aLblFacPrv, { "NIVALIN"    ,"N",  6, 2, "" }                                                                      )
   aAdd( aLblFacPrv, { "LIVALIN"    ,"L",  1, 0, "" }                                                                      )
   aAdd( aLblFacPrv, { "CCODPR1"    ,"C", 10, 0, "Código de la propiedad 1",    "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CCODPR2"    ,"C", 10, 0, "Código de la propiedad 2",    "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CVALPR1"    ,"C", 10, 0, "Valor de la propiedad 1" ,    "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CVALPR2"    ,"C", 10, 0, "Valor de la propiedad 2" ,    "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NFACCNV"    ,"N", 16, 6, "Factor de conversión de la compra", "",              "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CALMLIN"    ,"C",  3, 0, "Código del almacen" ,         "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NCTLSTK"    ,"N",  1, 0, "Tipo de stock de la línea",   "'9'",                 "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "LLOTE"      ,"L",  1, 0, "",                            "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NLOTE"      ,"N",  9, 0, "",                            "'999999999'",         "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CLOTE"      ,"C", 12, 0, "Número de lote",              "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NNUMLIN"    ,"N",  4, 0, "Número de la línea",          "9999",                "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NUNDKIT"    ,"N", 16, 6, "Unidades del producto kit",   "MasUnd()",            "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "LKITART"    ,"L",  1, 0, "Línea con escandallo",        "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "LKITCHL"    ,"L",  1, 0, "Línea pertenciente a escandallo", "",                "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "LKITPRC"    ,"L",  1, 0, "",                            "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "LIMPLIN"    ,"L",  1, 0, "Imprimir línea",              "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "MNUMSER"    ,"M", 10, 0, "" ,                           "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CCODUBI1"   ,"C",  5, 0, "",                            "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CCODUBI2"   ,"C",  5, 0, "",                            "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CCODUBI3"   ,"C",  5, 0, "",                            "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CVALUBI1"   ,"C",  5, 0, "",                            "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CVALUBI2"   ,"C",  5, 0, "",                            "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CVALUBI3"   ,"C",  5, 0, "",                            "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CNOMUBI1"   ,"C", 30, 0, "",                            "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CNOMUBI2"   ,"C", 30, 0, "",                            "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CNOMUBI3"   ,"C", 30, 0, "",                            "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CCODFAM"    ,"C", 16, 0, "Código de familia",           "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "CGRPFAM"    ,"C",  3, 0, "Código del grupo de familia", "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NREQ"       ,"N", 16, 6, "Recargo de equivalencia",     "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "MOBSLIN"    ,"M", 10, 0, "Observación de línea",        "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "nPvpRec"    ,"N", 16, 6, "Precio de venta recomendado", "cPinDivFac",          "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NUNDLIN"    ,"N",  5, 0, "",                            "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "LLABEL"     ,"L",  1, 0, "Lógico de etiqueta",          "",                    "", "( cDbfCol )" } )
   aAdd( aLblFacPrv, { "NLABEL"     ,"N",  5, 0, "Número de etiquetas",         "",                    "", "( cDbfCol )" } )

return ( aLblFacPrv )



Static Function DataReport( oFr )





   oFr:ClearDataSets()

   oFr:SetWorkArea(     "Facturas rectificativas", ( dbfRctPrvT )->( Select() ), .F., { 1, 1, 0 } )
   oFr:SetFieldAliases( "Facturas rectificativas", cItemsToReport( aItmRctPrv() ) )

   oFr:SetWorkArea(     "Lineas de facturas rectificativas", ( dbfRctPrvL )->( Select() ) )
   oFr:SetFieldAliases( "Lineas de facturas rectificativas", cItemsToReport( aColRctPrv() ) )

   oFr:SetWorkArea(     "Incidencias de facturas rectificativas", ( dbfRctPrvI )->( Select() ) )
   oFr:SetFieldAliases( "Incidencias de facturas rectificativas", cItemsToReport( aIncRctPrv() ) )

   oFr:SetWorkArea(     "Documentos de facturas rectificativas", ( dbfRctPrvD )->( Select() ) )
   oFr:SetFieldAliases( "Documentos de facturas rectificativas", cItemsToReport( aFacPrvDoc() ) )

   oFr:SetWorkArea(     "Empresa", ( dbfEmp )->( Select() ) )
   oFr:SetFieldAliases( "Empresa", cItemsToReport( aItmEmp() ) )

   oFr:SetWorkArea(     "Proveedores", ( dbfPrv )->( Select() ) )
   oFr:SetFieldAliases( "Proveedores", cItemsToReport( aItmPrv() ) )

   oFr:SetWorkArea(     "Almacenes", ( dbfAlm )->( Select() ) )
   oFr:SetFieldAliases( "Almacenes", cItemsToReport( aItmAlm() ) )

   oFr:SetWorkArea(     "Formas de pago", ( dbfFpago )->( Select() ) )
   oFr:SetFieldAliases( "Formas de pago", cItemsToReport( aItmFPago() ) )

   oFr:SetWorkArea(     "Unidades de medición",  oUndMedicion:Select() )
   oFr:SetFieldAliases( "Unidades de medición",  cObjectsToReport( oUndMedicion:oDbf ) )

   oFr:SetWorkArea(     "Bancos", ( dbfPrvBnc )->( Select() ) )
   oFr:SetFieldAliases( "Bancos", cItemsToReport( aPrvBnc() ) )

   oFr:SetMasterDetail( "Facturas rectificativas", "Lineas de facturas rectificativas",      {|| ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Incidencias de facturas rectificativas", {|| ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Documentos de facturas rectificativas",  {|| ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Proveedores",                            {|| ( dbfRctPrvT )->cCodPrv } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Almacenes",                              {|| ( dbfRctPrvT )->cCodAlm } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Formas de pago",                         {|| ( dbfRctPrvT )->cCodPago} )
   oFr:SetMasterDetail( "Facturas rectificativas", "Empresa",                                {|| cCodigoEmpresaEnUso() } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Bancos",                                 {|| ( dbfRctPrvT )->cCodPrv } )

   oFr:SetMasterDetail( "Lineas de facturas rectificativas", "Unidades de medición",         {|| ( dbfRctPrvL )->cUnidad } )

   oFr:SetResyncPair(   "Facturas rectificativas", "Lineas de facturas rectificativas" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Incidencias de facturas rectificativas" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Documentos de facturas rectificativas" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Proveedores" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Almacenes" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Formas de pago" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Bancos" )

   oFr:SetResyncPair(   "Lineas de facturas rectificativas", "Unidades de medición" )

Return nil



Static Function VariableReport( oFr )

   oFr:DeleteCategory(  "Facturas rectificativas" )
   oFr:DeleteCategory(  "Lineas de facturas rectificativas" )





   oFr:AddVariable(     "Facturas rectificativas",             "Total bruto",                         "GetHbVar('nTotBrt')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total factura",                       "GetHbVar('nTotFac')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total descuento",                     "GetHbVar('nTotDto')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total descuento pronto pago",         "GetHbVar('nTotDpp')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total primer descuento definible",    "GetHbVar('nTotDto')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total segundo descuento definible",   "GetHbVar('nTotDpp')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total neto",                          "GetHbVar('nTotNet')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total " + cImp(),                           "GetHbVar('nTotIva')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total RE",                            "GetHbVar('nTotReq')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total retenciones por IRPF",          "GetHbVar('nTotRet')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total impuestos",                     "GetHbVar('nTotImp')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total unidades",                      "GetHbVar('nTotUnd')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Bruto primer tipo de " + cImp(),            "GetHbArrayVar('aIvaUno',1)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Bruto segundo tipo de " + cImp(),           "GetHbArrayVar('aIvaDos',1)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Bruto tercer tipo de " + cImp(),            "GetHbArrayVar('aIvaTre',1)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Base primer tipo de " + cImp(),             "GetHbArrayVar('aIvaUno',2)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Base segundo tipo de " + cImp(),            "GetHbArrayVar('aIvaDos',2)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Base tercer tipo de " + cImp(),             "GetHbArrayVar('aIvaTre',2)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Porcentaje primer tipo " + cImp(),          "GetHbArrayVar('aIvaUno',3)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Porcentaje segundo tipo " + cImp(),         "GetHbArrayVar('aIvaDos',3)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Porcentaje tercer tipo " + cImp(),          "GetHbArrayVar('aIvaTre',3)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Porcentaje primer tipo RE",           "GetHbArrayVar('aIvaUno',4)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Porcentaje segundo tipo RE",          "GetHbArrayVar('aIvaDos',4)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Porcentaje tercer tipo RE",           "GetHbArrayVar('aIvaTre',4)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe primer tipo " + cImp(),             "GetHbArrayVar('aIvaUno',5)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe segundo tipo " + cImp(),            "GetHbArrayVar('aIvaDos',5)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe tercer tipo " + cImp(),             "GetHbArrayVar('aIvaTre',5)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe primer RE",                   "GetHbArrayVar('aIvaUno',6)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe segundo RE",                  "GetHbArrayVar('aIvaDos',6)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe tercer RE",                   "GetHbArrayVar('aIvaTre',6)" )

   oFr:AddVariable(     "Facturas rectificativas",             "Cuenta bancaria proveedor",           "CallHbFunc('cCtaRctPrv')" )

   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Código del artículo con propiedades", "CallHbFunc('cPrpRctPrv')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Detalle del artículo",                "CallHbFunc('cDesRctPrv')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Total unidades artículo",             "CallHbFunc('nTotNRctPrv')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Precio unitario de factura",          "CallHbFunc('nTotURctPrv')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Total línea de factura",              "CallHbFunc('nTotLRctPrv')" )

Return nil



Function DesignReportRctPrv( oFr, dbfDoc )

   local lOpen    := .F.
   local lFlag    := .F.





   if lOpenFiles
      lFlag       := .T.
   else
      if Openfiles()
         lFlag    := .T.
         lOpen    := .T.
      else
         lFlag    := .F.
      end
   end

   if lFlag





      DataReport( oFr )





      if !Empty( ( dbfDoc )->mReport )

         oFr:LoadFromBlob( ( dbfDoc )->( Select() ), "mReport")

      else

         oFr:SetProperty(     "Report",            "ScriptLanguage", "PascalScript" )







         oFr:SetProperty(     "Report.ScriptText", "Text", +  "procedure DetalleOnMasterDetail(Sender: TfrxComponent);"   + Chr(13) + Chr(10) +  "begin"                                                     + Chr(13) + Chr(10) +  "CallHbFunc('nTotRctPrv');"                                 + Chr(13) + Chr(10) +  "end;"                                                      + Chr(13) + Chr(10) +  "begin"                                                     + Chr(13) + Chr(10) +  "end." )

         oFr:AddPage(         "MainPage" )

         oFr:AddBand(         "CabeceraDocumento", "MainPage", 2 )
         oFr:SetProperty(     "CabeceraDocumento", "Top", 0 )
         oFr:SetProperty(     "CabeceraDocumento", "Height", 200 )

         oFr:AddBand(         "CabeceraColumnas",  "MainPage", 6 )
         oFr:SetProperty(     "CabeceraColumnas",  "Top", 200 )
         oFr:SetProperty(     "CabeceraColumnas",  "Height", 0 )
         oFr:SetProperty(     "CabeceraColumnas",  "StartNewPage", .T. )
         oFr:SetObjProperty(  "CabeceraColumnas",  "DataSet", "Facturas rectificativas" )

         oFr:AddBand(         "DetalleColumnas",   "MainPage", 7  )
         oFr:SetProperty(     "DetalleColumnas",   "Top", 230 )
         oFr:SetProperty(     "DetalleColumnas",   "Height", 28 )
         oFr:SetObjProperty(  "DetalleColumnas",   "DataSet", "Lineas de facturas rectificativas" )
         oFr:SetProperty(     "DetalleColumnas",   "OnMasterDetail", "DetalleOnMasterDetail" )

         oFr:AddBand(         "PieDocumento",      "MainPage", 3 )
         oFr:SetProperty(     "PieDocumento",      "Top", 930 )
         oFr:SetProperty(     "PieDocumento",      "Height", 110 )

      end





      VariableReport( oFr )





      oFr:SetTabTreeExpanded( 16, .F. )
      oFr:DesignReport()





      oFr:DestroyFr()





      if lOpen
         CloseFiles()
      end

   else

      Return .F.

   end

Return .T.



Function PrintReportRctPrv( nDevice, nCopies, cPrinter, dbfDoc )

   local oFr
   local cFilePdf

   IIF( nDevice == nil, nDevice := 2, ) ;
   IIF( nCopies == nil, nCopies := 1, ) ;
   IIF( cPrinter == nil, cPrinter := PrnGetName(), ) ;

   SysRefresh()

   oFr                  := frReportManager():New()

   oFr:LoadLangRes(     "Spanish.Xml" )

   oFr:SetIcon( 1 )

   oFr:SetTitle(        "Diseñador de documentos" )





   oFr:SetEventHandler( "Designer", "OnSaveReport", {|| oFr:SaveToBlob( ( dbfDoc )->( Select() ), "mReport" ) } )





   DataReport( oFr )

   cFilePdf             := cPatTmp() + "RectificativaProveedor" + StrTran( ( dbfRctPrvT )->cSerFac + Str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac, " ", "" ) + ".Pdf"





   if !Empty( ( dbfDoc )->mReport )

      oFr:LoadFromBlob( ( dbfDoc )->( Select() ), "mReport")





      VariableReport( oFr )





      oFr:PrepareReport()





      do case
         case nDevice == 2
            oFr:PrepareReport()
            oFr:ShowPreparedReport()

         case nDevice == 1
            oFr:PrintOptions:SetPrinter( cPrinter )
            oFr:PrintOptions:SetCopies( nCopies )
            oFr:PrintOptions:SetShowDialog( .F. )
            oFr:PrepareReport()
            oFr:Print()

         case nDevice == 3
            oFr:PrintOptions:SetShowDialog( .F. )
            oFr:SetProperty(  "PDFExport", "DefaultPath",      cPatTmp() )
            oFr:SetProperty(  "PDFExport", "FileName",         cFilePdf )
            oFr:SetProperty(  "PDFExport", "ShowDialog",       .F. )
            oFr:SetProperty(  "PDFExport", "EmbeddedFonts",    .T. )
            oFr:SetProperty(  "PDFExport", "PrintOptimized",   .T. )
            oFr:SetProperty(  "PDFExport", "Outline",          .T. )
            oFr:SetProperty(  "PDFExport", "OpenAfterExport",  .T. )
            oFr:DoExport(     "PDFExport" )

         case nDevice == 6

            oFr:SetProperty(  "PDFExport", "ShowDialog",       .F. )
            oFr:SetProperty(  "PDFExport", "DefaultPath",      cPatTmp() )
            oFr:SetProperty(  "PDFExport", "FileName",         cFilePdf  )
            oFr:SetProperty(  "PDFExport", "EmbeddedFonts",    .T. )
            oFr:SetProperty(  "PDFExport", "PrintOptimized",   .T. )
            oFr:SetProperty(  "PDFExport", "Outline",          .T. )
            oFr:SetProperty(  "PDFExport", "OpenAfterExport",  .F. )
            oFr:DoExport(     "PDFExport" )

            if file( cFilePdf )

               with object ( TGenMailing():New() )

                  :SetTypeDocument( "nRctPrv" )
                  :SetDe(           uFieldEmpresa( "cNombre" ) )
                  :SetCopia(        uFieldEmpresa( "cCcpMai" ) )
                  :SetAdjunto(      cFilePdf )
                  :SetPara(         RetFld( ( dbfAlbPrvT )->cCodPrv, dbfPrv, "cMeiInt" ) )
                  :SetAsunto(       "Envio de factura rectificativa de proveedor número " + ( dbfRctPrvT )->cSerFac + "/" + Alltrim( Str( ( dbfRctPrvT )->nNumFac ) ) )
                  :SetMensaje(      "Adjunto le remito nuestra factura rectificativa de proveedor " + ( dbfRctPrvT )->cSerFac + "/" + Alltrim( Str( ( dbfRctPrvT )->nNumFac ) ) + Space( 1 ) )
                  :SetMensaje(      "de fecha " + Dtoc( ( dbfRctPrvT )->dfecFac ) + Space( 1 ) )
                  :SetMensaje(      Chr(13)+Chr(10) )
                  :SetMensaje(      Chr(13)+Chr(10) )
                  :SetMensaje(      "Reciba un cordial saludo." )

                  :GeneralResource( dbfRctPrvT, aItmRctPrv() )

               end

            end

      end

   end





   oFr:DestroyFr()

Return .T.





FUNCTION nIncURctPrv( dbfTmpLin, nDec, nVdv )

   local nCalculo

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo       := nTotURctPrv( dbfTmpLin, nDec, nVdv )

   if !( dbfTmpLin )->lIvaLin
      nCalculo    += nCalculo * ( dbfTmpLin )->nIva / 100
   end

    IF nVdv <> 0
      nCalculo    := nCalculo / nVdv
    end

RETURN ( Round( nCalculo, nDec ) )



FUNCTION nIncLRctPrv( dbfLin, nDec, nRouDec, nVdv )

   local nCalculo := nTotLRctPrv( dbfLin, nDec, nRouDec, nVdv )

   if !( dbfLin )->lIvaLin
      nCalculo    += nCalculo * ( dbfLin )->nIva / 100
   end

RETURN ( nCalculo )


Static Function YearComboBoxChange()

     if oWndBrw:oWndBar:lAllYearComboBox()
      DestroyFastFilter( dbfRctPrvT )
      CreateUserFilter( "", dbfRctPrvT, .F., , , "all" )
     else
      DestroyFastFilter( dbfRctPrvT )
      CreateUserFilter( "Year( Field->dFecFac ) == " + oWndBrw:oWndBar:cYearComboBox(), dbfRctPrvT, .F., , , "Year( Field->dFecFac ) == " + oWndBrw:oWndBar:cYearComboBox() )
     end

    ( dbfRctPrvT )->( dbGoTop() )

     oWndBrw:Refresh()

Return nil






function nNewReciboProveedor( cNumFac, cTipRec, dbfFacPrvP )

   local nCon
   local nRec
   local nOrd

   IIF( cTipRec == nil, cTipRec := .F., ) ;

   nCon                    := 1
   nRec                    := ( dbfFacPrvP )->( Recno() )

   if Empty( cTipRec )
      nOrd                 := ( dbfFacPrvP )->( OrdSetFocus( "nNumFac" ) )
   else
      nOrd                 := ( dbfFacPrvP )->( OrdSetFocus( "rNumFac" ) )
   end

   if ( dbfFacPrvP )->( dbSeek( cNumFac ) )

      while ( dbfFacPrvP )->cSerFac + Str( ( dbfFacPrvP )->nNumFac ) + ( dbfFacPrvP )->cSufFac == cNumFac .AND. !( dbfFacPrvP )->( eof() )

         ++nCon

         ( dbfFacPrvP )->( dbSkip() )

      end

   end

   ( dbfFacPrvP )->( OrdSetFocus( nOrd ) )
   ( dbfFacPrvP )->( dbGoTo( nRec ) )

return ( nCon )



Static Function EditarNumeroSerie( aTmp, nMode )

   with object ( TNumerosSerie() )

      :lCompras         := .T.
      :nMode            := nMode

      :cCodArt          := aTmp[ 4    ]
      :cCodAlm          := aTmp[ 57 ]
      :nNumLin          := aTmp[ 63 ]

      :nTotalUnidades   := nTotNRctPrv( aTmp )

      :oStock           := oStock

      :uTmpSer          := dbfTmpSer

      :Resource()

   end

Return ( nil )



Static Function OldEditarNumeroSerie( aTmp, nMode )

   local n        := 1
   local oDlg
   local oBrwSer
   local oProSer
   local nProSer
   local aNumSer
   local cPreFix  := Space( 18 )
   local oSerIni
   local nSerIni  := 0
   local oSerFin
   local nSerFin  := 0
   local oNumGen
   local nNumGen  := 0
   local nTotUnd

   IIF( nMode == nil, nMode := 1, ) ;

   nTotUnd        := Abs( nTotNRctPrv( aTmp ) )

   if nTotUnd == 0
      MsgStop( "No hay unidades para asignar números de serie." )
      Return ( nil )
   end

   aNumSer        := Afill( Array( nTotUnd ), Space( 40 ) )

   if ( dbfTmpSer )->( dbSeek( Str( aTmp[ 63 ], 4 ) + aTmp[ 4 ] ) )
      while ( Str( ( dbfTmpSer )->nNumLin, 4 ) + ( dbfTmpSer )->cRef == Str( aTmp[ 63 ], 4 ) + aTmp[ 4 ] ) .AND. !( dbfTmpSer )->( Eof() )
         if ( n <= nTotUnd )
            aNumSer[ n ]   := ( dbfTmpSer )->cNumSer
         end
         ( dbfTmpSer )->( dbSkip() )
         n++
      end
   end

   oDlg = TDialog():New(,,,,, "VtaNumSer",, .F.,,,,,, .F.,,,,,, .F., )





      TGetHlp():ReDefine( 100, { | u | If( PCount()==0, nTotUnd, nTotUnd:= u ) }, oDlg,, MasUnd(),,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )




      TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cPreFix, cPreFix:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )







      oSerIni := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, nSerIni, nSerIni:= u ) }, oDlg,, "99999999999999999999", {||    ( oSerFin:cText( nSerIni + nTotUnd ), .T. )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





      oSerFin := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, nSerFin, nSerFin:= u ) }, oDlg,, "99999999999999999999",,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )






      oNumGen := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, nNumGen, nNumGen:= u ) }, oDlg,, "99999999999999999999",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





      TButton():ReDefine( 500, {||( GenNumSer( cPreFix, aNumSer, nSerIni, nNumGen, oBrwSer ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )

      oBrwSer                 := TXBrowse():New( oDlg )

      oBrwSer:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwSer:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwSer:lHScroll        := .F.
      oBrwSer:lRecordSelector := .T.
      oBrwSer:lFastEdit       := .T.

      oBrwSer:nMarqueeStyle   := 3

      oBrwSer:SetArray( aNumSer, , , .F. )

      oBrwSer:nColSel         := 2

      with object ( oBrwSer:addCol() )
         :cHeader       := "N."
         :bStrData      := {|| Trans( oBrwSer:nArrayAt, "999999999" ) }
         :nWidth        := 60
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
      end

      with object ( oBrwSer:addCol() )
         :cHeader       := "Serie"
         :bEditValue    := {|| aNumSer[ oBrwSer:nArrayAt ] }
         :nWidth        := 240
         :nEditType     := 1
         :bOnPostEdit   := {|o,x| aNumSer[ oBrwSer:nArrayAt ] := x }
      end

      oBrwSer:CreateFromResource( 150 )

      oProSer     := TMeter():ReDefine( 240, { | u | if( pCount() == 0, nProSer, nProSer := u ) }, 10, oDlg, .F., , , .T., ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ), , ( 128 + ( 255 * 256 ) + ( 0 * 65536 ) ) )





      TButton():ReDefine( 510, {||( SalvarNumeroSerie( aNumSer, aTmp, oProSer, nMode ), oDlg:End() )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )




      TButton():ReDefine( 520, {||( oDlg:End() )}, oDlg,,, .F.,,,, .F. )

      oDlg:AddFastKey( 116, {|| SalvarNumeroSerie( aNumSer, aTmp, oProSer, nMode ), oDlg:End() } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

Return ( aNumSer )



Static Function SalvarNumeroSerie( aNumSer, aTmp, oProSer, nMode )

   local cNumSer
   local nTotUnd              := len( aNumSer )

   while ( ( dbfTmpSer )->( dbSeek( Str( aTmp[ 63 ], 4 ) + aTmp[ 4 ] ) ) ) .AND. !( dbfTmpSer )->( Eof() )
      ( dbfTmpSer )->( dbDelete() )
   end

   if !Empty( oProSer )
      oProSer:SetTotal( nTotUnd )
   end

   for each cNumSer in aNumSer

      ( dbfTmpSer )->( dbAppend() )
      ( dbfTmpSer )->cRef     := aTmp[ 4    ]
      ( dbfTmpSer )->nNumLin  := aTmp[ 63 ]
      ( dbfTmpSer )->cAlmLin  := aTmp[ 57 ]
      ( dbfTmpSer )->cNumSer  := cNumSer

      if !Empty( oProSer ) .AND. ( Mod( hb_enumindex(), int( nTotUnd / 100 ) ) == 0 )
         oProSer:Set( hb_enumindex() )
      end

   next

Return ( nil )
