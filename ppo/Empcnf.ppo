#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 16 ".\Prg\Empcnf.prg"
FUNCTION RetPicCodPrvEmp()

RETURN Replicate( "9", RetNumCodPrvEmp() )



FUNCTION cProCnt( cSerie )

   IIF( cSerie == nil, cSerie := "A", ) ;

   do case
      case cSerie == "A"
         RETURN aEmp()[ 78 ]
      case cSerie == "B"
         RETURN aEmp()[ 79 ]
      case cSerie == "C"
         RETURN aEmp()[ 80 ]
      case cSerie == "D"
         RETURN aEmp()[ 81 ]
      case cSerie == "E"
         RETURN aEmp()[ 82 ]
      case cSerie == "F"
         RETURN aEmp()[ 83 ]
      case cSerie == "G"
         RETURN aEmp()[ 84 ]
      case cSerie == "H"
         RETURN aEmp()[ 85 ]
      case cSerie == "I"
         RETURN aEmp()[ 86 ]
      case cSerie == "J"
         RETURN aEmp()[ 87 ]
      case cSerie == "K"
         RETURN aEmp()[ 88 ]
      case cSerie == "L"
         RETURN aEmp()[ 89 ]
      case cSerie == "M"
         RETURN aEmp()[ 90 ]
      case cSerie == "N"
         RETURN aEmp()[ 91 ]
      case cSerie == "0"
         RETURN aEmp()[ 92 ]
      case cSerie == "P"
         RETURN aEmp()[ 93 ]
      case cSerie == "Q"
         RETURN aEmp()[ 94 ]
      case cSerie == "R"
         RETURN aEmp()[ 95 ]
      case cSerie == "S"
         RETURN aEmp()[ 96 ]
      case cSerie == "T"
         RETURN aEmp()[ 97 ]
      case cSerie == "U"
         RETURN aEmp()[ 98 ]
      case cSerie == "V"
         RETURN aEmp()[ 99 ]
      case cSerie == "W"
         RETURN aEmp()[ 100 ]
      case cSerie == "X"
         RETURN aEmp()[ 101 ]
      case cSerie == "Y"
         RETURN aEmp()[ 102 ]
      case cSerie == "Z"
         RETURN aEmp()[ 103 ]
   end

return ( aEmp()[ 78 ] )



FUNCTION cCodEnvUsr() ; return ( aEmp()[ 21 ] )
FUNCTION nTipConInt() ; return ( aEmp()[ 22 ] )
FUNCTION cRutConInt() ; return ( Upper( cPath( AllTrim( aEmp()[ 23 ] ) ) ) )
FUNCTION cNomConInt() ; return ( aEmp()[ 24 ] )
FUNCTION cUsrConInt() ; return ( aEmp()[ 25 ] )
FUNCTION cPswConInt() ; return ( aEmp()[ 26 ] )



FUNCTION cUsrConUsr() ; return ( aEmp()[ 25 ] )



FUNCTION cSitFtp() ; return ( aEmp()[ 27 ] )
FUNCTION cUsrFtp() ; return ( aEmp()[ 28 ] )
FUNCTION cPswFtp() ; return ( aEmp()[ 29 ] )



FUNCTION cSitSql() ; return ( aEmp()[ 158 ] )
FUNCTION cUsrSql() ; return ( aEmp()[ 159 ] )
FUNCTION cPswSql() ; return ( aEmp()[ 160 ] )
FUNCTION nPrtSql() ; return ( aEmp()[ 161 ] )
FUNCTION cDtbSql() ; return ( aEmp()[ 162 ] )








FUNCTION nCurCob( nCurCob, dbfEmp )

   local oBlock
   local oError
   local lCloEmp  := .F.

   oBlock         := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if nCurCob <> nil

      if dbfEmp == nil
         dbUseArea( .T., ( cDriver() ), ( cPatDat() + "EMPRESA.DBF" ), ( cCheckArea( "EMPRESA", @dbfEmp ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
         if !lAIS() ; ordListAdd( ( cPatDat() + "EMPRESA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
         lCloEmp   := .T.
      end

      if ( dbfEmp )->( dbSeek( cEmpUsr() ) )
         if ( dbfEmp )->( dbRLock() )
            aEmp()[ 123 ]   := nCurCob
            ( dbfEmp )->nNumCob  := nCurCob
            ( dbfEmp )->( dbUnLock() )
         end
      end

      if lCloEmp
         ( dbfEmp )->( dbCloseArea() )
      end

   else

      nCurCob              := if( aEmp()[ 123 ] == 0, 1, aEmp()[ 123 ] )

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

RETURN ( nCurCob )



FUNCTION lActCos() ; RETURN ( aEmp()[ 38 ] )



FUNCTION lNumObr( lNumObr ) ; RETURN ( aEmp()[ 45 ] )



FUNCTION cNumObr() ; RETURN ( aEmp()[ 46 ] )



FUNCTION lNumPed( lNumPed )

   if lNumPed <> Nil
      Return ( aEmp()[ 40 ] )
   end

RETURN ( aEmp()[ 39 ] )



FUNCTION cNumPed() ; RETURN ( aEmp()[ 40 ] )



FUNCTION lNumAlb( lNumAlb )

   if lNumAlb <> Nil
      Return ( aEmp()[ 42 ] )
   end

RETURN ( aEmp()[ 41 ] )



FUNCTION cNumAlb() ; RETURN ( aEmp()[ 42 ] )



FUNCTION lSuAlb( lSuAlb )

   if lSuAlb <> Nil
      Return ( aEmp()[ 44 ] )
   end

RETURN ( aEmp()[ 43 ] )



FUNCTION cSuAlb() ; RETURN ( aEmp()[ 44 ] )



FUNCTION SetDefAlm( cDefAlm )

   if !Empty( cDefAlm )
      aEmp()[ 47 ] := cDefAlm
   end

RETURN ( aEmp()[ 47 ] )



FUNCTION cDefAlm() ; RETURN ( aEmp()[ 47 ] )



FUNCTION cDefCli() ; RETURN ( aEmp()[ 107 ] )



FUNCTION cDefCaj() ; RETURN ( aEmp()[ 109 ] )



FUNCTION lObras()     ; RETURN ( aEmp()[ 113 ] )



FUNCTION DecUnd() ; RETURN ( aEmp()[ 50 ] )



FUNCTION cCtaCli() ; RETURN ( aEmp()[ 104 ] )



FUNCTION cCtaPrv() ; RETURN ( aEmp()[ 105 ] )



FUNCTION cCtaVta() ; RETURN ( aEmp()[ 106 ] )



FUNCTION cCtaCob() ; RETURN ( aEmp()[ 111 ] )



FUNCTION cCtaSin() ; RETURN ( aEmp()[ 112 ] )



FUNCTION cCtaAnt() ; RETURN ( aEmp()[ 149 ] )



FUNCTION cCtaRet() ; RETURN ( aEmp()[ 157 ] )



FUNCTION cEmpCnt( cSerie )

   IIF( cSerie == nil, cSerie := "A", ) ;

   do case
      case cSerie == "A"
         RETURN aEmp()[ 52 ]
      case cSerie == "B"
         RETURN aEmp()[ 53 ]
      case cSerie == "C"
         RETURN aEmp()[ 54 ]
      case cSerie == "D"
         RETURN aEmp()[ 55 ]
      case cSerie == "E"
         RETURN aEmp()[ 56 ]
      case cSerie == "F"
         RETURN aEmp()[ 57 ]
      case cSerie == "G"
         RETURN aEmp()[ 58 ]
      case cSerie == "H"
         RETURN aEmp()[ 59 ]
      case cSerie == "I"
         RETURN aEmp()[ 60 ]
      case cSerie == "J"
         RETURN aEmp()[ 61 ]
      case cSerie == "K"
         RETURN aEmp()[ 62 ]
      case cSerie == "L"
         RETURN aEmp()[ 63 ]
      case cSerie == "M"
         RETURN aEmp()[ 64 ]
      case cSerie == "N"
         RETURN aEmp()[ 65 ]
      case cSerie == "0"
         RETURN aEmp()[ 66 ]
      case cSerie == "P"
         RETURN aEmp()[ 67 ]
      case cSerie == "Q"
         RETURN aEmp()[ 68 ]
      case cSerie == "R"
         RETURN aEmp()[ 69 ]
      case cSerie == "S"
         RETURN aEmp()[ 70 ]
      case cSerie == "T"
         RETURN aEmp()[ 71 ]
      case cSerie == "U"
         RETURN aEmp()[ 72 ]
      case cSerie == "V"
         RETURN aEmp()[ 73 ]
      case cSerie == "W"
         RETURN aEmp()[ 74 ]
      case cSerie == "X"
         RETURN aEmp()[ 75 ]
      case cSerie == "Y"
         RETURN aEmp()[ 76 ]
      case cSerie == "Z"
         RETURN aEmp()[ 77 ]
   end

RETURN ""



Function nDefBnf( nPct )

   IIF( nPct == nil, nPct := 1, ) ;

   do case
      case nPct == 1
         return aEmp()[ 124 ]
      case nPct == 2
         return aEmp()[ 125 ]
      case nPct == 3
         return aEmp()[ 126 ]
      case nPct == 4
         return aEmp()[ 127 ]
      case nPct == 5
         return aEmp()[ 128 ]
      case nPct == 6
         return aEmp()[ 129 ]
   end

return ( 0 )



FUNCTION nDefSbr( nPct )

   IIF( nPct == nil, nPct := 1, ) ;

   do case
      case nPct == 1
         Return aEmp()[ 130 ]
      case nPct == 2
         Return aEmp()[ 131 ]
      case nPct == 3
         Return aEmp()[ 132 ]
      case nPct == 4
         Return aEmp()[ 133 ]
      case nPct == 5
         Return aEmp()[ 134 ]
      case nPct == 6
         Return aEmp()[ 135 ]
   end

return ( 0 )



FUNCTION lLotes() ; RETURN ( aEmp()[ 140 ] )



FUNCTION lMostrarCostos() ; RETURN ( !( aEmp()[ 142 ] .OR. oUser():lNotCostos() ) )



FUNCTION lRecogerUsuario() ; RETURN ( uFieldEmpresa( "lGetUsr" ) )



FUNCTION lRecogerUbicacion() ; RETURN ( uFieldEmpresa( "lGetUbi" ) )



FUNCTION lImporteExacto() ; RETURN ( aEmp()[ 144 ] )



FUNCTION lShwKit( lShwKit )

   if ValType( lShwKit ) == "L"
      aEmp()[ 136 ] := lShwKit
      SetFieldEmpresa( lShwKit, "lShwKit" )
   end

RETURN ( aEmp()[ 136 ] )



FUNCTION cNbrEmp() ; RETURN ( if( IsArray( aEmp() ), Rtrim( aEmp()[ 2    ] ), "" ) )
FUNCTION cNifEmp() ; RETURN ( if( IsArray( aEmp() ), Rtrim( aEmp()[ 3       ] ), "" ) )
FUNCTION cAdmEmp() ; RETURN ( if( IsArray( aEmp() ), Rtrim( aEmp()[ 4   ] ), "" ) )
FUNCTION cDomEmp() ; RETURN ( if( IsArray( aEmp() ), Rtrim( aEmp()[ 5 ] ), "" ) )
FUNCTION cPobEmp() ; RETURN ( if( IsArray( aEmp() ), Rtrim( aEmp()[ 6 ] ), "" ) )
FUNCTION cPrvEmp() ; RETURN ( if( IsArray( aEmp() ), Rtrim( aEmp()[ 7 ] ), "" ) )
FUNCTION cCdpEmp() ; RETURN ( if( IsArray( aEmp() ), Rtrim( aEmp()[ 8    ] ), "" ) )
FUNCTION cTlfEmp() ; RETURN ( if( IsArray( aEmp() ), Rtrim( aEmp()[ 9       ] ), "" ) )
FUNCTION cFaxEmp() ; RETURN ( if( IsArray( aEmp() ), Rtrim( aEmp()[ 10       ] ), "" ) )
FUNCTION cEmaEmp() ; RETURN ( if( IsArray( aEmp() ), Rtrim( aEmp()[ 11      ] ), "" ) )
FUNCTION cWebEmp() ; RETURN ( if( IsArray( aEmp() ), Rtrim( aEmp()[ 12        ] ), "" ) )







FUNCTION cFormatoDocumento( cSerie, cTipDoc, dbfCount )

   local oBlock
   local oError
   local nPos
   local lClo        := .F.
   local cDoc        := ""

   IIF( cSerie == nil, cSerie := "A", ) ;

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if Empty( dbfCount )
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "NCOUNT.DBF" ), ( cCheckArea( "NCOUNT", @dbfCount ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "NCOUNT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClo           := .T.
   end

   nPos              := ( dbfCount )->( fieldPos( "Doc" + cSerie ) )





   if ( dbfCount )->( dbSeek( Upper( cTipDoc ) ) )
      cDoc           := ( dbfCount )->( fieldGet( nPos ) )
   else
      msgStop( "No encuentro el tipo de documento " + cTipDoc )
   end





   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClo
      ( dbfCount )->( dbCloseArea() )
   end

RETURN ( cDoc )



FUNCTION nCopiasDocumento( cSerie, cTipDoc, dbfCount )

   local oBlock
   local oError
   local nPos
   local lClo        := .F.
   local nCop        := 0

   IIF( cSerie == nil, cSerie := "A", ) ;

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if Empty( dbfCount )
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "NCOUNT.DBF" ), ( cCheckArea( "NCOUNT", @dbfCount ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "NCOUNT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClo           := .T.
   end

   nPos              := ( dbfCount )->( fieldPos( "Copias" + cSerie ) )





   if ( dbfCount )->( dbSeek( Upper( cTipDoc ) ) )

      nCop           := ( dbfCount )->( fieldGet( nPos ) )

   else

      msgStop( "No encuentro el tipo de documento " + cTipDoc )

   end





   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClo
      ( dbfCount )->( dbCloseArea() )
   end

RETURN ( nCop )



FUNCTION cGetHtmlDocumento( cTipDoc, dbfCount )

   local oBlock
   local oError
   local lClo        := .F.
   local cDoc        := ""

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      if Empty( dbfCount )
         dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "NCOUNT.DBF" ), ( cCheckArea( "nCount", @dbfCount ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
         if !lAIS() ; ordListAdd( ( cPatEmp() + "NCOUNT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
         lClo        := .T.
      end

      if ( dbfCount )->( dbSeek( Upper( cTipDoc ) ) )
         cDoc        := ( dbfCount )->cPltDfl
      else
         msgStop( "No encuentro el tipo de documento " + cTipDoc )
      end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClo
      ( dbfCount )->( dbCloseArea() )
   end

RETURN ( cDoc )



FUNCTION cSetHtmlDocumento( cTipDoc, cHtmlDocumento, dbfCount )

   local oBlock
   local oError
   local lClo        := .F.
   local cDoc        := ""

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      if Empty( dbfCount )
         dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "NCOUNT.DBF" ), ( cCheckArea( "nCount", @dbfCount ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
         if !lAIS() ; ordListAdd( ( cPatEmp() + "NCOUNT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
         lClo        := .T.
      end

      if ( dbfCount )->( dbSeek( Upper( cTipDoc ) ) )
         if ( dbfCount )->( dbRLock() )
            ( dbfCount )->cPltDfl   := cHtmlDocumento
            ( dbfCount )->( dbUnLock() )
         end
      else
         msgStop( "No encuentro el tipo de documento " + cTipDoc )
      end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClo
      ( dbfCount )->( dbCloseArea() )
   end

RETURN ( cDoc )



Function lIvaReq() ; Return ( aEmp()[ 146 ] )



Function lEnviarEntregados() ; Return ( aEmp()[ 147 ] )



Function nDiasValidez() ; Return ( aEmp()[ 148 ] )







FUNCTION MasUnd( lCeros )

   if Empty( aEmp() )
      RETURN RetPic( 8, 0, lCeros )
   end

RETURN RetPic( aEmp()[ 49 ], aEmp()[ 50 ], lCeros )



FUNCTION MasEsc( lCeros )

   if Empty( aEmp() )
      RETURN RetPic( 8, 0, lCeros )
   end

RETURN RetPic( aEmp()[ 138 ], aEmp()[ 139 ], lCeros )



FUNCTION cDivChg( cDiv )

   local cDivChg     := "PTS"

   if !Empty( aEmp() )

      if cDiv <> nil
          aEmp()[ 18 ]  := cDiv
          cDivChg             := cDiv
      else
          cDivChg             := aEmp()[ 18 ]
      end

   end

RETURN ( cDivChg )



FUNCTION cDivEmp( cDiv )

   local cDivEmp  := "EUR"

   if !Empty( aEmp() )

      if cDiv <> nil
          aEmp()[ 17 ]  := cDiv
          cDivEmp             := cDiv
      else
          cDivEmp             := aEmp()[ 17 ]
      end

   end

RETURN ( cDivEmp )



FUNCTION lCalCaj()

   local lCalCaj  := .F.

   if !Empty( aEmp() )
      lCalCaj     := aEmp()[ 33 ]
   end

RETURN ( lCalCaj )



FUNCTION cCodEmp() ; RETURN ( if( IsArray( aEmp() ), aEmp()[ 1 ], "" ) )







Function lEmpCnv()

   if Empty( aEmp() )
      Return ( .T. )
   end

Return ( aEmp()[ 17 ] <> "PTS" )



Function uFieldEmpresa( cField, uDefault )

   local uField
   local nField

   nField         := aScan( aItmEmp(), {|x| Upper( x[1] ) == Upper( cField ) } )

   if nField <> 0 .AND. !Empty( aEmp() )

      uField      := aEmp()[ nField ]

      if Valtype( uField ) == "C"
         uField   := Alltrim( uField )
      end

   end

   if Empty( uField ) .AND. !IsNil( uDefault )
      uField      := uDefault
   end

Return ( uField )





FUNCTION SetFieldEmpresa( nVal, cField )

   local nField
   local oBlock
   local oError
   local dbfEmp
   local cCodEmp  := cCodigoEmpresaEnUso()

   oBlock         := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "EMPRESA.DBF" ), ( cCheckArea( "EMPRESA", @dbfEmp ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "EMPRESA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      nField      := ( dbfEmp )->( FieldPos( cField ) )

      if nField <> 0

         if ( dbfEmp )->( dbSeek( cCodEmp ) )

            if ( dbfEmp )->( dbRLock() )
               ( dbfEmp )->( FieldPut( nField, nVal ) )
               ( dbfEmp )->( dbUnLock() )
            end

            SetEmp( nVal, nField )

         end

      end

      ( dbfEmp )->( dbCloseArea() )

   RECOVER USING oError

      msgStop( "Imposible abrir las bases de datos de empresas" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

RETURN ( nVal )









Function RetNumCodCliEmp()

   local nNumCod  := 7
   local dbfEmp

   if !Empty( aEmp() )

      if Empty( aEmp()[ 200 ] )

         nNumCod     := aEmp()[ 14 ]

      else

         if !aEmp()[ 224 ]

            nNumCod     := aEmp()[ 14 ]

         else

            dbUseArea( .T., ( cDriver() ), ( cPatDat() + "EMPRESA.DBF" ), ( cCheckArea( "EMPRESA", @dbfEmp ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatDat() + "EMPRESA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            if ( dbfEmp )->( dbSeek( aEmp()[ 200 ] ) )
               nNumCod     := ( dbfEmp )->nCodCli
            else
               nNumCod     := aEmp()[ 14 ]
            end

            ( dbfEmp )->( dbCloseArea() )

         end

      end

   end

return ( nNumCod )



FUNCTION RetSufEmp()

   local cSufEmp  := Space( 2 )

   if !Empty( aEmp() )
      cSufEmp     := aEmp()[ 16 ]
   end





return ( cSufEmp )




FUNCTION cDefFpg()
   local cDefFpg  := Space( 2 )

   if !Empty( aEmp() )
      cDefFpg     := aEmp()[ 48 ]
   end

RETURN ( cDefFpg )



FUNCTION lRecogerAgentes() ; RETURN ( aEmp()[ 143 ] )







FUNCTION nNewDoc( cSerie, dbf, cTipDoc, nLen, dbfCount )

   local oBlock
   local oError
   local nPos
   local lClo        := .F.
   local nDoc        := 0
   local nRecAnt     := ( dbf )->( Recno() )
   local nOrdAnt     := ( dbf )->( OrdSetFocus( 1 ) )
   local cSufEmp     := RetSufEmp()
   local lNotSerie   := .F.

   if Empty( cSerie )
      lNotSerie      := .T.
   end

   IIF( nLen == nil, nLen := 9, ) ;
   IIF( cSerie == nil, cSerie := "A", ) ;





   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if Empty( dbfCount )
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "NCOUNT.DBF" ), ( cCheckArea( "NCOUNT", @dbfCount ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "NCOUNT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClo           := .T.
   end

   nPos              := ( dbfCount )->( fieldPos( cSerie ) )





   if dbSeekInOrd( Upper( cTipDoc ), "Doc", dbfCount, nil, nil, .T. )

      nDoc           := ( dbfCount )->( fieldGet( nPos ) )

      if !IsNum( nDoc )
         nDoc        := 0
      end

      if lNotSerie

         while ( dbf )->( dbSeek( Str( nDoc, nLen ) + cSufEmp ) )
            ++nDoc
         end

      else

         while ( dbf )->( dbSeek( cSerie + Str( nDoc, nLen ) + cSufEmp ) )
            ++nDoc
         end

      end

      if dbLock( dbfCount )
         ( dbfCount )->( fieldPut( nPos, nDoc + 1 ) )
         ( dbfCount )->( dbUnLock() )
      end

   else

      msgStop( "No encuentro el tipo de documento " + cTipDoc )

   end





   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClo
      ( dbfCount )->( dbCloseArea() )
   end

   ( dbf )->( OrdSetFocus( nOrdAnt ) )
   ( dbf )->( dbGoTo( nRecAnt ) )

   if nDoc == 0
      msgStop( "No puedo obtener el número de nuevo documento" )
   end

RETURN ( nDoc )






FUNCTION nPutDoc( cSerDoc, nNumDoc, cSufDoc, dbf, cTipDoc, nLen, dbfCount )

   local oBlock
   local oError
   local nPos
   local lClo        := .F.
   local aStaAnt     := aGetStatus( dbf )

   ( dbf )->( ordSetFocus( 1 ) )

   IIF( nLen == nil, nLen := 9, ) ;

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if Empty( dbfCount )

      mkNewCount( cPatEmp() )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "NCOUNT.DBF" ), ( cCheckArea( "NCOUNT", @dbfCount ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "NCOUNT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      lClo        := .T.

   end

   nPos              := ( dbfCount )->( fieldPos( cSerDoc ) )





   if ( dbfCount )->( dbSeek( Upper( cTipDoc ) ) ) .AND. dbLock( dbfCount )
      ( dbfCount )->( fieldPut( nPos, nNumDoc ) )
   end





   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClo
      ( dbfCount )->( dbCloseArea() )
   end

   SetStatus( dbf, aStaAnt )

RETURN ( nil )



FUNCTION nNewNFC( cSerie, dbf, cTipDoc, dbfCount )

   local oBlock
   local oError
   local nPosPrefijo
   local nPosNumero
   local nLenNumero
   local cDocPrefijo
   local cDocNumero
   local lClo        := .F.
   local nRecAnt     := ( dbf )->( Recno() )
   local nOrdAnt     := ( dbf )->( OrdSetFocus( "cNfc" ) )

   IIF( cSerie == nil, cSerie := "A", ) ;





   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if Empty( dbfCount )
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "NCOUNT.DBF" ), ( cCheckArea( "NCOUNT", @dbfCount ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "NCOUNT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClo           := .T.
   end

   nPosPrefijo       := ( dbfCount )->( fieldPos( "cNFC" + cSerie ) )
   nPosNumero        := ( dbfCount )->( fieldPos( "nNFC" + cSerie ) )





   if dbSeekInOrd( Upper( cTipDoc ), "Doc", dbfCount, nil, nil, .T. )

      cDocPrefijo    := Alltrim( ( dbfCount )->( fieldGet( nPosPrefijo ) ) )
      cDocNumero     := Alltrim( ( dbfCount )->( fieldGet( nPosNumero ) ) )
      nLenNumero     := Len( cDocNumero )

      while ( dbf )->( dbSeek( cDocPrefijo + cDocNumero ) )
         cDocNumero  := StrZero( Val( cDocNumero ) + 1, nLenNumero )
      end

      if dbLock( dbfCount )
         ( dbfCount )->( fieldPut( nPosNumero, StrZero( Val( cDocNumero ) + 1, nLenNumero ) ) )
         ( dbfCount )->( dbUnLock() )
      end

   else

      msgStop( "No encuentro el tipo de documento " + cTipDoc )

   end





   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClo
      ( dbfCount )->( dbCloseArea() )
   end

   ( dbf )->( OrdSetFocus( nOrdAnt ) )
   ( dbf )->( dbGoTo( nRecAnt ) )

RETURN ( cDocPrefijo + cDocNumero )







FUNCTION RetPicCodCliEmp()

RETURN Replicate( "9", RetNumCodCliEmp() )







FUNCTION cNewSer( cTipDoc, dbfCount )

   local oBlock
   local oError
   local lClo        := .F.
   local cSerie

   cSerie            := cDefSer()





   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if Empty( dbfCount )

      mkNewCount( cPatEmp() )

      while .T.

         dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "NCOUNT.DBF" ), ( cCheckArea( "NCOUNT", @dbfCount ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
         if !lAIS() ; ordListAdd( ( cPatEmp() + "NCOUNT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

         if !netErr()
            exit
         else
            loop
         end

      end

      lClo           := .T.

   end

   if ( dbfCount )->( dbSeek( Upper( cTipDoc ) ) ) .AND. !Empty( ( dbfCount )->cSerie )
      cSerie         := ( dbfCount )->cSerie
   end





   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClo
      ( dbfCount )->( dbCloseArea() )
   end

   if Empty( cSerie )
      cSerie         := "A"
   end

RETURN ( cSerie )



FUNCTION cDefSer()

   local cDefSer  := "A"

   if !Empty( aEmp() )

      cDefSer     := Upper( aEmp()[ 108 ] )

   end

RETURN ( cDefSer )



FUNCTION lEntCon()

   local lEntCon  := .T.

   if !Empty( aEmp() )

      lEntCon     := aEmp()[ 34 ]

   end

 RETURN ( lEntCon )



FUNCTION lBuscaImportes()

   local lBuscaImportes := .T.

   if !Empty( aEmp() )

      lBuscaImportes    := aEmp()[ 141 ]

   end

 RETURN ( lBuscaImportes )



 FUNCTION lTipMov()

   local lTipMov := .T.

   if !Empty( aEmp() )

      lTipMov    := aEmp()[ 37 ]

   end

 RETURN ( lTipMov )



 FUNCTION lModDes()

   local lModDes := .T.

   if !Empty( aEmp() )

      lModDes    := aEmp()[ 35 ]

   end

 RETURN ( lModDes )



 FUNCTION lModIva()

   local lModIva  := .T.

   if !Empty( aEmp() )

      lModIva     := aEmp()[ 36 ]

   end

 RETURN ( lModIva )



 FUNCTION lUseCaj()

   local lUseCaj     := .T.

   if !Empty( aEmp() )
      lUseCaj        := aEmp()[ 32 ]
   end

 RETURN ( lUseCaj )



 FUNCTION cDefVta()

   local cDefVta  := Space( 1 )

   if !Empty( aEmp() )

      cDefVta     := aEmp()[ 154 ]

   end

 RETURN ( cDefVta )



 FUNCTION cRutCnt()

   local cRutCnt  := Space( 1 )

   if !Empty( aEmp() )

      cRutCnt     := Rtrim( aEmp()[ 51 ] )

   end

 RETURN ( cRutCnt )



 FUNCTION cPatImg( cPath )

   local cPatImg  := Rtrim( aEmp()[ 120 ] )

   if !Empty( cPatImg )
      if Right( cPatImg, 1 ) <> "\"
         cPatImg  := cPatImg += "\"
      end
   end

RETURN ( cPatImg )







FUNCTION RetNumCodPrvEmp()

   local RetNumCodPrvEmp  := Space( 7 )
   local dbfEmp

   if !Empty( aEmp() )

      if Empty( aEmp()[ 200 ] )

         RetNumCodPrvEmp     := aEmp()[ 15 ]

      else

         if !aEmp()[ 230 ]

            RetNumCodPrvEmp     := aEmp()[ 15 ]

         else

            dbUseArea( .T., ( cDriver() ), ( cPatDat() + "EMPRESA.DBF" ), ( cCheckArea( "EMPRESA", @dbfEmp ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
            if !lAIS() ; ordListAdd( ( cPatDat() + "EMPRESA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

            if ( dbfEmp )->( dbSeek( aEmp()[ 200 ] ) )
               RetNumCodPrvEmp  := ( dbfEmp )->nCodPrv
            else
               RetNumCodPrvEmp  := aEmp()[ 15 ]
            end

            ( dbfEmp )->( dbCloseArea() )

         end

      end

   end

return ( RetNumCodPrvEmp )



FUNCTION lRetCodArt()

   local lRetCodArt  := .F.

   if !Empty( aEmp() )

      lRetCodArt     := aEmp()[ 20 ]

   end

return ( lRetCodArt )





FUNCTION lMultipleCodeBar()

   local lMultipleCodeBar  := .T.

   if !Empty( aEmp() )
      lMultipleCodeBar     := aEmp()[ 153 ]
   end

return ( lMultipleCodeBar )



FUNCTION cDefIva()

   local cDefIva  := Space( 1 )

   if !Empty( aEmp() )
      cDefIva     := aEmp()[ 121 ]
   end

RETURN ( cDefIva )




FUNCTION lPasNil()
   local lPasNil  := .T.

   if !Empty( aEmp() )
      lPasNil     := aEmp()[ 137 ]
   end

return ( lPasNil )
