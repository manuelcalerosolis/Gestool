#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\fivewin.ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 5 ".\Prg\Carpeta.prg"
_HB_CLASS TCarpeta ; UTILITY FUNCTION TCarpeta(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TCarpeta" , { HBObject():Classh } ) ) ;

      _HB_MEMBER {AS NUMERIC nInitID} ; IIF( !.F., s_oClass:AddMultiClsData("NUMERIC", 2000, nScope + IIF( .F., 32, 0 ) + 64, { "nInitID" }, .F. ), )

      _HB_MEMBER {AS ARRAY aGrupos} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aGrupos" }, .F., .F. ), )
      _HB_MEMBER { bWhen} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bWhen" }, .F., .F. ), )
      _HB_MEMBER {AS CHARACTER cName} ; IIF( !.F., s_oClass:AddMultiData( "CHARACTER", "oCarpeta", nScope + IIF( .F., 32, 0 ), { "cName" }, .F., .F. ), )
      _HB_MEMBER { cPrompt} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPrompt" }, .F., .F. ), )
      _HB_MEMBER {AS LOGICAL lAjustados} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lAjustados" }, .F., .F. ), )
      _HB_MEMBER {AS LOGICAL lEnabled} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .T., nScope + IIF( .F., 32, 0 ), { "lEnabled" }, .F., .F. ), )
      _HB_MEMBER {AS NUMERIC nClrBorde} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", ( 141 + ( 178 * 256 ) + ( 227 * 65536 ) ), nScope + IIF( .F., 32, 0 ), { "nClrBorde" }, .F., .F. ), )
      _HB_MEMBER {AS NUMERIC nClrPane0} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", ( 218 + ( 229 * 256 ) + ( 243 * 65536 ) ), nScope + IIF( .F., 32, 0 ), { "nClrPane0" }, .F., .F. ), )
      _HB_MEMBER {AS NUMERIC nClrPane1} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", ( 199 + ( 216 * 256 ) + ( 237 * 65536 ) ), nScope + IIF( .F., 32, 0 ), { "nClrPane1" }, .F., .F. ), )
      _HB_MEMBER {AS NUMERIC nClrPane2} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", ( 217 + ( 232 * 256 ) + ( 246 * 65536 ) ), nScope + IIF( .F., 32, 0 ), { "nClrPane2" }, .F., .F. ), )
      _HB_MEMBER {AS NUMERIC nClrPane3} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", ( 195 + ( 217 * 256 ) + ( 243 * 65536 ) ), nScope + IIF( .F., 32, 0 ), { "nClrPane3" }, .F., .F. ), )
      _HB_MEMBER {AS NUMERIC nClrSolapa1} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", ( 239 + ( 245 * 256 ) + ( 254 * 65536 ) ), nScope + IIF( .F., 32, 0 ), { "nClrSolapa1" }, .F., .F. ), )
      _HB_MEMBER {AS NUMERIC nClrSolapa2} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", ( 239 + ( 245 * 256 ) + ( 254 * 65536 ) ), nScope + IIF( .F., 32, 0 ), { "nClrSolapa2" }, .F., .F. ), )
      _HB_MEMBER {AS NUMERIC nClrText} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", ( 141 + ( 178 * 256 ) + ( 227 * 65536 ) ), nScope + IIF( .F., 32, 0 ), { "nClrText" }, .F., .F. ), )
      _HB_MEMBER { nID} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nID" }, .F., .F. ), )
      _HB_MEMBER {AS NUMERIC nOption} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 0, nScope + IIF( .F., 32, 0 ), { "nOption" }, .F., .F. ), )
      _HB_MEMBER { oParent} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oParent" }, .F., .F. ), )
      _HB_MEMBER {AS ARRAY rcSolapa} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {0,0,0,0}, nScope + IIF( .F., 32, 0 ), { "rcSolapa" }, .F., .F. ), )
      _HB_MEMBER {AS LOGICAL lHide} ; IIF( !.F., s_oClass:AddMultiData( "LOGICAL", .F., nScope + IIF( .F., 32, 0 ), { "lHide" }, .F., .F. ), )
      _HB_MEMBER { bAction} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bAction" }, .F., .F. ), )
      _HB_MEMBER { aColorsTab} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aColorsTab" }, .F., .F. ), )


      _HB_MEMBER New( oWnd, cText, lDefine, bAction, aColorsTab) AS CLASS TCarpeta; IIF( .F., s_oClass:ModMethod( "New", @TCarpeta_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TCarpeta_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
      _HB_MEMBER Paint( hDC); IIF( .F., s_oClass:ModMethod( "Paint", @TCarpeta_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paint", @TCarpeta_Paint(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
      _HB_MEMBER PintaSolapa( hDC, lSolapa, lOver); IIF( .F., s_oClass:ModMethod( "PintaSolapa", @TCarpeta_PintaSolapa(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PintaSolapa", @TCarpeta_PintaSolapa(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

      _HB_MEMBER CalcSizes(); IIF( .F., s_oClass:ModMethod( "CalcSizes", @TCarpeta_CalcSizes(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CalcSizes", @TCarpeta_CalcSizes(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
      _HB_MEMBER Copy(); IIF( .F., s_oClass:ModMethod( "Copy", @TCarpeta_Copy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Copy", @TCarpeta_Copy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
      _HB_MEMBER Edit(); IIF( .F., s_oClass:ModMethod( "Edit", @TCarpeta_Edit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Edit", @TCarpeta_Edit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
      _HB_MEMBER End( ); IIF( !.F., s_oClass:AddVirtual( "End" ), )
      _HB_MEMBER GenPrg(); IIF( .F., s_oClass:ModMethod( "GenPrg", @TCarpeta_GenPrg(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GenPrg", @TCarpeta_GenPrg(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
      _HB_MEMBER HideGroups(); IIF( .F., s_oClass:ModMethod( "HideGroups", @TCarpeta_HideGroups(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HideGroups", @TCarpeta_HideGroups(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
      _HB_MEMBER IsOverSolapa(nRow, nCol); IIF( .F., s_oClass:ModInline( "IsOverSolapa", {|Self,nRow, nCol | Self, PtInRect( nRow, nCol, ::rcSolapa ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "IsOverSolapa", {|Self,nRow, nCol | Self, PtInRect( nRow, nCol, ::rcSolapa ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
      _HB_MEMBER RButtonDown( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "RButtonDown", @TCarpeta_RButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RButtonDown", @TCarpeta_RButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
      _HB_MEMBER Search( cGrupo); IIF( .F., s_oClass:ModMethod( "Search", @TCarpeta_Search(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Search", @TCarpeta_Search(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
      _HB_MEMBER ShowGroups(); IIF( .F., s_oClass:ModMethod( "ShowGroups", @TCarpeta_ShowGroups(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ShowGroups", @TCarpeta_ShowGroups(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
      _HB_MEMBER oGrupoOver( nRow, nCol); IIF( .F., s_oClass:ModMethod( "oGrupoOver", @TCarpeta_oGrupoOver(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "oGrupoOver", @TCarpeta_oGrupoOver(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
      _HB_MEMBER Paste(); IIF( .F., s_oClass:ModMethod( "Paste", @TCarpeta_Paste(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Paste", @TCarpeta_Paste(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TCarpeta ;



  UTILITY STATIC function TCarpeta_New( oWnd, cText, lDefine, bAction, aColorsTab) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta


   if cText == nil;   cText   := "item" ;endif
   if lDefine == nil; lDefine := .F.    ;endif

   ::oParent  := oWnd
   ::cPrompt  := cText

   ::nClrBorde    := ::oParent:oColor:_GRISB
   ::nClrPane0    := ::oParent:oColor:P1GRUPOS
   ::nClrPane1    := ::oParent:oColor:_GRIS2
   ::nClrPane2    := ::oParent:oColor:_GRIS3
   ::nClrPane3    := ::oParent:oColor:_BACKTITLE
   ::nClrSolapa1  := ::oParent:oColor:_GRISBOX2
   ::nClrSolapa2  := ::oParent:oColor:_GRISBOX2
   ::nClrText     := ::oParent:oColor:_GRISB

   if ::nInitID == nil
      ::nInitID  := 20000
   endif

   ::nID      := ::nInitID++

   if !lDefine
      aadd( ::oParent:aCarpetas, self )
      ::oParent:GetCoords()
   endif

   ::bAction := bAction
   ::aColorsTab := aColorsTab

return self



      UTILITY STATIC function TCarpeta_Paint( hDC) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local lSelected := .F.
local nTop, nLeft, nBottom, nRight
local hPen, hBrush
local hOldPen, hOldBrush
local n
local nLen := len(::aGrupos)
local lRet
local a := {::oParent:nRow, ::oParent:nCol }
local aPoint := {a[1],a[2]}
local lIsOver
local rc := GetClientRect( ::oParent:hWnd )


if ::lHide
   return 0
endif


if ::bWhen <> nil
   lRet := eval( ::bWhen, self )
   ::lEnabled := lRet
endif


if ::oParent:nOption <> 0
   if ::oParent:aCarpetas[::oParent:nOption]:nID == ::nID
      lSelected := .T.
   endif
endif

nTop    := ::rcSolapa[1]
nLeft   := ::rcSolapa[2]
nBottom := ::rcSolapa[3] + 5
nRight  := ::rcSolapa[4]

lIsOver := ::IsOverSolapa( aPoint[1], aPoint[2] ) .AND. !lSelected .AND. GetActiveWindow() == ::oParent:oWnd:hWnd



if lSelected
   if empty( ::aColorsTab )
      FillSolidRect( hDC, {::rcSolapa[3]-2,::rcSolapa[2]+2,::rcSolapa[3]+10,::rcSolapa[4]-2}, ::oParent:oColor:_GRIS1 )
   else
      FillSolidRect( hDC, {::rcSolapa[3]-2,::rcSolapa[2]+2,::rcSolapa[3]-1,::rcSolapa[4]-2}, ::aColorsTab[2] )
      FillSolidRect( hDC, {::rcSolapa[3]-1,rc[2]+4,::rcSolapa[3]+1,rc[4]-3}, ::aColorsTab[2] )
   endif
endif







if lIsOver
   Box( hDC, {::rcSolapa[3]-3,::rcSolapa[2]+1,::rcSolapa[3]-2,::rcSolapa[4]-1}, ( 206 + ( 194 * 256 ) + ( 151 * 65536 ) ) )
endif

   nLeft := 3
   for n := 1 to nLen

       if lSelected
          ::aGrupos[n]:Show()
          ::aGrupos[n]:Paint( hDC )
       else
          ::aGrupos[n]:Hide()
       endif

   next



return 0



UTILITY STATIC function TCarpeta_PintaSolapa( hDC, lSolapa, lOver) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local hOldFont, nColor, nMode, hFont
local rc := {::rcSolapa[1],::rcSolapa[2],::rcSolapa[3],::rcSolapa[4]}
local oFont := nil
local nClrPane1     := ::oParent:oColor:nClrPaneSolapa1
local nClrPane2     := ::oParent:oColor:nClrPaneSolapa2
local nClrPane1Over := ::oParent:oColor:nClrPaneSolapaOver1
local nClrPane2Over := ::oParent:oColor:nClrPaneSolapaOver2
local a := {::oParent:nRow, ::oParent:nCol }
local aPoint := {a[1],a[2]}
local lIsOver


if ::lHide
   return 0
endif


   if lOver == nil; lOver := .F.; endif

   if lOver .OR. ( ::oParent:lPaintAll .AND. !lSolapa )
      nClrPane1 := nClrPane1Over
      nClrPane2 := nClrPane2Over
   endif

   if ::oParent:oFont <> nil
      hFont := ::oParent:oFont:hFont
   else
      oFont := TFont():New( "Ms Sans Serif", 0, -12.3,,,,,,,,,,,,,, )
      hFont := oFont:hFont
   endif

   if empty( ::aColorsTab )

      if ( lSolapa .AND. !lOver ) .OR. ( lOver .AND. !lSolapa ) .OR. ::oParent:lPaintAll
         VerticalGradient( hDC, { rc[1] + ::oParent:nTopMargin+1, rc[2]+4, rc[3], rc[4] -4}, nClrPane1, nClrPane2 )
         RoundBox        ( hDC,   rc[2] + 2, rc[1]+::oParent:nTopMargin  , rc[4] -  2, rc[3] + 6, ::oParent:oColor:nCorner1, ::oParent:oColor:nCorner1, ::oParent:oColor:_GRISB )
         RoundBox        ( hDC,   rc[2] + 3, rc[1]+::oParent:nTopMargin+1, rc[4] -  3, rc[3] + 6, ::oParent:oColor:nCorner1, ::oParent:oColor:nCorner1, 16777215 )
      endif

      if lSolapa .AND. ::IsOverSolapa( aPoint[1], aPoint[2] )
         VerticalGradient( hDC, { rc[1] + ::oParent:nTopMargin+1, rc[2]+4, rc[3], rc[4] -4}, nClrPane1, nClrPane2 )
         RoundBox        ( hDC,   rc[2] + 2, rc[1]+::oParent:nTopMargin  , rc[4] -  2, rc[3] + 6, ::oParent:oColor:nCorner1, ::oParent:oColor:nCorner1, ::oParent:oColor:ROUNDBOXCAR1 )
         RoundBox        ( hDC,   rc[2] + 3, rc[1]+::oParent:nTopMargin+1, rc[4] -  3, rc[3] + 6, ::oParent:oColor:nCorner1, ::oParent:oColor:nCorner1, ::oParent:oColor:ROUNDBOXCAR2 )
      endif

   else

      VerticalGradient( hDC, { rc[1] + ::oParent:nTopMargin+1, rc[2]+4, rc[3], rc[4] -4}, ::aColorsTab[1], ::aColorsTab[2] )

      if ::aColorsTab[3] <> nil
         RoundBox        ( hDC,   rc[2] + 2, rc[1]+::oParent:nTopMargin  , rc[4] -  2, rc[3] + 6, ::oParent:oColor:nCorner1, ::oParent:oColor:nCorner1, ::aColorsTab[3] )
      endif

      if ::aColorsTab[4] <> nil
         RoundBox        ( hDC,   rc[2] + 3, rc[1]+::oParent:nTopMargin+1, rc[4] -  3, rc[3] + 6, ::oParent:oColor:nCorner1, ::oParent:oColor:nCorner1, ::aColorsTab[4] )
      endif

   endif

   hOldFont := SelectObject( hDC, hFont )

   if empty(::aColorsTab )
      nColor   := SetTextColor( hDC, ( 21 + ( 66 * 256 ) + ( 139 * 65536 ) ) )
   else
      nColor   := SetTextColor( hDC, ::aColorsTab[5] )
   endif

   nMode    := SetBkMode( hDC, 1 )


   DrawText( hDC, ::cPrompt, {rc[1]+1, rc[2]+ 3, rc[3], rc[4]-3}, nOr( 32, 4, 1, 2048, 0x00040000 ) )

   SetBkMode( hDC, nMode )
   SetTextColor( hDC, nColor )
   SelectObject( hDC, hOldFont )

   if oFont <> nil ;      oFont:End();   endif


return 0



      UTILITY STATIC function TCarpeta_HideGroups() ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local n
local nLen := len(::aGrupos)
for n := 1 to nLen
    ::aGrupos[n]:Hide()
next


return 0


      UTILITY STATIC function TCarpeta_ShowGroups() ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local n
local nLen := len(::aGrupos)
for n := 1 to nLen
    ::aGrupos[n]:Show()
next

return 0


      UTILITY STATIC function TCarpeta_CalcSizes() ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local n
local nLen := len( ::aGrupos )
local nWidth
local lAjustado
local oGrupo


   for n := 1 to nLen
       oGrupo := ::aGrupos[n]
       if oGrupo:lAjustado()
          nWidth := oGrupo:SizeCapSm()[1]
       else
          nWidth := ::aGrupos[n]:nWidth
       endif
       if n > 1
          ::aGrupos[n]:nLeft := ::aGrupos[n-1]:nRight + 3
       endif
       ::aGrupos[n]:nRight := ::aGrupos[n]:nLeft + nWidth
       oGrupo:ResizeItems()
   next


return 0


      UTILITY STATIC function TCarpeta_Search( cGrupo) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local oGrupo
local n, o
local nLen := len( ::aGrupos )

for n := 1 to nLen
    oGrupo := ::aGrupos[n]
    if alltrim( oGrupo:cPrompt ) == alltrim( cGrupo )
       o := oGrupo
       exit
    endif
next

return o


  UTILITY STATIC function TCarpeta_RButtonDown( nRow, nCol, nOption) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local oPopup
local o := self
local oClp
local cInfo := ""
local lPaste := .F.

  oClp := TClipBoard():New( Upper("TEXT"), )

  if oClp:Open()
     cInfo := oClp:GetText()
     oClp:End()
  endif

  lPaste := at( "tcarpeta()",lower(cInfo)) == 0 .AND. at("tdotnetgroup",lower(cInfo) ) <> 0

  oPopup := MenuBegin( .T.,,, .F., .F. )
     MenuAddItem( "Add grupo",, .F.,, {|oMenuItem|( SetFocus(o:oParent:hWnd ), TDotNetGroup():New( self, 200, "cItem"  ), ::oParent:Refresh())},,,,,,, .F.,,, .F. )
     MenuAddItem()
     MenuAddItem( "Copy",, .F.,, {|oMenuItem|::Copy()},,,,,,, .F.,,, .F. )
     if lPaste
        MenuAddItem( "Paste",, .F.,, {|oMenuItem|::Paste()},,,,,,, .F.,,, .F. )
     endif
  MenuEnd()
  oPopup:Activate( nRow, nCol, ::oParent, ! .F., )
  SetFocus(::oParent:hWnd )

return 0




   UTILITY STATIC function TCarpeta_oGrupoOver( nRow, nCol) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local n, nLen, oGrupo

nLen := len( ::aGrupos )

for n := 1 to nLen

    oGrupo := ::aGrupos[n]

    if oGrupo:IsOver( nRow, nCol )
       return oGrupo
    endif

next

return nil


   UTILITY STATIC function TCarpeta_Edit() ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local oFont
local bValid := {||.T.}
local o := self
local uVar
local nTop, nLeft, nWidth, nHeight

uVar := padr(::cPrompt, 100)

nTop    := ::rcSolapa[1] + 6
nLeft   := ::rcSolapa[2] +4
nWidth  := ::rcSolapa[4]-::rcSolapa[2] -8
nHeight := ::rcSolapa[3]-::rcSolapa[1] -8

oFont := TFont():New( "Ms Sans Serif", 0, -10,,,,,,,,,,,,,, )

   ::oParent:oGet := TGet():New(nTop,nLeft,{ | u | If( PCount()==0, uVar, uVar:= u ) },o:oParent,nWidth,nHeight,,,0,16777215,oFont,.F.,,.T.,,.F.,,.F.,.F.,,.F.,.F.,.T.,)

   ::oParent:nLastKey := 0
   ::oParent:oGet:SetFocus()
   ::oParent:oGet:bValid := {|| .T. }




   ::oParent:oGet:bLostFocus := {||  o:oParent:oGet:Assign(), o:oParent:oGet:VarPut( o:oParent:oGet:oGet:VarGet() ), o:cPrompt := if( o:oParent:nLastKey <> 27, alltrim(o:oParent:oGet:oGet:VarGet()), o:cPrompt ) , o:oParent:GetCoords(), o:oParent:Refresh() }

   ::oParent:oGet:bKeyDown := { | nKey | If( nKey == 13 .OR. nKey == 27, ( o:oParent:nLastKey := nKey, o:oParent:oGet:End()), ) }



return nil



   UTILITY STATIC function TCarpeta_GenPrg() ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local cPrg := ""
local n
local nGrupos
local cGrupo := ""
local aGrupos

::cName := "oCarpeta" + + alltrim(str(::nId-2000))

::oParent:cVars += "local " + ::cName + Chr(13)+Chr(10)

cPrg := space( 7 ) + ::cName + " := TCarpeta():New( oBar, " + '"' + ::cPrompt + '"' + " )" + Chr(13)+Chr(10)

nGrupos := len( ::aGrupos )

aGrupos := array( nGrupos )

for n := 1 to nGrupos

    aGrupos[n] := ::aGrupos[n]:GenPrg()

next

for n := 1 to nGrupos

    cGrupo += aGrupos[n]

next


cPrg += cGrupo + Chr(13)+Chr(10)

return cPrg



   UTILITY STATIC function TCarpeta_Copy() ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local cInfo := ::GenPrg()
local oClp

   oClp := TClipBoard():New( Upper("TEXT"), )

   if oClp:Open()
      oClp:Clear()
      oClp:SetText( cInfo )
      oClp:End()
   else
      MsgAlert( "The clipboard is not available now!" )
   endif

return nil


   UTILITY STATIC function TCarpeta_Paste() ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local cInfo
local aLines := {}
local nLines
local n := 1
local n2
local nEstado := 0
local cLinea
local aParams := {}
local cWord
local cObject

local aWords := {{"tdotnetgroup():new(" ,3  }    , {"tdotnetbutton():new(",4 } }
local cBar
local aCarpetas := {}
local aGrupos   := {}
local o
local lDefinida := .F.
local oError
local oClp

   oClp := TClipBoard():New( Upper("TEXT"), )

   if oClp:Open()
      cInfo := oClp:GetText()
      oClp:End()
   else
      MsgAlert( "The clipboard is not available now!" )
   endif


if empty( cInfo )
   MsgInfo("Proceso cancelado")
   return 0
endif

nLines := strcount( cInfo, Chr(13)+Chr(10) )

for n := 1 to nLines
    aadd( aLines, memoline( cInfo,255,n) )
next

n := 1

while n < nLines .AND. nEstado <> 100

    cLinea := alltrim(aLines[n])
    cLinea := strtran(cLinea,'"',"")

    if left( lower(cLinea), len( "local "   )) == "local "   ; cLinea := substr( cLinea, len( "local "   )+1); endif
    if left( lower(cLinea), len( "private " )) == "private " ; cLinea := substr( cLinea, len( "private " )+1); endif
    if left( lower(cLinea), len( "public "  )) == "public "  ; cLinea := substr( cLinea, len( "public "  )+1); endif


    nEstado := 0

    cWord := ""

    for n2 := 1 to len( aWords )
        cWord := lower(aWords[n2,1])
        if at( cWord, lower(cLinea) ) <> 0
           nEstado := aWords[n2,2]
           exit
        endif
    next

       if nEstado <> 0

          asize( aParams, 0 )

          cObject := left  ( cLinea, at(":=",cLinea)-1 )
          cLinea  := substr( cLinea, at( lower(cWord), lower(cLinea) )+len(cWord)+1 )
          cLinea  := left  ( cLinea, len( cLinea ) - 1 )
          aParams := aSplit( cLinea, "," )


          do case
             case nEstado == 3







                     o := TDotNetGroup():New( self, val( aParams[2]), aParams[3], lower(aParams[4])==".t.", nil, aParams[6] )


                     aadd( aGrupos, {cObject, o } )

             case nEstado == 4



                     o := GetMyObject( aGrupos, aParams[2] )








                     o := TDotNetButton():New( val( aParams[1]), o, alltrim(aParams[3]), alltrim(aParams[4]), val(aParams[5]), , , , lower(aParams[9])==".t.", lower(aParams[10])==".t.", lower(aParams[11])==".t." )
          endcase

       endif


    n++


enddo


::oParent:Refresh()


return 0
