#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 38 ".\Prg\Tshell.prg"
static oFontLittelTitle







_HB_CLASS TShell ; UTILITY FUNCTION TShell(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TShell" , {TMdiChild():classh} ) ) ; ;

   _HB_MEMBER { oBrw} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBrw" }, .F., .F. ), )
   _HB_MEMBER { oWndBar} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oWndBar" }, .F., .F. ), )
   _HB_MEMBER { oBtnBar} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBtnBar" }, .F., .F. ), )
   _HB_MEMBER { oBtnMain} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBtnMain" }, .F., .F. ), )
   _HB_MEMBER { oBtnTop} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBtnTop" }, .F., .F. ), )
   _HB_MEMBER { oMsgBar} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oMsgBar" }, .F., .F. ), )
   _HB_MEMBER { oTabs} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTabs" }, .F., .F. ), )
   _HB_MEMBER { oCombobox} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oCombobox" }, .F., .F. ), )
   _HB_MEMBER { cCombobox} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cCombobox" }, .F., .F. ), )
   _HB_MEMBER { oFont} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFont" }, .F., .F. ), )
   _HB_MEMBER { oIcon} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oIcon" }, .F., .F. ), )

   _HB_MEMBER { xAlias} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "xAlias" }, .F., .F. ), )
   _HB_MEMBER { nArea} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nArea" }, .F., .F. ), )
   _HB_MEMBER { cTitle} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTitle" }, .F., .F. ), )
   _HB_MEMBER { cWinName} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cWinName" }, .F., .F. ), )
   _HB_MEMBER { cCodigoUsuario} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cCodigoUsuario" }, .F., .F. ), )

   _HB_MEMBER { aPrompt} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aPrompt" }, .F., .F. ), )
   _HB_MEMBER { aFastKey} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aFastKey" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aFlds} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aFlds" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aHeaders} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aHeaders" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aColSizes} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aColSizes" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aColSelect} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aColSelect" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aColPos} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aColPos" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aJustify} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aJustify" }, .F., .F. ), )
   _HB_MEMBER { nLevel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nLevel" }, .F., .F. ), )
   _HB_MEMBER { lCenter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lCenter" }, .F., .F. ), )
   _HB_MEMBER { nSizeBtn} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nSizeBtn" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aKey} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aKey" }, .F., .F. ), )
   _HB_MEMBER { oTxtSea} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTxtSea" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aLstSea} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aLstSea" }, .F., .F. ), )
   _HB_MEMBER { dbfUsr} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "dbfUsr" }, .F., .F. ), )
   _HB_MEMBER { dbfCol} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "dbfCol" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nRec} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 0, nScope + IIF( .F., 32, 0 ), { "nRec" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nTab} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 1, nScope + IIF( .F., 32, 0 ), { "nTab" }, .F., .F. ), )
   _HB_MEMBER { cCfg} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cCfg" }, .F., .F. ), )
   _HB_MEMBER { lMin} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lMin" }, .F., .F. ), )
   _HB_MEMBER { lZoom} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lZoom" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lNoSave} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lNoSave" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aOriginal} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aOriginal" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lBmpMenu} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lBmpMenu" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lAutoSeek} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lAutoSeek" }, .F., .F. ), )
   _HB_MEMBER { bExpFilter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bExpFilter" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aRecFilter} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY",, nScope + IIF( .F., 32, 0 ), { "aRecFilter" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lBigStyle} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lBigStyle" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lDrag} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC",, nScope + IIF( .F., 32, 0 ), { "lDrag" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lAutoPos} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .T., nScope + IIF( .F., 32, 0 ), { "lAutoPos" }, .F., .F. ), )
   _HB_MEMBER { nFlds} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nFlds" }, .F., .F. ), )
   _HB_MEMBER { cHtmlHelp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cHtmlHelp" }, .F., .F. ), )
   _HB_MEMBER { aGoTo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aGoTo" }, .F., .F. ), )

   _HB_MEMBER { bAdd} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bAdd" }, .F., .F. ), )
   _HB_MEMBER { bEdit} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bEdit" }, .F., .F. ), )
   _HB_MEMBER { bDel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bDel" }, .F., .F. ), )
   _HB_MEMBER { bDup} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bDup" }, .F., .F. ), )
   _HB_MEMBER { bZoo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bZoo" }, .F., .F. ), )

   _HB_MEMBER {AS LOGIC lTactil} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lTactil" }, .F., .F. ), )

   _HB_MEMBER { oActiveFilter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oActiveFilter" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lActiveFilter} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lActiveFilter" }, .F., .F. ), )

   _HB_MEMBER {AS LOGIC lChanged} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lChanged" }, .F., .F. ), )

   _HB_MEMBER { bDestroy} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bDestroy" }, .F., .F. ), )

   _HB_MEMBER { oImageList} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oImageList" }, .F., .F. ), )
   _HB_MEMBER { oVerticalSplitter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oVerticalSplitter" }, .F., .F. ), )
   _HB_MEMBER { oHorizontalSplitter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oHorizontalSplitter" }, .F., .F. ), )

   _HB_MEMBER {AS LOGIC lOnProcess} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lOnProcess" }, .F., .F. ), )

   _HB_MEMBER {AS LOGIC lOpenData} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .T., nScope + IIF( .F., 32, 0 ), { "lOpenData" }, .F., .F. ), )

   _HB_MEMBER {AS LOGIC lFechado} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lFechado" }, .F., .F. ), )

   _HB_MEMBER { oFilter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFilter" }, .F., .F. ), )

   _HB_MEMBER { bToolTip} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bToolTip" }, .F., .F. ), )
   _HB_MEMBER { oToolTip} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oToolTip" }, .F., .F. ), )
   _HB_MEMBER { oTimer} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTimer" }, .F., .F. ), )

   _HB_MEMBER { bChgIndex} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bChgIndex" }, .F., .F. ), )

   _HB_MEMBER { bFilter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bFilter" }, .F., .F. ), )

   _HB_MEMBER {AS NUMERIC nToolTip} ; IIF( !.F., s_oClass:AddMultiClsData("NUMERIC", 900, nScope + IIF( .F., 32, 0 ) + 64, { "nToolTip" }, .F. ), )




   _HB_MEMBER New( nTop, nLeft, nBottom, nRight, cTitle, oMenu, oWnd, oIcon, oCursor, lPixel, nHelpId, aFlds, xAlias, aHeaders, aColSizes, aColSelect, aJustify, aPrompt, bAdd, bEdit, bDel, bDup, nSizeBtn, nLevel, cMru, cInifile) AS CLASS TShell; IIF( .F., s_oClass:ModMethod( "New", @TShell_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TShell_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Create(); IIF( .F., s_oClass:ModInline( "Create", {|Self | Self, ( Self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Create", {|Self | Self, ( Self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )




   _HB_MEMBER Activate( cShow, bLClicked, bRClicked, bMoved, bResized, bPainted, bKeyDown, bInit, bUp, bDown, bPgUp, bPgDn, bLeft, bRight, bPgLeft, bPgRight, bValid, bDropFiles, bLButtonUp); IIF( .F., s_oClass:ModMethod( "Activate", @TShell_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Activate", @TShell_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CreateXBrowse(); IIF( .F., s_oClass:ModMethod( "CreateXBrowse", @TShell_CreateXBrowse(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateXBrowse", @TShell_CreateXBrowse(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CreateXFromCode(); IIF( .F., s_oClass:ModMethod( "CreateXFromCode", @TShell_CreateXFromCode(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateXFromCode", @TShell_CreateXFromCode(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER AddXCol(); IIF( .F., s_oClass:ModInline( "AddXCol", {|Self | Self, ( ::oBrw:AddCol() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AddXCol", {|Self | Self, ( ::oBrw:AddCol() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

    _HB_MEMBER GotFocus(); IIF( .F., s_oClass:ModMethod( "GotFocus", @TShell_GotFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GotFocus", @TShell_GotFocus(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER KeyChar( nKey, nFlags); IIF( .F., s_oClass:ModMethod( "KeyChar", @TShell_KeyChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyChar", @TShell_KeyChar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER KeySearch( nKey, nFlags, oWndBar); IIF( .F., s_oClass:ModMethod( "KeySearch", @TShell_KeySearch(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeySearch", @TShell_KeySearch(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER RecAdd(); IIF( .F., s_oClass:ModMethod( "RecAdd", @TShell_RecAdd(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RecAdd", @TShell_RecAdd(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RecEdit(); IIF( .F., s_oClass:ModMethod( "RecEdit", @TShell_RecEdit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RecEdit", @TShell_RecEdit(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RecDup(); IIF( .F., s_oClass:ModMethod( "RecDup", @TShell_RecDup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RecDup", @TShell_RecDup(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RecZoom(); IIF( .F., s_oClass:ModMethod( "RecZoom", @TShell_RecZoom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RecZoom", @TShell_RecZoom(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER RecDel(); IIF( .F., s_oClass:ModMethod( "RecDel", @TShell_RecDel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RecDel", @TShell_RecDel(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER CtrlKey( nKey); IIF( .F., s_oClass:ModMethod( "CtrlKey", @TShell_CtrlKey(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CtrlKey", @TShell_CtrlKey(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER KeyDown( nKey, nFlags); IIF( .F., s_oClass:ModMethod( "KeyDown", @TShell_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "KeyDown", @TShell_KeyDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER NewAt( cResName1, cResName2, cBmpFile1, cBmpFile2, cMsg, bAction, lGroup, lAdjust, bWhen, cToolTip, lPressed, bDrop, cAction, cPrompt, oFont, lNoBorder, bMenu, cKey, lMru, lSeaMru, lOpened); IIF( .F., s_oClass:ModMethod( "NewAt", @TShell_NewAt(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "NewAt", @TShell_NewAt(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

    _HB_MEMBER Search(); IIF( .F., s_oClass:ModMethod( "Search", @TShell_Search(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Search", @TShell_Search(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AddSearch(); IIF( .F., s_oClass:ModMethod( "AddSearch", @TShell_AddSearch(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddSearch", @TShell_AddSearch(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ChangeSeek( oIndice); IIF( .F., s_oClass:ModMethod( "ChangeSeek", @TShell_ChangeSeek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ChangeSeek", @TShell_ChangeSeek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ChgIndex( oGet, oIndice); IIF( .F., s_oClass:ModMethod( "ChgIndex", @TShell_ChgIndex(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ChgIndex", @TShell_ChgIndex(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER FastSeek( oGet, cText); IIF( .F., s_oClass:ModMethod( "FastSeek", @TShell_FastSeek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FastSeek", @TShell_FastSeek(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lCloseArea(); IIF( .F., s_oClass:ModInline( "lCloseArea", {|Self | Self, ( .T. ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lCloseArea", {|Self | Self, ( .T. ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Refresh(); IIF( .F., s_oClass:ModInline( "Refresh", {|Self | Self, ( if( !Empty( ::oBtnMain ), ::oBtnBar:Select( ::oBtnMain ), ), if( !Empty( ::oBrw ) .AND. ( ::oBrw:lActive ), ::oBrw:Refresh(), ), if( !Empty( ::oBtnTop ), ::oBtnTop:Refresh(), ), ::TMdiChild:Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Refresh", {|Self | Self, ( if( !Empty( ::oBtnMain ), ::oBtnBar:Select( ::oBtnMain ), ), if( !Empty( ::oBrw ) .AND. ( ::oBrw:lActive ), ::oBrw:Refresh(), ), if( !Empty( ::oBtnTop ), ::oBtnTop:Refresh(), ), ::TMdiChild:Refresh() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER UpStable(); IIF( .F., s_oClass:ModInline( "UpStable", {|Self | Self, ( if( !Empty( ::oBtnMain ), ::oBtnBar:Select( ::oBtnMain ), ), if( !Empty( ::oBrw ) .AND. ( ::oBrw:lActive ), ::oBrw:Refresh(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "UpStable", {|Self | Self, ( if( !Empty( ::oBtnMain ), ::oBtnBar:Select( ::oBtnMain ), ), if( !Empty( ::oBrw ) .AND. ( ::oBrw:lActive ), ::oBrw:Refresh(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER GoUp(); IIF( .F., s_oClass:ModInline( "GoUp", {|Self | Self, ( ::oBrw:GoUp() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GoUp", {|Self | Self, ( ::oBrw:GoUp() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER GoDown(); IIF( .F., s_oClass:ModInline( "GoDown", {|Self | Self, ( ::oBrw:GoDown() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "GoDown", {|Self | Self, ( ::oBrw:GoDown() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Select(); IIF( .F., s_oClass:ModInline( "Select", {|Self | Self, ( if( !Empty( ::oBrw ) .AND. ( ::oBrw:lActive ), ( ::oBrw:Refresh(), ::oBrw:Select() ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Select", {|Self | Self, ( if( !Empty( ::oBrw ) .AND. ( ::oBrw:lActive ), ( ::oBrw:Refresh(), ::oBrw:Select() ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetFocus(); IIF( .F., s_oClass:ModInline( "SetFocus", {|Self | Self, ( if( !Empty( ::oBtnMain ), ::oBtnBar:Select( ::oBtnMain ), ), if( !Empty( ::oBrw ), ( ::oBrw:SetFocus(), ::oBrw:Select( 0 ), ::oBrw:Select( 1 ) ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetFocus", {|Self | Self, ( if( !Empty( ::oBtnMain ), ::oBtnBar:Select( ::oBtnMain ), ), if( !Empty( ::oBrw ), ( ::oBrw:SetFocus(), ::oBrw:Select( 0 ), ::oBrw:Select( 1 ) ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetIndex( nIndex); IIF( .F., s_oClass:ModMethod( "SetIndex", @TShell_SetIndex(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetIndex", @TShell_SetIndex(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER RButtonDown( nRow, nCol, nFlags); IIF( .F., s_oClass:ModMethod( "RButtonDown", @TShell_RButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RButtonDown", @TShell_RButtonDown(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AddMru(); IIF( .F., s_oClass:ModMethod( "AddMru", @TShell_AddMru(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddMru", @TShell_AddMru(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SaveOriginal(); IIF( .F., s_oClass:ModMethod( "SaveOriginal", @TShell_SaveOriginal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SaveOriginal", @TShell_SaveOriginal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER PutOriginal(); IIF( .F., s_oClass:ModMethod( "PutOriginal", @TShell_PutOriginal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PutOriginal", @TShell_PutOriginal(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetColumn(); IIF( .F., s_oClass:ModMethod( "SetColumn", @TShell_SetColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetColumn", @TShell_SetColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   _HB_MEMBER ActColSizes(); IIF( .F., s_oClass:ModMethod( "ActColSizes", @TShell_ActColSizes(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ActColSizes", @TShell_ActColSizes(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER UpColumn( nPos); IIF( .F., s_oClass:ModMethod( "UpColumn", @TShell_UpColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "UpColumn", @TShell_UpColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DwColumn( nPos); IIF( .F., s_oClass:ModMethod( "DwColumn", @TShell_DwColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DwColumn", @TShell_DwColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AutoButtons( oParent); IIF( .F., s_oClass:ModMethod( "AutoButtons", @TShell_AutoButtons(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AutoButtons", @TShell_AutoButtons(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER GralButtons( oParent); IIF( .F., s_oClass:ModMethod( "GralButtons", @TShell_GralButtons(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GralButtons", @TShell_GralButtons(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER EndButtons( oParent); IIF( .F., s_oClass:ModMethod( "EndButtons", @TShell_EndButtons(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "EndButtons", @TShell_EndButtons(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER End(); IIF( .F., s_oClass:ModMethod( "End", @TShell_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @TShell_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Destroy(); IIF( .F., s_oClass:ModMethod( "Destroy", @TShell_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Destroy", @TShell_Destroy(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Maximize(); IIF( .F., s_oClass:ModMethod( "Maximize", @TShell_Maximize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Maximize", @TShell_Maximize(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SysCommand( nWParam, nLParam); IIF( .F., s_oClass:ModMethod( "SysCommand", @TShell_SysCommand(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SysCommand", @TShell_SysCommand(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Display(); IIF( .F., s_oClass:ModInline( "Display", {|Self | Self, ::BeginPaint(), ::Paint(), ::EndPaint() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Display", {|Self | Self, ::BeginPaint(), ::Paint(), ::EndPaint() }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER ChgTabs(); IIF( .F., s_oClass:ModMethod( "ChgTabs", @TShell_ChgTabs(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ChgTabs", @TShell_ChgTabs(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ChgCombo( nTab); IIF( .F., s_oClass:ModMethod( "ChgCombo", @TShell_ChgCombo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ChgCombo", @TShell_ChgCombo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ChgFilter( nTab); IIF( .F., s_oClass:ModMethod( "ChgFilter", @TShell_ChgFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ChgFilter", @TShell_ChgFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AddSeaBar(); IIF( .F., s_oClass:ModMethod( "AddSeaBar", @TShell_AddSeaBar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddSeaBar", @TShell_AddSeaBar(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER NextTabOption(); IIF( .F., s_oClass:ModMethod( "NextTabOption", @TShell_NextTabOption(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "NextTabOption", @TShell_NextTabOption(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER PrevTabOption(); IIF( .F., s_oClass:ModMethod( "PrevTabOption", @TShell_PrevTabOption(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PrevTabOption", @TShell_PrevTabOption(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lPressCol(); IIF( .F., s_oClass:ModMethod( "lPressCol", @TShell_lPressCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lPressCol", @TShell_lPressCol(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ClickOnHeader( oCol); IIF( .F., s_oClass:ModMethod( "ClickOnHeader", @TShell_ClickOnHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ClickOnHeader", @TShell_ClickOnHeader(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER HelpTopic(); IIF( .F., s_oClass:ModMethod( "HelpTopic", @TShell_HelpTopic(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "HelpTopic", @TShell_HelpTopic(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AddGoTo( cCaption, bAction); IIF( .F., s_oClass:ModMethod( "AddGoTo", @TShell_AddGoTo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddGoTo", @TShell_AddGoTo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SearchSetFocus(); IIF( .F., s_oClass:ModInline( "SearchSetFocus", {|Self | Self, ( if( !Empty( ::oWndBar ), ::oWndBar:SetGetFocus(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SearchSetFocus", {|Self | Self, ( if( !Empty( ::oWndBar ), ::oWndBar:SetGetFocus(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER SetYearComboBoxChange(bBlock); IIF( .F., s_oClass:ModInline( "SetYearComboBoxChange", {|Self,bBlock | Self, ( if( !Empty( ::oWndBar ), ::oWndBar:SetYearComboBoxChange( bBlock ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetYearComboBoxChange", {|Self,bBlock | Self, ( if( !Empty( ::oWndBar ), ::oWndBar:SetYearComboBoxChange( bBlock ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetKillFilter(bBlock); IIF( .F., s_oClass:ModInline( "SetKillFilter", {|Self,bBlock | Self, ( if( !Empty( ::oWndBar ), ::oWndBar:SetKillFilter( bBlock ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetKillFilter", {|Self,bBlock | Self, ( if( !Empty( ::oWndBar ), ::oWndBar:SetKillFilter( bBlock ), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER AddImageList( cImage); IIF( .F., s_oClass:ModMethod( "AddImageList", @TShell_AddImageList(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AddImageList", @TShell_AddImageList(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ClickTree(); IIF( .F., s_oClass:ModMethod( "ClickTree", @TShell_ClickTree(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ClickTree", @TShell_ClickTree(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER BarDisable(); IIF( .F., s_oClass:ModInline( "BarDisable", {|Self | Self, ( if( !Empty( ::oWndBar ), ::oWndBar:Disable(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "BarDisable", {|Self | Self, ( if( !Empty( ::oWndBar ), ::oWndBar:Disable(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER BarEnable(); IIF( .F., s_oClass:ModInline( "BarEnable", {|Self | Self, ( if( !Empty( ::oWndBar ), ::oWndBar:Enable(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "BarEnable", {|Self | Self, ( if( !Empty( ::oWndBar ), ::oWndBar:Enable(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER BrwDisable(); IIF( .F., s_oClass:ModInline( "BrwDisable", {|Self | Self, ( if( !Empty( ::oBrw ), ::oBrw:Disable(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "BrwDisable", {|Self | Self, ( if( !Empty( ::oBrw ), ::oBrw:Disable(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER BrwEnable(); IIF( .F., s_oClass:ModInline( "BrwEnable", {|Self | Self, ( if( !Empty( ::oBrw ), ::oBrw:Enable(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "BrwEnable", {|Self | Self, ( if( !Empty( ::oBrw ), ::oBrw:Enable(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER SetOnProcess(); IIF( .F., s_oClass:ModInline( "SetOnProcess", {|Self | Self, ( ::BrwDisable(), ::BarDisable(), ::lOnProcess := .T., ::CheckExtendInfo() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetOnProcess", {|Self | Self, ( ::BrwDisable(), ::BarDisable(), ::lOnProcess := .T., ::CheckExtendInfo() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER KillProcess(); IIF( .F., s_oClass:ModInline( "KillProcess", {|Self | Self, ( ::lOnProcess := .F., ::BarEnable(), ::BrwEnable() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "KillProcess", {|Self | Self, ( ::lOnProcess := .F., ::BarEnable(), ::BrwEnable() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER QuitOnProcess(); IIF( .F., s_oClass:ModInline( "QuitOnProcess", {|Self | Self, ( ::lOnProcess := .F., ::BarEnable(), ::BrwEnable() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "QuitOnProcess", {|Self | Self, ( ::lOnProcess := .F., ::BarEnable(), ::BrwEnable() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER ShowButtonFilter(); IIF( .F., s_oClass:ModInline( "ShowButtonFilter", {|Self | Self, ( ::lActiveFilter := .T., ::oWndBar:ShowButtonFilter() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ShowButtonFilter", {|Self | Self, ( ::lActiveFilter := .T., ::oWndBar:ShowButtonFilter() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER HideButtonFilter(); IIF( .F., s_oClass:ModInline( "HideButtonFilter", {|Self | Self, ( ::lActiveFilter := .F., ::oWndBar:HideButtonFilter() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "HideButtonFilter", {|Self | Self, ( ::lActiveFilter := .F., ::oWndBar:HideButtonFilter() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER ShowAddButtonFilter(); IIF( .F., s_oClass:ModInline( "ShowAddButtonFilter", {|Self | Self, ( ::oWndBar:ShowAddButtonFilter() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ShowAddButtonFilter", {|Self | Self, ( ::oWndBar:ShowAddButtonFilter() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER HideAddButtonFilter(); IIF( .F., s_oClass:ModInline( "HideAddButtonFilter", {|Self | Self, ( ::oWndBar:HideAddButtonFilter() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "HideAddButtonFilter", {|Self | Self, ( ::oWndBar:HideAddButtonFilter() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER ShowEditButtonFilter(); IIF( .F., s_oClass:ModInline( "ShowEditButtonFilter", {|Self | Self, ( ::oWndBar:ShowEditButtonFilter() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ShowEditButtonFilter", {|Self | Self, ( ::oWndBar:ShowEditButtonFilter() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER HideEditButtonFilter(); IIF( .F., s_oClass:ModInline( "HideEditButtonFilter", {|Self | Self, ( ::oWndBar:HideEditButtonFilter() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "HideEditButtonFilter", {|Self | Self, ( ::oWndBar:HideEditButtonFilter() ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER KillFilter(); IIF( .F., s_oClass:ModInline( "KillFilter", {|Self | Self, ( if( ::lActiveFilter .AND. !Empty( ::oActiveFilter ), ::oActiveFilter:KillFilter(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "KillFilter", {|Self | Self, ( if( ::lActiveFilter .AND. !Empty( ::oActiveFilter ), ::oActiveFilter:KillFilter(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER AddFilter(); IIF( .F., s_oClass:ModInline( "AddFilter", {|Self | Self, ( if( !Empty( ::oActiveFilter ), ::oActiveFilter:AddFilter(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AddFilter", {|Self | Self, ( if( !Empty( ::oActiveFilter ), ::oActiveFilter:AddFilter(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER EditFilter(); IIF( .F., s_oClass:ModInline( "EditFilter", {|Self | Self, ( if( !Empty( ::oActiveFilter ), ::oActiveFilter:EditFilter(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "EditFilter", {|Self | Self, ( if( !Empty( ::oActiveFilter ), ::oActiveFilter:EditFilter(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER CreateData(); IIF( .F., s_oClass:ModMethod( "CreateData", @TShell_CreateData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateData", @TShell_CreateData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER OpenData(); IIF( .F., s_oClass:ModMethod( "OpenData", @TShell_OpenData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "OpenData", @TShell_OpenData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CleanData(); IIF( .F., s_oClass:ModMethod( "CleanData", @TShell_CleanData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CleanData", @TShell_CleanData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DeleteData(); IIF( .F., s_oClass:ModMethod( "DeleteData", @TShell_DeleteData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DeleteData", @TShell_DeleteData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CloseData(); IIF( .F., s_oClass:ModMethod( "CloseData", @TShell_CloseData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CloseData", @TShell_CloseData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ReindexData(); IIF( .F., s_oClass:ModMethod( "ReindexData", @TShell_ReindexData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReindexData", @TShell_ReindexData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER LoadData(); IIF( .F., s_oClass:ModMethod( "LoadData", @TShell_LoadData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LoadData", @TShell_LoadData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SaveData(); IIF( .F., s_oClass:ModMethod( "SaveData", @TShell_SaveData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SaveData", @TShell_SaveData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AppendData( cPath, cPathFrom); IIF( .F., s_oClass:ModMethod( "AppendData", @TShell_AppendData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AppendData", @TShell_AppendData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DefControl( ); IIF( !.F., s_oClass:AddVirtual( "DefControl" ), )

   _HB_MEMBER CheckExtendInfo(); IIF( .F., s_oClass:ModMethod( "CheckExtendInfo", @TShell_CheckExtendInfo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CheckExtendInfo", @TShell_CheckExtendInfo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER ShowExtendInfo( nRow, nCol, cToolTip); IIF( .F., s_oClass:ModMethod( "ShowExtendInfo", @TShell_ShowExtendInfo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ShowExtendInfo", @TShell_ShowExtendInfo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER DestroyToolTip(); IIF( .F., s_oClass:ModMethod( "DestroyToolTip", @TShell_DestroyToolTip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DestroyToolTip", @TShell_DestroyToolTip(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER FastFilter(); IIF( .F., s_oClass:ModMethod( "FastFilter", @TShell_FastFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FastFilter", @TShell_FastFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetAutoFilter(); IIF( .F., s_oClass:ModMethod( "SetAutoFilter", @TShell_SetAutoFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetAutoFilter", @TShell_SetAutoFilter(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AplyFilter(); IIF( .F., s_oClass:ModInline( "AplyFilter", {|Self | Self, ( if( !Empty( ::oActiveFilter ), ::oActiveFilter:AplyFilter(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "AplyFilter", {|Self | Self, ( if( !Empty( ::oActiveFilter ), ::oActiveFilter:AplyFilter(), ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER ChangeFilter(cFilter); IIF( .F., s_oClass:ModInline( "ChangeFilter", {|Self,cFilter | Self, ( msgAlert( cFilter ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ChangeFilter", {|Self,cFilter | Self, ( msgAlert( cFilter ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER EnableComboFilter(aFilter); IIF( .F., s_oClass:ModInline( "EnableComboFilter", {|Self,aFilter | Self, ( ::oWndBar:EnableComboFilter( ::oActiveFilter:aFilter ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "EnableComboFilter", {|Self,aFilter | Self, ( ::oWndBar:EnableComboFilter( ::oActiveFilter:aFilter ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER SetDefaultComboFilter(aFilter); IIF( .F., s_oClass:ModInline( "SetDefaultComboFilter", {|Self,aFilter | Self, ( ::oWndBar:SetDefaultComboFilter( ::oActiveFilter:aFilter ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetDefaultComboFilter", {|Self,aFilter | Self, ( ::oWndBar:SetDefaultComboFilter( ::oActiveFilter:aFilter ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )
   _HB_MEMBER SetComboFilter(cItem); IIF( .F., s_oClass:ModInline( "SetComboFilter", {|Self,cItem | Self, ( ::oWndBar:SetComboFilter( cItem ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SetComboFilter", {|Self,cItem | Self, ( ::oWndBar:SetComboFilter( cItem ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TShell ;






UTILITY STATIC function TShell_New( nTop, nLeft, nBottom, nRight, cTitle, oMenu, oWnd, oIcon, oCursor, lPixel, nHelpId, aFlds, xAlias, aHeaders, aColSizes, aColSelect, aJustify, aPrompt, bAdd, bEdit, bDel, bDup, nSizeBtn, nLevel, cMru, cBitmap, lBigStyle, bZoo, lXBrowse) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local n
   local nPos
   local aRect

   IIF( nTop == nil, nTop := 0, ) ;
   IIF( nLeft == nil, nLeft := 0, ) ;
   IIF( nBottom == nil, nBottom := 22, ) ;
   IIF( nRight == nil, nRight := 80, ) ;
   IIF( cTitle == nil, cTitle := "MDI Child", ) ;
   IIF( oWnd == nil, oWnd := GetWndFrame(), ) ;
   IIF( lPixel == nil, lPixel := .F., ) ;
   IIF( oIcon == nil, oIcon := TIcon():New( ,, "BROWSE",, ), ) ;
   IIF( oCursor == nil, oCursor := TCursor():New( , "ARROW" ), ) ;
   IIF( aPrompt == nil, aPrompt := { "General" }, ) ;
   IIF( nSizeBtn == nil, nSizeBtn := 42, ) ;
   IIF( nLevel == nil, nLevel := nOr( 2, 4, 8, 16, 32 ), ) ;
   IIF( aFlds == nil, aFlds := {}, ) ;
   IIF( aHeaders == nil, aHeaders := {}, ) ;
   IIF( aColSizes == nil, aColSizes := {}, ) ;
   IIF( aColSelect == nil, aColSelect := {}, ) ;
   IIF( aJustify == nil, aJustify := {}, ) ;
   IIF( cBitmap == nil, cBitmap := ( 0 + ( 0 * 256 ) + ( 0 * 65536 ) ), ) ;
   IIF( lBigStyle == nil, lBigStyle := .F., ) ;

   ::oWndBar         := oWndBar()

   ::BarDisable()



   aRect             := GetWndRect( GetDeskTopWindow() )
   if aRect[4] >= 800
      nBottom        += 6
      nRight         += 20
   endif

   ::nTop            := nTop
   ::nLeft           := nLeft
   ::nBottom         := nBottom
   ::nRight          := nRight
   ::cTitle          := cTitle
    ::aFastKey            := {}
   ::aPrompt         := aPrompt
   ::oIcon           := oIcon
   ::nSizeBtn        := nSizeBtn
   ::aKey            := {}
   ::aFlds           := aFlds
   ::aHeaders        := aHeaders
   ::aColSizes       := aColSizes
   ::aColSelect      := aColSelect
   ::aJustify        := aJustify
   ::lBigStyle       := lBigStyle
   ::xAlias          := xAlias

   ::bAdd            := bAdd
   ::bEdit           := bEdit
   ::bDel            := bDel
   ::bDup            := bDup
   ::bZoo            := bZoo



   ::oFont           := oFontLittelTitle()



   ::nTop            := nTop    * if( !lPixel, 16, 1 )
   ::nLeft           := nLeft   * if( !lPixel, 8, 1 )
   ::nBottom         := nBottom * if( !lPixel, 16, 1 )
   ::nRight          := nRight  * if( !lPixel, 8, 1 )



   ::lAutoSeek       := .F.



   ::oActiveFilter   := TDlgFlt():Init( Self )






   ::TMdiChild:New( 0, 0, 0, 0, cTitle, 0, oMenu, oWnd, oIcon, , , , oCursor, , .T., , nHelpId, "NONE", .F., .F., .F., .F. )



   if ::lBigStyle
      ::oImageList      := TImageList():New( 32, 32 )
   else
      ::oImageList      := TImageList():New( 16, 16 )
   end









   if IsNum( cBitmap )
   ::oBtnTop            := TWebBar():New( 0, 0, 400, 44,,,, ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ), ( cBitmap ),,,,,, Self )
   else
   ::oBtnTop            := TWebBar():New( 0, 0, 400, 44,,,, ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ), ( 104 + ( 0 * 256 ) + ( 63 * 65536 ) ),,,,,, Self )
   end

   ::oBtnTop:Say( -14, 200, ::cTitle )

   ::oBtnBar            := TTreeView():New( 44, 0, Self, , , .T., .F., 200, 400 )

   ::oBtnBar:SetItemHeight( 20 )

   ::oBtnBar:OnClick    := {|| ::ClickTree() }

   if !::lBigStyle
      ::oBtnMain        := ::oBtnBar:Add( ::cTitle, ::AddImageList( cMru ) )
   end



   if At( ":", ::cTitle ) <> 0
      ::cWinName        := Padr( SubStr( ::cTitle, 1, At( ":", ::cTitle ) ), 30 )
   else
      ::cWinName        := Padr( Rtrim( ::cTitle ), 30 )
   end



   ::cCodigoUsuario     := cCurUsr()



   ::nLevel             := nLevel



   if !::CreateXBrowse()
      Return .F.
   end

   ::oHorizontalSplitter         := TSplitter():New( 44 , 0, .F., { ::oBtnTop }, .T., { ::oBtnBar, ::oBrw }, .T., {|| 0}, {|| 0}, Self, , 800, 0, .T., .T., ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ), .F., .F., .F. )
   ::oHorizontalSplitter:lStatic := .T.

   ::oVerticalSplitter           := TSplitter():New( 44 + 0, 200, .T., { ::oBtnBar }, .T., { ::oBrw }, .T., {|| 0}, {|| 0}, Self, , 0, 800, .T., .F., , .F., .T., .T. )

RETURN Self






UTILITY STATIC function TShell_Activate( cShow, bLClicked, bRClicked, bMoved, bResized, bPainted, bKeyDown, bInit, bUp, bDown, bPgUp, bPgDn, bLeft, bRight, bPgLeft, bPgRight, bValid, bDropFiles, bLButtonUp, lCenter) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local oError
   local oBlock

   IIF( lCenter == nil, lCenter := ( ::nTop == 0 .AND. ::nLeft == 0 ), ) ;

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   CursorWait()

   if Empty( bValid )
      bValid         := {|| ::oBrw:Hide() }
   end

   ::lCenter         := lCenter



   ::TMdiChild:Activate(   cShow, bLClicked, bRClicked, bMoved, bResized, bPainted, bKeyDown, bInit, bUp, bDown, bPgUp, bPgDn, bLeft, bRight, bPgLeft, bPgRight, bValid, bDropFiles, bLButtonUp )

   ::Maximize()

   if !::lBigStyle
      ::oHorizontalSplitter:AdjRight()
   end

   ::oVerticalSplitter:AdjBottom()

   ::oBtnBar:SetImagelist( ::oImageList )

   ::oBtnBar:Select( ::oBtnMain )

   ::oBtnMain:Expand()

   if !Empty( ::nTab ) .AND. ::nTab <> 0
      ::ChgCombo( ::nTab )
   end



   do case
      case IsObject( ::xAlias ) .AND. ::xAlias:Used()

         if !Empty( ::oBrw )
            aEval( ::oBrw:aCols, {|oCol| if( oCol:cSortOrder == ::xAlias:OrdSetFocus(), ( oCol:SetOrder(), oCol:Adjust() ), ) } )
         end

      case  IsChar( ::xAlias ) .AND. ( ::xAlias )->( Used() )

         if !Empty( ::oBrw )
            aEval( ::oBrw:aCols, {|oCol| if( oCol:cSortOrder == ( ::xAlias )->( OrdSetFocus() ), ( oCol:SetOrder(), oCol:Adjust() ), ) } )
         end

   end



   ::oActiveFilter:Load()



   if !Empty( ::oWndBar )

      ::oWndBar:EnableComboBox(  ::aPrompt )

      ::EnableComboFilter(       ::oActiveFilter:aFilter )

      ::SetDefaultComboFilter(   ::oActiveFilter:aFilter )

      ::ShowAddButtonFilter()

      ::oWndBar:EnableGet()

      if ::lFechado
         ::oWndBar:ShowYearCombobox()
      end

   end

   CursorWE()

   RECOVER USING oError

      msgStop( "Error al iniciar al abrir las bases de datos" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

      ::End()

   end

   ErrorBlock( oBlock )

   ::BarEnable()

RETURN NIL



UTILITY STATIC function TShell_GotFocus() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

    ::TMdiChild:GotFocus()

   if ::oBrw <> nil
        ::oBrw:SetFocus()
   end

return 0



UTILITY STATIC function TShell_KeyChar( nKey, nFlags) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   do case
   case nKey == 27 .AND. ::oWnd <> nil
      if ::oTxtSea <> nil .AND. GetFocus() == ::oTxtSea:hWnd
         ::oBrw:SetFocus()
      else
         ::End()
      end
      return 0
   case nKey == 13 .AND. ::oWnd <> nil
      ::RecEdit()
   case nKey == 45 .AND. ::oWnd <> nil
      ::RecAdd()
   case nKey == 46 .AND. ::oWnd <> nil
      ::RecDel()
   case nKey == 116
      ::Refresh()
   case nKey == 120
      ::PutOriginal()
   case nKey == 120
      ::oBrw:Refresh()
   end

return ::TMdiChild:KeyChar( nKey, nFlags )



UTILITY STATIC function TShell_KeySearch( nKey, nFlags, oWndBar) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if ( nKey == 27 .OR. nKey == 13 )
      ::BrwEnable()
      ::GotFocus()
      Return ( 0 )
   end

Return ( 1 )



UTILITY STATIC function TShell_NewAt( cResName1, cResName2, cMsg, bAction, cToolTip, cKey, cPrompt, bMenu, nLevel, oGroup, lAllowExit) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local oBtn

   IIF( cMsg == nil, cMsg := "", ) ;
   IIF( oGroup == nil, oGroup := nil, ) ;
   IIF( cToolTip == nil, cToolTip := "", ) ;
   IIF( lAllowExit == nil, lAllowExit := .F., ) ;



   if nLevel <> nil .AND. nAnd( ::nLevel, nLevel ) == 0
      return nil
   end

   if !Empty( cResName1 )
      if ::lBigStyle
         cResName1   += "32"
      else
         cResName1   += "16"
      end
   end

   cToolTip          := StrTran( cToolTip, "(", "" )
   cToolTip          := StrTran( cToolTip, ")", ""  )

   if Empty( oGroup )
      if ::lBigStyle
         oBtn        := ::oBtnBar:Add( cTooltip, ::AddImageList( cResName1 ), bAction )
      else
         oBtn        := ::oBtnMain:Add( cTooltip, ::AddImageList( cResName1 ), bAction )
      end
   else
      if Empty( cResName1 )
         oBtn        := oGroup:Add( cTooltip, nil, bAction )
      else
         oBtn        := oGroup:Add( cTooltip, ::AddImageList( cResName1 ), bAction )
      end
   end

   oBtn:Cargo        := lAllowExit

   if cKey <> nil

      if Valtype( cKey ) == "C"
         cKey        := Upper( cKey )
      end

      aAdd( ::aFastKey, { cKey, bAction } )

   end

return oBtn



UTILITY STATIC function TShell_CtrlKey( nKey) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local nLen
   local nCont

   if !::lOnProcess

      nLen        := len( ::aFastKey )

      for nCont   := 1 to nLen


         if ( IsChar( ::aFastKey[ nCont, 1 ] ) .AND. ( nKey == Asc( Upper( ::aFastKey[ nCont, 1 ] ) ) .OR. nKey == Asc( Lower( ::aFastKey[ nCont, 1 ] ) ) ) ) .OR.  ( IsNum( ::aFastKey[ nCont, 1 ] ) .AND. nKey == ::aFastKey[ nCont, 1 ] )

            if ( nCont <> 1 ) .AND. ( nCont <> nLen )
               ::SetOnProcess()
            end

            Eval( ::aFastKey[ nCont, 2 ] )

            SysRefresh()

            ::QuitOnProcess()







         end

      next





      if nKey == 43
         ::NextTabOption()
      end

      if nKey == 45
         ::PrevTabOption()
      end

      if nKey == 27
         ::End()
      end

   end

return ( 0 )



UTILITY STATIC function TShell_KeyDown( nKey, nFlags) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if ::lOnProcess
      Return 0
   end

   do case
      case nKey == 27
         ::End()
      case nKey == 13 .AND. ::oWnd <> nil
         ::RecEdit()
      case nKey == 45 .AND. ::oWnd <> nil
         ::RecAdd()
      case nKey == 46 .AND. ::oWnd <> nil
         ::RecDel()
      case nKey == 116
         ::Refresh()
      case nKey == 120
         ::PutOriginal()
      case nKey == 113
         ::NextTabOption()
      case nKey == 114
         ::PrevTabOption()




   end

return ::TMdiChild:KeyDown( nKey, nFlags )



UTILITY STATIC function TShell_End( lForceExit) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   IIF( lForceExit == nil, lForceExit := .F., ) ;

   if ::lOnProcess .AND. !lForceExit
      Return ( .F. )
   end

   CursorWait()

   if !Empty( ::oToolTip )
      ::oToolTip:End()
   end



   ::KillFilter()

   if ::lOpenData



      do case
         case ValType( ::xAlias ) == "O"
            ::nRec            := ::xAlias:RecNo()
         case  ValType( ::xAlias ) == "C" .AND. ( ::xAlias )->( Used() )
            ::nRec            := ( ::xAlias )->( RecNo() )
      end

      if !::lBigStyle .AND. !Empty( ::oWndBar )
         ::nTab               := ::oWndBar:GetComboBoxAt( .T. )
      end



      ::SaveData( .F. )

      ::CloseData()

   end



   if !::lBigStyle .AND. !Empty( ::oWndBar )

      ::oWndBar:DisableGet()

      ::oWndBar:DisableComboBox()

      ::oWndBar:DisableComboFilter()

      ::HideButtonFilter()
      ::HideAddButtonFilter()
      ::HideEditButtonFilter()

      if ::lFechado
         ::oWndBar:HideYearCombobox()
      end

   end



   if !Empty( ::oBrw )
      ::oBrw:End()
      ::oBrw   := nil
   end



   if ::bValid <> nil
      if !Eval( ::bValid )
         Return .F.
      end
   end

   ::oWndClient:ChildClose( Self )

   ::TMdiChild:End()

   CursorWE()

Return ( .T. )



UTILITY STATIC function TShell_Search() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

    local oDlg
   local oIndice
   local cIndice
   local oAutoSeek
   local oThis    := Self
   local xCadena  := Space( 100 )

   if len( ::aPrompt ) == 0
      msgAlert( "No hay indices definidos" )
      return nil
   end

   do case
   case ValType( ::xAlias ) == "O"
      cIndice     := ::aPrompt[ ::xAlias:OrdNumber() ]
   case ValType( ::xAlias ) == "C" .AND. ( ::xAlias )->( Used() )
      cIndice     := ::aPrompt[ ( ::xAlias )->( OrdNumber() ) ]
   end

   oDlg = TDialog():New(,,,,, "SEARCH",, .F.,,,,,, .F.,,,,,, .F., )





   ::oTxtSea := TComboBox():ReDefine( 100, { | u | If( PCount()==0, xCadena, xCadena:= u ) }, ::aLstSea, oDlg,,,,,,, .F.,,,, 2,, )

      ::oTxtSea:bValid        := {|| ::AddSearch() }
      ::oTxtSea:bChange       := {|| ::ChangeSeek( oIndice ) }

      ::oTxtSea:oGet:bChange  := {| nKey, nFlags | ::FastSeek( nKey, nFlags, ::oTxtSea ) }




   oIndice := TComboBox():ReDefine( 101, { | u | If( PCount()==0, cIndice, cIndice:= u ) }, ::aPrompt, oDlg,,,,,,, .F.,,,,,, )

      oIndice:bChange         := {|| ::ChgIndex( oIndice ) }




   oAutoSeek := TCheckBox():ReDefine( 102, { | u | If( PCount()==0, ::lAutoSeek, ::lAutoSeek:= u ) }, oDlg,,,,,,, .F.,, .F. )



   TButton():ReDefine( 510, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T., {|Self|( oThis:AddSearch() )},,, oDlg:bRClicked,,, )

RETURN NIL






UTILITY STATIC function TShell_AddSearch() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local nRec

   CursorWait()

   ::oWndBar:CleanGet()

   do case
   case IsObject( ::xAlias ) .AND. ::xAlias:Used()

      nRec  := ::xAlias:Recno()

      ::xAlias:OrdClearScope()
      ::xAlias:GoTo( nRec )

   case IsChar( ::xAlias ) .AND. ( ::xAlias )->( Used() )

      nRec  := ( ::xAlias )->( Recno() )

      ( ::xAlias )->( OrdScope( 0, nil ) )
      ( ::xAlias )->( OrdScope( 1, nil ) )
      ( ::xAlias )->( dbGoTo( nRec ) )

   end

   ::oBrw:Refresh()

   CursorWE()

RETURN .T.







UTILITY STATIC function TShell_ChgIndex( oIndice) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   do case
   case ValType( ::xAlias ) == "O"
      ::xAlias:OrdSetFocus( oIndice:nAt )
   case ValType( ::xAlias ) == "C" .AND. ( ::xAlias )->( Used() )
      ( ::xAlias )->( OrdSetFocus( oIndice:nAt ) )
   end

   if !Empty( ::oWndBar )
      ::oWndBar:SetComboBoxSelect( oIndice:nAt )
   end

   ::oComboBox:Select( oIndice:nAt )



   if !Empty( ::bChgIndex )
      Eval( ::bChgIndex )
   end

   ::oBrw:SetOrder()

   ::oTxtSea:SetFocus()
   ::oTxtSea:SelectAll()

RETURN NIL






UTILITY STATIC function TShell_ChangeSeek( oIndice) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local n
   local xCadena
   local cType
   local oGet     := ::oTxtSea:oGet
   local nOrd     := if( SubStr( oGet:varGet(), 1, 1 ) $ "0123456789", 1, 2 )

   do case
   case ValType( ::xAlias ) == "O"
      ::xAlias:OrdSetFocus( n )
      cType       := ValType( ::xAlias:OrdKey() )
   case ValType( ::xAlias ) == "C" .AND. ( ::xAlias )->( Used() )
      ( ::xAlias )->( OrdSetFocus( n ) )
      cType       := ValType( ( ::xAlias )->( OrdKey() ) )
   end

   oIndice:Set( nOrd )

   if !Empty( ::oWndBar )
      ::oWndBar:SetComboBoxSelect( nOrd )
   end

   ::oComboBox:Select( nOrd )

   if cType == "C"
      xCadena     := Rtrim( oGet:GetText() )
   elseif cType == "N"
      xCadena     := Val( Rtrim( oGet:GetText() ) )
   end

   do case
   case ValType( ::xAlias ) == "O"
      ::xAlias:Seek( xCadena )
   case ValType( ::xAlias ) == "C" .AND. ( ::xAlias )->( Used() )
      ( ::xAlias )->( dbSeek( xCadena ) )
   end

   ::oBrw:Refresh()

RETURN .T.






UTILITY STATIC function TShell_FastSeek( oGet, xCadena) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local nRec
   local cOrd
   local oCol
   local lSeek
   local cAlias

   do case
      case IsObject( ::xAlias )
         cAlias      := ::xAlias:cAlias
      case IsChar( ::xAlias )
         cAlias      := ::xAlias
   end

   if Empty( cAlias ) .OR. !( cAlias )->( Used() )
      Return .F.
   end





   xCadena           := Alltrim( Upper( cValToChar( xCadena ) ) )
   xCadena           := StrTran( xCadena, Chr( 8 ), "" )

   if Empty( xCadena )
      Return .F.
   end





   nRec              := ( cAlias )->( RecNo() )
   cOrd              := ( cAlias )->( OrdSetFocus() )





   lSeek             := ::FastFilter( xCadena, cAlias )

   if !lSeek

      lSeek          := lMiniSeek( nil, xCadena, cAlias )





      if !lSeek .AND. uFieldEmpresa( "lBusCir" )

         for each oCol in ::oBrw:aCols

            if isChar( oCol:cSortOrder ) .AND. !Empty( oCol:cSortOrder )

               ( cAlias )->( OrdSetFocus( oCol:cSortOrder ) )

               lSeek := lMiniSeek( nil, xCadena, cAlias )

               if lSeek
                  ::ClickOnHeader( oCol )
                  exit
               end

            end

         next

      end

   end

   if lSeek .OR. Empty( xCadena )

      oGet:SetColor( ( 0 + ( 0 * 256 ) + ( 0 * 65536 ) ), ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ) )

   else

      ( cAlias )->( OrdSetFocus( cOrd ) )
      ( cAlias )->( dbGoTo( nRec ) )

      oGet:SetColor( ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ), ( 255 + ( 102 * 256 ) + ( 102 * 65536 ) ) )

   end

   ::oBrw:Select( 0 )
   ::oBrw:Select( 1 )
   ::oBrw:Refresh()

Return ( lSeek )



UTILITY STATIC function TShell_FastFilter( xCadena, cAlias) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   DestroyFastFilter( cAlias, .F., .F. )

   CreateFastFilter( "", cAlias, .F. )

   if Left( xCadena, 1 ) == "*"

      if Right( xCadena, 1 ) == "*" .AND. len( Rtrim( xCadena ) ) > 1



         CreateFastFilter( SubStr( xCadena, 2, len( xCadena ) - 2 ), cAlias, .T. )

         ::SetKillFilter( {|| DestroyFastFilter( cAlias ), ::HideButtonFilter() } )

         ::ShowButtonFilter()
         ::ShowAddButtonFilter()
         ::ShowEditButtonFilter()

      else

         ::HideButtonFilter()
         ::HideAddButtonFilter()
         ::HideEditButtonFilter()

      end

      Return .T.

   end

Return .F.



UTILITY STATIC function TShell_RButtonDown( nRow, nCol, nFlags) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local nFor
   local nLen
   local oCol
   local oMenuItem
   local oMenu       := MenuBegin( .T. )
   local bMenuSelect := ::bMenuSelect





   ::bMenuSelect     := nil

   MenuAddItem( "Columnas", "Columnas de la rejilla de datos", .F., .T., , , "Column_16", oMenu )

   MenuBegin( .F.,,, .F. )

   for each oCol in ::oBrw:aCols
      MenuAddItem( oCol:cHeader, , !oCol:lHide, ( Len( ::oBrw:aDisplay ) <> 1 .OR. oCol:nPos <> 1 ), GenMenuBlock( oCol ) )
   next

   MenuEnd()

   MenuAddItem( "Guardar vista actual", "Guarda la vista actual de la rejilla de datos", .F., .T., {|| ::SaveData() }, , "Column_Disk_16", oMenu )

   MenuAddItem( "Cargar vista por defecto", "Carga la vista por defecto de la rejilla de datos", .F., .T., {|| ::PutOriginal() }, , "Column_Refresh_16", oMenu )

   MenuAddItem()

   MenuAddItem( "Seleccionar &todo", "Selecciona todas las filas de la rejilla", .F., .T., {|| ::oBrw:SelectAll() }, , "Table_Selection_All_16", oMenu )

   MenuAddItem( "&Quitar seleccin", "Quita la seleccin de todas las filas de la rejilla", .F., .T., {|| ::oBrw:SelectNone() }, , "Table_Sql_16", oMenu )

   MenuAddItem()

   MenuAddItem( "Exportar a E&xcel", "Exportar rejilla de datos a Excel", .F., .T., {|| ::oBrw:ToExcel() }, , "Text_Sum_16", oMenu )

   MenuEnd()

   oMenu:Activate( nRow, nCol, ::oBrw )

   ::bMenuSelect := bMenuSelect

   oMenu:end()

   if !Empty( ::oBrw )
      ::oBrw:SetFocus()
   end

Return nil



static function GenMenuBlock( oCol )

return {|| iif( oCol:lHide, oCol:Show(), oCol:Hide() ) }



UTILITY STATIC function TShell_AddMru() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local cAlias

   if IsObject( ::xAlias )
      cAlias   := ::xAlias:nArea
   else
      cAlias   := ::xAlias
   end

   if Empty( ( cAlias )->( OrdSetFocus() ) )
      MsgInfo( LoadString( GetResources(), 15 ) )
      Return nil
   end

RETURN NIL



UTILITY STATIC function TShell_RecDel() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if nAnd( ::nLevel, 16 ) <> 0 .AND. !Empty( ::bDel )

      ::SetOnProcess()

      Eval( ::bDel )

      ::QuitOnProcess()

      ::Refresh()

      ::SetFocus()

   end

RETURN NIL



UTILITY STATIC function TShell_RecAdd() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if nAnd( ::nLevel, 2 ) <> 0 .AND. !Empty( ::bAdd )

      ::SetOnProcess()

      Eval( ::bAdd )

      ::QuitOnProcess()

      ::Refresh()

      ::SetFocus()

   else

      msgStop( "Acceso no permitido" )

   end

RETURN NIL



UTILITY STATIC function TShell_RecEdit() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if nAnd( ::nLevel, 4 ) <> 0 .AND. !Empty( ::bEdit )

      ::SetOnProcess()

      Eval( ::bEdit )

      if !Empty( ::oBrw )
         ::oBrw:Refresh()
      end

      ::QuitOnProcess()

      ::SetFocus()

   else

      msgStop( "Acceso no permitido" )

   end

RETURN NIL



UTILITY STATIC function TShell_RecDup() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if nAnd( ::nLevel, 2 ) <> 0 .AND. !Empty( ::bDup )

      ::SetOnProcess()

      Eval( ::bDup )

      ::QuitOnProcess()

      ::Refresh()

      ::SetFocus()

   else

      msgStop( "Acceso no permitido" )

   end

RETURN NIL



UTILITY STATIC function TShell_RecZoom() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if nAnd( ::nLevel, 8 ) <> 0 .AND. !Empty( ::bZoo )

      ::SetOnProcess()

      Eval( ::bZoo )

      ::QuitOnProcess()

      ::SetFocus()

   else

      msgStop( "Acceso no permitido" )

   end

RETURN NIL






static function SeaSeek( nKey, Self )

   local xKey
   local nOrd
   local cType

   if nKey > 0 .AND. nKey <= 10





      nOrd     := if( SubStr( ::aLstSea[ nKey ], 1, 1 ) $ "0123456789", 1, 2 )

      if ValType( ::xAlias ) == "O"
         nOrd  := ::xAlias:OrdSetFocus( nOrd )
         cType := ValType( ::xAlias:OrdKey() )
      else
         nOrd  := ( ::xAlias )->( OrdSetFocus( nOrd ) )
         cType := ValType( ( ::xAlias )->( OrdKey() ) )
      end

      ::oBrw:GoTop()

      if cType == "C"
         xKey  := ::aLstSea[ nKey ]
      elseif cType == "N"
         xKey  := Val( ::aLstSea[ nKey ] )
      end

      if ValType( ::xAlias ) == "O"
         ::xAlias:Seek( xKey )
         ::xAlias:OrdSetFocus( nOrd )
      else
         ( ::xAlias )->( dbSeek( ::aLstSea[ nKey ] ) )
         ( ::xAlias )->( OrdSetFocus( nOrd ) )
      end

      ::oBrw:SetFocus()
      ::oBrw:Refresh()

   end

return  nil



static function bSeaSeek( n, Self )
return {|| SeaSeek( n, Self ) }



UTILITY STATIC function TShell_SaveOriginal() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   ::aOriginal := ::oBrw:SaveState()

return nil



UTILITY STATIC function TShell_PutOriginal() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   ::oBrw:RestoreState( ::aOriginal )





   do case
      case ValType( ::xAlias ) == "O"
         ::xAlias:GoTop()

      case ValType( ::xAlias ) == "C" .AND. ( ::xAlias )->( Used() )
         ( ::xAlias )->( dbGoTop() )
   end

return nil



static function bSelColumn( nFor, Self )
return {|| ::aColSelect[ nFor ] := !::aColSelect[ nFor ], ::SetColumn() }



UTILITY STATIC function TShell_SetColumn( lChanged) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local aData       := _aData( ::aFlds, ::aColSelect )
   local aHeaders    := _aColHead( ::aHeaders, ::aColSelect )
   local aColSizes   := _aColSize( ::aColSizes, ::aColSelect )
   local aJustify    := _aColJustify( ::aJustify, ::aColSelect )

   if lChanged <> nil
      ::lChanged     := lChanged
   end

   ::oBrw:SetCols( aData, aHeaders, aColSizes )
   ::oBrw:aJustify   := aJustify
   ::oBrw:Refresh()

return nil































































































UTILITY STATIC function TShell_ActColSizes() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local nFor
   local n     := 1
   local nLen  := len( ::aFlds )





   for nFor := 1 to nLen
      if ::aColSelect[ nFor ]
         ::aColSizes[ nFor ]  := ::oBrw:aColSizes[n]
         n++
      end
   next

return nil



UTILITY STATIC function TShell_UpColumn( oBrw, aFlds, aHeaders, aColSizes, aColSelect, aColPos, aJustify) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local nPos  := oBrw:nAt

   if nPos <= len( aFlds ) .AND. nPos > 1

      SwapUpArray( aFlds,      nPos )
      SwapUpArray( aHeaders,   nPos )
      SwapUpArray( aColSizes,  nPos )
      SwapUpArray( aColSelect, nPos )
      SwapUpArray( aColPos,    nPos )
      SwapUpArray( aJustify,   nPos )

      oBrw:GoUp()
      oBrw:Refresh()
      oBrw:SetFocus()

   end

return ( Self )



UTILITY STATIC function TShell_DwColumn( oBrw, aFlds, aHeaders, aColSizes, aColSelect, aColPos, aJustify) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local nPos  := oBrw:nAt

   if nPos < len( aFlds ) .AND. nPos > 0

      SwapDwArray( aFlds,      nPos )
      SwapDwArray( aHeaders,   nPos )
      SwapDwArray( aColSizes,  nPos )
      SwapDwArray( aColSelect, nPos )
      SwapDwArray( aColPos,    nPos )
      SwapDwArray( aJustify,   nPos )

      oBrw:GoDown()
      oBrw:Refresh()
      oBrw:SetFocus()

   end

return ( Self )













UTILITY STATIC function TShell_AutoButtons( oParent) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   ::GralButtons( oParent )

   ::EndButtons( oParent )

return nil



UTILITY STATIC function TShell_GralButtons( oParent) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell






   Self:NewAt( "BUS",,, {||( ::SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )
      ::AddSeaBar()

   if !Empty( ::bAdd )








   Self:NewAt( "NEW",,, {||( ::RecAdd() )}, "(A)adir", "A",,, 2,, .F. )

   end

   if !Empty( ::bDup )






   Self:NewAt( "DUP",,, {||( ::RecDup() )}, "(D)uplicar", "D",,, 2,, .F. )

   end

   if !Empty( ::bEdit )






   Self:NewAt( "EDIT",,, {||( ::RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )

   end

   if !Empty( ::bZoo )






   Self:NewAt( "ZOOM",,, {||( ::RecZoom() )}, "(Z)oom", "Z",,, 8,, .F. )

   end







   Self:NewAt( "DEL",,, {||( ::RecDel() )}, "(E)liminar", "E",,, 16,, .F. )

   if oParent:lReport






   Self:NewAt( "IMP",,, {||( oParent:Report() )}, "(L)istado", "L",,, 32,, .F. )

   end

return nil



UTILITY STATIC function TShell_EndButtons( oParent) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if oParent <> nil





   Self:NewAt( "END",,, {||( oParent:end() )}, "(S)alir", "S",,,,, .F. )

   end

return nil



STATIC FUNCTION ChgGet( cType, nLen, nDec, oVal )

    oVal:bValid            := {|| .T. }
    oVal:oGet:Picture := ""

    DO CASE
    CASE cType == "L"
        oVal:bValid    := {| oVal | oVal:varGet() $ "SN" }
        oVal:cText( "Si" )
    CASE cType == "N"
        oVal:oGet:Picture := retPic( nLen, nDec, .T. )
    end

    oVal:cText( retGet( cType, nLen, nDec ) )
    oVal:refresh()

RETURN NIL



STATIC FUNCTION retGet( cType, nLen, nDec )

    local cRet    := ""

    DO CASE
    CASE cType == "L"
      cRet     := "S"
    CASE cType == "C"
      cRet     := Space( nLen )
    CASE cType == "N"
      cRet     := 0
    CASE cType == "D"
      cRet     := date()
    end

RETURN cRet



STATIC FUNCTION mkExpSea( aTblFld, oFld, oCon, aVal, oNex )

    local n            := 1
    local cExp        := ""
    local aNex        := {     " .AND. ", " .OR. " }






    local aTblCon    := {     " == ",    " != ",    " > ",    " < ",    " >= ",    " <= ",    " $ " }

    WHILE n <= len( aVal )

        IF aTblCon[ oCon[n]:nAt ] == " $ "



            cExp    += cGetVal( aVal[n] ) +     aTblCon[ oCon[n]:nAt ] +     rtrim( aTblFld[ oFld[n]:nAt ] )

        ELSE



            cExp    += rtrim( aTblFld[ oFld[n]:nAt ] ) +     aTblCon[ oCon[n]:nAt ] +     cGetVal( aVal[n] )

        end

        IF oNex[n]:nAt <> 1
            cExp     += aNex[ oNex[n]:nAt - 1 ]
        ELSE
            EXIT
        end

        n++

    end

    IF At( Type( cExp ), "UEUI" ) <> 0
      msgAlert( "Expresin " + rtrim( cExp ) + " no valida" )
        cExp    := NIL
   ELSE
      cExp  := &( "{|| " + cExp + " }" )
   end

RETURN cExp



STATIC FUNCTION cGetVal( xVal )

    local cTemp
   local cType := Valtype( xVal )

   do case
   case cType == "C"

        IF Upper( xVal )         == "S"
            cTemp := ".T."
        ELSEIF Upper( xVal ) == "N"
            cTemp := ".F."
        ELSE
            xVal    := rtrim( xVal )
            cTemp := '"' + cValToChar( xVal ) + '"'
        end

   case cType == "N"

        cTemp := cValToChar( xVal )

   case cType == "D"

        cTemp := 'CTOD( "' + cValToChar( xVal ) + '" )'

   end

RETURN ( cTemp )



UTILITY STATIC function TShell_Maximize() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local oWnd

   oWnd        := GetWndFrame()

   ::Restore()

   ::nTop      := 0
   ::nLeft     := 0
   ::nBottom   := oWnd:oWndClient:nHeight()
   ::nRight    := oWnd:oWndClient:nWidth()

   ::Move( ::nTop, ::nLeft, ::nRight, ::nBottom,  .T. )

return nil



UTILITY STATIC function TShell_SysCommand( nWParam, nLParam) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if nWParam == 61488
      ::Maximize()
      return 0
   else
      ::TMdiChild:SysCommand( nWParam, nLParam )
   endif

return nil



UTILITY STATIC function TShell_Destroy() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if ::oBrw <> nil
      ::oBrw:end()
   end

   if ::oBtnBar <> nil
      ::oBtnBar:end()
   end

   if ::oBtnTop <> nil
      ::oBtnTop:end()
   end

   if ::oMsgBar <> nil
      ::oMsgBar:end()
   end

   if ::oComboBox <> nil
      ::oComboBox:end()
   end

   if ::oIcon <> nil
      ::oIcon:end()
   end

   if ::oCursor <> nil
      ::oCursor:end()
   end

   if ::oTop <> nil
      ::oTop:end()
   end

   if ::oLeft <> nil
      ::oLeft:end()
   end

   if ::oRight <> nil
      ::oRight:end()
   end

   if ::oClient <> nil
      ::oClient:end()
   end

   if ::oTxtSea <> nil
      ::oTxtSea:end()
   end

   if ::oImageList <> nil
      ::oImageList:End()
   end

   if ::oHorizontalSplitter <> nil
      ::oHorizontalSplitter:End()
   end

   if ::oVerticalSplitter <> nil
      ::oVerticalSplitter:End()
   end

   if ::hWnd <> 0
      ::TMdiChild:Destroy()
   endif

   if ::bDestroy <> nil
      Eval( ::bDestroy )
   end

return ( Self )



UTILITY STATIC function TShell_ChgTabs( nTab) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   IIF( nTab == nil, nTab := ::oTabs:nOption, ) ;

   do case
      case ValType( ::xAlias ) == "O"
         ::xAlias:SetOrder( nTab )
      case ValType( ::xAlias ) == "C" .AND. ( ::xAlias )->( Used() )
         (::xAlias)->( dbSetOrder( nTab ) )
   end



   if !Empty( ::bChgIndex )
      Eval( ::bChgIndex )
   end



   ::oBrw:Refresh()

   if ::oTxtSea <> nil .AND. ::oTxtSea:ClassName() == "TGET"
      ::oTxtSea:oGet:Home()
      ::oTxtSea:cText( Space( 100 ) )
   end

return ( Self )



UTILITY STATIC function TShell_ChgCombo( nTab) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local oCol
   local cOrd                 := ""

   if Empty( nTab ) .AND. !Empty( ::oWndBar )
      nTab                    := ::oWndBar:GetComboBoxAt( .T. )
   end

   nTab                       := Max( nTab, 1 )

   if !Empty( ::oWndBar )
      ::oWndBar:SetComboBoxSelect( nTab )
   end



   if !Empty( ::bChgIndex )
      Eval( ::bChgIndex )
   end



   if !Empty( ::oWndBar )
      cOrd                    := ::oWndBar:GetComboBox()
   end



   if !Empty( ::oBrw ) .AND. !Empty( cOrd )

      with object ::oBrw

         do case
         case IsObject( ::xAlias ) .AND. ::xAlias:Used()

            for each oCol in :aCols

               if Eq( cOrd, oCol:cHeader )
                  oCol:cOrder       := "A"
                  oCol:SetOrder()
               else
                  oCol:cOrder       := " "
               end

            next

         case IsChar( ::xAlias ) .AND. ( ::xAlias )->( Used() )

            for each oCol in :aCols

               if Eq( cOrd, oCol:cHeader )
                  oCol:cOrder       := "A"
                  oCol:SetOrder()
               else
                  oCol:cOrder       := " "
               end

            next

         end

      end



      ::AplyFilter()



      ::oBrw:Refresh()

   end

return ( Self )



UTILITY STATIC function TShell_AddSeaBar() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if !Empty( ::oWndBar )

      ::oWndBar:SetComboBoxChange(     {|| ::ChgCombo() } )
      ::oWndBar:SetComboFilterChange(  {|| ::ChgFilter() } )

      ::oWndBar:SetGetLostFocus(       {|| ::AddSearch() } )
      ::oWndBar:SetKillFilter(         {|| ::KillFilter() } )

      ::oWndBar:SetAddButtonFilter(    {|| ::AddFilter() } )
      ::oWndBar:SetEditButtonFilter(   {|| ::EditFilter() } )

      ::oWndBar:SetGetPostKey(         {| oGet, cText  | ::FastSeek( oGet, cText ) } )
      ::oWndBar:SetGetKeyDown(         {| nKey, nFlags | ::KeySearch( nKey ) } )

   end

RETURN ( Self )



UTILITY STATIC function TShell_SetIndex( nOrd) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   do case
   case IsObject( ::xAlias ) .AND. ::xAlias:Used()
      ::xAlias:SetOrder( nOrd )
   case IsChar( ::xAlias ) .AND. ( ::xAlias )->( Used() )
      ( ::xAlias )->( dbSetOrder( nOrd ) )
   end

   if !Empty( ::oWndBar )
      ::oWndBar:SetComboBoxSelect( nOrd )
   end

   ::oComboBox:Select( nOrd )

   ::oBrw:Refresh()

RETURN nil



UTILITY STATIC function TShell_NextTabOption() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local nOpt

   if !Empty( ::oWndBar )

      nOpt        := ::oWndBar:GetComboBoxAt( .T. )

      if nOpt < len( ::aPrompt )
         nOpt++
         ::ChgCombo( nOpt )
      end

   end

RETURN ( Self )



UTILITY STATIC function TShell_PrevTabOption() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local nOpt

   if !Empty( ::oWndBar )

      nOpt  := ::oWndBar:GetComboBoxAt( .T. )

      if nOpt > 1
         nOpt--
         ::ChgCombo( nOpt )
      end

   end

RETURN ( Self )



UTILITY STATIC function TShell_lPressCol( nCol) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local nPos
   local cHeader

   if !Empty( nCol ) .AND. nCol <= len( ::oBrw:aHeaders )

      cHeader     := ::oBrw:aHeaders[ nCol ]

      nPos        := aScan( ::aPrompt, cHeader )
      if nPos     <> 0

         ::oWndBar:SetComboBoxSet( cHeader )

         do case
            case IsObject( ::xAlias )

               ::xAlias:OrdSetFocus( ::oWndBar:GetComboBoxAt() )

            case IsChar( ::xAlias ) .AND. ( ::xAlias )->( Used() )

               ( ::xAlias )->( OrdSetFocus( ::oWndBar:GetComboBoxAt() ) )

         end

         ::oBrw:Refresh()

      end

   end

RETURN ( Self )



UTILITY STATIC function TShell_ClickOnHeader( oCol) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if !Empty( oCol )
      if aScan( ::aPrompt, oCol:cHeader ) <> 0
         ::oWndBar:SetComboBoxSet( oCol:cHeader )
         oCol:SetOrder()
      end
   end

   ::AplyFilter()

RETURN ( Self )



UTILITY STATIC function TShell_HelpTopic() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if !Empty( ::cHtmlHelp )
      HtmlHelp( ::cHtmlHelp )
   end

RETURN ( Self )



UTILITY STATIC function TShell_AddGoTo( cCaption, bAction) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   aAdd( ::aGoTo, { cCaption, bAction } )

Return ( Self )



UTILITY STATIC function TShell_AddImageList( cImage) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local oImage
   local nImageList     := 0

   if !Empty( cImage )
      oImage            := TBitmap():Define( cImage )
      oImage:cResName   := cImage
      ::oImageList:AddMasked( oImage, ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )
      nImageList        := len( ::oImageList:aBitmaps ) - 1
   end

Return ( nImageList )



UTILITY STATIC function TShell_ClickTree() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local oItem       := ::oBtnBar:GetSelected()

   if !Empty( oItem ) .AND. oItem:ClassName() == "TTVITEM" .AND. Valtype( oItem:bAction ) == "B"

      if !::lOnProcess

         if !( oItem:cPrompt $ "Salir" ) .AND. !oItem:Cargo
            ::SetOnProcess()
         end

         Eval( oItem:bAction )

         if ::oBtnMain <> nil
            ::oBtnBar:Select( ::oBtnMain )
         end

         ::QuitOnProcess()

      end

      if !( oItem:cPrompt $ "Buscar" )
         if !Empty( ::oBrw )
            ::oBrw:SetFocus()
         end
      end

   end

Return ( Self )



UTILITY STATIC function TShell_OpenData( cPath) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local oBlock
   local oError

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "CfgUse.Dbf" ) .OR. !lExistTable( cPatEmp() + "CfgCol.Dbf" )
      ::CreateData( cPath )
   end

   if !lExistIndex( cPath + "CfgUse.Cdx" ) .OR. !lExistIndex( cPatEmp() + "CfgCol.Cdx" )
      ::ReindexData( cPath )
   end

   oBlock               := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., cDriver(), ( cPath + "CfgUse.Dbf" ), ( ::dbfUsr := cCheckArea( "CfgUse" ) ), .T. )
      IIF( !lAIS(), ( ::dbfUsr )->( OrdListAdd( cPath + "CfgUse.Cdx" ) ), ( ::dbfUsr )->( OrdSetFocus( 1 ) ) )

      dbUseArea( .T., cDriver(), ( cPath + "CfgCol.Dbf" ), ( ::dbfCol := cCheckArea( "CfgCol" ) ), .T. )
      IIF( !lAIS(), ( ::dbfCol )->( OrdListAdd( cPath + "CfgCol.Cdx" ) ), ( ::dbfCol )->( OrdSetFocus( 1 ) ) )

   RECOVER USING oError

      ::lOpenData       := .F.
      msgStop( "Imposible abrir todas las bases de datos" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

Return ( Self )



UTILITY STATIC function TShell_CreateData( cPath) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "CfgUse.Dbf" )
      dbCreate( cPath + "CfgUse.Dbf", aSqlStruct( aItmHea() ), cDriver() )
   end

   if !lExistTable( cPath + "CfgCol.Dbf" )
      dbCreate( cPath + "CfgCol.Dbf", aSqlStruct( aItmCol() ), cDriver() )
   end

Return ( Self )



UTILITY STATIC function TShell_ReindexData( cPath) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local dbfUse
   local dbfCol

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "CfgUse.Dbf" ) .OR. !lExistTable( cPath + "CfgCol.Dbf" )
      ::CreateData( cPath )
   end

   dbUseArea( .T., cDriver(), cPath + "CfgUse.Dbf", cCheckArea( "CfgUse", @dbfUse ), .F. )

   if !( dbfUse )->( neterr() )

      ( dbfUse )->( __dbPack() )

      ( dbfUse )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
      ( dbfUse )->( ordCreate( cPath + "CfgUse.Cdx", "cCodUse", "cCodUse + cNomCfg", {|| Field->cCodUse + Field->cNomCfg } ) )

      ( dbfUse )->( dbCloseArea() )

   else

      msgStop( "Imposible abrir en modo exclusivo la tabla de ventanas" )

   end

   dbUseArea( .T., cDriver(), cPath + "CfgCol.Dbf", cCheckArea( "CfgCol", @dbfCol ), .F. )

   if !( dbfCol )->( neterr() )

      ( dbfCol )->( __dbPack() )

      ( dbfCol )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
      ( dbfCol )->( ordCreate( cPath + "CfgCol.Cdx", "cCodUse", "cCodUse + cNomCfg + Str( nNumCol )", {|| Field->cCodUse + Field->cNomCfg + Str( Field->nNumCol ) } ) )

      ( dbfCol )->( dbCloseArea() )

   else

      msgStop( "Imposible abrir en modo exclusivo la tabla de configuracin de ventanas" )

   end

Return ( self )



UTILITY STATIC function TShell_AppendData( cPath, cPathFrom) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   ::OpenData( cPath )

   if ::lOpenData

      if file( cPathFrom + "CfgCol.Dbf" )
         ( ::dbfCol )->( __dbApp( cPathFrom + "CfgCol.Dbf" ) )
      end

      ::CloseData()

   end

Return ( self )



UTILITY STATIC function TShell_LoadData() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local n
   local oError
   local oBlock   := ErrorBlock( { | oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE

   if ( ::dbfUsr )->( dbSeek( ::cCodigoUsuario + ::cWinName ) )

      ::cCfg      := ( ::dbfUsr )->cBrwCfg
      ::nRec      := Max( ( ::dbfUsr )->nRecCfg, 1 )
      ::nTab      := Max( ( ::dbfUsr )->nTabCfg, 1 )

      if ::lAutoPos

         do case
            case ValType( ::xAlias ) == "O" .AND. ::xAlias:Used()

               ::xAlias:OrdSetFocus( ::nTab )
               ::xAlias:GoTo( ::nRec )

               if ::xAlias:Recno() <> ::nRec .OR. ::nRec > ::xAlias:Lastrec()
                  ::xAlias:GoTop()
               end

            case ValType( ::xAlias ) == "C" .AND. ( ::xAlias )->( Used() )

               ( ::xAlias )->( OrdSetFocus( ::nTab ) )
               ( ::xAlias )->( dbGoTo( ::nRec ) )

               if ( ::xAlias )->( Recno() ) <> ::nRec .OR. ::nRec > ( ::xAlias )->( Lastrec() )
                  ( ::xAlias )->( dbGoTop() )
               end

         end

      end

   end



   RECOVER USING oError

      msgStop( "Establecer la configuracin de columnas.", "Error" )

   end

   ErrorBlock( oBlock )

Return ( Self )



UTILITY STATIC function TShell_SaveData( lSaveBrowseState) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local n
   local nCols
   local oError
   local oBlock

   IIF( lSaveBrowseState == nil, lSaveBrowseState := .T., ) ;

   oBlock                        := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE



   if !Empty( ::dbfUsr ) .AND. ( ::dbfUsr )->( Used() )

      if ( ::dbfUsr )->( dbSeek( ::cCodigoUsuario + ::cWinName ) )

         if ( ::dbfUsr )->( dbRLock() )
            ( ::dbfUsr )->nRecCfg   := ::nRec
            ( ::dbfUsr )->nTabCfg   := ::nTab
            if lSaveBrowseState
            ( ::dbfUsr )->cBrwCfg   := ::oBrw:SaveState()
            end
            ( ::dbfUsr )->( dbRUnLock() )
         end

      else

         ( ::dbfUsr )->( dbAppend() )
         if !( ::dbfUsr )->( neterr() )
            ( ::dbfUsr )->cCodUse   := ::cCodigoUsuario
            ( ::dbfUsr )->cNomCfg   := ::cWinName
            ( ::dbfUsr )->nRecCfg   := ::nRec
            ( ::dbfUsr )->nTabCfg   := ::nTab
            if lSaveBrowseState
            ( ::dbfUsr )->cBrwCfg   := ::oBrw:SaveState()
            end
            ( ::dbfUsr )->( dbRUnLock() )
         end

      end

      if lSaveBrowseState
         msgInfo( "Configuracin de columnas guardada." )
      end

   end

   RECOVER USING oError

      msgStop( "Imposible salvar las configuraciones de columnas" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

Return ( Self )



UTILITY STATIC function TShell_CleanData() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell



   while ( ::dbfCol )->( dbSeek( ::cCodigoUsuario + ::cWinName ) )
      dbDel( ::dbfCol )
   end

Return ( Self )



UTILITY STATIC function TShell_DeleteData() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if File( cPatEmp() + "CfgUse.Dbf" )
      fErase( cPatEmp() + "CfgUse.Dbf" )
   end

   if File( cPatEmp() + "CfgUse.Cdx" )
      fErase( cPatEmp() + "CfgUse.Cdx" )
   end

   if File( cPatEmp() + "CfgCol.Dbf" )
      fErase( cPatEmp() + "CfgCol.Dbf" )
   end

   if File( cPatEmp() + "CfgCol.Cdx" )
      fErase( cPatEmp() + "CfgCol.Cdx" )
   end

RETURN ( Self )



UTILITY STATIC function TShell_CloseData() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if !Empty( ::dbfUsr ) .AND. ( ::dbfUsr )->( Used() )
      ( ::dbfUsr )->( dbCloseArea() )
   end

   if !Empty( ::dbfCol ) .AND. ( ::dbfCol )->( Used() )
      ( ::dbfCol )->( dbCloseArea() )
   end

RETURN ( Self )



UTILITY STATIC function TShell_CreateXBrowse() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local oError
   local oBlock
   local lCreateXBrowse    := .T.

   oBlock                  := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      ::oBrw                  := TXBrowse():New( Self )
      ::oBrw:nStyle           := nOr( 1073741824, 268435456, 65536 )

      ::oBrw:lRecordSelector  := .F.



      ::oBrw:nMarqueeStyle    := 6

      ::oBrw:bClrStd          := {|| { 0, 16777215 } }



      ::oBrw:bRClicked        := {| nRow, nCol, nFlags | ::RButtonDown( nRow, nCol, nFlags ) }

      ::oBrw:bClrSel          := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      ::oBrw:bClrSelFocus     := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      do case
      case IsObject( ::xAlias )

         ::xAlias:SetBrowse( ::oBrw )

      case IsChar( ::xAlias ) .AND. ( ::xAlias )->( Used() )

         ::oBrw:nDataType  := 0
         ::oBrw:cAlias     := ::xAlias
         ::oBrw:bGoTop     := {|| ( ::xAlias )->( DbGoTop() ) }
         ::oBrw:bGoBottom  := {|| ( ::xAlias )->( DbGoBottom() ) }
         ::oBrw:bSkip      := {| n | iif( n == nil, n := 1, ), ( ::xAlias )->( dbSkipper( n ) ) }
         ::oBrw:bBof       := {|| ( ::xAlias )->( Bof() ) }
         ::oBrw:bEof       := {|| ( ::xAlias )->( Eof() ) }
         ::oBrw:bBookMark  := {| n | iif( n == nil, ( ::xAlias )->( RecNo() ), ( ::xAlias )->( dbGoto( n ) ) ) }
         ::oBrw:bLock      := {|| ( ::xAlias )->( DbrLock() ) }
         ::oBrw:bUnlock    := {|| ( ::xAlias )->( DbrUnlock() ) }

         if lAdsRdd()
         ::oBrw:bKeyNo     := {| n | iif( n == nil, Round( ( ::xAlias )->( ADSGetRelKeyPos() ) * ::oBrw:nLen, 0 ), ( ::xAlias )->( ADSSetRelKeyPos( n / ::oBrw:nLen ) ) ) }
         ::oBrw:bKeyCount  := {|| ( ::xAlias )->( ADSKeyCount(,,1) ) }
         else
         ::oBrw:bKeyNo     := {| n | iif( n == nil, ( ::xAlias )->( OrdKeyNo() ), ( ::xAlias )->( OrdKeyGoto( n ) ) ) }
         ::oBrw:bKeyCount  := {|| ( ::xAlias )->( OrdKeyCount() ) }
         end

      end

      ::oBrw:bKeyChar      := {|nKey| ::CtrlKey( nKey ) }



      if !::lBigStyle
         ::oBrw:nTop       := 44 + 0
      else
         ::oBrw:nTop       := 0
         ::oBrw:nRowHeight := 36
      endif

      ::oBrw:nLeft         := 200 + 0 + 0
      ::oBrw:nRight        := ::nRight - ::nLeft
      ::oBrw:nBottom       := ::nBottom - ::nTop

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Imposible crear rejilla de datos" )

      lCreateXBrowse       := .F.

   end

   ErrorBlock( oBlock )

Return ( lCreateXBrowse )



UTILITY STATIC function TShell_CreateXFromCode() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local oCol



   ::OpenData()

   if ::lOpenData
      ::LoadData()
   end



   for each oCol in ::oBrw:aCols
      oCol:bLDClickData    := {|| ::RecEdit() }
   next



   ::oBrw:CreateFromCode()



   ::SaveOriginal()



   if !Empty( ::cCfg )
      ::oBrw:RestoreState( ::cCfg )
   end



   ::oBrw:SetFocus()

Return ( Self )



UTILITY STATIC function TShell_CheckExtendInfo() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if Empty( ::bToolTip )
      Return ( Self )
   endif

   if !Empty( ::oToolTip )
      ::oToolTip:End()
      ::oToolTip  := nil
   endif

   if !Empty( ::oTimer )
      ::oTimer:End()
      ::oTimer    := nil
   endif

   if !::lOnProcess
      ::oTimer             := TTimer():New( ::nToolTip, {|| ::ShowExtendInfo(), if( ::oTimer <> nil, ::oTimer:End(), nil ), ::oTimer := nil }, )
      ::oTimer:hWndOwner   := GetActiveWindow()
      ::oTimer:Activate()
   end

Return ( Self )



UTILITY STATIC function TShell_ShowExtendInfo() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local nRow
   local oBlock

   ::lOnProcess      := .T.

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if ::oToolTip == nil

      ::oToolTip     := CheckEval( ::bToolTip )

      if Valtype( ::oToolTip ) == "O"

         nRow        := ( ::oBrw:nRowSel * ::oBrw:DataHeight ) + ::oBrw:HeaderHeight()

         if ( nRow + ::oToolTip:nHeight() ) >= ( ::oBrw:BrwHeight() - 100 )
            nRow     -= ( ::oToolTip:nHeight() + ::oBrw:DataHeight + 108 )
            nRow     := Max( nRow, 0 )
         else
            nRow     += 4
         end

         ::oToolTip:Activate( , , , .F., , .F., {|o| o:Move( nRow, ( ::oBrw:BrwWidth() - ::oToolTip:nWidth() - 4 ), ::oToolTip:nWidth(), ::oToolTip:nHeight() ) } )

         ::oBrw:SetFocus()
         ::oBrw:Select()

         if !Empty( ::oTimer )
            ::oTimer:End()
            ::oTimer := nil
         endif

      end

   end

   end

   ErrorBlock( oBlock )

   ::lOnProcess     := .F.

return nil



UTILITY STATIC function TShell_DestroyToolTip() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

  if !Empty( ::oToolTip )

     ::oToolTip:End()
     ::oToolTip      := nil

       ::oBrw:SetFocus()

  endif



return nil



UTILITY STATIC function TShell_SetAutoFilter( cFilter) ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   if Empty( ::bFilter ) .AND. !Empty( cFilter )

      do case
         case IsObject( ::xAlias ) .AND. ::xAlias:Used()
            ::xAlias:SetFocus()

         case IsChar( ::xAlias ) .AND. ( ::xAlias )->( Used() )
            dbSelectArea( ( ::xAlias )->( Used() ) )
      end

      if Empty( cFilter ) .OR. At( Type( cFilter ), "UEUI" ) <> 0
         ::bFilter   := nil
      else
         ::bFilter   := Compile( cFilter )
      end

   end

Return ( Self )



UTILITY STATIC function TShell_ChgFilter() ; local Self AS CLASS TShell := QSelf() AS CLASS TShell

   local cFilter              := ""

   if !Empty( ::oWndBar )
      cFilter                 := ::oWndBar:GetComboFilter()
   end

   if !Empty( cFilter )
      ::oActiveFilter:SetFilter( cFilter )
   end

   ::SetFocus()

return ( Self )



Function aItmHea()

   local aBase := {}

   aAdd( aBase, { "cCodUse",  "C",  3, 0, "Cdigo usuario"           } )
   aAdd( aBase, { "cNomCfg",  "C", 30, 0, "Nombre ventana"           } )
   aAdd( aBase, { "nRecCfg",  "N", 10, 0, "Recno de la ventana"      } )
   aAdd( aBase, { "nTabCfg",  "N", 10, 0, "Orden de la ventana"      } )
   aAdd( aBase, { "cBrwCfg",  "M", 10, 0, "Configuracin del browse" } )

Return ( aBase )



Static Function aItmCol()

   local aBase := {}

   aAdd( aBase, { "cCodUse",  "C",  3, 0, "Cdigo usuario"           } )
   aAdd( aBase, { "cNomCfg",  "C", 30, 0, "Nombre ventana"           } )
   aAdd( aBase, { "nNumCol",  "N",  2, 0, "Nmero de la columna"     } )
   aAdd( aBase, { "lSelCol",  "L",  1, 0, "Columna seleccionada"     } )
   aAdd( aBase, { "nPosCol",  "N",  2, 0, "Posicicin de la columna" } )
   aAdd( aBase, { "nSizCol",  "N",  6, 0, "Tamao de la columna"     } )
   aAdd( aBase, { "lJusCol",  "L",  1, 0, "Columna a la derecha"     } )

Return ( aBase )











function CheckOne( aColSelect )

   local lOne  := .F.

   aEval( aColSelect, {|x| if( x, lOne := .T., ) } )

   if !lOne
      msgAlert( "La ventana debe de contener al menos una columna seleccionada" )
   end

return ( lOne )



function SwapDwArray( aArray, nPos )

   local uTmp

   IIF( nPos == nil, nPos := len( aArray ), ) ;

   if nPos < len( aArray ) .AND. nPos > 0
      uTmp              := aArray[nPos]
      aArray[nPos]      := aArray[nPos + 1 ]
      aArray[nPos + 1 ] := uTmp
   end

return nil



function SwapUpArray( aArray, nPos )

   local uTmp

   IIF( nPos == nil, nPos := len( aArray ), ) ;

   if nPos <= len( aArray ) .AND. nPos > 1
      uTmp              := aArray[nPos]
      aArray[nPos]      := aArray[nPos - 1 ]
      aArray[nPos - 1 ] := uTmp
   end

return nil



Function _aColFoot( aColFoot, aColSel )

   local nFor
   local nLen  := Len( aColFoot )
   local aFoo  := {}

   for nFor = 1 to nLen
      if aColSel[ nFor ]
         aAdd( aFoo, aColFoot[ nFor ] )
      end
   next

return ( aFoo )



Function _aData( aFields, aColSel )

   local nFor
   local nLen  := Len( aFields )
   local aFld  := {}

   for nFor = 1 to nLen
      if aColSel[ nFor ]
         aAdd( aFld, aFields[ nFor ] )
      end
   next

return aFld



Function _aColHead( aHeaders, aColSel )

   local nFor
   local nLen  := Len( aHeaders )
   local aHea  := {}

   for nFor = 1 to nLen
      if aColSel[ nFor ]
         aAdd( aHea, aHeaders[ nFor ] )
      end
   next

return aHea



Function _aColSize( aColSizes, aColSel, oBrw )

   local nFor
   local nLen  := Len( aColSizes )
   local aSiz  := {}

   for nFor = 1 to nLen
      if aColSel[ nFor ]
         aAdd( aSiz, aColSizes[ nFor ] )
      end
   next

return aSiz



Function _aColJustify( aColJustify, aColSel, oBrw )

   local nFor
   local nLen  := Len( aColJustify )
   local aJus  := {}

   for nFor = 1 to nLen
      if aColSel[ nFor ]
         aAdd( aJus, aColJustify[ nFor ] )
      end
   next

return aJus



Function _aFld( aFields, aColSel )

   local nFor
   local nLen  := Len( aFields )
   local aFld  := {}

   for nFor := 1 to nLen
      if aColSel[ nFor ] .AND. !Empty( aFields[ nFor ] )
         aAdd( aFld, Eval( aFields[ nFor ] ) )
      end
   next

return aFld





Function oFontLittelTitle()

   if Empty( oFontLittelTitle )
      oFontLittelTitle  := TFont():New( "Ms Sans Serif", 6, 12, .F. )
   end

Return ( oFontLittelTitle )
