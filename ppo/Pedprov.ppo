#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 135 ".\Prg\Pedprov.prg"
memvar cDbf
memvar cDbfCol
memvar cDbfPrv
memvar cDbfPgo
memvar cDbfIva
memvar cDbfAlm
memvar cDbfDiv
memvar cDbfArt
memvar cDbfKit
memvar cDbfPro
memvar cDbfUsr
memvar cDbfTblPro
memvar aTotIva
memvar aIvaUno
memvar aIvaDos
memvar aIvaTre
memvar nTotBrt
memvar nTotDto
memvar nTotDpp
memvar nTotNet
memvar nTotIva
memvar nTotReq
memvar nTotPed
memvar nTotImp
memvar cPicUndPed
memvar cPinDivPed
memvar cPirDivPed
memvar nDinDivPed
memvar nDirDivPed
memvar nVdvDivPed
memvar nPagina
memvar lEnd

static oWndBrw
static oBrwIva
static dbfPedPrvT
static dbfPedPrvL
static dbfPedPrvI
static dbfPedPrvD
static dbfPedPrvS
static dbfAlbPrvT
static dbfAlbPrvL
static dbfPedCliT
static dbfPedCliL
static dbfPedCliR
static dbfInci
static dbfPrv
static dbfIva
static dbfTmp
static dbfFPago
static dbfDiv
static dbfCajT
static oBandera
static dbfArticulo
static dbfCodebar
static dbfTmpInc
static dbfTmpDoc
static dbfTmpArt
static dbfTmpLin
static dbfTmpSer
static cTmpArt
static cTmpSer
static cTmpPedL
static cTmpInc
static cTmpDoc
static dbfFamilia
static dbfDelega
static dbfArtPrv
static dbfArtCom
static dbfAlm
static dbfPro
static dbfTblPro
static dbfTblCnv
static dbfDoc
static dbfKit
static dbfUsr
static dbfFlt
static dbfCount
static dbfEmp
static dbfFacPrvL
static dbfRctPrvL
static dbfAlbCliL
static dbfFacCliL
static dbfFacRecL
static dbfTikCliL
static dbfProLin
static dbfProMat
static dbfHisMov
static dbfSitua
static oStock
static oGetNet
static oGetIva
static oGetReq
static oGetTotal
static oUsr
static cUsr
static cPirDiv
static cPinDiv
static cPicUnd
static nDinDiv
static nDirDiv
static cNewFile
static nGetNeto         := 0
static nGetIva          := 0
static nGetReq          := 0
static nVdvDiv          := 1
static oFont
static oMenu
static cOldCodCli       := ""
static cOldCodArt       := ""
static cOldPrpArt       := ""
static cOldUndMed       := ""
static lOpenFiles       := .F.
static lExternal        := .F.
static cFiltroUsuario   := ""
static bEdtRec          := { |aTmp, aGet, dbfPedPrvT, oBrw, bWhen, bValid, nMode | EdtRec( aTmp, aGet, dbfPedPrvT, oBrw, bWhen, bValid, nMode ) }
static bEdtDet          := { |aTmp, aGet, dbfPedPrvL, oBrw, bWhen, bValid, nMode, aPedPrv | EdtDet( aTmp, aGet, dbfPedPrvL, oBrw, bWhen, bValid, nMode, aPedPrv ) }
static bEdtInc          := { |aTmp, aGet, dbfPedPrvI, oBrw, bWhen, bValid, nMode, aTmpLin | EdtInc( aTmp, aGet, dbfPedPrvI, oBrw, bWhen, bValid, nMode, aTmpLin ) }
static bEdtDoc          := { |aTmp, aGet, dbfPedPrvD, oBrw, bWhen, bValid, nMode, aTmpLin | EdtDoc( aTmp, aGet, dbfPedPrvD, oBrw, bWhen, bValid, nMode, aTmpLin ) }
static oUndMedicion



STATIC FUNCTION OpenFiles( lExt )

   local oBlock

   if lOpenFiles
      MsgStop( "Ficheros de pedidos a proveedores abiertos previamente" )
      Return ( .F. )
   end

   IIF( lExt == nil, lExt := .F., ) ;

   lExternal            := lExt

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      DisableAcceso()

      lOpenFiles        := .T.

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPROVT.DBF" ), ( cCheckArea( "PEDPROVT", @dbfPedPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPROVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPROVL.DBF" ), ( cCheckArea( "PEDPROVL", @dbfPedPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPROVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPRVI.DBF" ), ( cCheckArea( "PEDPRVI", @dbfPedPrvI ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPRVI.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPRVD.DBF" ), ( cCheckArea( "PEDPRVD", @dbfPedPrvD ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPRVD.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBPROVT.DBF" ), ( cCheckArea( "ALBPROVT", @dbfAlbPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBPROVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBPROVL.DBF" ), ( cCheckArea( "ALBPROVL", @dbfAlbPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBPROVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatPrv() + "PROVEE.DBF" ), ( cCheckArea( "PROVEE", @dbfPrv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatPrv() + "PROVEE.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIVA.DBF" ), ( cCheckArea( "TIVA", @dbfIva ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TIVA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatGrp() + "FPAGO.DBF" ), ( cCheckArea( "FPAGO", @dbfFPago ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatGrp() + "FPAGO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "DIVISAS.DBF" ), ( cCheckArea( "DIVISAS", @dbfDiv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "DIVISAS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "PROVART.DBF" ), ( cCheckArea( "PROVART", @dbfArtPrv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "PROVART.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cCodPrv" )

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ArtDiv.Dbf" ), ( cCheckArea( "ARTCOM", @dbfArtCom ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ArtDiv.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ARTICULO.DBF" ), ( cCheckArea( "ARTICULO", @dbfArticulo ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ARTICULO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ArtCodebar.Dbf" ), ( cCheckArea( "CODEBAR", @dbfCodebar ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ArtCodebar.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "FAMILIAS.DBF" ), ( cCheckArea( "FAMILIAS", @dbfFamilia ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "FAMILIAS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatAlm() + "ALMACEN.DBF" ), ( cCheckArea( "ALMACEN", @dbfAlm ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatAlm() + "ALMACEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TBLCNV.DBF" ), ( cCheckArea( "TBLCNV", @dbfTblCnv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TBLCNV.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ARTKIT.DBF" ), ( cCheckArea( "ARTTIK", @dbfKit ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ARTKIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RDOCUMEN.DBF" ), ( cCheckArea( "RDOCUMEN", @dbfDoc ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RDOCUMEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cTipo" )

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "Cajas.Dbf" ), ( cCheckArea( "CAJAS", @dbfCajT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "Cajas.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "USERS.DBF" ), ( cCheckArea( "USERS", @dbfUsr ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "USERS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TIPINCI.DBF" ), ( cCheckArea( "TIPINCI", @dbfInci ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TIPINCI.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDCLIT.DBF" ), ( cCheckArea( "PEDCLIT", @dbfPedCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDCLIL.DBF" ), ( cCheckArea( "PEDCLIL", @dbfPedCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDCLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDCLIR.DBF" ), ( cCheckArea( "PEDCLIR", @dbfPedCliR ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDCLIR.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "PRO.DBF" ), ( cCheckArea( "PRO", @dbfPro ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "PRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "TBLPRO.DBF" ), ( cCheckArea( "TBLPRO", @dbfTblPro ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "TBLPRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "DELEGA.DBF" ), ( cCheckArea( "DELEGA", @dbfDelega ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "DELEGA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "CNFFLT.DBF" ), ( cCheckArea( "CNFFLT", @dbfFlt ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "CNFFLT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "NCOUNT.DBF" ), ( cCheckArea( "NCOUNT", @dbfCount ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "NCOUNT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "EMPRESA.DBF" ), ( cCheckArea( "EMPRESA", @dbfEmp ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "EMPRESA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACPRVL.DBF" ), ( cCheckArea( "FACPRVL", @dbfFacPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FACPRVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cRef" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvL.DBF" ), ( cCheckArea( "RctPrvL", @dbfRctPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cRef" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBCLIL.DBF" ), ( cCheckArea( "ALBCLIL", @dbfAlbCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBCLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cStkFast" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACCLIL.DBF" ), ( cCheckArea( "FACCLIL", @dbfFacCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FACCLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cRef" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacRecL.DBF" ), ( cCheckArea( "FacRecL", @dbfFacRecL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacRecL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cRef" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TIKEL.DBF" ), ( cCheckArea( "TIKEL", @dbfTikCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TIKEL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "CSTKFAST" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PROLIN.DBF" ), ( cCheckArea( "PROLIN", @dbfProLin ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PROLIN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cCodArt" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PROMAT.DBF" ), ( cCheckArea( "PROMAT", @dbfProMat ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PROMAT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cCodArt" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "HISMOV.DBF" ), ( cCheckArea( "HISMOV", @dbfHisMov ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "HISMOV.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cRefMov" )

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "SITUA.DBF" ), ( cCheckArea( "SITUA", @dbfSitua ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "SITUA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end



      oUndMedicion      := UniMedicion():Create( cPatGrp() )
      if !oUndMedicion:OpenFiles()
         lOpenFiles     := .F.
      end

      oStock            := TStock():Create( cPatGrp() )

      if !oStock:lOpenFiles()
         lOpenFiles     := .F.
      else
      oStock:cPedPrvT   := dbfPedPrvT
      oStock:cPedPrvL   := dbfPedPrvL
      oStock:cAlbPrvT   := dbfAlbPrvT
      oStock:cAlbPrvL   := dbfAlbPrvL
      oStock:cPedCliT   := dbfPedCliT
      oStock:cPedCliL   := dbfPedCliL
      oStock:cKit       := dbfKit
      oStock:cFacPrvL   := dbfFacPrvL
      oStock:cRctPrvL   := dbfRctPrvL

      oStock:cAlbCliL   := dbfAlbCliL
      oStock:cFacCliL   := dbfFacCliL
      oStock:cFacRecL   := dbfFacRecL
      oStock:cTikL      := dbfTikCliL
      oStock:cProducL   := dbfProLin
      oStock:cProducM   := dbfProMat
      oStock:cHisMov    := dbfHisMov
      end

      oBandera          := TBandera():New()





      oFont             := TFont():New( "Arial", 8, 26, .F., .T. )





      public nTotPed    := 0
      public nTotBrt    := 0
      public nTotDto    := 0
      public nTotDPP    := 0
      public nTotNet    := 0
      public nTotIva    := 0
      public nTotReq    := 0
      public nTotImp    := 0
      public aTotIva    := { { 0,0,nil,0,0,0 }, { 0,0,nil,0,0,0 }, { 0,0,nil,0,0,0 } }
      public aIvaUno    := aTotIva[ 1 ]
      public aIvaDos    := aTotIva[ 2 ]
      public aIvaTre    := aTotIva[ 3 ]





      if oUser():lFiltroVentas()
         cFiltroUsuario    := "Field->cCodUsr == '" + oUser():cCodigo() + "' .and. Field->cCodCaj == '" + oUser():cCaja() + "'"
      end

      EnableAcceso()

   RECOVER

      lOpenFiles        := .F.

      EnableAcceso()

      MsgStop( "Imposible abrir ficheros de pedidos a proveedores" )

   end

   ErrorBlock( oBlock )

   if !lOpenFiles
      CloseFiles()
   end

RETURN ( lOpenFiles )



STATIC FUNCTION CloseFiles()

   DisableAcceso()

   DestroyFastFilter( dbfPedPrvT, .T., .T. )

   if !Empty( dbfPedPrvT )
      ( dbfPedPrvT )->( dbCloseArea() )
   end

   if !Empty( oFont )
      oFont:end()
   end

   if dbfPedPrvL <> nil
      ( dbfPedPrvL )->( dbCloseArea() )
   end

   if !Empty( dbfPedPrvI )
      ( dbfPedPrvI )->( dbCloseArea() )
   end

   if !Empty( dbfPedPrvD )
      ( dbfPedPrvD )->( dbCloseArea() )
   end

   if !Empty( dbfPedCliR )
      ( dbfPedCliR )->( dbCloseArea() )
   end

   if dbfAlbPrvT <> nil
      ( dbfAlbPrvT )->( dbCloseArea() )
   end

   if dbfAlbPrvL <> nil
      ( dbfAlbPrvL )->( dbCloseArea() )
   end

   if dbfPrv <> nil
      ( dbfPrv )->( dbCloseArea() )
   end

   if dbfIva <> nil
      ( dbfIva )->( dbCloseArea() )
   end

   if dbfFPago <> nil
      ( dbfFPago )->( dbCloseArea() )
   end

   if dbfDiv <> nil
      ( dbfDiv )->( dbCloseArea() )
   end

   if dbfArtPrv <> nil
      ( dbfArtPrv )->( dbCloseArea() )
   end

   if dbfArtCom <> nil
      ( dbfArtCom )->( dbCloseArea() )
   end

   if dbfArticulo <> nil
      ( dbfArticulo )->( dbCloseArea() )
   end

   if dbfCodebar <> nil
      ( dbfCodebar )->( dbCloseArea() )
   end

   if dbfFamilia <> nil
      ( dbfFamilia )->( dbCloseArea() )
   end

   if dbfAlm <> nil
      ( dbfAlm )->( dbCloseArea() )
   end

   if dbfKit <> nil
      ( dbfKit )->( dbCloseArea() )
   end

   if dbfTblCnv <> nil
      ( dbfTblCnv )->( dbCloseArea() )
   end

   if dbfDoc <> nil
      ( dbfDoc )->( dbCloseArea() )
   end

   if dbfPro <> nil
      ( dbfPro   )->( dbCloseArea() )
   end

   if dbfTblPro <> nil
      ( dbfTblPro)->( dbCloseArea() )
   end

   if dbfCajT <> nil
      ( dbfCajT )->( dbCloseArea() )
   end

   if dbfUsr <> nil
      ( dbfUsr )->( dbCloseArea() )
   end

   if dbfInci <> nil
      ( dbfInci )->( dbCloseArea() )
   end

   if dbfDelega <> nil
      ( dbfDelega )->( dbCloseArea() )
   end

   if dbfFlt <> nil
      ( dbfFlt )->( dbCloseArea() )
   end

   if dbfPedCliT <> nil
      ( dbfPedCliT )->( dbCloseArea() )
   end

   if dbfPedCliL <> nil
      ( dbfPedCliL )->( dbCloseArea() )
   end

   if dbfCount <> nil
      ( dbfCount )->( dbCloseArea() )
   end

   if dbfEmp <> nil
      ( dbfEmp )->( dbCloseArea() )
   end

   if dbfFacPrvL <> nil
      ( dbfFacPrvL )->( dbCloseArea() )
   end

   if dbfRctPrvL <> nil
      ( dbfRctPrvL )->( dbCloseArea() )
   end

   if dbfAlbCliL <> nil
      ( dbfAlbCliL )->( dbCloseArea() )
   end

   if dbfFacCliL <> nil
      ( dbfFacCliL )->( dbCloseArea() )
   end

   if dbfFacRecL <> nil
      ( dbfFacRecL )->( dbCloseArea() )
   end

   if dbfTikCliL <> nil
      ( dbfTikCliL )->( dbCloseArea() )
   end

   if dbfProLin <> nil
      ( dbfProLin )->( dbCloseArea() )
   end

   if dbfProMat <> nil
      ( dbfProMat )->( dbCloseArea() )
   end

   if dbfHisMov <> nil
      ( dbfHisMov )->( dbCloseArea() )
   end

   if dbfSitua <> nil
      ( dbfSitua )->( dbCloseArea() )
   end

   if oStock <> nil
      oStock:end()
   end

   if !Empty( oUndMedicion )
      oUndMedicion:end()
   end

   dbfPedPrvT  := nil
   dbfPedPrvL  := nil
   dbfPedPrvI  := nil
   dbfPrv      := nil
   dbfIva      := nil
   dbfFPago    := nil
   dbfDiv      := nil
   dbfKit      := nil
   dbfArticulo := nil
   dbfCodebar  := nil
   dbfFamilia  := nil
   dbfAlm      := nil
   dbfUsr      := Nil
   dbfCajT     := nil
   oStock      := nil
   oBandera    := nil
   dbfInci     := nil
   dbfPedCliR  := nil
   dbfDelega   := nil
   dbfFlt      := nil
   dbfPedCliT  := nil
   dbfPedCliL  := nil
   dbfCount    := nil
   dbfEmp      := nil
   dbfFacPrvL  := nil
   dbfRctPrvL  := nil
   dbfAlbCliL  := nil
   dbfFacCliL  := nil
   dbfFacRecL  := nil
   dbfTikCliL  := nil
   dbfProLin   := nil
   dbfProMat   := nil
   dbfHisMov   := nil
   dbfSitua    := nil

   lOpenFiles  := .F.

   oWndBrw     := nil

   EnableAcceso()

RETURN .T.



FUNCTION PedPrv( oMenuItem, oWnd, cCodPrv, cCodArt )

   local oPrv
   local oImp
   local oSnd
   local oDel
   local oRpl
   local oPdf
   local oMail
   local oRotor
   local oBtnEur
   local nLevel
   local lEuro          := .F.

   IIF( oMenuItem == nil, oMenuItem := "01046", ) ;
   IIF( oWnd == nil, oWnd := oWnd(), ) ;
   IIF( cCodPrv == nil, cCodPrv := "", ) ;
   IIF( cCodArt == nil, cCodArt := "", ) ;





   nLevel               := nLevelUsr( oMenuItem )
   if nAnd( nLevel, 1 ) <> 0
      msgStop( "Acceso no permitido." )
      return .F.
   end





   if oWnd <> nil
      SysRefresh(); oWnd:CloseAll(); SysRefresh()
   end

   if !OpenFiles()
      return .F.
   end

   DisableAcceso()


















   oWndBrw := TShell():New( 0, 0, 22, 80, "Pedidos a proveedores",, oWnd,,, .F.,,, ( dbfPedPrvT ),,,,, {"Número", "Fecha", "Entrada", "Código", "Nombre proveedor"}, {||( WinAppRec( oWndBrw:oBrw, bEdtRec, dbfPedPrvT, cCodPrv, cCodArt ) )}, {||( WinEdtRec( oWndBrw:oBrw, bEdtRec, dbfPedPrvT, cCodPrv, cCodArt ) )}, {||( WinDelRec( oWndBrw:oBrw, dbfPedPrvT, {|| QuiPedPrv() } ) )}, {||( WinDupRec( oWndBrw:oBrw, bEdtRec, dbfPedPrvT, cCodPrv, cCodArt ) )}, nil, nLevel, "Clipboard_empty_businessman_16", ( 0 + ( 114 * 256 ) + ( 198 * 65536 ) ),, {||( WinZooRec( oWndBrw:oBrw, bEdtRec, dbfPedPrvT ) )}, .T. )

      oWndBrw:lFechado     := .T.
      oWndBrw:bChgIndex    := {|| if( oUser():lFiltroVentas(), CreateFastFilter( cFiltroUsuario, dbfPedPrvT, .F., , cFiltroUsuario ), CreateFastFilter( "", dbfPedPrvT, .F. ) ) }
      oWndBrw:SetYearComboBoxChange( {|| YearComboBoxChange() } )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Sesión cerrada"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfPedPrvT )->lCloPed }
         :nWidth           := 20
         :lHide            := .T.
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "Zoom16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Envio"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfPedPrvT )->lSndDoc }
         :nWidth           := 20
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "Lbl16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Estado"
         :nHeadBmpNo       := 4
         :bStrData         := {|| "" }
         :bBmpData         := {|| Max( ( dbfPedPrvT )->nEstado, 1 ) }
         :nWidth           := 20
         :AddResource( "Bullet_Square_Red_16" )
         :AddResource( "Bullet_Square_Yellow_16" )
         :AddResource( "Bullet_Square_Green_16" )
         :AddResource( "trafficlight_on_16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Incidencia"
         :nHeadBmpNo       := 4
         :bStrData         := {|| "" }
         :bBmpData         := {|| nEstadoIncidencia( ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed ) }
         :nWidth           := 20
         :lHide            := .T.
         :AddResource( "Bullet_Square_Red_16" )
         :AddResource( "Bullet_Square_Yellow_16" )
         :AddResource( "Bullet_Square_Green_16" )
         :AddResource( "Informacion_16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Impreso"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfPedPrvT )->lImprimido }
         :nWidth           := 20
         :lHide            := .T.
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "IMP16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Número"
         :cSortOrder       := "nNumPed"
         :bEditValue       := {|| ( dbfPedPrvT )->cSerPed + "/" + Alltrim( Str( ( dbfPedPrvT )->nNumPed ) ) + "/" + ( dbfPedPrvT )->cSufPed }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Delegación"
         :bEditValue       := {|| ( dbfPedPrvT )->cCodDlg }
         :nWidth           := 60
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Sesión"
         :bEditValue       := {|| Trans( ( dbfPedPrvT )->cTurPed, "######" ) }
         :nWidth           := 60
         :lHide            := .T.
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Fecha"
         :cSortOrder       := "dFecPed"
         :bEditValue       := {|| Dtoc( ( dbfPedPrvT )->dFecPed ) }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Caja"
         :bEditValue       := {|| ( dbfPedPrvT )->cCodCaj }
         :nWidth           := 40
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Usuario"
         :bEditValue       := {|| ( dbfPedPrvT )->cCodUsr }
         :nWidth           := 40
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Entrada"
         :cSortOrder       := "dFecEnt"
         :bEditValue       := {|| Dtoc( ( dbfPedPrvT )->dFecEnt ) }
         :nWidth           := 80
         :lHide            := .T.
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Situación"
         :cSortOrder       := "cSituac"
         :bEditValue       := {|| ( dbfPedPrvT )->cSituac }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodPrv"
         :bEditValue       := {|| ( dbfPedPrvT )->cCodPrv }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Nombre proveedor"
         :cSortOrder       := "cNomPrv"
         :bEditValue       := {|| ( dbfPedPrvT )->cNomPrv }
         :nWidth           := 180
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Base"
         :bEditValue       := {|| ( dbfPedPrvT )->nTotNet }
         :cEditPicture     := cPirDiv( ( dbfPedPrvT )->cDivPed, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := cImp()
         :bEditValue       := {|| ( dbfPedPrvT )->nTotIva }
         :cEditPicture     := cPirDiv( ( dbfPedPrvT )->cDivPed, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "R.E."
         :bEditValue       := {|| ( dbfPedPrvT )->nTotReq }
         :cEditPicture     := cPirDiv( ( dbfPedPrvT )->cDivPed, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Total"
         :bEditValue       := {|| ( dbfPedPrvT )->nTotPed }
         :cEditPicture     := cPirDiv( ( dbfPedPrvT )->cDivPed, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Div."
         :bEditValue       := {|| cSimDiv( if( lEuro, cDivChg(), ( dbfPedPrvT )->cDivPed ), dbfDiv ) }
         :nWidth           := 30
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Cliente"
         :bEditValue       := {|| if( !Empty( ( dbfPedPrvT )->cNumPedCli ), AllTrim( GetCodCli( ( dbfPedPrvT )->cNumPedCli ) ) + " - " + AllTrim( GetNomCli( ( dbfPedPrvT )->cNumPedCli ) ), "" ) }
         :nWidth           := 280
         :lHide            := .T.
      end

      oWndBrw:cHtmlHelp    := "Pedido a proveedor"

      oWndBrw:CreateXFromCode()





   oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

   oWndBrw:AddSeaBar()








   oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )






   oWndBrw:NewAt( "DUP",,, {||( oWndBrw:RecDup() )}, "(D)uplicar", "D",,, 2,, .F. )






   oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )






   oWndBrw:NewAt( "ZOOM",,, {||( oWndBrw:RecZoom() )}, "(Z)oom", "Z",,, 8,, .F. )







   oDel := oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",, {|This|This:Toggle()}, 16,, .F. )







   oPrv := oWndBrw:NewAt( "IMP",,, {||( GenPedPrv( 1 ) )}, "(I)mprimir", "I",, {|This|This:Toggle()}, 32,, .F. )


      lGenPed( oWndBrw:oBrw, oPrv, 1 )





   oWndBrw:NewAt( "SERIE1",,, {||( PrnSerie( oWndBrw:oBrw), oWndBrw:Refresh() )}, "Imp(r)imir series", "R",,, 32,, .F. )







   oImp := oWndBrw:NewAt( "PREV1",,, {||( GenPedPrv( 2 ), oWndBrw:Refresh() )}, "(P)revisualizar", "P",, {|This|This:Toggle()}, 32,, .F. )


      lGenPed( oWndBrw:oBrw, oImp, 2 )






   oPdf := oWndBrw:NewAt( "DOCLOCK",,, {||( GenPedPrv( 3 ) )}, "Pd(f)", "F",, {|This|This:Toggle()}, 32,, .F. )


      lGenPed( oWndBrw:oBrw, oPdf, 3 )





   oMail := oWndBrw:NewAt( "Mail",,, {||( GenPedPrv( 6 ) )}, "Correo electrónico",,, {|This|This:Toggle()}, 32,, .F. )


      lGenPed( oWndBrw:oBrw, oMail, 6 )
   if oUser():lAdministrador()






      oWndBrw:NewAt( "ChgState",,, {||( ChgState( oWndBrw:oBrw ) )}, "Cambiar Es(t)ado", "T",,, 4,, .F. )

   end








   oSnd := oWndBrw:NewAt( "Lbl",, "Seleccionar pedidos para ser enviados", {||lSnd( oWndBrw, dbfPedPrvT )}, "En(v)iar", "V",, {|This|This:Toggle()}, 4,, .F. )






   oBtnEur := oWndBrw:NewAt( "BAL_EURO",,, {||( lEuro := !lEuro, oWndBrw:Refresh() )}, "M(o)neda", "O",,,,, .F. )
   if oUser():lAdministrador()






      oRpl := oWndBrw:NewAt( "BMPCHG",,, {||( TDlgFlt():New( aItmPedPrv(), dbfPedPrvT ):ChgFields(), oWndBrw:Refresh() )}, "Cambiar campos",,, {|This|This:Toggle()}, 4,, .F. )







         oWndBrw:NewAt( "BMPCHG",,, {||( TDlgFlt():New( aColPedPrv(), dbfPedPrvL ):ChgFields(), oWndBrw:Refresh() )}, "Lineas",,,, 4, oRpl, .F. )

   end






   oWndBrw:NewAt( "SHOPPINGCART",,, {||( Generador( oWndBrw:oBrw ) )}, "(G)enerar", "G",,,,, .F. )





   oWndBrw:NewAt( "INFO",,, {||( TTrazaDocumento():Activate( "01", ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed ) )}, "I(n)forme documento", "N",,, 4,, .F. )






   oRotor := oWndBrw:NewAt( "ROTOR",,, {||( oRotor:Expand() )}, "Rotor",,, {|This|This:Toggle()}, 4,, .F. )







      oWndBrw:NewAt( "BUSINESSMAN_",,, {||( EdtPrv( ( dbfPedPrvT )->cCodPrv ) )}, "Modificar proveedor",,,, 4, oRotor, .T. )







      oWndBrw:NewAt( "INFO",,, {||( InfProveedor( ( dbfPedPrvT )->cCodPrv ) )}, "Informe proveedor",,,, 4, oRotor, .F. )






      oWndBrw:NewAt( "DOCUMENT_PLAIN_BUSINESSMAN_",,, {||( if( ( dbfPedPrvT )->nEstado == 3, MsgStop( "Pedido recibido" ), AlbPrv( nil, oWnd, nil, nil, ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed ) ) )}, "Generar albarán",,,, 4, oRotor, .T. )





      oWndBrw:NewAt( "DOCUMENT_PLAIN_BUSINESSMAN_",,, {||( Ped2Alb( ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed ) )}, "Modificar albarán",,,, 4, oRotor, .F. )





   oWndBrw:NewAt( "END",,, {||( oWndBrw:End() )}, "(S)alir", "S",,,,, .F. )

   if !oUser():lFiltroVentas()
      oWndBrw:oActiveFilter:aTField       := aItmPedPrv()
      oWndBrw:oActiveFilter:cDbfFilter    := dbfFlt
      oWndBrw:oActiveFilter:cTipFilter    := "01"
   end

   oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp )

   EnableAcceso()

   if !Empty( cCodPrv ) .OR. !Empty( cCodArt )

      if !Empty( oWndBrw )
         oWndBrw:RecAdd()
      end

      cCodPrv  := nil
      cCodArt  := nil

   end

Return .T.



STATIC FUNCTION EdtRec( aTmp, aGet, dbfPedPrvT, oBrw, cCodPrv, cCodArt, nMode )

    local oDlg
   local oFld
   local oBrwLin
   local oBrwInc
   local oBrwDoc
   local oSay        := Array( 5 )
   local cSay        := Array( 5 )
   local oSayLabels  := Array( 7 )
   local oBmpDiv
   local oBmpEmp
   local cEstPed
   local oGetMasDiv
   local cGetMasDiv  := ""
   local cTlfPrv
   local oTlfPrv
   local oPedCli
   local oCodCli
   local oNomCli
   local cCodCli     := GetCodCli( aTmp[38] )
   local cNomCli     := GetNomCli( aTmp[38] )
   local oBmpGeneral





   cOldCodCli        := aTmp[ 6 ]
   cPicUnd           := MasUnd()

   do case
   case nMode  == 1

      if !lCajaOpen( oUser():cCaja() ) .AND. !oUser():lAdministrador()
         msgStop( "Esta caja " + oUser():cCaja() + " esta cerrada." )
         Return .F.
      end

      aTmp[ 1 ]  := cNewSer( "nPedPrv" )
      aTmp[ 4 ]  := cCurSesion()
      aTmp[ 8 ]  := oUser():cCaja()
      aTmp[ 7 ]  := oUser():cAlmacen()
      aTmp[ 29 ]  := cDivEmp()
      aTmp[ 30 ]  := nChgDiv( aTmp[ 29 ], dbfDiv )
      aTmp[ 3 ]  := RetSufEmp()
      aTmp[ 31 ]  := .T.
      aTmp[ 16 ]  := 1
      aTmp[ 37 ]  := cCurUsr()
      aTmp[ 44 ]  := oUser():cDelegacion()
      if !Empty( cCodPrv )
         aTmp[ 6 ]  := cCodPrv
      end

   case nMode == 4
      if !lCajaOpen( oUser():cCaja() ) .AND. !oUser():lAdministrador()
         msgStop( "Esta caja " + oUser():cCaja() + " esta cerrada." )
         Return .F.
      end

      aTmp[ 4 ]  := cCurSesion()
      aTmp[ 8 ]  := oUser():cCaja()
      aTmp[ 31 ]  := .T.
      aTmp[ 36 ]  := .F.
      aTmp[ 16 ]  := 1

   case nMode == 2

      if aTmp[ 16 ] == 3
         msgStop( "El pedido ya fue recibido." )
         Return .F.
      end

      if aTmp[ 36 ] .AND. !oUser():lAdministrador()
         msgStop( "Solo puede modificar los pedidos cerrados los administradores." )
         Return .F.
      end

   end





   if BeginTrans( aTmp, nMode )
      Return .F.
   end

   if aTmp[ 16 ] == 0
      aTmp[ 16 ]  := 1
   end

   do case
   case  aTmp[ 16 ] == 1
      cEstPed           := "Pendiente"
   case  aTmp[ 16 ] == 2
      cEstPed           := "Parcial"
   case  aTmp[ 16 ] == 3
      cEstPed           := "Recibido"
   end

   if Empty( aTmp[ 21 ] )
      aTmp[ 21 ]  := Padr( "General", 50 )
   end

   if Empty( aTmp[ 23 ] )
      aTmp[ 23 ]     := Padr( "Pronto pago", 50 )
   end





   cSay[ 1 ]            := RetFld( aTmp[ 7 ], dbfAlm )
   cSay[ 2 ]            := RetFld( aTmp[ 18 ], dbfFPago )
   cSay[ 3 ]            := RetFld( aTmp[ 8 ], dbfCajT )
   cSay[ 4 ]            := RetFld( aTmp[ 6 ], dbfPrv )
   cTlfPrv              := RetFld( aTmp[ 6 ], dbfPrv, "Telefono" )
   cUsr                 := RetFld( aTmp[ 37 ], dbfUsr, "cNbrUse" )
   cSay[ 5 ]            := RetFld( cCodEmp() + aTmp[ 44 ], dbfDelega, "cNomDlg" )

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "pedidos a proveedores", "PEDPRV",, .F.,,,,,, .F.,,,,,, .F., )



        oFld := TFolder():ReDefine( 400, {"&Pedido",  "Da&tos",   "&Incidencias",   "D&ocumentos"}, { "PEDPRV_1","PEDPRV_2","PEDCLI_3","PEDCLI_4" }, oDlg,,,,, .F., )







      aGet[ 37 ] := TGetHlp():ReDefine( 215, { | u | If( PCount()==0, aTmp[ 37 ], aTmp[ 37 ]:= u ) }, oFld:aDialogs[2],,, {||    ( SetUsuario( aGet[ 37 ], oUsr, nil, dbfUsr ) )},,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )




      oUsr := TGetHlp():ReDefine( 216, { | u | If( PCount()==0, cUsr, cUsr:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )







      oBmpGeneral := TBitmap():ReDefine( 990, "pedidos_proveedores_48_alpha",, oFld:aDialogs[1],,, .F., .F.,,, .F.,,, .T. )





      oBmpGeneral := TBitmap():ReDefine( 990, "folder2_red_alpha_48",, oFld:aDialogs[2],,, .F., .F.,,, .F.,,, .T. )





      oBmpGeneral := TBitmap():ReDefine( 990, "information_48_alpha",, oFld:aDialogs[3],,, .F., .F.,,, .F.,,, .T. )





      oBmpGeneral := TBitmap():ReDefine( 990, "address_book2_alpha_48",, oFld:aDialogs[4],,, .F., .F.,,, .F.,,, .T. )









      aGet[6] := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTmp[6], aTmp[6]:= u ) }, oFld:aDialogs[1],, ( RetPicCodPrvEmp() ), {||    ( LoaPrv( aGet, aTmp, dbfPrv, nMode, oSay[ 4 ], oTlfPrv ) )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwProvee( aGet[6], oSay[ 4 ] ) )}, nil, "LUPA",, )





      aGet[9] := TGetHlp():ReDefine( 141, { | u | If( PCount()==0, aTmp[ 9 ], aTmp[ 9 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[14] := TGetHlp():ReDefine( 145, { | u | If( PCount()==0, aTmp[14], aTmp[14]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )




      oTlfPrv := TGetHlp():ReDefine( 146, { | u | If( PCount()==0, cTlfPrv, cTlfPrv:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )






      aGet[ 10 ] := TGetHlp():ReDefine( 142, { | u | If( PCount()==0, aTmp[ 10 ], aTmp[ 10 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|GoogleMaps( aTmp[ 10 ], Rtrim( aTmp[ 11 ] ) + Space( 1 ) + Rtrim( aTmp[ 12 ] ) )}, nil, "Environnment_View_16",, )





      aGet[ 13 ] := TGetHlp():ReDefine( 143, { | u | If( PCount()==0, aTmp[ 13 ], aTmp[ 13 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 11 ] := TGetHlp():ReDefine( 144, { | u | If( PCount()==0, aTmp[ 11 ], aTmp[ 11 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 12 ] := TGetHlp():ReDefine( 147, { | u | If( PCount()==0, aTmp[ 12 ], aTmp[ 12 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )








        aGet[7] := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, aTmp[7], aTmp[7]:= u ) }, oFld:aDialogs[1],,, {||    ( cAlmacen( aGet[7], dbfAlm, oSay[ 1 ] ) )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwAlmacen( aGet[7], oSay[ 1 ] ) )}, nil, "LUPA",, )





      oSay[ 1 ] := TGetHlp():ReDefine( 151, { | u | If( PCount()==0, cSay[ 1 ], cSay[ 1 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )








      aGet[18] := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, aTmp[18], aTmp[18]:= u ) }, oFld:aDialogs[1],, "@!", {||    cFPago( aGet[18], dbfFPago, oSay[ 2 ] )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|BrwFPago( aGet[18 ], oSay[ 2 ])}, nil, "LUPA",, )





      oSay[ 2 ] := TGetHlp():ReDefine( 161, { | u | If( PCount()==0, cSay[ 2 ], cSay[ 2 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )












      aGet[ 8 ] := TGetHlp():ReDefine( 165, { | u | If( PCount()==0, aTmp[ 8 ], aTmp[ 8 ]:= u ) }, oFld:aDialogs[1],,, {||    cCajas( aGet[ 8 ], dbfCajT, oSay[ 3 ] )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwCajas( aGet[ 8 ], oSay[ 3 ] ) )}, nil, "LUPA",, )





      oSay[ 3 ] := TGetHlp():ReDefine( 166, { | u | If( PCount()==0, cSay[ 3 ], cSay[ 3 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )













        aGet[ 29 ] := TGetHlp():ReDefine( 170, { | u | If( PCount()==0, aTmp[ 29 ], aTmp[ 29 ]:= u ) }, oFld:aDialogs[1],, "@!", {||    ( cDivIn( aGet[ 29 ], oBmpDiv, aGet[ 30 ], @cPinDiv, @nDinDiv, @cPirDiv, @nDirDiv, oGetMasDiv, dbfDiv, oBandera ) )}, "N/W*",,,,, .F., {||     ( nMode == 1 .AND. ( dbfTmpLin )->( LastRec() ) == 0 )},, .F., .F.,,,,, {|Self|BrwDiv( aGet[ 29 ], oBmpDiv, aGet[ 30 ], dbfDiv, oBandera )}, nil, "LUPA",, )




        oBmpDiv := TBitmap():ReDefine( 171, "BAN_EURO",, oFld:aDialogs[1],,, .F., .F.,,, .F.,,, .F. )






        aGet[ 30 ] := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, aTmp[ 30 ], aTmp[ 30 ]:= u ) }, oFld:aDialogs[1],, "@E 999,999.9999",, "N/W*",,,,, .F., {||         ( .F. )},, .F., .F.,,,,,, nil,,, )









      oBmpEmp := TBitmap():ReDefine( 500,, "Bmp\ImgPedPrv.bmp", oDlg,,, .F., .F.,,, .F.,,, .F. )








      oBrwLin                 := IXBrowse():New( oFld:aDialogs[1] )

      oBrwLin:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwLin:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwLin:cAlias          := dbfTmpLin

      oBrwLin:nMarqueeStyle   := 6
      oBrwLin:cName           := "Lineas de pedidos a proveedor"

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Número"
            :bStrData         := {|| "" }
            :bEditValue       := {|| if( ( dbfTmpLin )->lKitChl, "", Trans( ( dbfTmpLin )->nNumLin, "9999" ) ) }
            :nWidth           := 65
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Es. Estado"
            :bStrData         := {|| "" }
            :bBmpData         := {|| nTotRecibido( dbfTmpLin, dbfAlbPrvL ) }
            :nWidth           := 20
            :AddResource( "Bullet_Square_Red_16" )
            :AddResource( "Bullet_Square_Yellow_16" )
            :AddResource( "Bullet_Square_Green_16" )
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Código"
            :bEditValue       := {|| ( dbfTmpLin )->cRef }
            :nWidth           := 80
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "C. Barras"
            :bEditValue       := {|| cCodigoBarrasDefecto( ( dbfTmpLin )->cRef, dbfCodeBar ) }
            :nWidth           := 100
            :lHide            := .T.
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Código proveedor"
            :bEditValue       := {|| ( dbfTmpLin )->cRefPrv }
            :nWidth           := 80
            :lHide            := .T.
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Descripción"
            :bEditValue       := {|| if( Empty( ( dbfTmpLin )->cRef ), ( dbfTmpLin )->mLngDes, ( dbfTmpLin )->cDetalle ) }
            :nWidth           := 280
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Prop. 1"
            :bEditValue       := {|| ( dbfTmpLin )->cValPr1 }
            :nWidth           := 60
            :lHide            := .T.
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Prop. 2"
            :bEditValue       := {|| ( dbfTmpLin )->cValPr2 }
            :nWidth           := 60
            :lHide            := .T.
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Lote"
            :bEditValue       := {|| ( dbfTmpLin )->cLote }
            :nWidth           := 80
            :lHide            := .T.
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := cNombreUnidades()
            :bEditValue       := {|| nTotNPedPrv( dbfTmpLin ) }
            :cEditPicture     := cPicUnd
            :nWidth           := 60
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "UM. Unidad de medición"
            :bEditValue       := {|| ( dbfTmpLin )->cUnidad }
            :nWidth           := 25
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Almacen"
            :bEditValue       := {|| ( dbfTmpLin )->cAlmLin }
            :nWidth           := 60
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Importe"
            :bEditValue       := {|| nTotUPedPrv( dbfTmpLin, nDinDiv ) }
            :cEditPicture     := cPinDiv
            :nWidth           := 90
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "% Dto."
            :bEditValue       := {|| ( dbfTmpLin )->nDtoLin }
            :cEditPicture     := "@E 999.99"
            :nWidth           := 50
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "% Prm."
            :bEditValue       := {|| ( dbfTmpLin )->nDtoPrm }
            :cEditPicture     := "@E 999.99"
            :nWidth           := 40
            :lHide            := .T.
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "% " + cImp()
            :bEditValue       := {|| ( dbfTmpLin )->nIva }
            :cEditPicture     := "@E 999.99"
            :nWidth           := 50
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         with object ( oBrwLin:AddCol() )
            :cHeader          := "Total"
            :bEditValue       := {|| nTotLPedPrv( dbfTmpLin, nDinDiv, nDirDiv ) }
            :cEditPicture     := cPirDiv
            :nWidth           := 80
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end

         if nMode <> 3
            oBrwLin:bLDblClick   := {|| EdtDeta( oBrwLin, bEdtDet, aTmp ) }
         end

         oBrwLin:CreateFromResource( 190 )





        TButton():ReDefine( 500, {||( AppDeta( oBrwLin, bEdtDet, aTmp ) )}, oFld:aDialogs[1],,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 501, {||( EdtDeta( oBrwLin, bEdtDet, aTmp ) )}, oFld:aDialogs[1],,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 502, {||( WinDelRec( oBrwLin, dbfTmpLin, {|| delDeta() }, {|| RecalculaTotal( aTmp ) } ) )}, oFld:aDialogs[1],,, .F., {||         ( nMode <> 3 )},,, .F. )




        TButton():ReDefine( 503, {||( EdtZoom( oBrwLin, bEdtDet, aTmp ) )}, oFld:aDialogs[1],,, .F.,,,, .F. )





        TButton():ReDefine( 524, {||( DbSwapUp( dbfTmpLin, oBrwLin ) )}, oFld:aDialogs[1],,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 525, {||( DbSwapDown( dbfTmpLin, oBrwLin ) )}, oFld:aDialogs[1],,, .F., {||         ( nMode <> 3 )},,, .F. )









      aGet[ 21 ] := TGetHlp():ReDefine( 199, { | u | If( PCount()==0, aTmp[ 21 ], aTmp[ 21 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .F.,,,,,, nil,,, )








        aGet[ 22 ] := TGetHlp():ReDefine( 200, { | u | If( PCount()==0, aTmp[ 22 ], aTmp[ 22 ]:= u ) }, oFld:aDialogs[1],, "@E 999.99",, "N/W*",,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )





      aGet[ 23 ] := TGetHlp():ReDefine( 209, { | u | If( PCount()==0, aTmp[ 23 ], aTmp[ 23 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .F.,,,,,, nil,,, )








        aGet[ 24 ] := TGetHlp():ReDefine( 210, { | u | If( PCount()==0, aTmp[ 24 ], aTmp[ 24 ]:= u ) }, oFld:aDialogs[1],, "@E 999.99",, "N/W*",,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )






      aGet[ 32 ] := TGetHlp():ReDefine( 240, { | u | If( PCount()==0, aTmp[ 32 ], aTmp[ 32 ]:= u ) }, oFld:aDialogs[1],, "@!",, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )








      aGet[ 33 ] := TGetHlp():ReDefine( 250, { | u | If( PCount()==0, aTmp[ 33 ], aTmp[ 33 ]:= u ) }, oFld:aDialogs[1],, "@E 99.99",, "N/W*",,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )






      aGet[ 34 ] := TGetHlp():ReDefine( 260, { | u | If( PCount()==0, aTmp[ 34 ], aTmp[ 34 ]:= u ) }, oFld:aDialogs[1],, "@!",, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )








      aGet[ 35 ] := TGetHlp():ReDefine( 270, { | u | If( PCount()==0, aTmp[ 35 ], aTmp[ 35 ]:= u ) }, oFld:aDialogs[1],, "@E 99.99",, "N/W*",,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .T.,,,,,, nil,,, )





      oBrwIva                        := TXBrowse():New( oFld:aDialogs[ 1 ] )

      oBrwIva:bClrSel                := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwIva:bClrSelFocus           := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwIva:SetArray( aTotIva )

      oBrwIva:lHScroll               := .F.
      oBrwIva:lVScroll               := .F.
      oBrwIva:nMarqueeStyle          := 5
      oBrwIva:lRecordSelector        := .F.

      oBrwIva:CreateFromResource( 490 )

      with object ( oBrwIva:aCols[ 1 ] )
         :cHeader       := "Bruto"
         :bStrData      := {|| if( !Empty( aTotIva[ oBrwIva:nArrayAt, 1 ] ), Trans( aTotIva[ oBrwIva:nArrayAt, 2 ], cPirDiv ), "" ) }
         :nWidth        := 106
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
         :nFootStrAlign := 1
      end

      with object ( oBrwIva:aCols[ 2 ] )
         :cHeader       := "Base"
         :bStrData      := {|| if( !Empty( aTotIva[ oBrwIva:nArrayAt, 2 ] ), Trans( aTotIva[ oBrwIva:nArrayAt, 2 ], cPirDiv ), "" ) }
         :nWidth        := 106
         :cEditPicture  := cPirDiv
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
         :nFootStrAlign := 1
      end

      with object ( oBrwIva:aCols[ 3 ] )
         :cHeader       := "%" + cImp()
         :bStrData      := {|| if( !IsNil( aTotIva[ oBrwIva:nArrayAt, 3 ] ), aTotIva[ oBrwIva:nArrayAt, 3 ], "" ) }
         :bEditValue    := {|| aTotIva[ oBrwIva:nArrayAt, 3 ] }
         :nWidth        := 55
         :cEditPicture  := "@E 999.99"
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
         :nFootStrAlign := 1
         :nEditType     := 1
         :bEditWhen     := {|| !IsNil( aTotIva[ oBrwIva:nArrayAt, 3 ] ) }
         :bOnPostEdit   := {|o,x| EdtIva( o, x, aTotIva[ oBrwIva:nArrayAt, 3 ], dbfTmp, dbfIva, oBrwLin ), RecalculaTotal( aTmp ) }
      end

      with object ( oBrwIva:aCols[ 4 ] )
         :cHeader       := "%R.E."
         :bStrData      := {|| if( !Empty( aTotIva[ oBrwIva:nArrayAt, 4 ] ) .AND. aTmp[ 25 ], Trans( aTotIva[ oBrwIva:nArrayAt, 4 ], "@E 99.9" ), "" ) }
         :nWidth        := 55
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
         :nFootStrAlign := 1
      end

      with object ( oBrwIva:aCols[ 5 ] )
         :cHeader       := cImp()
         :bStrData      := {|| if( !Empty( aTotIva[ oBrwIva:nArrayAt, 5 ] ), Trans( aTotIva[ oBrwIva:nArrayAt, 5 ], cPirDiv ), "" ) }
         :nWidth        := 80
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
         :nFootStrAlign := 1
      end

      with object ( oBrwIva:aCols[ 6 ] )
         :cHeader       := "R.E."
         :bStrData      := {|| if( !Empty( aTotIva[ oBrwIva:nArrayAt, 6 ] ) .AND. aTmp[ 25 ], Trans( aTotIva[ oBrwIva:nArrayAt, 6 ], cPirDiv ), "" ) }
         :nWidth        := 80
         :cEditPicture  := cPirDiv
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
      end








        oGetNet := TSay():ReDefine( 370, {|| nGetNeto}, oFld:aDialogs[1],,,, .F.,, .F., .F. )



        oGetIva := TSay():ReDefine( 380, {|| nGetIva}, oFld:aDialogs[1],,,, .F.,, .F., .F. )



        oGetReq := TSay():ReDefine( 390, {|| nGetReq}, oFld:aDialogs[1],,,, .F.,, .F., .F. )





      aGet[ 25 ] := TCheckBox():ReDefine( 400, { | u | If( PCount()==0, aTmp[ 25 ], aTmp[ 25 ]:= u ) }, oFld:aDialogs[1],, {||( RecalculaTotal( aTmp ) )},,,,, .F., {||         ( nMode <> 3 )}, .F. )




      oGetTotal := TSay():ReDefine( 410, {|| nTotPed}, oFld:aDialogs[1],,,, .F., oFont, .F., .F. )




      oGetMasDiv := TSay():ReDefine( 420, {|| cGetMasDiv}, oFld:aDialogs[1],,,, .F., oFont, .F., .F. )










      aGet[ 1 ] := TGetHlp():ReDefine( 690, { | u | If( PCount()==0, aTmp[ 1 ], aTmp[ 1 ]:= u ) }, oFld:aDialogs[1],, "@!", {||    ( aTmp[1] >= "A" .AND. aTmp[1] <= "Z"  )}, "N/W*",,,,, .F., {||     ( nMode == 1 .OR. nMode == 4 )},, .F., .T., {||    ( UpSerie( aGet[1] ) )}, {||  ( DwSerie( aGet[1] ) )},,,, nil,,, )





        aGet[2] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[2], aTmp[2]:= u ) }, oFld:aDialogs[1],, "999999999",,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )




        aGet[3] := TGetHlp():ReDefine( 105, { | u | If( PCount()==0, aTmp[3], aTmp[3]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )






        aGet[5] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[5], aTmp[5]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )




      aGet[16] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, cEstPed, cEstPed:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )






      aGet[15] := TGetHlp():ReDefine( 125, { | u | If( PCount()==0, aTmp[15], aTmp[15]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





      aGet[ 45 ] := TComboBox():ReDefine( 218, { | u | If( PCount()==0, aTmp[ 45 ], aTmp[ 45 ]:= u ) }, ( aSituacion( dbfSitua ) ), oFld:aDialogs[1],,,,,,, .F., {||     ( nMode <> 3 )},,,,, )




      aGet[ 46 ] := TRadMenu():Redefine( { | u | If( PCount()==0, aTmp[ 46 ], aTmp[ 46 ]:= u ) }, oFld:aDialogs[2],, { 270, 271, 272, 273 },,,,, .F., {||     ( .F. )}, )







      aGet[19] := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTmp[19], aTmp[19]:= u ) }, oFld:aDialogs[2],, "@E 999,999",, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )






      aGet[ 44 ] := TGetHlp():ReDefine( 300, { | u | If( PCount()==0, aTmp[ 44 ], aTmp[ 44 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )




      oSay[ 5 ] := TGetHlp():ReDefine( 301, { | u | If( PCount()==0, cSay[ 5 ], cSay[ 5 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )





      aGet[17] := TGetHlp():ReDefine( 235, { | u | If( PCount()==0, aTmp[17], aTmp[17]:= u ) }, oFld:aDialogs[2],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )

      oSayLabels[ 1 ] := TGroup():ReDefine( 700,, oFld:aDialogs[ 1 ],,,, .T. )
      oSayLabels[ 2 ] := TSay():ReDefine( 701,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 3 ] := TSay():ReDefine( 702,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 4 ] := TSay():ReDefine( 703,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 5 ] := TSay():ReDefine( 704,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 6 ] := TSay():ReDefine( 705,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 7 ] := TSay():ReDefine( 706,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )









      aGet[27] := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, aTmp[27], aTmp[27]:= u ) }, oFld:aDialogs[2],,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )










      aGet[28] := TMultiGet():ReDefine( 200, { | u | If( PCount()==0, aTmp[28], aTmp[28]:= u ) }, oFld:aDialogs[2],, "N/W*",,,,, .F., {||         ( nMode <> 3 )}, .F.,, )





      oPedCli := TGetHlp():ReDefine( 230, { | u | If( PCount()==0, aTmp[38], aTmp[38]:= u ) }, oFld:aDialogs[2],, "@R #/#########/##",,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )




      oCodCli := TGetHlp():ReDefine( 210, { | u | If( PCount()==0, cCodCli, cCodCli:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )




      oNomCli := TGetHlp():ReDefine( 220, { | u | If( PCount()==0, cNomCli, cNomCli:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )






      aGet[ 39 ] := TCheckBox():ReDefine( 120, { | u | If( PCount()==0, aTmp[ 39 ], aTmp[ 39 ]:= u ) }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )}, .F. )




      aGet[ 40 ] := TGetHlp():ReDefine( 121, { | u | If( PCount()==0, aTmp[ 40 ], aTmp[ 40 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )},, .F., .F.,,,,,, nil,,, )




      aGet[ 41 ] := TGetHlp():ReDefine( 122, { | u | If( PCount()==0, aTmp[ 41 ], aTmp[ 41 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )},, .F., .F.,,,,,, nil,,, )





      oBrwInc                 := IXBrowse():New( oFld:aDialogs[ 3 ] )

      oBrwInc:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwInc:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwInc:cAlias          := dbfTmpInc

      oBrwInc:nMarqueeStyle   := 5
      oBrwInc:cName           := "Incidencias de pedidos a proveedor"

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Resuelta"
            :bStrData         := {|| "" }
            :bEditValue       := {|| ( dbfTmpInc )->lListo }
            :nWidth           := 65
            :SetCheck( { "Sel16", "Cnt16" } )
         end

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Código"
            :bEditValue       := {|| ( dbfTmpInc )->cCodTip }
            :nWidth           := 80
         end

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Incidencia"
            :bEditValue       := {|| cNomInci( ( dbfTmpInc )->cCodTip, dbfInci ) }
            :nWidth           := 250
         end

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Fecha"
            :bEditValue       := {|| Dtoc( ( dbfTmpInc )->dFecInc ) }
            :nWidth           := 90
         end

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Descripción"
            :bEditValue       := {|| ( dbfTmpInc )->mDesInc }
            :nWidth           := 390
         end

         if nMode <> 3
            oBrwInc:bLDblClick   := {|| WinEdtRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) }
         end

         oBrwInc:CreateFromResource( 210 )







































      TButton():ReDefine( 500, {||( WinAppRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) )}, oFld:aDialogs[ 3 ],,, .F., {||         ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 501, {||( WinEdtRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) )}, oFld:aDialogs[ 3 ],,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 502, {||( DbDelRec( oBrwInc, dbfTmpInc, nil, nil, .T. ) )}, oFld:aDialogs[ 3 ],,, .F., {||         ( nMode <> 3 )},,, .F. )




        TButton():ReDefine( 503, {||( WinZooRec( oBrwInc, bEdtInc, dbfTmpInc ) )}, oFld:aDialogs[ 3 ],,, .F.,,,, .F. )

      oBrwDoc                 := TXBrowse():New( oFld:aDialogs[ 4 ] )

      oBrwDoc:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwDoc:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwDoc:cAlias          := dbfTmpDoc

      oBrwDoc:nMarqueeStyle   := 5
      oBrwDoc:nRowHeight      := 40
      oBrwDoc:nDataLines      := 2

         with object ( oBrwDoc:AddCol() )
            :cHeader          := "Documento"
            :bEditValue       := {|| Rtrim( ( dbfTmpDoc )->cNombre ) + Chr(13)+Chr(10) + Space( 5 ) + Rtrim( ( dbfTmpDoc )->cRuta ) }
            :nWidth           := 885
         end

         if nMode <> 3
            oBrwDoc:bLDblClick   := {|| ShellExecute( oDlg:hWnd, "open", Rtrim( ( dbfTmpDoc )->cRuta ) ) }
         end

         oBrwDoc:CreateFromResource( 210 )





      TButton():ReDefine( 500, {||( WinAppRec( oBrwDoc, bEdtDoc, dbfTmpDoc, nil, nil, aTmp ) )}, oFld:aDialogs[ 4 ],,, .F., {||         ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 501, {||( WinEdtRec( oBrwDoc, bEdtDoc, dbfTmpDoc, nil, nil, aTmp ) )}, oFld:aDialogs[ 4 ],,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 502, {||( DbDelRec( oBrwDoc, dbfTmpDoc, nil, nil, .F. ) )}, oFld:aDialogs[ 4 ],,, .F., {||         ( nMode <> 3 )},,, .F. )




        TButton():ReDefine( 503, {||( WinZooRec( oBrwDoc, bEdtDoc, dbfTmpDoc ) )}, oFld:aDialogs[ 4 ],,, .F.,,,, .F. )




      TButton():ReDefine( 504, {||( ShellExecute( oDlg:hWnd, "open", Rtrim( ( dbfTmpDoc )->cRuta ) ) )}, oFld:aDialogs[ 4 ],,, .F.,,,, .F. )









     TButton():ReDefine( 4, {||( RecalculaPedidoProveedores( aTmp, oDlg ), ( oBrwLin:Refresh() ), RecalculaTotal( aTmp ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





     TButton():ReDefine( 1, {||( EndTrans( aGet, aTmp, oBrw, nMode, oDlg ) )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 3, {||( if( EndTrans( aGet, aTmp, oBrw, nMode, oDlg ), GenPedPrv( 1 ), ) )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( If( ExitNoSave( nMode, dbfTmpLin ), ( oDlg:end() ), ) )}, oDlg,,, .F.,,,, .T. )

      if nMode <> 3
         oFld:aDialogs[1]:AddFastKey( 113, {|| AppDeta( oBrwLin, bEdtDet, aTmp ) } )
         oFld:aDialogs[1]:AddFastKey( 114, {|| EdtDeta( oBrwLin, bEdtDet, aTmp ) } )
         oFld:aDialogs[1]:AddFastKey( 115, {|| WinDelRec( oBrwLin, dbfTmpLin, {|| DelDeta() }, {|| RecalculaTotal( aTmp ) } ) } )

         oFld:aDialogs[3]:AddFastKey( 113, {|| WinAppRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) } )
         oFld:aDialogs[3]:AddFastKey( 114, {|| WinEdtRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) } )
         oFld:aDialogs[3]:AddFastKey( 115, {|| DbDelRec( oBrwInc, dbfTmpInc, nil, nil, .T. ) } )

         oFld:aDialogs[4]:AddFastKey( 113, {|| WinAppRec( oBrwDoc, bEdtDoc, dbfTmpDoc, nil, nil, aTmp ) } )
         oFld:aDialogs[4]:AddFastKey( 114, {|| WinEdtRec( oBrwDoc, bEdtDoc, dbfTmpDoc, nil, nil, aTmp ) } )
         oFld:aDialogs[4]:AddFastKey( 115, {|| DbDelRec( oBrwDoc, dbfTmpDoc, nil, nil, .F. ) } )

         oDlg:AddFastKey( 116, {|| EndTrans( aGet, aTmp, oBrw, nMode, oDlg ) } )
         oDlg:AddFastKey( 117, {|| if( EndTrans( aGet, aTmp, oBrw, nMode, oDlg ), GenPedPrv( 1 ), ) } )
         oDlg:AddFastKey( 118, {|| ImportarExcel( aTmp, dbfTmpLin, dbfArticulo, dbfDiv, oBrwLin ) } )
         oDlg:AddFastKey( 65,    {|| if( GetKeyState( 17 ), CreateInfoArticulo(), ) } )
      end

      oDlg:AddFastKey ( 112, {|| GoHelp() } )

   do case
      case nMode == 1 .AND. lRecogerUsuario() .AND. Empty( cCodArt )
         oDlg:bStart := {|| if( lGetUsuario( aGet[ 37 ], dbfUsr ), , oDlg:end() ) }

      case nMode == 1 .AND. lRecogerUsuario() .AND. !Empty( cCodArt )
         oDlg:bStart := {|| if( lGetUsuario( aGet[ 37 ], dbfUsr ), AppDeta( oBrwLin, bEdtDet, aTmp, cCodArt ), oDlg:end() ) }

      case nMode == 1 .AND. !lRecogerUsuario() .AND. !Empty( cCodArt )
         oDlg:bStart := {|| AppDeta( oBrwLin, bEdtDet, aTmp, cCodArt ) }

   end







    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted := {|hDC,cPS|(  RecalculaTotal( aTmp ) )}, .T.,,, {|Self|(  EdtRecMenu( aGet, aTmp, oBrw, oBrwLin, nMode, oDlg ), ShowKitCom( dbfPedPrvT, dbfTmpLin, oBrwLin, cCodPrv, dbfTmpInc, aGet ), oBrwLin:Load(), oBrwInc:Load() )}, oDlg:bRClicked,,, )

   KillTrans( oBrwLin )

   EndEdtRecMenu()

   oBmpDiv:end()
   oBmpEmp:end()
   oBmpGeneral:End()





RETURN ( oDlg:nResult == 1 )



Static Function EdtRecMenu( aGet, aTmp, oBrw, oBrwLin, nMode, oDlg )

   oMenu := MenuBegin( .F.,,, .F., .F. )

      MenuAddItem( "&1. Rotor",, .F.,,,,,,,,, .F.,,, .F. )

         MenuBegin( .F.,,, .F., .F. )

            if !lExternal




            MenuAddItem( "&1. Modificar proveedor", "Modificar la ficha del proveedor", .F.,, {|oMenuItem|( EdtPrv( aTmp[ 6 ] ) )},, "Businessman_16",,,,, .F.,,, .F. )





            MenuAddItem( "&2. Informe de proveedor", "Abrir el informe del proveedor", .F.,, {|oMenuItem|( InfProveedor( aTmp[ 6 ] ) )},, "Info16",,,,, .F.,,, .F. )
            MenuAddItem()

            end




            MenuAddItem( "&3. Informe del documento", "Abrir el informe del documento", .F.,, {|oMenuItem|( TTrazaDocumento():Activate( "01", aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ] ) )},, "Info16",,,,, .F.,,, .F. )

         MenuEnd()

   MenuEnd()

   oDlg:SetMenu( oMenu )

Return ( oMenu )



Static Function EndEdtRecMenu()

Return ( if( oMenu <> nil, oMenu:End(), ) )



Static Function RecalculaPedidoProveedores( aTmp, oDlg )

   local nRecNum
   local nPreCom




   if !ApoloMsgNoYes( "¡Atención!,"                                      + Chr(13)+Chr(10) +  "todos los precios se recalcularán en función de"  + Chr(13)+Chr(10) +  "los valores en las bases de datos.", "¿ Desea proceder ?" )
      return nil
   end

   oDlg:Disable()

   ( dbfArticulo )->( ordSetFocus( "Codigo" ) )

   nRecNum                          := ( dbfTmpLin )->( RecNo() )

   ( dbfTmpLin )->( dbGotop() )
   while !( dbfTmpLin )->( eof() )





      nPreCom                       := nComPro( ( dbfTmpLin )->cRef, ( dbfTmpLin )->cCodPr1, ( dbfTmpLin )->cValPr1, ( dbfTmpLin )->cCodPr2, ( dbfTmpLin )->cValPr2, dbfArtCom )

      if nPrecom  <> 0

         ( dbfTmpLin )->nPreDiv     := nPreCom

      else

         if uFieldEmpresa( "lCosPrv", .F. )
            nPreCom                 := nPreArtPrv( aTmp[ 6 ], ( dbfTmpLin )->cRef, dbfArtPrv )
         end

         if nPreCom <> 0
            ( dbfTmpLin )->nPreDiv  := nPreCom
         else
            ( dbfTmpLin )->nPreDiv  := nCosto( ( dbfTmpLin )->cRef, dbfArticulo, dbfKit, .F., aTmp[ 29 ], dbfDiv )
         end





         if uFieldEmpresa( "lCosPrv", .F. )

            nPreCom                    := nDtoArtPrv( aTmp[ 6 ], ( dbfTmpLin )->cRef, dbfArtPrv )

            if nPreCom <> 0
               ( dbfTmpLin )->nDtoLin  := nPreCom
            end





            nPreCom                    := nPrmArtPrv( aTmp[ 6 ], ( dbfTmpLin )->cRef, dbfArtPrv )

            if nPreCom <> 0
               ( dbfTmpLin )->nDtoPrm  := nPreCom
            end

         end

      end

      ( dbfTmpLin )->( dbSkip() )

   end

   ( dbfTmpLin )->( dbGoTo( nRecNum ) )

   oDlg:Enable()

Return nil



Static Function EdtDoc( aTmp, aGet, dbfPedPrvD, oBrw, bWhen, bValid, nMode, aTmpLin )

   local oDlg
   local oRuta
   local oNombre
   local oObservacion

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "documento de pedido a proveedor", "DOCUMENTOS",, .F.,,,,,, .F.,,,,,, .F., )




      oNombre := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ ( dbfTmpDoc )->( FieldPos( "cNombre" ) ) ], aTmp[ ( dbfTmpDoc )->( FieldPos( "cNombre" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      oRuta := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfTmpDoc )->( FieldPos( "cRuta" ) ) ], aTmp[ ( dbfTmpDoc )->( FieldPos( "cRuta" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oRuta:cText( cGetFile( "Doc ( *.* ) | " + "*.*", "Seleccione el nombre del fichero" ) ) )}, nil, "FOLDER",, )





      oObservacion := TMultiGet():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( dbfTmpDoc )->( FieldPos( "mObsDoc" ) ) ], aTmp[ ( dbfTmpDoc )->( FieldPos( "mObsDoc" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||     ( nMode <> 3 )}, .F.,, )





      TButton():ReDefine( 1, {||( WinGather( aTmp, nil, dbfTmpDoc, oBrw, nMode ), oDlg:end( 1 ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| WinGather( aTmp, nil, dbfTmpDoc, oBrw, nMode ), oDlg:end( 1 ) } )
   end

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

Return ( oDlg:nResult == 1 )



Static Function EdtInc( aTmp, aGet, dbfPedPrvI, oBrw, bWhen, bValid, nMode, aTmpLin )

   local oDlg
   local oNomInci
   local cNomInci

   if !Empty( aTmp[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ] )
      cNomInci          := cNomInci( aTmp[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ], dbfInci )
   end

   if nMode == 1
      aTmp[ 1  ] := aTmpLin[ 1 ]
      aTmp[ 2  ] := aTmpLin[ 2 ]
      aTmp[ 3  ] := aTmpLin[ 3 ]
      if IsMuebles()
         aTmp[ ( dbfTmpInc )->( FieldPos( "lAviso" ) ) ]  := .T.
      end
   end

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "incidencias de pedido a proveedor", "INCIDENCIA",, .F.,,,,,, .F.,,,,,, .F., )








      aGet[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ]:= u ) }, oDlg,,, {||    ( cTipInci( aGet[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ], dbfInci, oNomInci ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwIncidencia( dbfInci, aGet[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ], oNomInci ) )}, nil, "LUPA",, )




      oNomInci := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, cNomInci, cNomInci:= u ) }, oDlg,,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )





      TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "dFecInc" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "dFecInc" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





      TMultiGet():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "mDesInc" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "mDesInc" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||     ( nMode <> 3 )}, .F.,, )




      TCheckBox():ReDefine( 140, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "lListo" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "lListo" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||         ( nMode <> 3 )}, .F. )




      TCheckBox():ReDefine( 150, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "lAviso" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "lAviso" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||         ( nMode <> 3 )}, .F. )





      TButton():ReDefine( 1, {||( WinGather( aTmp, nil, dbfTmpInc, oBrw, nMode ), oDlg:end( 1 ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| WinGather( aTmp, nil, dbfTmpInc, oBrw, nMode ), oDlg:end( 1 ) } )
   end

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

Return ( oDlg:nResult == 1 )



Static Function ImportarExcel( aTmpPed, dbfTmpLin, dbfArticulo, dbfDiv, oBrw )

   local n
   local m
   local nUnidad
   local nCajas
   local cCodigo
   local cProp1
   local cProp2
   local oOleExcel
   local cFileExcel
   local nCompro

   cFileExcel        := cGetFile( "Excel ( *.Xls ) | " + "*.Xls", "Seleccione la hoja de calculo" )

   if File( cFileExcel )

      oOleExcel                        := TOleExcel():New( "Importando hoja de excel", "Conectando...", .F. )

      oOleExcel:oExcel:Visible         := .T.
      oOleExcel:oExcel:DisplayAlerts   := .F.
      oOleExcel:oExcel:WorkBooks:Open( cFileExcel )

      for m := 1 to 3

         oOleExcel:oExcel:WorkSheets( m ):Activate()

         for n := 9 to 33

            nUnidad  := oOleExcel:oExcel:ActiveSheet:Range( "C" + lTrim( Str( n ) ) ):Value
            nCajas   := oOleExcel:oExcel:ActiveSheet:Range( "E" + lTrim( Str( n ) ) ):Value
            cCodigo  := oOleExcel:oExcel:ActiveSheet:Range( "D" + lTrim( Str( n ) ) ):Value

            if !Empty( nUnidad ) .AND. !Empty( nCajas ) .AND. !Empty( cCodigo )
               cProp1   := Str( nCajas, 3 )
               cProp2   := StrTran( cCodigo, "V", "T" )
               cCodigo  := "2044" + StrTran( Str( nCajas, 3 ), Space( 1 ), "0" )





               if ( dbfArticulo )->( dbSeek( cCodigo ) )

                  ( dbfTmpLin )->( dbAppend() )
                  ( dbfTmpLin )->nNumLin     := nLastNum( dbfTmpLin )
                  ( dbfTmpLin )->cRef        := ( dbfArticulo )->Codigo
                  ( dbfTmpLin )->cDetalle    := ( dbfArticulo )->Nombre
                  ( dbfTmpLin )->cCodPr1     := "1"
                  ( dbfTmpLin )->cValPr1     := cProp1
                  ( dbfTmpLin )->cCodPr2     := "2"
                  ( dbfTmpLin )->cValPr2     := cProp2
                  ( dbfTmpLin )->nIva        := nIva( dbfIva, ( dbfArticulo )->TipoIva )
                  ( dbfTmpLin )->cAlmLin     := aTmpPed[ 7 ]
                  ( dbfTmpLin )->nCanPed     := nCajas / 100
                  ( dbfTmpLin )->nUniCaja    := nUnidad





                  nComPro                    := nComPro( ( dbfTmpLin )->cRef, ( dbfTmpLin )->cCodPr1, ( dbfTmpLin )->cValPr1, ( dbfTmpLin )->cCodPr2, ( dbfTmpLin )->cValPr2, dbfArtCom )
                  if nComPro <> 0
                     ( dbfTmpLin )->nPreDiv  := nCnv2Div( nComPro, cDivEmp(), aTmpPed[ 29 ], dbfDiv )
                  else
                     ( dbfTmpLin )->nPreDiv  := nCnv2Div( ( dbfArticulo )->pCosto, cDivEmp(), aTmpPed[ 29 ], dbfDiv )
                  end

                  ( dbfTmpLin )->( dbUnLock() )

               end

            end

         next

      next

      oOleExcel:oExcel:Quit()

      oOleExcel:oExcel:DisplayAlerts := .T.

      oOleExcel:End()

      ( dbfTmpLin )->( dbGoTop() )

      oBrw:Refresh()

   end

Return nil






STATIC FUNCTION AppDeta( oBrwLin, bEdtDet, aTmp, cCodArt )

   WinAppRec( oBrwLin, bEdtDet, dbfTmpLin, aTmp, cCodArt )

Return ( RecalculaTotal( aTmp ) )






STATIC FUNCTION EdtDeta( oBrwLin, bEdtDet, aTmp )

   WinEdtRec( oBrwLin, bEdtDet, dbfTmpLin, aTmp )

Return ( RecalculaTotal( aTmp ) )







STATIC FUNCTION DelDeta()

   if ( dbfTmpLin )->lKitArt
      dbDelKit( , dbfTmpLin, ( dbfTmpLin )->nNumLin )
   end

Return ( .T. )







STATIC FUNCTION EdtZoom( oBrwLin, bEdtDet, aTmp )

   WinZooRec( oBrwLin, bEdtDet, dbfTmpLin, aTmp )

RETURN NIL







STATIC FUNCTION EdtDet( aTmp, aGet, dbfPedPrvL, oBrw, aTmpPed, cCodArt, nMode )

    local oDlg
   local oFld
   local oBmp
   local oBtn
   local oSay2
   local cSay2
   local oSayPr1
   local oSayPr2
   local cSayPr1        := ""
   local cSayPr2        := ""
   local oSayVp1
   local oSayVp2
   local cSayVp1        := ""
   local cSayVp2        := ""
   local oTotal
   local nTotal         := 0
   local oGet1
   local oGetStk
   local nGetStk        := 0
   local oGetIra
   local cGetIra        := Space( 50 )
   local oSayLote
   local nTotRes
   local oTotUni
   local oTotEnt
   local oTotPdt
   local oBrwAlb
   local nOrdAnt
   local oBrwPrp
   local cNumPed        := aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ]

   cOldCodArt           := aTmp[ 4 ]
   cOldUndMed           := aTmp[ 13 ]

   if nMode == 1

      aTmp[9]   := 1
      aTmp[24 ]   := aTmpPed[ 7 ]

      if !Empty( cCodArt )
         aTmp[ 4 ]  := cCodArt
      end

   else

      nGetStk           := oStock:nPutStockActual( aTmp[ 5 ], aTmp[ 24 ], , , , aTmp[ 30 ], aTmp[ 23 ] )

   end

   nTotRes              := nUnidadesRecibidasPedPrv( aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ], aTmp[ 4 ], aTmp[ 20 ], aTmp[ 21 ], aTmp[ 5 ], aTmp[ 6 ], dbfAlbPrvL )

   if nTotRes > nTotNPedPrv( aTmp )
      nTotRes           := nTotNPedPrv( aTmp )
   end

   nOrdAnt              := ( dbfAlbPrvL )->( OrdSetFocus( "cPedPrvRef" ) )

   ( dbfAlbPrvL )->( OrdScope( 0, aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ] + aTmp[ 4 ] + aTmp[ 20 ] + aTmp[ 21 ] + aTmp[ 27 ] ) )
   ( dbfAlbPrvL )->( OrdScope( 1, aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ] + aTmp[ 4 ] + aTmp[ 20 ] + aTmp[ 21 ] + aTmp[ 27 ] ) )
   ( dbfAlbPrvL )->( dbGoTop() )



   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "líneas a pedidos de proveedores", "LPEDPRV",, .F.,,,,,, .F.,,,,,, .F., )



        oFld := TFolder():ReDefine( 400, {"&General"  , "Da&tos",    "&Anular",     "&Observaciones"}, { "LFACPRV_1","LPEDPRV_2","LFACPRV_4","LFACPRV_6" }, oDlg,,,,, .F., )







      aGet[ 4 ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ 4 ], aTmp[ 4 ]:= u ) }, oFld:aDialogs[1],,, {||    ( LoaArt( aGet, aTmp, nMode, aTmpPed, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oSayLote, oBrwPrp, oGetIra, oDlg, oBmp, oGetStk ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwArticulo( aGet[ 4 ], aGet[ 6 ] ) )}, nil, "LUPA",, )








      oSayLote := TSay():ReDefine( 111,, oFld:aDialogs[1],,,, .F.,, .F., .F. )




      aGet[27] := TGetHlp():ReDefine( 112, { | u | If( PCount()==0, aTmp[27], aTmp[27]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[6] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[6], aTmp[6]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( ( lModDes() .OR. Empty( aTmp[ 6 ] ) ) .AND. nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






        aGet[14] := TMultiGet():ReDefine( 121, { | u | If( PCount()==0, aTmp[14], aTmp[14]:= u ) }, oFld:aDialogs[1],, "N/W*",,,,, .F., {||         ( nMode <> 3 )}, .F.,, )















      aGet[ 20 ] := TGetHlp():ReDefine( 220, { | u | If( PCount()==0, aTmp[ 20 ], aTmp[ 20 ]:= u ) }, oFld:aDialogs[1],,, {||    ( if( lPrpAct( aGet[ 20 ], oSayVp1, aTmp[ 18 ], dbfTblPro ), LoaArt( aGet, aTmp, nMode, aTmpPed, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oSayLote, oBrwPrp, oGetIra, oDlg, oBmp, oGetStk ), .F. ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( brwPrpAct( aGet[ 20 ], oSayVp1, aTmp[18 ] ) )}, nil, "LUPA",, )

         aGet[ 20 ]:bChange   := {|| aGet[ 20 ]:Assign(), oStock:nPutStockActual( aTmp[ 4 ], aTmp[ 24 ], aTmp[ 20 ], aTmp[ 21 ], aTmp[ 27 ], aTmp[ 30 ], aTmp[ 23 ], oGetStk ) }



      oSayPr1 := TSay():ReDefine( 221, {|| cSayPr1}, oFld:aDialogs[1],,,, .F.,, .F., .F. )





      oSayVp1 := TGetHlp():ReDefine( 222, { | u | If( PCount()==0, cSayVp1, cSayVp1:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )










      aGet[ 21 ] := TGetHlp():ReDefine( 230, { | u | If( PCount()==0, aTmp[ 21 ], aTmp[ 21 ]:= u ) }, oFld:aDialogs[1],,, {||    ( if( lPrpAct( aGet[ 21 ], oSayVp2, aTmp[ 19 ], dbfTblPro ), LoaArt( aGet, aTmp, nMode, aTmpPed, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oSayLote, oBrwPrp, oGetIra, oDlg, oBmp, oGetStk ), .F. ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( brwPrpAct( aGet[ 21 ], oSayVp2, aTmp[ 19 ] ) )}, nil, "LUPA",, )

         aGet[ 21 ]:bChange   := {|| aGet[ 21 ]:Assign(), oStock:nPutStockActual( aTmp[ 4 ], aTmp[ 24 ], aTmp[ 20 ], aTmp[ 21 ], aTmp[ 27 ], aTmp[ 30 ], aTmp[ 23 ], oGetStk ) }



      oSayPr2 := TSay():ReDefine( 231, {|| cSayPr2}, oFld:aDialogs[1],,,, .F.,, .F., .F. )





      oSayVp2 := TGetHlp():ReDefine( 232, { | u | If( PCount()==0, cSayVp2, cSayVp2:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )








      aGet[ 24 ] := TGetHlp():ReDefine( 240, { | u | If( PCount()==0, aTmp[ 24 ], aTmp[ 24 ]:= u ) }, oFld:aDialogs[1],,, {||    ( cAlmacen( aGet[24], dbfAlm, oSay2 ), oStock:lPutStockActual( aTmp[ 4 ], aTmp[ 24 ], aTmp[ 20 ], aTmp[ 21 ], aTmp[ 27 ], aTmp[ 30 ], aTmp[ 23 ], oGetStk ) )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwAlmacen( Self, oSay2 ) )}, nil, "LUPA",, )




        oSay2 := TGetHlp():ReDefine( 241, { | u | If( PCount()==0, cSay2, cSay2:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )





      oBrwPrp := TWBrowse():ReDefine( 100, {|| { "" } }, oFld:aDialogs[1], {""},,,,,,,,,,,,, .F.,,,,, )





































      aGet[ 7 ] := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTmp[ 7 ], aTmp[ 7 ]:= u ) }, oFld:aDialogs[1],, "@E 99.99", {||    ( lTiva( dbfIva, aTmp[ 7 ], @aTmp[ 41 ] ) )},,,,,, .F., {||     ( lModIva() .AND. nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, oTotal ) ) }, .F., .F.,,,,, {|Self|( BrwIva( aGet[ 7 ], dbfIva, , .T. ) )}, nil, "LUPA",, )








      aGet[ 8 ] := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTmp[ 8 ], aTmp[ 8 ]:= u ) }, oFld:aDialogs[1],, cPicUnd,,,,,,, .F., {||     ( lUseCaj() .AND. nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, oTotal ) ) }, .F., .T.,,,,,, nil,, 141, )











      aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ] := TGetHlp():ReDefine( 300, { | u | If( PCount()==0, aTmp[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ], aTmp[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]:= u ) }, oFld:aDialogs[1],, MasUnd(),,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, oTotal ) ) }, .F., .T.,,,,,, nil,, 301, )

      aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]:oSay:SetColor( 8388608 )









      aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ] := TGetHlp():ReDefine( 310, { | u | If( PCount()==0, aTmp[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ], aTmp[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]:= u ) }, oFld:aDialogs[1],, MasUnd(),,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, oTotal ) ) }, .F., .T.,,,,,, nil,, 311, )

      aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]:oSay:SetColor( 8388608 )









      aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ] := TGetHlp():ReDefine( 320, { | u | If( PCount()==0, aTmp[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ], aTmp[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]:= u ) }, oFld:aDialogs[1],, MasUnd(),,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, oTotal ) ) }, .F., .T.,,,,,, nil,, 321, )

      aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]:oSay:SetColor( 8388608 )









        aGet[9] := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, aTmp[9], aTmp[9]:= u ) }, oFld:aDialogs[1],, cPicUnd,, "N/W*",,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, oTotal ) ) }, .F., .T.,,,,,, nil,, 151, )







      aGet[ 10 ] := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, aTmp[ 10 ], aTmp[ 10 ]:= u ) }, oFld:aDialogs[1],, cPinDiv,,,,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, oTotal ) ) }, .F., .T.,,,,,, nil,,, )








      aGet[13] := TGetHlp():ReDefine( 170, { | u | If( PCount()==0, aTmp[13], aTmp[13]:= u ) }, oFld:aDialogs[1],,, {||    ( oUndMedicion:Existe( aGet[ 13 ], aGet[ 13 ]:oHelpText, "cNombre" ), ValidaMedicion( aTmp, aGet) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oUndMedicion:Buscar( aGet[ 13 ] ), ValidaMedicion( aTmp, aGet ) )}, nil, "LUPA",, 171 )








        aGet[15] := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, aTmp[15], aTmp[15]:= u ) }, oFld:aDialogs[1],, "@E 999.99",, "N/W*",,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, oTotal ) ) }, .F., .T.,,,,,, nil,,, )







      aGet[16] := TGetHlp():ReDefine( 250, { | u | If( PCount()==0, aTmp[16], aTmp[16]:= u ) }, oFld:aDialogs[1],, "@E 99.99",,,,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, oTotal ) ) }, .F., .T.,,,,,, nil,,, )






      aGet[17] := TGetHlp():ReDefine( 260, { | u | If( PCount()==0, aTmp[17], aTmp[17]:= u ) }, oFld:aDialogs[1],, "@E 99.99",,,,,,, .F., {||         ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





      oGetStk := TGetHlp():ReDefine( 190, { | u | If( PCount()==0, nGetStk, nGetStk:= u ) }, oFld:aDialogs[1],, cPicUnd,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )




      aGet[ 5 ] := TGetHlp():ReDefine( 400, { | u | If( PCount()==0, aTmp[ 5 ], aTmp[ 5 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )







      oGetIra := TGetHlp():ReDefine( 410, { | u | If( PCount()==0, cGetIra, cGetIra:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( SearchProperty( oGetIra, oBrwPrp ) )}, nil, "Lupa", 411, )





        oTotal := TGetHlp():ReDefine( 210, { | u | If( PCount()==0, nTotal, nTotal:= u ) }, oFld:aDialogs[1],, cPirDiv,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )



      oBmp := TBitmap():ReDefine( 100,,, oDlg,,, .F., .F.,,, .F.,,, .F. )

      oBmp:SetColor( , GetSysColor( 15 ) )









      oTotUni := TSay():ReDefine( 150, {|| nTotNPedPrv( aTmp )}, oFld:aDialogs[2], cPicUnd, "B/W*",, .F.,, .F., .F. )





      oTotEnt := TSay():ReDefine( 160, {|| nTotRes}, oFld:aDialogs[2], cPicUnd, "G/W*",, .F.,, .F., .F. )





      oTotPdt := TSay():ReDefine( 170, {|| nTotNPedPrv( aTmp ) - nTotRes}, oFld:aDialogs[2], cPicUnd, "R/W*",, .F.,, .F., .F. )





      oBrwAlb                 := TXBrowse():New( oFld:aDialogs[ 2 ] )

      oBrwAlb:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwAlb:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwAlb:cAlias          := dbfAlbPrvL

      oBrwAlb:lFooter         := .F.
      oBrwAlb:nMarqueeStyle   := 5

      oBrwAlb:CreateFromResource( 180 )

         with object ( oBrwAlb:AddCol() )
            :cHeader          := "Fecha"
            :bEditValue       := {|| Dtoc( dFecAlbPrv( ( dbfAlbPrvL )->cSerAlb + Str( ( dbfAlbPrvL )->nNumAlb ) + ( dbfAlbPrvL )->cSufAlb, dbfAlbPrvT ) ) }
            :nWidth           := 80
         end

         with object ( oBrwAlb:AddCol() )
            :cHeader          := "Albarán"
            :bEditValue       := {|| AllTrim( ( dbfAlbPrvL )->cSerAlb ) + "/" + AllTrim( Str( ( dbfAlbPrvL )->nNumAlb ) ) + "/" + AllTrim( ( dbfAlbPrvL )->cSufAlb ) }
            :nWidth           := 80
         end

         with object ( oBrwAlb:AddCol() )
            :cHeader          := "Proveedor"
            :bEditValue       := {|| AllTrim( aTmpPed[ 6 ] ) + " - " + AllTrim( aTmpPed[ 9 ] ) }
            :nWidth           := 240
         end

         with object ( oBrwAlb:AddCol() )
            :cHeader          := "Total unidades"
            :bEditValue       := {|| nTotNAlbPrv( dbfAlbPrvL ) }
            :bFooter          := {|| nTotRes }
            :cEditPicture     := cPicUnd
            :nWidth           := 80
            :nDataStrAlign    := 1
            :nHeadStrAlign    := 1
         end





      oBtn := TButton():ReDefine( 1, {||( SaveDeta( aTmp, aGet, oBrwPrp, oGetIra, oFld, oDlg, oBrw, nMode, oTotal, oGet1, aTmpPed, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oGetStk, oSayLote, oBtn ) )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )




        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 9, {||( GoHelp() )}, oDlg,,, .F.,,,, .F. )





      aGet[36] := TCheckBox():ReDefine( 400, { | u | If( PCount()==0, aTmp[36], aTmp[36]:= u ) }, oFld:aDialogs[3],, {||( CambiaAnulado( aGet, aTmp ) )},,,,, .F., {||     ( nMode <> 3 )}, .F. )






      aGet[37] := TGetHlp():ReDefine( 410, { | u | If( PCount()==0, aTmp[37], aTmp[37]:= u ) }, oFld:aDialogs[3],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )






      aGet[ 38 ] := TMultiGet():ReDefine( 420, { | u | If( PCount()==0, aTmp[38], aTmp[38]:= u ) }, oFld:aDialogs[3],, "N/W*",,,,, .F., {||     ( nMode <> 3 )}, .F.,, )





      aGet[42] := TMultiGet():ReDefine( 100, { | u | If( PCount()==0, aTmp[42], aTmp[42]:= u ) }, oFld:aDialogs[4],,,,,,, .F., {||     ( nMode <> 3 )}, .F.,, )

   if nMode <> 3
      oDlg:AddFastKey(  116, {|| SaveDeta( aTmp, aGet, oBrwPrp, oGetIra, oFld, oDlg, oBrw, nMode, oTotal, oGet1, aTmpPed, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oGetStk, oSayLote, oBtn ) } )
   end

   oDlg:AddFastKey(     112, {|| GoHelp() } )





   oDlg:bStart    := {||   SetDlgMode( aGet, aTmp, aTmpPed, nMode, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oSayLote, oBrwPrp, oGetIra, oFld, oDlg, oTotal, oGetStk ), if( !Empty( cCodArt ), aGet[ 4 ]:lValid(), ), lCalcDeta( aTmp, oTotal ), aGet[ 13 ]:lValid(), oBrwAlb:GoTop(), oBrwAlb:Refresh() }



   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( EdtDetMenu( aGet[ 4 ], oDlg ) )}, oDlg:bRClicked,,, )

   EndDetMenu()

   ( dbfAlbPrvL )->( OrdScope( 0, nil ) )
   ( dbfAlbPrvL )->( OrdScope( 1, nil ) )
   ( dbfAlbPrvL )->( OrdSetFocus( nOrdAnt ) )

RETURN ( oDlg:nResult == 1 )



STATIC FUNCTION SetDlgMode( aGet, aTmp, aTmpPed, nMode, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oSayLote, oBrwPrp, oGetIra, oFld, oDlg, oTotal )

   local cCodArt        := aGet[ 4 ]:VarGet()

   if !lUseCaj()
      aGet[ 8 ]:Hide()
   else
      aGet[ 8 ]:SetText( cNombreCajas() )
   end

   aGet[ 9 ]:SetText( cNombreUnidades() )

   if Empty( aTmp[24 ] )
      aTmp[ 24 ]  := aTmpPed[ 7 ]
   end

   oBrwPrp:Hide()

   oGetIra:Hide()

   oSayPr1:SetText( "" )
   oSayVp1:SetText( "" )

   oSayPr2:SetText( "" )
   oSayVp2:SetText( "" )

   do case
   case nMode == 1

      aGet[ 4    ]:show()
      aGet[ 6]:show()
      aGet[ 14 ]:hide()
      aGet[ 27   ]:hide()
      aGet[ 9]:cText( 1 )
      aGet[ 8 ]:cText( 1 )
      aGet[ 24 ]:cText( aTmpPed[ 7 ] )
      aGet[ 37]:cText( Ctod( "" ) )
      aGet[ 36]:Click( .F. )
      aGet[ 7    ]:cText( nIva( dbfIva, cDefIva() ) )

      aTmp[ 41    ]  := nReq( dbfIva, cDefIva() )

      aTmp[ 28 ]  := nLastNum( dbfTmpLin )

      oSayLote:hide()

   case nMode <> 1 .AND. empty( cCodArt )

      aGet[4    ]:hide()
        aGet[6]:hide()
        aGet[14 ]:show()
      aGet[27   ]:hide()

      oSayLote:hide()

   case nMode <> 1 .AND. !empty( cCodArt )

      aGet[4    ]:show()
        aGet[6]:show()
        aGet[14 ]:hide()

      if aTmp[25]
         aGet[27   ]:Show()
         oSayLote:Show()
      else
         aGet[27   ]:Hide()
         oSayLote:Hide()
      end

   end

   if !Empty( aTmp[ 18 ] )
      aGet[ 20 ]:Show()
      aGet[ 20 ]:lValid()
      oSayPr1:SetText( retProp( aTmp[ 18 ], dbfPro ) )
      oSayPr1:Show()
      oSayVp1:Show()
   else
      aGet[ 20 ]:Hide()
      oSayPr1:Hide()
      oSayVp1:Hide()
   end

   if !Empty( aTmp[ 19 ] )
      aGet[ 21 ]:Show()
      aGet[ 21 ]:lValid()
      oSayPr2:SetText( retProp( aTmp[ 19 ], dbfPro ) )
      oSayPr2:Show()
      oSayVp2:Show()
   else
      aGet[ 21 ]:hide()
      oSayPr2:Hide()
      oSayVp2:Hide()
   end



   aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]:Hide()
   aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]:Hide()
   aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]:Hide()

   if oUndMedicion:oDbf:Seek(  aTmp[ 13 ] )

      if oUndMedicion:oDbf:nDimension >= 1 .AND. !Empty( oUndMedicion:oDbf:cTextoDim1 )
         aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim1 )
         aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]:Show()
      end

      if oUndMedicion:oDbf:nDimension >= 2 .AND. !Empty( oUndMedicion:oDbf:cTextoDim2 )
         aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim2 )
         aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]:Show()
      end

      if oUndMedicion:oDbf:nDimension >= 3 .AND. !Empty( oUndMedicion:oDbf:cTextoDim3 )
         aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim3 )
         aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]:Show()
      end

   end



   oFld:SetOption( 1 )

   aGet[ 24 ]:lValid()
   aGet[ 4    ]:SetFocus()

   oTotal:cText( 0 )

RETURN .T.



STATIC FUNCTION LoaArt( aGet, aTmp, nMode, aTmpPed, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oSayLote, oBrwPrp, oGetIra, oDlg, oBmp, oGetStk )

   local nOrdAnt
   local cCodFam
   local cCodPrv
   local cPrpArt
   local cCodArt
   local nUnidad
   local nPreCom
   local lChgCodArt
   local lSeek       := .F.

   nPreCom           := 0
   cCodPrv           := aTmpPed[ 6 ]
   cCodArt           := aGet[ 4 ]:varGet()
   cPrpArt           := aTmp[ 18 ] + aTmp[ 19 ] + aTmp[ 20 ] + aTmp[ 21 ]
   lChgCodArt        := ( Rtrim( cOldCodArt ) <> Rtrim( cCodArt ) .OR. Rtrim( cOldPrpArt ) <> Rtrim( cPrpArt ) )

   if Empty( cCodArt )

      if lRetCodArt()
         MsgStop( "No se pueden añadir lineas sin codificar" )
         return .F.
      end

      aGet[ 7     ]:bWhen := {|| .T. }
      aGet[ 6 ]:Hide()
      aGet[ 27    ]:Hide()

      oSayLote:Hide()

      aGet[ 14  ]:Show()
      aGet[ 14  ]:SetFocus()

      if !Empty( oBrwPrp )
         oBrwPrp:Hide()
      end

   else

      if lModIva()
         aGet[ 7  ]:bWhen := {|| .T. }
      else
         aGet[ 7  ]:bWhen := {|| .F. }
      end

      aGet[ 4     ]:Show()
      aGet[ 6 ]:Show()
      aGet[ 14  ]:Hide()

      if !( ( dbfArticulo )->( dbSeek( cCodArt ) ) .OR. ( dbfArticulo )->( dbSeek( Upper( cCodArt ) ) ) )





         nOrdAnt                 := ( dbfArtPrv )->( OrdSetFocus( "cRefPrv" ) )

         if ( dbfArtPrv )->( dbSeek( cCodPrv + cCodArt ) )
            cCodArt              := ( dbfArtPrv )->cCodArt
         end

         ( dbfArtPrv )->( ordSetFocus( nOrdAnt ) )





         cCodArt                 := cSeekCodebar( cCodArt, dbfCodebar, dbfArticulo )





         lSeek                   := ( dbfArticulo )->( dbSeek( cCodArt ) ) .OR. ( dbfArticulo )->( dbSeek( Upper( cCodArt ) ) )

      else

         lSeek                   := .T.

      end



      if lSeek

         if ( lChgCodArt )

            if ( dbfArticulo )->lObs
               MsgStop( "Artículo catalogado como obsoleto" )
               return .F.
            end

            aGet[ 4     ]:cText( ( dbfArticulo )->Codigo )
            aGet[ 6 ]:cText( ( dbfArticulo )->Nombre )

            if ( dbfArticulo )->lMosCom .AND. !Empty( ( dbfArticulo )->mComent )
               MsgStop( Trim( ( dbfArticulo )->mComent ) )
            end





            aGet[ 7 ]:cText( nIva( dbfIva, ( dbfArticulo )->TipoIva ) )

            aTmp[ 41 ]     := nReq( dbfIva, ( dbfArticulo )->TipoIva )

            if ( dbfArticulo )->nCajEnt <> 0
               aGet[ 8 ]:cText( ( dbfArticulo )->nCajEnt )
            end

            if ( dbfArticulo )->nUniCaja <> 0
               aGet[ 9 ]:cText( ( dbfArticulo )->nUniCaja )
            end






            aTmp[ 25 ]    := ( dbfArticulo )->lLote

            if ( dbfArticulo )->lLote
               oSayLote:Show()
               aGet[ 27 ]:Show()
               aGet[ 27 ]:cText( ( dbfArticulo )->cLote )
            else
               oSayLote:Hide()
               aGet[ 27 ]:Hide()
            end





            nOrdAnt                 := ( dbfArtPrv )->( OrdSetFocus( "cCodPrv" ) )

            if ( dbfArtPrv )->( dbSeek( cCodPrv + cCodArt ) )

               if !Empty( aGet[ 5 ] )
                  aGet[ 5 ]:cText( ( dbfArtPrv )->cRefPrv )
               end

            else

               if !Empty( aGet[ 5 ] )
                  aGet[ 5 ]:cText( Space( 20 ) )
               end

            end

            ( dbfArtPrv )->( ordSetFocus( nOrdAnt ) )





            if ( dbfArticulo )->lKitArt
               aTmp[ 30 ]     := ( dbfArticulo )->lKitArt
               aTmp[ 33 ]     := lImprimirCompuesto( ( dbfArticulo )->Codigo, dbfArticulo )
               aTmp[ 32 ]     := lPreciosCompuestos( ( dbfArticulo )->Codigo, dbfArticulo )
               if lStockCompuestos( ( dbfArticulo )->Codigo, dbfArticulo )
                  aTmp[ 23 ]  := ( dbfArticulo )->nCtlStock
               else
                  aTmp[ 23 ]  := 3
               end
            else
               aTmp[ 33 ]     := .F.
               aTmp[ 23 ]     := ( dbfArticulo )->nCtlStock
            end





            aTmp[18 ]         := ( dbfArticulo )->cCodPrp1
            aTmp[19 ]         := ( dbfArticulo )->cCodPrp2


            if ( !Empty( aTmp[ 18 ] ) .OR. !Empty( aTmp[ 19 ] ) ) .AND.  ( uFieldEmpresa( "lUseTbl" ) .AND. ( nMode == 1 ) )

               nPreCom              := nCosto( nil, dbfArticulo, dbfKit, .F., aTmpPed[ 29 ], dbfDiv )

               LoadPropertiesTable( cCodArt, nPreCom, aTmp[ 18 ], aTmp[ 19 ], dbfPro, dbfTblPro, dbfArtCom, oBrwPrp, aGet[ 9 ], aGet[ 10 ] )

               oGetIra:Show()

            else

               oBrwPrp:Hide()

               oGetIra:Hide()

               if !Empty( aTmp[ 18 ] )

                  if aGet[ 20 ] <> nil
                     aGet[ 20 ]:Show()
                     aGet[ 20 ]:SetFocus()
                  end

                  if oSayPr1 <> nil
                     oSayPr1:SetText( retProp( ( dbfArticulo )->cCodPrp1, dbfPro ) )
                     oSayPr1:Show()
                  end

                  if oSayVp1 <> nil
                     oSayVp1:Show()
                  end

               else

                  if aGet[ 20 ] <>  nil
                     aGet[ 20 ]:Hide()
                  end

                  if oSayPr1 <> nil
                     oSayPr1:Hide()
                  end

                  if oSayVp1 <> nil
                     oSayVp1:Hide()
                  end

               end

               if !Empty( aTmp[19 ] )

                  if aGet[ 21 ] <> nil
                     aGet[ 21 ]:show()
                  end

                  if oSayPr2 <> nil
                     oSayPr2:SetText( retProp( ( dbfArticulo )->cCodPrp2, dbfPro ) )
                     oSayPr2:Show()
                  end

                  if oSayVp2 <> nil
                     oSayVp2:Show()
                  end

               else

                  if aGet[ 21 ] <> nil
                     aGet[ 21 ]:Hide()
                  end

                  if oSayPr2 <> nil
                     oSayPr2:Hide()
                  end

                  if oSayVp2 <> nil
                     oSayVp2:Hide()
                  end

               end





               nPreCom           := nComPro( aTmp[ 4 ], aTmp[ 18 ], aTmp[ 20 ], aTmp[ 19 ], aTmp[ 21 ], dbfArtCom )
               if nPrecom  <> 0

                  aGet[ 10 ]:cText( nPreCom )

               else

                  if uFieldEmpresa( "lCosPrv", .F. )
                     nPreCom     := nPreArtPrv( cCodPrv, cCodArt, dbfArtPrv )
                  end

                  if nPreCom <> 0
                     aGet[ 10 ]:cText( nPreCom )
                  else
                     aGet[ 10 ]:cText( nCosto( nil, dbfArticulo, dbfKit, .F., aTmpPed[ 29 ], dbfDiv ) )
                  end





                  if uFieldEmpresa( "lCosPrv", .F. )

                     nPreCom     := nDtoArtPrv( cCodPrv, cCodArt, dbfArtPrv )
                     if nPreCom <> 0
                        aGet[ 15 ]:cText( nPreCom )
                     end





                     nPreCom     := nPrmArtPrv( cCodPrv, cCodArt, dbfArtPrv )
                     if nPreCom <> 0
                        aGet[ 16 ]:cText( nPreCom )
                     end

                  end

               end

            end





            cCodFam              := ( dbfArticulo )->Familia
            if !Empty( cCodFam )
               aTmp[ 39 ]  := cCodFam
               aTmp[ 40 ]  := cGruFam( cCodFam, dbfFamilia )
            end





            aTmp[ 44  ]    := ( dbfArticulo )->PvpRec





            if oGetStk <> nil .AND. aTmp[ 23 ] <= 1
               oStock:nPutStockActual( cCodArt, aTmp[ 24 ], , , , aTmp[ 30 ], aTmp[ 23 ], oGetStk )
            end

            if !Empty( aGet[ 13 ] )
                aGet[ 13 ]:cText( ( dbfArticulo )->cUnidad )
                aGet[ 13 ]:lValid()
            else
                aTmp[ 13 ]    := ( dbfArticulo )->cUnidad
            end

            ValidaMedicion( aTmp, aGet )

         end

      else

         msgStop( "Artículo no encontrado" )
         Return .F.

      end

   end

   cOldCodArt        := cCodArt
   cOldPrpArt        := cPrpArt

Return .T.



STATIC FUNCTION GetArtPrv( cRefPrv, cCodPrv, aGet )

    local nOrdAnt

   if Empty( cRefPrv )

      Return .T.

   else

      nOrdAnt  := ( dbfArtPrv )->( ordSetFocus( "cRefPrv" ) )

      if ( dbfArtPrv )->( dbSeek( cCodPrv + cRefPrv ) )

         aGet[ 4 ]:cText( ( dbfArtPrv )->cCodArt )
            aGet[ 4 ]:lValid()

      else

         msgStop( "Referencia de proveedor no encontrada" )

      end

        ( dbfArtPrv )->( ordSetFocus( nOrdAnt ) )

   end

Return .T.



STATIC FUNCTION SaveDeta( aTmp, aGet, oBrwPrp, oGetIra, oFld, oDlg, oBrw, nMode, oTotal, oGet, aTmpPed, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oGetStk, oSayLote, oBtn )

   local n, i

   if !lMoreIva( aTmp[7] )
      Return nil
   end

   if Empty( aTmp[ 24 ] ) .AND. !Empty( aTmp[ 4 ] )
      msgStop( "Código de almacén no puede estar vacío", "Atención" )
      Return nil
   end

   if !cAlmacen( aGet[ 24 ], dbfAlm )
      Return nil
   end





   if nMode == 1

      if aTmp[ 25 ]
         GraLotArt( aTmp[ 4 ], dbfArticulo, aTmp[ 27 ] )
      end

      if !Empty( oBrwPrp:Cargo )

         for n := 1 to len( oBrwPrp:Cargo )

            for i := 1 to len( oBrwPrp:Cargo[ n ] )

               if oBrwPrp:Cargo[ n, i ]:Value <> nil .AND. oBrwPrp:Cargo[ n, i ]:Value <> 0

                  aTmp[ 9]  := oBrwPrp:Cargo[ n, i ]:Value
                  aTmp[ 18 ]  := oBrwPrp:Cargo[ n, i ]:cCodigoPropiedad1
                  aTmp[ 20 ]  := oBrwPrp:Cargo[ n, i ]:cValorPropiedad1
                  aTmp[ 19 ]  := oBrwPrp:Cargo[ n, i ]:cCodigoPropiedad2
                  aTmp[ 21 ]  := oBrwPrp:Cargo[ n, i ]:cValorPropiedad2
                  aTmp[ 10 ]  := oBrwPrp:Cargo[ n, i ]:nPrecioCompra

                  WinGather( aTmp, aGet, dbfTmpLin, oBrw, nMode, nil, .F. )

               end

            next

         next

         aCopy( dbBlankRec( dbfTmpLin ), aTmp )

         aEval( aGet, {| o, i | if( "GET" $ o:ClassName(), o:cText( aTmp[ i ] ), ) } )

      else

         WinGather( aTmp, aGet, dbfTmpLin, oBrw, nMode )

      end

      if lEntCon()

         SetDlgMode( aGet, aTmp, aTmpPed, nMode, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oSayLote, oBrwPrp, oGetIra, oFld, oDlg, oTotal, oGetStk )

         nTotPedPrv( nil, dbfPedPrvT, dbfTmpLin, dbfIva, dbfDiv, aTmpPed )

      else

         oDlg:end( 1 )

      end

   else

      WinGather( aTmp, aGet, dbfTmpLin, oBrw, nMode )

      oDlg:end( 1 )

   end

   aTmp[ 35 ]                 := ""
   cOldCodArt                       := ""
   cOldUndMed                       := ""

   if !Empty( aGet[ 13 ] )
      aGet[ 13 ]:lValid()
   end

   if !Empty( oBrwPrp )
      oBrwPrp:Cargo                 := nil
   end

   if oGet <> nil
      oGet:cText( Space( 14 ) )
      oGet:SetFocus()
   end

   if oGetStk <> nil
      oGetStk:cText( 0 )
   end

Return nil



STATIC FUNCTION lMoreIva( nCodIva )





    IF aTotIva[ 1, 3 ] == NIL .OR. aTotIva[ 2, 3 ] == NIL .OR. aTotIva[ 3, 3 ] == NIL
        RETURN .T.
    end

    IF aTotIva[ 1, 3 ] == nCodIva .OR. aTotIva[ 2, 3 ] == nCodIva .OR. aTotIva[ 3, 3 ] == nCodIva
        RETURN .T.
    end

   MsgStop( "Pedido con mas de 3 tipos de " + cImp(), "Imposible añadir" )

Return .F.



STATIC FUNCTION PrnSerie( oBrw )

    local oDlg
   local oFmtDoc
   local cFmtDoc     := cFormatoDocumento( ( dbfPedPrvT )->cSerPed, "nPedPrv", dbfCount )
   local oSayFmt
   local cSayFmt
   local oSerIni
   local oSerFin
   local nRecno      := ( dbfPedPrvT )->( Recno() )
   local nOrdAnt     := ( dbfPedPrvT )->( OrdSetFocus( 1 ) )
   local cSerIni     := ( dbfPedPrvT )->cSerPed
   local cSerFin     := ( dbfPedPrvT )->cSerPed
   local nDocIni     := ( dbfPedPrvT )->nNumPed
   local nDocFin     := ( dbfPedPrvT )->nNumPed
   local cSufIni     := ( dbfPedPrvT )->cSufPed
   local cSufFin     := ( dbfPedPrvT )->cSufPed
   local oPrinter
   local cPrinter    := PrnGetName()
   local lCopiasPre  := .T.
   local lInvOrden   := .F.
   local oNumCop
   local nNumCop     := if( nCopiasDocumento( ( dbfPedPrvT )->cSerPed, "nPedPrv", dbfCount ) == 0, Max( Retfld( ( dbfPedPrvT )->cCodPrv, dbfPrv, "nCopiasF" ), 1 ), nCopiasDocumento( ( dbfPedPrvT )->cSerPed, "nPedPrv", dbfCount ) )

   if Empty( cFmtDoc )
      cFmtDoc        := cSelPrimerDoc( "PP" )
   end

   cSayFmt           := cNombreDoc( cFmtDoc )

   oDlg = TDialog():New(,,,, "Imprimir series de pedidos", "IMPSERDOC",, .F.,,,,,, .F.,,,,,, .F., )









   oSerIni := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, cSerIni, cSerIni:= u ) }, oDlg,, "@!", {||    ( cSerIni >= "A" .AND. cSerIni <= "Z"  )},,,,,, .T.,,, .F., .T., {||    ( UpSerie( oSerIni ) )}, {||  ( DwSerie( oSerIni ) )},,,, nil,,, )









   oSerFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cSerFin, cSerFin:= u ) }, oDlg,, "@!", {||    ( cSerFin >= "A" .AND. cSerFin <= "Z"  )},,,,,, .T.,,, .F., .T., {||    ( UpSerie( oSerFin ) )}, {||  ( DwSerie( oSerFin ) )},,,, nil,,, )





   TGetHlp():ReDefine( 120, { | u | If( PCount()==0, nDocIni, nDocIni:= u ) }, oDlg,, "999999999",,,,,,, .F.,,, .F., .T.,,,,,, nil,,, )





   TGetHlp():ReDefine( 130, { | u | If( PCount()==0, nDocFin, nDocFin:= u ) }, oDlg,, "999999999",,,,,,, .F.,,, .F., .T.,,,,,, nil,,, )




   TGetHlp():ReDefine( 140, { | u | If( PCount()==0, cSufIni, cSufIni:= u ) }, oDlg,, "##",,,,,,, .F.,,, .F., .F.,,,,,, nil,,, )




   TGetHlp():ReDefine( 150, { | u | If( PCount()==0, cSufFin, cSufFin:= u ) }, oDlg,, "##",,,,,,, .F.,,, .F., .F.,,,,,, nil,,, )



   TCheckBox():ReDefine( 500, { | u | If( PCount()==0, lInvOrden, lInvOrden:= u ) }, oDlg,,,,,,, .F.,, .F. )



   TCheckBox():ReDefine( 170, { | u | If( PCount()==0, lCopiasPre, lCopiasPre:= u ) }, oDlg,,,,,,, .F.,, .F. )









   oNumCop := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, nNumCop, nNumCop:= u ) }, oDlg,, "999999999", {||    nNumCop > 0},,,,,, .F., {||     !lCopiasPre},, .F., .T.,,, {||      1}, {||      99999},, nil,,, )







   oFmtDoc := TGetHlp():ReDefine( 90, { | u | If( PCount()==0, cFmtDoc, cFmtDoc:= u ) }, oDlg,,, {||    ( cDocumento( oFmtDoc, oSayFmt, dbfDoc ) )}, "N/W*",,,,, .F.,,, .F., .F.,,,,, {|Self|( BrwDocumento( oFmtDoc, oSayFmt, "PP" ) )}, nil, "LUPA",, )





   oSayFmt := TGetHlp():ReDefine( 91, { | u | If( PCount()==0, cSayFmt, cSayFmt:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )

   TBtnBmp():ReDefine( 92, "Printer_pencil_16",,,,,{|| EdtDocumento( cFmtDoc ) }, oDlg, .F., , .F.,  )




   oPrinter := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, cPrinter, cPrinter:= u ) }, oDlg,,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )

   TBtnBmp():ReDefine( 161, "Printer_preferences_16",,,,,{|| PrinterPreferences( oPrinter ) }, oDlg, .F., , .F.,  )





   TButton():ReDefine( 1, {||(  StartPrint( SubStr( cFmtDoc, 1, 3 ), cSerIni + Str( nDocIni, 9 ) + cSufIni, cSerFin + Str( nDocFin, 9 ) + cSufFin, oDlg, cPrinter, lCopiasPre, nNumCop, lInvOrden ), oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   oDlg:AddFastKey( 116, {|| StartPrint( SubStr( cFmtDoc, 1, 3 ), cSerIni + Str( nDocIni, 9 ) + cSufIni, cSerFin + Str( nDocFin, 9 ) + cSufFin, oDlg, cPrinter, lCopiasPre, nNumCop, lInvOrden ), oDlg:end( 1 ) } )

   oDlg:bStart := { || oSerIni:SetFocus() }

    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   ( dbfPedPrvT )->( ordSetFocus( nOrdAnt ) )
   ( dbfPedPrvT )->( dbGoTo( nRecNo ) )

    oBrw:refresh()

RETURN NIL



STATIC FUNCTION StartPrint( cFmtDoc, cDocIni, cDocFin, oDlg, cPrinter, lCopiasPre, nNumCop, lInvOrden )

   local nCopyProvee

   oDlg:disable()

   if !lInvOrden

      ( dbfPedPrvT )->( dbSeek( cDocIni, .T. ) )


      while ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + (dbfPedPrvT)->cSufPed >= cDocIni .AND.  ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + (dbfPedPrvT)->cSufPed <= cDocFin

            lChgImpDoc( dbfPedPrvT )

         if lCopiasPre

            nCopyProvee := if( nCopiasDocumento( ( dbfPedPrvT )->cSerPed, "nPedPrv", dbfCount ) == 0, Max( Retfld( ( dbfPedPrvT )->cCodPrv, dbfPrv, "nCopiasF" ), 1 ), nCopiasDocumento( ( dbfPedPrvT )->cSerPed, "nPedPrv", dbfCount ) )

            GenPedPrv( 1, "Imprimiendo documento : " + ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + (dbfPedPrvT)->cSufPed, cFmtDoc, cPrinter, nCopyProvee )

         else

            GenPedPrv( 1, "Imprimiendo documento : " + ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + (dbfPedPrvT)->cSufPed, cFmtDoc, cPrinter, nNumCop )

         end

      ( dbfPedPrvT )->( dbSkip() )

      end

   else

   ( dbfPedPrvT )->( dbSeek( cDocFin ) )



      while ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed >= cDocIni .AND. ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed <= cDocFin .AND. !( dbfPedPrvT )->( Bof() )

            lChgImpDoc( dbfPedPrvT )

         if lCopiasPre

            nCopyProvee := if( nCopiasDocumento( ( dbfPedPrvT )->cSerPed, "nPedPrv", dbfCount ) == 0, Max( Retfld( ( dbfPedPrvT )->cCodPrv, dbfPrv, "nCopiasF" ), 1 ), nCopiasDocumento( ( dbfPedPrvT )->cSerPed, "nPedPrv", dbfCount ) )

            GenPedPrv( 1, "Imprimiendo documento : " + ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + (dbfPedPrvT)->cSufPed, cFmtDoc, cPrinter, nCopyProvee )

         else

            GenPedPrv( 1, "Imprimiendo documento : " + ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + (dbfPedPrvT)->cSufPed, cFmtDoc, cPrinter, nNumCop )

         end

      ( dbfPedPrvT )->( dbSkip( -1 ) )

      end

   end

   oDlg:enable()

RETURN NIL



FUNCTION GenPedPrv( nDevice, cCaption, cCodDoc, cPrinter, nCopies )

   local oInf
   local oDevice
   local nPedido

   if ( dbfPedPrvT )->( Lastrec() ) == 0
      return nil
   end

   nPedido              := ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed

   IIF( nDevice == nil, nDevice := 1, ) ;
   IIF( cCaption == nil, cCaption := "Imprimiendo pedido", ) ;
   IIF( cCodDoc == nil, cCodDoc := cFormatoDocumento( ( dbfPedPrvT )->cSerPed, "nPedPrv", dbfCount ), ) ;
   IIF( nCopies == nil, nCopies := if( nCopiasDocumento( ( dbfPedPrvT )->cSerPed, "nPedPrv", dbfCount ) == 0, Max( Retfld( ( dbfPedPrvT )->cCodPrv, dbfPrv, "nCopiasF" ), 1 ), nCopiasDocumento( ( dbfPedPrvT )->cSerPed, "nPedPrv", dbfCount ) ), ) ;

   if Empty( cCodDoc )
      cCodDoc           := cFirstDoc( "PP", dbfDoc )
   end

   if !lExisteDocumento( cCodDoc, dbfDoc )
      return nil
   end





   if lVisualDocumento( cCodDoc, dbfDoc )

      PrintReportPedPrv( nDevice, nCopies, cPrinter, dbfDoc )

   else





      ( dbfPedPrvL)->( dbSeek( nPedido ) )
      ( dbfPrv    )->( dbSeek( ( dbfPedPrvT )->cCodPrv ) )
      ( dbfDiv    )->( dbSeek( ( dbfPedPrvT )->cDivPed ) )
      ( dbfFPago  )->( dbSeek( ( dbfPedPrvT )->cCodPgo ) )
      ( dbfAlm    )->( dbSeek( ( dbfPedPrvT )->cCodAlm ) )
      ( dbfUsr    )->( dbSeek( ( dbfPedPrvT )->cCodUsr ) )

      private cDbf         := dbfPedPrvT
      private cDbfCol      := dbfPedPrvL
      private cDbfPrv      := dbfPrv
      private cDbfPgo      := dbfFPago
      private cDbfIva      := dbfIva
      private cDbfAlm      := dbfAlm
      private cDbfDiv      := dbfDiv
      private cDbfArt      := dbfArticulo
      private cDbfKit      := dbfKit
      private cDbfUsr      := dbfUsr
      private cDbfPro      := dbfPro
      private cDbfTblPro   := dbfTblPro
      private cPicUndPed   := cPicUnd
      private cPinDivPed   := cPinDiv
      private cPirDivPed   := cPirDiv
      private nDinDivPed   := nDinDiv
      private nDirDivPed   := nDirDiv
      private nVdvDivPed   := ( dbfPedPrvT )->nVdvPed





      if !Empty( cPrinter )
         oDevice           := TPrinter():New( cCaption, .F., .T., cPrinter )
         oInf := RptBegin({}, {}, {}, {}, {}, .F.,,,, .F.,, oDevice, cCaption,,, )
      else
         oInf := RptBegin({}, {}, {}, {}, {}, .F.,,,, .T.,,, cCaption,,, )
      end

      if !Empty( oInf ) .AND. oInf:lCreated
         oInf:lAutoland    := .F.
         oInf:lFinish      := .F.
         oInf:lNoCancel    := .T.
         oInf:bSkip        := {|| ( dbfPedPrvL )->( dbSkip() ) }

         oInf:oDevice:lPrvModal  := .T.

         do case
            case nDevice == 1
               oInf:bPreview  := {| oDevice | PrintPreview( oDevice ) }

            case nDevice == 3
               oInf:bPreview  := {| oDevice | PrintPdf( oDevice ) }

         end

         SetMargin(  cCodDoc, oInf )
         PrintColum( cCodDoc, oInf )
      end

      RptEnd()

      if !Empty( oInf )




         oInf:Activate({||         ( !( dbfPedPrvL )->lImpLin )}, {||       ( ( dbfPedPrvL )->cSerPed + Str( ( dbfPedPrvL )->nNumPed ) + ( dbfPedPrvL )->cSufPed == nPedido .AND. !( dbfPedPrvL )->( eof() ) )},,,, {||  ePage( oInf, cCodDoc )},,,,,,,, )

         if nDevice == 1
            oInf:oDevice:end()
         end

      end

      oInf                 := nil





   end

   lChgImpDoc( dbfPedPrvT )

RETURN NIL



STATIC FUNCTION EPage( oInf, cCodDoc )

   private nPagina      := oInf:nPage
    private lEnd            := oInf:lFinish

   PrintItems( cCodDoc, oInf )

RETURN NIL







FUNCTION nTotPedPrv( cPedido, cPedPrvT, cPedPrvL, cIva, cDiv, aTmp, cDivRet, lPic )

   local nRec
   local nTotArt
    local dFecFac
    local lRecargo
    local nDtoEsp
    local nDtoPP
   local nDtoUno
    local nDtoDos
    local nPorte
    local cCodDiv
   local nRegIva
   local aTotDto     := { 0, 0, 0 }
   local aTotDPP     := { 0, 0, 0 }
   local aTotUno     := { 0, 0, 0 }
   local aTotDos     := { 0, 0, 0 }
   local nTotUno
   local nTotDos
   local bCondition

   IIF( cPedPrvT == nil, cPedPrvT := dbfPedPrvT, ) ;
   IIF( cPedPrvL == nil, cPedPrvL := dbfPedPrvL, ) ;
   IIF( cIva == nil, cIva := dbfIva, ) ;
   IIF( cDiv == nil, cDiv := dbfDiv, ) ;
   IIF( lPic == nil, lPic := .F., ) ;
   IIF( cPedido == nil, cPedido := ( cPedPrvT )->cSerPed + Str( ( cPedPrvT )->nNumPed ) + ( cPedPrvT )->cSufPed, ) ;

   public nTotPed    := 0
   public nTotBrt    := 0
   public nTotDto    := 0
   public nTotDPP    := 0
   public nTotNet    := 0
   public nTotIva    := 0
   public nTotReq    := 0
   public nTotImp    := 0
   public aTotIva    := { { 0,0,nil,0,0,0 }, { 0,0,nil,0,0,0 }, { 0,0,nil,0,0,0 } }
   public aIvaUno    := aTotIva[ 1 ]
   public aIvaDos    := aTotIva[ 2 ]
   public aIvaTre    := aTotIva[ 3 ]

   nRec              := ( cPedPrvL )->( Recno() )

   if aTmp <> nil
        dFecFac            := aTmp[ 5 ]
        lRecargo            := aTmp[ 25]
        nDtoEsp            := aTmp[ 22 ]
        nDtoPP            := aTmp[ 24    ]
      nDtoUno        := aTmp[ 33 ]
      nDtoDos        := aTmp[ 35 ]
        nPorte            := aTmp[ 20 ]
        cCodDiv            := aTmp[ 29 ]
      nVdvDiv        := aTmp[ 30 ]
      nRegIva        := aTmp[ 46 ]
      bCondition     := {|| ( cPedPrvL )->( !eof() ) }
      ( cPedPrvL )->( dbGoTop() )
   else
      dFecFac        := ( cPedPrvT )->dFecPed
      lRecargo       := ( cPedPrvT )->lRecargo
      nDtoEsp        := ( cPedPrvT )->nDtoEsp
      nDtoPP         := ( cPedPrvT )->nDpp
      nDtoUno        := ( cPedPrvT )->nDtoUno
      nDtoDos        := ( cPedPrvT )->nDtoDos
      nPorte         := ( cPedPrvT )->nPortes
      cCodDiv        := ( cPedPrvT )->cDivPed
      nVdvDiv        := ( cPedPrvT )->nVdvPed
      nRegIva        := ( cPedPrvT )->nRegIva
      bCondition     := {|| ( cPedPrvL )->cSerPed + Str( ( cPedPrvL )->nNumPed ) + ( cPedPrvL )->cSufPed == cPedido .AND. ( cPedPrvL )->( !eof() ) }
      ( cPedPrvL )->( dbSeek( cPedido ) )
   end

   cPinDiv           := cPinDiv( cCodDiv, cDiv )
   cPirDiv           := cPirDiv( cCodDiv, cDiv )
   nDinDiv           := nDinDiv( cCodDiv, cDiv )
   nDirDiv           := nRinDiv( cCodDiv, cDiv )

   while Eval( bCondition )

      if lValLine( cPedPrvL )





         nTotArt           := nTotLPedPrv( cPedPrvL, nDinDiv, nDirDiv )
         if nTotArt <> 0





            do case
            case aTotIva[ 1, 3 ] == NIL .OR. aTotIva[ 1, 3 ] == ( cPedPrvL )->nIva
               aTotIva[ 1, 3 ]   := (cPedPrvL)->NIVA
               aTotIva[ 1, 4 ]   := (cPedPrvL)->NREQ
               aTotIva[ 1, 1 ]   += nTotArt

            case aTotIva[ 2, 3 ] == NIL .OR. aTotIva[ 2, 3 ] == ( cPedPrvL )->nIva
               aTotIva[ 2, 3 ]   := (cPedPrvL)->NIVA
               aTotIva[ 2, 4 ]   := (cPedPrvL)->NREQ
               aTotIva[ 2, 1 ]   += nTotArt

            case aTotIva[ 3, 3 ] == NIL .OR. aTotIva[ 3, 3 ] == ( cPedPrvL )->nIva
               aTotIva[ 3, 3 ]   := (cPedPrvL)->NIVA
               aTotIva[ 3, 4 ]   := (cPedPrvL)->NREQ
               aTotIva[ 3, 1 ]   += nTotArt
            end

         end

      end

      ( cPedPrvL )->( dbSkip() )

   end

   ( cPedPrvL )->( dbGoTo( nRec ) )





   nTotBrt           := aTotIva[ 1, 1 ] + aTotIva[ 2, 1 ] + aTotIva[ 3, 1 ]





   nTotBrt           += nPorte

   aTotIva[ 1, 2 ]         := aTotIva[ 1, 1 ]
   aTotIva[ 2, 2 ]         := aTotIva[ 2, 1 ]
   aTotIva[ 3, 2 ]         := aTotIva[ 3, 1 ]





    IF nDtoEsp <> 0

      aTotDto[1]     := Round( aTotIva[ 1, 2 ] * nDtoEsp / 100, nDirDiv )
      aTotDto[2]     := Round( aTotIva[ 2, 2 ] * nDtoEsp / 100, nDirDiv )
      aTotDto[3]     := Round( aTotIva[ 3, 2 ] * nDtoEsp / 100, nDirDiv )

      nTotDto        := aTotDto[1] + aTotDto[2] + aTotDto[3]

      aTotIva[ 1, 2 ]      -= aTotDto[1]
      aTotIva[ 2, 2 ]      -= aTotDto[2]
      aTotIva[ 3, 2 ]      -= aTotDto[3]

   end

    IF nDtoPP <> 0

      aTotDPP[1]     := Round( aTotIva[ 1, 2 ] * nDtoPP / 100, nDirDiv )
      aTotDPP[2]     := Round( aTotIva[ 2, 2 ] * nDtoPP / 100, nDirDiv )
      aTotDPP[3]     := Round( aTotIva[ 3, 2 ] * nDtoPP / 100, nDirDiv )

      nTotDPP        := aTotDPP[1] + aTotDPP[2] + aTotDPP[3]

      aTotIva[ 1, 2 ]      -= aTotDPP[1]
      aTotIva[ 2, 2 ]      -= aTotDPP[2]
      aTotIva[ 3, 2 ]      -= aTotDPP[3]

   end

   IF nDtoUno <> 0

      aTotUno[1]     := Round( aTotIva[ 1, 2 ] * nDtoUno / 100, nDirDiv )
      aTotUno[2]     := Round( aTotIva[ 2, 2 ] * nDtoUno / 100, nDirDiv )
      aTotUno[3]     := Round( aTotIva[ 3, 2 ] * nDtoUno / 100, nDirDiv )

      nTotUno        := aTotDPP[1] + aTotDPP[2] + aTotDPP[3]

      aTotIva[ 1, 2 ]      -= aTotUno[1]
      aTotIva[ 2, 2 ]      -= aTotUno[2]
      aTotIva[ 3, 2 ]      -= aTotUno[3]

    end

    IF nDtoDos <> 0

      aTotDos[1]     := Round( aTotIva[ 1, 2 ] * nDtoDos / 100, nDirDiv )
      aTotDos[2]     := Round( aTotIva[ 2, 2 ] * nDtoDos / 100, nDirDiv )
      aTotDos[3]     := Round( aTotIva[ 3, 2 ] * nDtoDos / 100, nDirDiv )

      nTotDos        := aTotDPP[1] + aTotDPP[2] + aTotDPP[3]

      aTotIva[ 1, 2 ]      -= aTotDos[1]
      aTotIva[ 2, 2 ]      -= aTotDos[2]
      aTotIva[ 3, 2 ]      -= aTotDos[3]

    end

   nTotNet           := Round( aTotIva[ 1, 2 ] + aTotIva[ 2, 2 ] + aTotIva[ 3, 2 ], nDirDiv )





   if nRegIva <= 1

      aTotIva[ 1, 5 ]      := if( aTotIva[ 1, 3 ] <> NIL, Round( aTotIva[ 1, 2 ] * aTotIva[ 1, 3 ] / 100, nDirDiv ), 0 )
      aTotIva[ 2, 5 ]      := if( aTotIva[ 2, 3 ] <> NIL, Round( aTotIva[ 2, 2 ] * aTotIva[ 2, 3 ] / 100, nDirDiv ), 0 )
      aTotIva[ 3, 5 ]      := if( aTotIva[ 3, 3 ] <> NIL, Round( aTotIva[ 3, 2 ] * aTotIva[ 3, 3 ] / 100, nDirDiv ), 0 )





      if lRecargo
         aTotIva[ 1, 6 ]   := if( aTotIva[ 1, 3 ] <> NIL, Round( aTotIva[ 1, 2 ] * aTotIva[ 1, 4 ] / 100, nDirDiv ), 0 )
         aTotIva[ 2, 6 ]   := if( aTotIva[ 2, 3 ] <> NIL, Round( aTotIva[ 2, 2 ] * aTotIva[ 2, 4 ] / 100, nDirDiv ), 0 )
         aTotIva[ 3, 6 ]   := if( aTotIva[ 3, 3 ] <> NIL, Round( aTotIva[ 3, 2 ] * aTotIva[ 3, 4 ] / 100, nDirDiv ), 0 )
      end

   end





   nTotIva           := Round( aTotIva[ 1, 5 ] + aTotIva[ 2, 5 ] + aTotIva[ 3, 5 ], nDirDiv )





   nTotReq           := Round( aTotIva[ 1, 6 ] + aTotIva[ 2, 6 ] + aTotIva[ 3, 6 ], nDirDiv )





   nTotImp           := Round( nTotIva + nTotReq, nDirDiv )





   nTotPed           := nTotNet + nTotImp





   aTotIva           := aSort( aTotIva,,, {|x,y| abs( x[1] ) > abs( y[1] ) } )





   if cDivRet <> nil .AND. cDivRet <> cCodDiv
      nTotNet        := nCnv2Div( nTotNet, cCodDiv, cDivRet, cDiv )
      nTotIva        := nCnv2Div( nTotIva, cCodDiv, cDivRet, cDiv )
      nTotReq        := nCnv2Div( nTotReq, cCodDiv, cDivRet, cDiv )
      nTotPed        := nCnv2Div( nTotPed, cCodDiv, cDivRet, cDiv )
      cPirDiv        := cPirDiv( cDivRet, cDiv )
   end

RETURN ( if( lPic, Trans( nTotPed, cPirDiv ), nTotPed ) )



Static Function RecalculaTotal( aTmp )

   nTotPedPrv( nil, dbfPedPrvT, dbfTmpLin, dbfIva, dbfDiv, aTmp )

   oBrwIva:Refresh()

   oGetNet:SetText( Trans( nTotNet, cPirDiv ) )

   oGetIva:SetText( Trans( nTotIva, cPirDiv ) )

   oGetReq:SetText( Trans( nTotReq, cPirDiv ) )

   oGetTotal:SetText( Trans( nTotPed, cPirDiv ) )

Return .T.



FUNCTION aTotPedPrv( cFactura, dbfPedPrvT, dbfLine, dbfIva, dbfDiv, cDivRet )

   nTotPedPrv( cFactura, dbfPedPrvT, dbfLine, dbfIva, dbfDiv, nil, cDivRet, .F. )

RETURN ( { nTotNet, nTotIva, nTotReq, nTotPed, aTotIva } )







STATIC FUNCTION LoaPrv( aGet, aTmp, dbfPrv, nMode, oSay, oTlfPrv )

   local lValid      := .F.
   local cNewCodCli  := aGet[ 6 ]:VarGet()
   local lChgCodCli  := ( Empty( cOldCodCli ) .OR. cOldCodCli <> cNewCodCli )

   if Empty( cNewCodCli )
      Return .T.
   elseif At( ".", cNewCodCli ) <> 0
      cNewCodCli     := PntReplace( aGet[ 6 ], "0", RetNumCodPrvEmp() )
   else
      cNewCodCli     := Rjust( cNewCodCli, "0", RetNumCodPrvEmp() )
   end

   if ( dbfPrv )->( dbSeek( cNewCodCli ) )

      if ( dbfPrv )->lBlqPrv
         msgStop( "Proveedor bloqueado, no se pueden realizar operaciones de compra" )
         return .F.
      end

      aGet[ 6 ]:cText( ( dbfPrv )->Cod )

      if Empty( aGet[ 9 ]:varGet() ) .OR. lChgCodCli
         aGet[ 9 ]:cText( ( dbfPrv )->Titulo )
      end

      if oTlfPrv <> nil
         oTlfPrv:SetText( ( dbfPrv )->Telefono )
      end

      if Empty( aGet[ 10 ]:varGet() ) .OR. lChgCodCli
         aGet[ 10 ]:cText( ( dbfPrv )->Domicilio )
      endif

      if Empty( aGet[ 11 ]:varGet() ) .OR. lChgCodCli
         aGet[ 11 ]:cText( ( dbfPrv )->Poblacion )
      endif

      if Empty( aGet[ 12 ]:varGet() ) .OR. lChgCodCli
         aGet[ 12 ]:cText( ( dbfPrv )->Provincia )
      endif

      if Empty( aGet[ 13 ]:varGet() ) .OR. lChgCodCli
         aGet[ 13 ]:cText( ( dbfPrv )->CodPostal )
      endif

      if Empty( aGet[ 14 ]:varGet() ) .OR. lChgCodCli
         aGet[ 14 ]:cText( ( dbfPrv )->Nif )
      endif





      if lChgCodCli
         aGet[ 21 ]:cText( ( dbfPrv )->cDtoEsp )
         aGet[ 22 ]:cText( ( dbfPrv )->nDtoEsp )
         aGet[ 23    ]:cText( ( dbfPrv )->cDtoPp  )
         aGet[ 24    ]:cText( ( dbfPrv )->DtoPp   )
      end

      if Empty( aGet[18]:VarGet() )
         aGet[ 18 ]:cText( ( dbfPrv )->fPago )
         aGet[ 18 ]:lValid()
      end





      if lChgCodCli
         if ( dbfPrv )->nPlzEnt <> 0
            aGet[ 15 ]:cText( GetSysDate() + ( dbfPrv )->nPlzEnt )
         else
            aGet[ 15 ]:cText( Ctod( "" ) )
         end
      end

      if nMode == 1

         aGet[ 46 ]:nOption( Max( ( dbfPrv )->nRegIva, 1 ) )
         aGet[ 46 ]:Refresh()

         if Empty( aTmp[ 1 ] )

            if !Empty( ( dbfPrv )->Serie )
               aGet[ 1 ]:cText( ( dbfPrv )->Serie )
            end

         else

            if !Empty( ( dbfPrv )->Serie ) .AND. aTmp[ 1 ] <> ( dbfPrv )->Serie .AND. ApoloMsgNoYes( "La serie del proveedor seleccionado es distinta a la anterior.", "¿Desea cambiar la serie?" )
               aGet[ 1 ]:cText( ( dbfPrv )->Serie )
            end

         end

      end

      if lChgCodCli
         aTmp[ 25 ] := ( dbfPrv )->lReq
         aGet[ 25 ]:Refresh()
      end

      if ( dbfPrv )->lMosCom .AND. !Empty( ( dbfPrv )->mComent ) .AND. lChgCodCli
         MsgStop( AllTrim( ( dbfPrv )->mComent ) )
      end

      cOldCodCli     := ( dbfPrv )->Cod

      lValid         := .T.

   else

        msgStop( "Proveedor no encontrado" )

   end

RETURN lValid



FUNCTION BrwPedPrv( oGetNum, dbfPedPrvT, dbfPedPrvL, dbfIva, dbfDiv, dbfFPago )

    local oDlg
    local oBrw
   local oGet1
   local cGet1
   local nOrd     := GetBrwOpt( "BrwPedPrv" )
    local oCbxOrd
   local aCbxOrd  := { "Número", "Fecha", "Código", "Nombre" }
   local cCbxOrd


   local aDbfBmp  := {  LoadBitmap( GetResources(), "BRED"   ), LoadBitmap( GetResources(), "BYELOW" ), LoadBitmap( GetResources(), "BGREEN" ) }

   nOrd              := Min( Max( nOrd, 1 ), len( aCbxOrd ) )
   cCbxOrd           := aCbxOrd[ nOrd ]

   ( dbfPedPrvT )->( dbSetFilter( {|| Field->NESTADO <> 3 }, "NESTADO != 3" ) )

   nOrd              := ( dbfPedPrvT )->( OrdSetFocus( nOrd ) )

   oDlg = TDialog():New(,,,, "Pedido a proveedores", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F., )






        oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, dbfPedPrvT ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfPedPrvT, .T., nil, .F. ) ) }, .F., .F.,,,,,, nil, "FIND",, )






        oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( dbfPedPrvT )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:refresh(), oGet1:SetFocus() )},,,, .F.,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfPedPrvT
      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Pedido a proveedor.Browse"

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }

      oBrw:CreateFromResource( 105 )

      with object ( oBrw:AddCol() )
         :cHeader          := "Es. Estado"
         :bStrData         := {|| "" }
         :bBmpData         := {|| ( dbfPedPrvT )->nEstado }
         :nWidth           := 20
         :AddResource( "Bullet_Square_Red_16" )
         :AddResource( "Bullet_Square_Yellow_16" )
         :AddResource( "Bullet_Square_Green_16" )
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Número"
         :cSortOrder       := "nNumPed"
         :bEditValue       := {|| ( dbfPedPrvT )->cSerPed + "/" + Str( ( dbfPedPrvT )->nNumPed ) + "/" + ( dbfPedPrvT )->cSufPed }
         :nWidth           := 60
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Fecha"
         :cSortOrder       := "dFecPed"
         :bEditValue       := {|| dToc( ( dbfPedPrvT )->dFecPed ) }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodPrv"
         :bEditValue       := {|| Rtrim( ( dbfPedPrvT )->cCodPrv ) }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cNomPrv"
         :bEditValue       := {|| Rtrim( ( dbfPedPrvT )->cNomPrv ) }
         :nWidth           := 200
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Importe"
         :bEditValue       := {|| nTotPedPrv( ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed, dbfPedPrvT, dbfPedPrvL, dbfIva, dbfDiv, nil, cDivEmp(), .T. ) }
         :nWidth           := 60
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end




        TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )




        TButton():ReDefine( 500,, oDlg,,, .F., {||         .F.},,, .F. )




        TButton():ReDefine( 501,, oDlg,,, .F., {||         .F.},,, .F. )

   oDlg:AddFastKey( 116, {|| oDlg:end( 1 ) } )
   oDlg:AddFastKey( 13, {|| oDlg:end( 1 ) } )

   oDlg:bStart    := {|| oBrw:Load() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   IF oDlg:nResult == 1
      oGetNum:cText( ( dbfPedPrvT )->CSERPED + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed )
      oGetNum:disable()
   end

   DestroyFastFilter( dbfPedPrvT )

   SetBrwOpt( "BrwPedPrv", ( dbfPedPrvT )->( OrdNumber() ) )

   ( dbfPedPrvT )->( dbSetFilter() )
   ( dbfPedPrvT )->( OrdSetFocus( nOrd ) )

   AEval( aDbfBmp, { | hBmp | DeleteObject( hBmp ) } )




   oBrw:CloseData()

RETURN ( oDlg:nResult == 1 )



FUNCTION ChgPedPrv( nPedido, nMode, dbfPedPrvT )

   local oBlock
   local oError
   local lExito   := .T.
   local lClose   := .F.

   if nMode <> 1 .OR. Empty( nPedido )
      return nil
   end

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if Empty( dbfPedPrvT )
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPROVT.DBF" ), ( cCheckArea( "PEDPROVT", @dbfPedPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPROVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
        lClose := .T.
   end

   if (dbfPedPrvT)->(DbSeek( nPedido ) )
      if dbDialogLock( dbfPedPrvT )
         ( dbfPedPrvT )->nEstado    := 1
      end
   else
      lExito      := .F.
   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClose
        (dbfPedPrvT)->( dbCloseArea() )
   end

RETURN lExito







STATIC FUNCTION lCalcDeta( aTmp, oTotal )

   local nCalculo := nTotUPedPrv( aTmp, nDinDiv )

   IF lCalCaj()
      nCalculo    *= If( aTmp[ 8 ] <> 0, aTmp[ 8 ], 1 )
    end

    IF aTmp[ 15 ] <> 0
      nCalculo    -= nCalculo * aTmp[ 15 ] / 100
    end

   IF aTmp[ 16 ] <> 0
        nCalculo     -= nCalculo * aTmp[ 16 ] / 100
    end

   nCalculo       *= nTotNPedPrv( aTmp )

   nCalculo       := Round( nCalculo, nDinDiv )

    oTotal:cText( nCalculo )

RETURN .T.



FUNCTION nTotEPedPrv( uTmp )

   local nCalculo := 0

   do case
   case ValType( uTmp ) == "C"
      nCalculo    := NotCaja( (uTmp)->nCanEnt ) * (uTmp)->nUniEnt
   case ValType( uTmp ) == "O"
      nCalculo    := NotCaja( uTmp:nCanEnt ) * uTmp:nUniEnt
   case ValType( uTmp ) == "A"
      nCalculo    := NotCaja( uTmp[ 11 ] * uTmp[ 12 ] )
   end

RETURN ( nCalculo )



FUNCTION nTotNPedPrv( uTmp )

   local nCalculo := 0

   IIF( uTmp == nil, uTmp := dbfPedPrvL, ) ;

   do case
   case ValType( uTmp ) == "C"
      nCalculo    := ( uTmp )->nUniCaja
      nCalculo    *= NotCaja( ( uTmp )->nCanPed )
      nCalculo    *= NotCero( ( uTmp )->nUndKit )
      nCalculo    *= NotCero( ( uTmp )->nMedUno )
      nCalculo    *= NotCero( ( uTmp )->nMedDos )
      nCalculo    *= NotCero( ( uTmp )->nMedTre )

   case ValType( uTmp ) == "O"
      nCalculo    := uTmp:nUniCaja
      nCalculo    *= NotCaja( uTmp:nCanPed )
      nCalculo    *= NotCero( uTmp:nUndKit )
      nCalculo    *= NotCero( uTmp:nMedUno )
      nCalculo    *= NotCero( uTmp:nMedDos )
      nCalculo    *= NotCero( uTmp:nMedTre )

   case ValType( uTmp ) == "A"
      nCalculo    := uTmp[ 9 ]
      nCalculo    *= NotCaja( uTmp[ 8 ] )
      nCalculo    *= NotCero( uTmp[ 29 ] )
      nCalculo    *= NotCero( uTmp[ 46 ] )
      nCalculo    *= NotCero( uTmp[ 47 ] )
      nCalculo    *= NotCero( uTmp[ 48 ] )

   end

RETURN ( nCalculo )



FUNCTION nTotUPedPrv( uTmp, nDec, nVdv )

   local nCalculo := 0

   IIF( uTmp == nil, uTmp := dbfPedPrvL, ) ;
   IIF( nDec == nil, nDec := nDinDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   do case
      case ValType( uTmp ) == "C"
         nCalculo := ( uTmp )->nPreDiv

      case ValType( uTmp ) == "O"
         nCalculo := uTmp:nPreDiv

      case ValType( uTmp ) == "A"
         nCalculo := uTmp[ 10 ]

   end

   if nVdv <> 0
      nCalculo    := nCalculo / nVdv
   end

RETURN ( Round( nCalculo, nDec ) )



FUNCTION nIvaUPedPrv( uTmp, nDec, nVdv )

   local nCalculo

   IIF( uTmp == nil, uTmp := dbfPedPrvL, ) ;
   IIF( nDec == nil, nDec := nDinDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo       := nTotUPedPrv( uTmp, nDec, nVdv )
   nCalculo       := nCalculo * ( uTmp )->nIva / 100

   if nVdv <> 0
      nCalculo    := nCalculo / nVdv
   end

RETURN ( Round( nCalculo, nDec ) )



FUNCTION nTotLPedPrv( uTmp, nDec, nRec, nVdv, cPouDiv )

   local nCalculo

   IIF( uTmp == nil, uTmp := dbfPedPrvL, ) ;
   IIF( nDec == nil, nDec := nDinDiv(), ) ;
   IIF( nRec == nil, nRec := nRinDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;



   nCalculo       := nTotUPedPrv( uTmp, nDec, nVdv )

   do case
      case ValType( uTmp ) == "C"

         if ( uTmp )->nDtoLin <> 0
            nCalculo    -= nCalculo * ( uTmp )->nDtoLin / 100
         end

         if ( uTmp )->nDtoPrm <> 0
            nCalculo    -= nCalculo * ( uTmp )->nDtoPrm / 100
         end

      case ValType( uTmp ) == "O"

         if uTmp:nDtoLin <> 0
            nCalculo    -= nCalculo * uTmp:nDtoLin / 100
         end

         if uTmp:nDtoPrm <> 0
            nCalculo    -= nCalculo * uTmp:nDtoPrm / 100
         end

   end



   nCalculo       *= nTotNPedPrv( uTmp )

   if nRec <> nil
      nCalculo    := Round( nCalculo, nRec )
   end

RETURN ( if( cPouDiv <> NIL, Trans( nCalculo, cPouDiv ), nCalculo ) )



FUNCTION nIvaLPedPrv( uPedPrvT, uPedPrvL, nDec, nRec, nVdv, cPouDiv )

   local nCalculo

   IIF( uPedPrvT == nil, uPedPrvT := dbfPedPrvT, ) ;
   IIF( uPedPrvL == nil, uPedPrvL := dbfPedPrvL, ) ;
   IIF( nDec == nil, nDec := nDinDiv(), ) ;
   IIF( nRec == nil, nRec := nRinDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo          := nImpLPedPrv( uPedPrvT, uPedPrvL, nDec, nRec, nVdv, .F., cPouDiv )
   nCalculo          := nCalculo * ( uPedPrvL )->nIva / 100

RETURN ( if( cPouDiv <> NIL, Trans( nCalculo, cPouDiv ), nCalculo ) )



FUNCTION nImpLPedPrv( uPedPrvT, uPedPrvL, nDec, nRec, nVdv, lIva, cPouDiv )

   local nCalculo

   IIF( uPedPrvT == nil, uPedPrvT := dbfPedPrvT, ) ;
   IIF( uPedPrvL == nil, uPedPrvL := dbfPedPrvL, ) ;
   IIF( nDec == nil, nDec := nDinDiv(), ) ;
   IIF( nRec == nil, nRec := nRinDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;
   IIF( lIva == nil, lIva := .F., ) ;

   nCalculo          := nTotLPedPrv( uPedPrvL, nDec, nRec, nVdv )

   if ValType( uPedPrvT ) == "A"
      nCalculo    -= Round( nCalculo * uPedPrvT[ 22 ]  / 100, nRec )
      nCalculo    -= Round( nCalculo * uPedPrvT[ 24    ]  / 100, nRec )
      nCalculo    -= Round( nCalculo * uPedPrvT[ 33 ]  / 100, nRec )
      nCalculo    -= Round( nCalculo * uPedPrvT[ 35 ]  / 100, nRec )
   else
      nCalculo    -= Round( nCalculo * ( uPedPrvT )->nDtoEsp / 100, nRec )
      nCalculo    -= Round( nCalculo * ( uPedPrvT )->nDpp    / 100, nRec )
      nCalculo    -= Round( nCalculo * ( uPedPrvT )->nDtoUno / 100, nRec )
      nCalculo    -= Round( nCalculo * ( uPedPrvT )->nDtoDos / 100, nRec )
   end

   if lIva .AND. ( dbfPedPrvL )->nIva <> 0
      nCalculo    += nCalculo * ( uPedPrvL )->nIva / 100
   end

RETURN ( if( cPouDiv <> NIL, Trans( nCalculo, cPouDiv ), nCalculo ) )



FUNCTION nBrtLPedPrv( uTmpLin, nDec, nRec, nVdv, cPorDiv )

   local nCalculo    := 0

   IIF( nDec == nil, nDec := 2, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo          := nTotUPedPrv( uTmpLin, nDec, nVdv, cPorDiv )
   nCalculo          *= nTotNPedPrv( uTmpLin )

   nCalculo          := Round( nCalculo / nVdv, nRec )

Return ( if( cPorDiv <> nil, Trans( nCalculo, cPorDiv ), nCalculo ) )



FUNCTION mkPedPrv( cPath, lAppend, cPathOld, oMeter, bFor )

   local dbfPedPrvT
   local dbfPedPrvL
   local oldPedPrvT
   local oldPedPrvL
   local oldPedPrvI
   local oldPedPrvD

   IIF( lAppend == nil, lAppend := .F., ) ;
   IIF( bFor == nil, bFor := {|| .T. }, ) ;

   if oMeter <> NIL
      oMeter:cText   := "Generando bases"
      SysRefresh()
   end

   CreateFiles( cPath )
   rxPedPrv( cPath, oMeter )

   IF lAppend .AND. lIsDir( cPathOld )

      dbUseArea( .T., cDriver(), cPath + "PedPROVT.DBF", cCheckArea( "PedPROVT", @dbfPedPrvT ), .F. )
      if !( dbfPedPrvT )->( neterr() )
            ordListAdd( cPath + "PedPROVT.CDX"  )
      end

      dbUseArea( .T., cDriver(), cPath + "PedPROVL.DBF", cCheckArea( "PedPROVL", @dbfPedPrvL ), .F. )
      if !( dbfPedPrvL )->( neterr() )
            ordListAdd( cPath + "PedPROVL.CDX"  )
      end

      dbUseArea( .T., cDriver(), cPathOld + "PEDPROVT.DBF", cCheckArea( "PEDPROVT", @oldPedPrvT ), .F. )
      if !( oldPedPrvT )->( neterr() )
            ordListAdd( cPathOld + "PEDPROVT.CDX"  )
      end

       dbUseArea( .T., cDriver(), cPathOld + "PEDPROVL.DBF", cCheckArea( "PEDPROVL", @oldPedPrvL ), .F. )
      if !( oldPedPrvL )->( neterr() )
            ordListAdd( cPathOld + "PEDPROVL.CDX"  )
      end

      dbUseArea( .T., cDriver(), cPath + "PedPrvI.Dbf", cCheckArea( "PedPrvI", @dbfPedPrvI ), .F. )
      if !( oldPedPrvL )->( neterr() )
            ( dbfPedPrvI )->( ordListAdd( cPath + "PedPrvI.Cdx" ) )
      end

      dbUseArea( .T., cDriver(), cPathOld + "PEDPRVI.DBF", cCheckArea( "PEDPRVI", @oldPedPrvI ), .F. )
      if !( oldPedPrvI )->( neterr() )
            ( oldPedPrvI )->( ordListAdd( cPathOld + "PEDPRVI.CDX" ) )
      end

      dbUseArea( .T., cDriver(), cPath + "PedPrvD.Dbf", cCheckArea( "PedPrvD", @dbfPedPrvD ), .F. )
      if !( dbfPedPrvD)->( neterr() )
            ( dbfPedPrvD )->( ordListAdd( cPath + "PedPrvD.Cdx" ) )
      end

      dbUseArea( .T., cDriver(), cPathOld + "PEDPRVD.DBF", cCheckArea( "PEDPRVD", @oldPedPrvD ), .F. )
      if !( dbfPedPrvD)->( neterr() )
            ( oldPedPrvD )->( ordListAdd( cPathOld + "PEDPRVD.CDX" ) )
      end

      while !( oldPedPrvT )->( eof() )

         if eval( bFor, oldPedPrvT )
            dbCopy( oldPedPrvT, dbfPedPrvT, .T. )

            if ( dbfPedPrvT )->( dbRLock() )
               ( dbfPedPrvT )->cTurPed    := Padl( "1", 6 )
               ( dbfPedPrvT )->( dbRUnlock() )
            end

            if ( oldPedPrvL )->( dbSeek( (oldPedPrvT)->CSERPED + Str( (oldPedPrvT)->nNumPed ) + (oldPedPrvT)->cSufPed ) )
               while (oldPedPrvT)->CSERPED + Str( (oldPedPrvL)->nNumPed ) + (oldPedPrvL)->cSufPed == (oldPedPrvT)->CSERPED + Str( (dbfPedPrvT)->nNumPed ) + (dbfPedPrvT)->cSufPed .AND. !(oldPedPrvL)->( eof() )
                  dbCopy( oldPedPrvL, dbfPedPrvL, .T. )
                  ( oldPedPrvL )->( dbSkip() )
               end
            end

            if ( oldPedPrvI )->( dbSeek( ( oldPedPrvT )->cSerPed + Str( ( oldPedPrvT )->nNumPed ) + ( oldPedPrvT )->cSufPed ) )
               while ( oldPedPrvI )->cSerPed + Str( ( oldPedPrvI )->nNumPed ) + ( oldPedPrvI )->cSufPed == ( oldPedPrvT )->cSerPed + Str( ( oldPedPrvT )->nNumPed ) + ( oldPedPrvT )->cSufPed .AND. !( oldPedPrvI )->( eof() )
                  dbCopy( oldPedPrvI, dbfPedPrvI, .T. )
                  ( oldPedPrvI )->( dbSkip() )
               end
            end

            if ( oldPedPrvD )->( dbSeek( ( oldPedPrvT )->cSerPed + Str( ( oldPedPrvT )->nNumPed ) + ( oldPedPrvT )->cSufPed ) )
               while ( oldPedPrvD )->cSerPed + Str( ( oldPedPrvD )->nNumPed ) + ( oldPedPrvD )->cSufPed == ( oldPedPrvT )->cSerPed + Str( ( oldPedPrvT )->nNumPed ) + ( oldPedPrvT )->cSufPed .AND. !( oldPedPrvD )->( eof() )
                  dbCopy( oldPedPrvD, dbfPedPrvD, .T. )
                  ( oldPedPrvD )->( dbSkip() )
               end
            end

         end

         ( oldPedPrvT )->( dbSkip() )

      end

      ( dbfPedPrvT )->( dbCloseArea() )
      ( dbfPedPrvL )->( dbCloseArea() )
      ( dbfPedPrvI )->( dbCloseArea() )
      ( dbfPedPrvD )->( dbCloseArea() )

      ( oldPedPrvT )->( dbCloseArea() )
      ( oldPedPrvL )->( dbCloseArea() )
      ( oldPedPrvI )->( dbCloseArea() )
      ( oldPedPrvD )->( dbCloseArea() )

   end

Return nil



FUNCTION rxPedPrv( cPath, oMeter )

    local dbfPedPrvT

   IIF( cPath == nil, cPath := cPatEmp(), ) ;




   if !lExistTable( cPath + "PEDPROVT.DBF" ) .OR.  !lExistTable( cPath + "PEDPROVL.DBF" ) .OR.  !lExistTable( cPath + "PEDPRVI.DBF" )  .OR.  !lExistTable( cPath + "PEDPRVD.DBF" )
      CreateFiles( cPath )
   end





   fEraseIndex( cPath + "PEDPROVT.CDX" )
   fEraseIndex( cPath + "PEDPROVL.CDX" )
   fEraseIndex( cPath + "PEDPRVI.CDX" )
   fEraseIndex( cPath + "PEDPRVD.CDX" )

   dbUseArea( .T., cDriver(), cPath + "PEDPROVT.DBF", cCheckArea( "PEDPROVT", @dbfPedPrvT ), .F. )
   if !( dbfPedPrvT )->( neterr() )
      ( dbfPedPrvT)->( __dbPack() )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVT.CDX", "NNUMPED", "CSERPED + STR( NNUMPED ) + CSUFPED", {|| Field->CSERPED + STR( Field->nNumPed ) + Field->cSufPed } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVT.CDX", "DFECPED", "DFECPED", {|| Field->DFECPED } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVT.CDX", "DFECENT", "DFECENT", {|| Field->DFECENT } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVT.CDX", "CCODPRV", "CCODPRV", {|| Field->CCODPRV } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVT.CDX", "CNOMPRV", "Upper( CNOMPRV )", {|| Upper( Field->CNOMPRV ) } ) )





      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVT.CDX", "nNumPedYea", "Str( Year( dFecPed ) ) + CSERPED + STR( NNUMPED ) + CSUFPED", {|| Str( Year( Field->dFecPed ) ) + Field->CSERPED + STR( Field->nNumPed ) + Field->cSufPed } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVT.CDX", "dFecPedYea", "Str( Year( dFecPed ) ) + Dtoc( DFECPED )", {|| Str( Year( Field->dFecPed ) ) + Dtoc( Field->DFECPED ) } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVT.CDX", "dFecEntYea", "Str( Year( dFecPed ) ) + Dtoc( DFECENT )", {|| Str( Year( Field->dFecPed ) ) + Dtoc( Field->DFECENT ) } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVT.CDX", "cCodPrvYea", "Str( Year( dFecPed ) ) + CCODPRV", {|| Str( Year( Field->dFecPed ) ) + Field->CCODPRV } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVT.CDX", "cNomPrvYea", "Str( Year( dFecPed ) ) + Upper( CNOMPRV )", {|| Str( Year( Field->dFecPed ) ) + Upper( Field->CNOMPRV ) } ) )





      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVT.CDX", "NESTADO", "NESTADO", {|| Field->NESTADO } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PedProvT.CDX", "cTurPed", "cTurPed + cSufPed + cCodCaj", {|| Field->cTurPed + Field->cSufPed + Field->cCodCaj } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PedProvT.Cdx", "cPedCli", "cNumPedCli", {|| Field->cNumPedCli } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PedProvT.Cdx", "cCodUsr", "cCodUsr + Dtos( dFecChg ) + cTimChg", {|| Field->cCodUsr + Dtos( Field->dFecChg ) + Field->cTimChg } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PedProvT.Cdx", "cNumAlb", "cNumAlb", {|| Field->cNumAlb } ) )

      ( dbfPedPrvT )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de pedidos de proveedores" )
   end

   dbUseArea( .T., cDriver(), cPath + "PEDPROVL.DBF", cCheckArea( "PEDPROVL", @dbfPedPrvT ), .F. )
   if !( dbfPedPrvT )->( neterr() )
      ( dbfPedPrvT)->( __dbPack() )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVL.CDX", "nNumPed", "cSerPed + Str( nNumPed ) + cSufPed", {|| Field->cSerPed + Str( Field->nNumPed ) + Field->cSufPed } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVL.CDX", "cRef", "cRef", {|| Field->cRef }, ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVL.CDX", "Lote", "cLote", {|| Field->cLote }, ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVL.CDX", "cPedCliRef", "cPedCli + cRef + cValPr1 + cValPr2", {|| Field->cPedCli + Field->cRef + Field->cValPr1 + Field->cValPr2 } ) )

      ( dbfPedPrvT)->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT)->( ordCreate( cPath + "PEDPROVL.CDX", "cPedCliDet", "cPedCli + cRef + cValPr1 + cValPr2 + cRefPrv ", {|| Field->cPedCli + Field->cRef + Field->cValPr1 + Field->cValPr2 + Field->cRefPrv } ) )

      ( dbfPedPrvT )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de pedidos de proveedores" )
   end

   dbUseArea( .T., cDriver(), cPath + "PedPrvI.DBF", cCheckArea( "PedPrvI", @dbfPedPrvT ), .F. )
   if !( dbfPedPrvT )->( neterr() )
      ( dbfPedPrvT )->( __dbPack() )

      ( dbfPedPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT )->( ordCreate( cPath + "PedPrvI.CDX", "NNUMPED", "CSERPED + STR( NNUMPED ) + CSUFPED", {|| Field->CSERPED + STR( Field->nNumPed ) + Field->cSufPed } ) )

      ( dbfPedPrvT )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de pedidos de proveedores" )
   end

   dbUseArea( .T., cDriver(), cPath + "PedPrvD.DBF", cCheckArea( "PedPrvD", @dbfPedPrvT ), .F. )
   if !( dbfPedPrvT )->( neterr() )
      ( dbfPedPrvT )->( __dbPack() )

      ( dbfPedPrvT )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfPedPrvT )->( ordCreate( cPath + "PedPrvD.CDX", "NNUMPED", "CSERPED + STR( NNUMPED ) + CSUFPED", {|| Field->CSERPED + STR( Field->nNumPed ) + Field->cSufPed } ) )

      ( dbfPedPrvT )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de pedidos de proveedores" )
   end

Return nil



STATIC FUNCTION BeginTrans( aTmp, nMode )

   local lErrors     := .F.
   local cDbf        := "PProL"
   local cDbfInc     := "PProI"
   local cDbfDoc     := "PProD"
   local nPedido     := aTmp[ 1 ] +  Str( aTmp[ 2 ] ) + aTmp[ 3 ]
   local oError
   local oBlock      := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE

      cNewFile       := cGetNewFileName( cPatTmp() + cDbf )
      cTmpInc        := cGetNewFileName( cPatTmp() + cDbfInc )
      cTmpDoc        := cGetNewFileName( cPatTmp() + cDbfDoc )





      dbCreate( cNewFile, aSqlStruct( aColPedPrv() ), cLocalDriver() )
      dbUseArea( .T., cLocalDriver(), cNewFile, cCheckArea( cDbf, @dbfTmpLin ), .F. )

      if !( dbfTmpLin )->( neterr() )

         ( dbfTmpLin )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
         ( dbfTmpLin )->( OrdCreate( cNewFile, "nNumLin", "Str( nNumLin, 4 )", {|| Str( Field->nNumLin, 4 ) } ) )

         ( dbfTmpLin )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
         ( dbfTmpLin )->( OrdCreate( cNewFile, "Recno", "Str( Recno() )", {|| Str( Recno() ) } ) )

      end





      dbCreate( cTmpInc, aSqlStruct( aIncPedPrv() ), cLocalDriver() )
      dbUseArea( .T., cLocalDriver(), cTmpInc, cCheckArea( cDbfInc, @dbfTmpInc ), .F. )

      if !( dbfTmpInc )->( neterr() )
         ( dbfTmpInc )->( ordCondSet( "!Deleted()", {||!Deleted() } ) )
         ( dbfTmpInc )->( ordCreate( cTmpInc, "Recno", "Recno()", {|| Recno() } ) )
      end





      dbCreate( cTmpDoc, aSqlStruct( aPedPrvDoc() ), cLocalDriver() )
      dbUseArea( .T., cLocalDriver(), cTmpDoc, cCheckArea( cDbfDoc, @dbfTmpDoc ), .F. )
      if !( dbfTmpDoc )->( neterr() )
         ( dbfTmpDoc )->( ordCondSet( "!Deleted()", {||!Deleted() } ) )
         ( dbfTmpDoc )->( ordCreate( cTmpDoc, "Recno", "Recno()", {|| Recno() } ) )
      end





      if ( dbfPedPrvL )->( dbSeek( nPedido ) )

         while ( ( dbfPedPrvL )->cSerPed + Str( ( dbfPedPrvL )->nNumPed ) + ( dbfPedPrvL )->cSufPed == nPedido )

            dbPass( dbfPedPrvL, dbfTmpLin, .T. )

            ( dbfPedPrvL )->( dbSkip() )

         end

      end

      ( dbfTmpLin )->( dbGoTop() )





      if ( dbfPedPrvI )->( dbSeek( nPedido ) )

         while ( ( dbfPedPrvI )->cSerPed + Str( ( dbfPedPrvI )->nNumPed ) + ( dbfPedPrvI )->cSufPed == nPedido ) .AND. ( dbfPedPrvI )->( !eof() )

            dbPass( dbfPedPrvI, dbfTmpInc, .T. )
            ( dbfPedPrvI )->( dbSkip() )

         end

      end

      ( dbfTmpInc )->( dbGoTop() )





      if ( dbfPedPrvD )->( dbSeek( nPedido ) )

         while ( ( dbfPedPrvD )->cSerPed + Str( ( dbfPedPrvD )->nNumPed ) + ( dbfPedPrvD )->cSufPed == nPedido ) .AND. ( dbfPedPrvD )->( !eof() )

            dbPass( dbfPedPrvD, dbfTmpDoc, .T. )
            ( dbfPedPrvD )->( dbSkip() )

         end

      end

      ( dbfTmpDoc )->( dbGoTop() )


   RECOVER USING oError

      msgStop( "Imposible crear tablas temporales." + Chr(13)+Chr(10) + ErrorMessage( oError ) )

      KillTrans()

      lErrors     := .T.

   end

   ErrorBlock( oBlock )

RETURN ( lErrors )



function aIncPedPrv()

   local aIncPedPrv  := {}

   aAdd( aIncPedPrv, { "cSerPed", "C",    1,  0, "Serie de pedido" ,                 "",                   "", "( cDbfCol )" } )
   aAdd( aIncPedPrv, { "nNumPed", "N",    9,  0, "Número de pedido" ,                "'999999999'",        "", "( cDbfCol )" } )
   aAdd( aIncPedPrv, { "cSufPed", "C",    2,  0, "Sufijo de pedido" ,                "",                   "", "( cDbfCol )" } )
   aAdd( aIncPedPrv, { "cCodTip", "C",    3,  0, "Tipo de incidencia" ,              "",                   "", "( cDbfCol )" } )
   aAdd( aIncPedPrv, { "dFecInc", "D",    8,  0, "Fecha de la incidencia" ,          "",                   "", "( cDbfCol )" } )
   aAdd( aIncPedPrv, { "mDesInc", "M",   10,  0, "Descripción de la incidencia" ,    "",                   "", "( cDbfCol )" } )
   aAdd( aIncPedPrv, { "lListo",  "L",    1,  0, "Lógico de listo" ,                 "",                   "", "( cDbfCol )" } )
   aAdd( aIncPedPrv, { "lAviso",  "L",    1,  0, "Lógico de Aviso" ,                 "",                   "", "( cDbfCol )" } )

return ( aIncPedPrv )



function aPedPrvDoc()

   local aPedPrvDoc  := {}

   aAdd( aPedPrvDoc, { "cSerPed", "C",    1,  0, "Serie de pedido" ,                 "",                   "", "( cDbfCol )" } )
   aAdd( aPedPrvDoc, { "nNumPed", "N",    9,  0, "Número de pedido" ,                "'999999999'",        "", "( cDbfCol )" } )
   aAdd( aPedPrvDoc, { "cSufPed", "C",    2,  0, "Sufijo de pedido" ,                "",                   "", "( cDbfCol )" } )
   aAdd( aPedPrvDoc, { "cNombre", "C",  250,  0, "Nombre del documento" ,            "",                   "", "( cDbfCol )" } )
   aAdd( aPedPrvDoc, { "cRuta",   "M",   10,  0, "Ruta del documento" ,              "",                   "", "( cDbfCol )" } )
   aAdd( aPedPrvDoc, { "mObsDoc", "M",   10,  0, "Observaciones del documento" ,     "",                   "", "( cDbfCol )" } )

return ( aPedPrvDoc )



STATIC FUNCTION EndTrans( aGet, aTmp, oBrw, nMode, oDlg )

   local oError
   local oBlock
   local aTabla
   local cSerie
   local nPedido
   local cSufPed
   local nNumLin
   local cNumPedCli

   if Empty( aTmp[ 1 ] )
      aTmp[ 1 ]  := "A"
   end

   nNumLin              := 1
   cSerie               := aTmp[ 1 ]
   nPedido              := aTmp[ 2 ]
   cSufPed              := aTmp[ 3 ]
   cNumPedCli           := aTmp[ 38 ]





   if !lValidaOperacion( aTmp[ 5 ] )
      Return .F.
   end





   if Empty( aTmp[ 6 ] )
      msgStop( "Proveedor no puede estar vacío." )
      aGet[ 6 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 7 ] )
      msgStop( "Almacen no puede estar vacío." )
      aGet[ 7 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 8 ] )
      msgStop( "Caja no puede estar vacía." )
      aGet[ 8 ]:SetFocus()
      return .F.
   end

   if ( dbfTmpLin )->( eof() )
      MsgStop( "No puede almacenar un documento sin líneas." )
      return .F.
   end

   oDlg:Disable()

   oMsgText( "Archivando" )

   aTmp[ 42 ]     := GetSysDate()
   aTmp[ 43 ]     := Time()

   do case
   case nMode == 1 .OR. nMode == 4

      nPedido           := nNewDoc( cSerie, dbfPedPrvT, "NPEDPRV", , dbfCount )
      aTmp[ 2 ]  := nPedido

   case nMode == 2

      if nPedido <> 0

         while ( dbfPedPrvL )->( dbSeek( cSerie + str( nPedido ) + cSufPed ) )
            if dbLock( dbfPedPrvL )
               ( dbfPedPrvL )->( dbDelete() )
               ( dbfPedPrvL )->( dbUnLock() )
            end
         end

         while ( dbfPedPrvI )->( dbSeek( cSerie + str( nPedido ) + cSufPed ) )
            if dbLock( dbfPedPrvI )
               ( dbfPedPrvI )->( dbDelete() )
               ( dbfPedPrvI )->( dbUnLock() )
            end
         end

         while ( dbfPedPrvD )->( dbSeek( cSerie + str( nPedido ) + cSufPed ) )
            if dbLock( dbfPedPrvD )
               ( dbfPedPrvD )->( dbDelete() )
               ( dbfPedPrvD )->( dbUnLock() )
            end
         end

      end





   end





   aTmp[ 47 ]     := nTotNet
   aTmp[ 48 ]     := nTotIva
   aTmp[ 49 ]     := nTotReq
   aTmp[ 50 ]     := nTotPed

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   BeginTransaction()





   ( dbfTmpLin )->( dbClearFilter() )

   oMsgProgress()
   oMsgProgress():SetRange( 0, ( dbfTmpLin )->( LastRec() ) )





   ( dbfTmpLin )->( dbGoTop() )
   while !( dbfTmpLin )->( eof() )
      dbPass( dbfTmpLin, dbfPedPrvL, .T., cSerie, nPedido, cSufPed )
      ( dbfTmpLin )->( dbSkip() )
      oMsgProgress():Deltapos(1)
   end





   ( dbfTmpInc )->( dbGoTop() )
   while ( dbfTmpInc )->( !eof() )
      dbPass( dbfTmpInc, dbfPedPrvI, .T., cSerie, nPedido, cSufPed )
      ( dbfTmpInc )->( dbSkip() )
   end





   ( dbfTmpDoc )->( dbGoTop() )
   while ( dbfTmpDoc )->( !eof() )
      dbPass( dbfTmpDoc, dbfPedPrvD, .T., cSerie, nPedido, cSufPed )
      ( dbfTmpDoc )->( dbSkip() )
   end











   WinGather( aTmp, , dbfPedPrvT, oBrw, nMode )





   oStock:SetPedPrv( cSerie + str( nPedido ) + cSufPed )





   dbCommitAll()

   CommitTransaction()

   RECOVER USING oError

      RollBackTransaction()
      msgStop( "Imposible almacenar pedido" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end
   ErrorBlock( oBlock )

   oMsgText()
   EndProgress()

   oDlg:Enable()
   oDlg:End( 1 )

Return .T.



STATIC FUNCTION KillTrans( oBrwLin )





   if !Empty( dbfTmpLin ) .AND. ( dbfTmpLin )->( Used() )
      ( dbfTmpLin )->( dbCloseArea() )
   end

   if !Empty( dbfTmpInc ) .AND. ( dbfTmpInc )->( Used() )
      ( dbfTmpInc )->( dbCloseArea() )
   end

   if !Empty( dbfTmpDoc ) .AND. ( dbfTmpDoc )->( Used() )
      ( dbfTmpDoc )->( dbCloseArea() )
   end


   dbfErase( cNewFile )
   dbfErase( cTmpInc )
   dbfErase( cTmpDoc )





   if oBrwLin <> nil
      oBrwLin:CloseData()
   end


RETURN .T.



STATIC FUNCTION CreateFiles( cPath )

   if !lExistTable( cPath + "PedProvT.DBF" )
      dbCreate( cPath + "PedProvT.DBF", aSqlStruct( aItmPedPrv() ), cDriver() )
   end

   if !lExistTable( cPath + "PedProvL.DBF" )
      dbCreate( cPath + "PedProvL.DBF", aSqlStruct( aColPedPrv() ), cDriver() )
   end

   if !lExistTable( cPath + "PedPrvI.Dbf" )
      dbCreate( cPath + "PedPrvI.Dbf", aSqlStruct( aIncPedPrv() ), cDriver() )
   end

   if !lExistTable( cPath + "PedPrvD.Dbf" )
      dbCreate( cPath + "PedPrvD.Dbf", aSqlStruct( aPedPrvDoc() ), cDriver() )
   end

RETURN NIL






STATIC FUNCTION ChgState( oBrw )

   local nRec
   local nRecAlb
   local nOrdAlb
   local cNumPed
   local lQuit

   CursorWait()
   SysRefresh()

   if ApoloMsgNoYes( "Al cambiar el estado perderá la referencia a cualquier documento que esté asociado.", "¿Desea cambiarlo?" )

















      for each nRec in ( oBrw:aSelected )

         ( dbfPedPrvT )->( dbGoTo( nRec ) )

         lQuit                         := .F.

         cNumPed                       := ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT  )->cSufPed





         if dbLock( dbfPedPrvT )

            if ( dbfPedPrvT )->nEstado == 1
               ( dbfPedPrvT )->nEstado := 3
            else
               lQuit                   := .T.
               ( dbfPedPrvT )->nEstado := 1
               ( dbfPedPrvT )->cNumAlb := ""
            end

            ( dbfPedPrvT )->( dbRUnlock() )

         end

         if lQuit





            nRecAlb  := ( dbfAlbPrvT )->( RecNo() )
            nOrdAlb  := ( dbfAlbPrvT )->( OrdSetFocus( "CNUMPED" ) )


            if ( dbfAlbPrvT )->( dbSeek( cNumPed ) )

               while ( dbfAlbPrvT )->cNumPed == cNumPed  .AND. !( dbfAlbPrvT )->( Eof() )

                  if dbLock( dbfAlbPrvT )
                     ( dbfAlbPrvT )->cNumPed    := ""
                     ( dbfAlbPrvT )->( dbUnLock() )
                  end

                  ( dbfAlbPrvT )->( dbSkip() )

               end

            end

            ( dbfAlbPrvT )->( OrdSetFocus( nOrdAlb ) )
            ( dbfAlbPrvT )->( dbGoTo( nRecAlb ) )





            nRecAlb  := ( dbfAlbPrvL )->( RecNo() )
            nOrdAlb  := ( dbfAlbPrvL )->( OrdSetFocus( "cCodPed" ) )

            if ( dbfAlbPrvL )->( dbSeek( cNumPed ) )

               while ( dbfAlbPrvL )->cCodPed == cNumPed  .AND. !( dbfAlbPrvL )->( Eof() )

                  if dbLock( dbfAlbPrvL )
                     ( dbfAlbPrvL )->cCodPed    := ""
                     ( dbfAlbPrvL )->( dbUnLock() )
                  end

                  ( dbfAlbPrvL )->( dbSkip() )

               end

            end

            ( dbfAlbPrvL )->( OrdSetFocus( nOrdAlb ) )
            ( dbfAlbPrvL )->( dbGoTo( nRecAlb ) )

         end

      next

    end

    oBrw:Refresh()
    oBrw:SetFocus()

   CursorArrow()
   SysRefresh()

RETURN NIL



FUNCTION lSnd( oWndBrw, dbf )

   local nRecAct
   local nRecOld           := ( dbf )->( Recno() )

   for each nRecAct in ( oWndBrw:oBrw:aSelected )

      ( dbf )->( dbGoTo( nRecAct ) )

      if dbDialogLock( dbf )

         ( dbf )->lSndDoc  := !( dbf )->lSndDoc

         ( dbf )->( dbUnlock() )

      end

   next

   ( dbf )->( dbGoTo( nRecOld ) )

    oWndBrw:Refresh()

    oWndBrw:SetFocus()

Return nil



Static Function lNotOpen()

   if NetErr()
      msgAlert( "Imposible abrir ficheros." )
      CloseFiles()
      return .T.
   end

return .F.



Function AppPedPrv( cCodPrv, cCodArt, lOpenBrowse )

   local nLevel         := nLevelUsr( "01046" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 2 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if PedPrv( nil, nil, cCodPrv, cCodArt )
         oWndBrw:RecAdd()
      end

   else

      if OpenFiles( .T. )
         WinAppRec( nil, bEdtRec, dbfPedPrvT, cCodPrv, cCodArt )
         CloseFiles()
      end

   end

RETURN .T.



FUNCTION EdtPedPrv( nNumPed, lOpenBrowse )

   local nLevel         := nLevelUsr( "01046" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 4 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if PedPrv()
         if dbSeekInOrd( nNumPed, "nNumPed", dbfPedPrvT )
            oWndBrw:RecEdit()
         else
            MsgStop( "No se encuentra pedido" )
         end
      end

   else

      if OpenFiles( .T. )
         if dbSeekInOrd( nNumPed, "nNumPed", dbfPedPrvT )
            WinEdtRec( nil, bEdtRec, dbfPedPrvT )
         else
            MsgStop( "No se encuentra pedido" )
         end
         CloseFiles()
      end

   end

RETURN NIL



FUNCTION ZooPedPrv( nNumPed, lOpenBrowse )

   local nLevel         := nLevelUsr( "01046" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 8 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if PedPrv()
         if dbSeekInOrd( nNumPed, "nNumPed", dbfPedPrvT )
            oWndBrw:RecZoom()
         else
            MsgStop( "No se encuentra pedido" )
         end
      end

   else

      if OpenFiles( .T. )
         if dbSeekInOrd( nNumPed, "nNumPed", dbfPedPrvT )
            WinZooRec( nil, bEdtRec, dbfPedPrvT )
         else
            MsgStop( "No se encuentra pedido" )
         end
         CloseFiles()
      end

   end

RETURN NIL



FUNCTION DelPedPrv( nNumPed, lOpenBrowse )

   local nLevel         := nLevelUsr( "01046" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 8 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if PedPrv()
         if dbSeekInOrd( nNumPed, "nNumPed", dbfPedPrvT )
            WinDelRec( nil, dbfPedPrvT, {|| QuiPedPrv() } )
         else
            MsgStop( "No se encuentra pedido" )
         end
      end

   else

      if OpenFiles( .T. )
         if dbSeekInOrd( nNumPed, "nNumPed", dbfPedPrvT )
            WinDelRec( nil, dbfPedPrvT, {|| QuiPedPrv() } )
         else
            MsgStop( "No se encuentra pedido" )
         end
         CloseFiles()
      end

   end

Return nil



FUNCTION PrnPedPrv( nNumPed, lOpenBrowse )

   local nLevel         := nLevelUsr( "01046" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 8 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if PedPrv()
         if dbSeekInOrd( nNumPed, "nNumPed", dbfPedPrvT )
            GenPedPrv( 1 )
         else
            MsgStop( "No se encuentra pedido" )
         end
      end

   else

      if OpenFiles( .T. )
         if dbSeekInOrd( nNumPed, "nNumPed", dbfPedPrvT )
            GenPedPrv( 1 )
         else
            MsgStop( "No se encuentra pedido" )
         end
         CloseFiles()
      end

   end

RETURN NIL



FUNCTION VisPedPrv( nNumPed, lOpenBrowse )

   local nLevel         := nLevelUsr( "01046" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 8 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if PedPrv()
         if dbSeekInOrd( nNumPed, "nNumPed", dbfPedPrvT )
            GenPedPrv( 2 )
         else
            MsgStop( "No se encuentra pedido" )
         end
      end

   else

      if OpenFiles( .T. )
         if dbSeekInOrd( nNumPed, "nNumPed", dbfPedPrvT )
            GenPedPrv( 2 )
         else
            MsgStop( "No se encuentra pedido" )
         end
         CloseFiles()
      end

   end

Return nil



function nVtaPedPrv( cCodPrv, dDesde, dHasta, dbfPedPrvT, dbfPedPrvL, dbfIva, dbfDiv )

   local nCon     := 0
   local nRec     := ( dbfPedPrvT )->( Recno() )





   if ( dbfPedPrvT )->( dbSeek( cCodPrv ) )

      while ( dbfPedPrvT )->cCodPrv == cCodPrv .AND. !( dbfPedPrvT )->( Eof() )


         if ( dDesde == nil .OR. ( dbfPedPrvT )->dFecPed >= dDesde )    .AND. ( dHasta == nil .OR. ( dbfPedPrvT )->dFecPed <= dHasta )

            nCon  += nTotPedPrv( ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed, dbfPedPrvT, dbfPedPrvL, dbfIva, dbfDiv, nil, cDivEmp(), .F. )

         end

         ( dbfPedPrvT )->( dbSkip() )

      end

   end

   ( dbfPedPrvT )->( dbGoTo( nRec ) )

return nCon



static function lGenPed( oBrw, oBtn, nDevice )

   local bAction

   IIF( nDevice == nil, nDevice := 1, ) ;

   if Empty( oBtn )
      return nil
   end

   if !( dbfDoc )->( dbSeek( "PP" ) )








      oWndBrw:NewAt( "DOCUMENT",,, {||( msgStop( "No hay pedidos de proveedores predefinidos" ) )}, "No hay documentos", "N",,, 4, oBtn, .F. )

   else

      while ( dbfDoc )->cTipo == "PP" .AND. !( dbfDoc )->( eof() )

         bAction  := bGenPed( nDevice, "Imprimiendo pedidos de proveedores", ( dbfDoc )->CODIGO )

         oWndBrw:NewAt( "Document", , , bAction, Rtrim( ( dbfDoc )->cDescrip ) , , , , , oBtn )

         ( dbfDoc )->( dbSkip() )

      end

   end

   SysRefresh()

return nil



static function bGenPed( nDevice, cTitle, cCodDoc )

   local bGen
   local nDev  := by( nDevice )
   local cTit  := by( cTitle    )
   local cCod  := by( cCodDoc   )

   if nDev == 1
      bGen     := {|| GenPedPrv( nDevice, cTit, cCod ) }
   else
      bGen     := {|| GenPedPrv( nDevice, cTit, cCod ) }
   end

return bGen



FUNCTION aDocPedPrv( dbfDocFld, dbfDocCol )

   local aDoc  := {}





   aAdd( aDoc, { "Empresa",         "EM" } )
   aAdd( aDoc, { "Pedido",          "PP" } )
   aAdd( aDoc, { "Proveedor",       "PR" } )
   aAdd( aDoc, { "Almacen",         "AL" } )
   aAdd( aDoc, { "Divisas",         "DV" } )
   aAdd( aDoc, { "Formas de pago",  "PG" } )

RETURN ( aDoc )



FUNCTION dFecPedPrv( cPedPrv, dbfPedPrvT )

   local dFecPed  := CtoD("")

   IF ( dbfPedPrvT )->( dbSeek( cPedPrv ) )
      dFecPed  := ( dbfPedPrvT )->dFecPed
   end

RETURN ( dFecPed )



FUNCTION nEstPedPrv( cPedPrv, dbfPedPrvT )

   local nEstPed  := 1

   IF ( dbfPedPrvT )->( dbSeek( cPedPrv ) )
      nEstPed     := ( dbfPedPrvT )->nEstado
   end

RETURN ( nEstPed )



FUNCTION cNbrPedPrv( cPedPrv, dbfPedPrvT )

   local cNomPrv  := ""

   IF ( dbfPedPrvT )->( dbSeek( cPedPrv ) )
      cNomPrv  := ( dbfPedPrvT )->cNomPrv
    end

RETURN ( cNomPrv )



function nTotDPedPrv( cCodArt, dbfPedPrvL, dbfPedPrvT, cCodAlm )

   local nTotVta  := 0
   local nRecno   := ( dbfPedPrvL )->( Recno() )

   if ( dbfPedPrvL )->( dbSeek( cCodArt ) )

      while ( dbfPedPrvL )->cRef == cCodArt .AND. !( dbfPedPrvL )->( eof() )

        if cCodAlm <> nil
           if cCodAlm == ( dbfPedPrvL )->cAlmLin
              nTotVta  += nTotNPedPrv( dbfPedPrvL )
           end
        else
           nTotVta     += nTotNPedPrv( dbfPedPrvL )
        end

        ( dbfPedPrvL )->( dbSkip() )

      end

   end

   ( dbfPedPrvL )->( dbGoTo( nRecno ) )

return ( nTotVta )



function nTotVPedPrv( cCodArt, dbfPedPrvL, nDec, nDor )

   local nTotVta  := 0
   local nRecno   := ( dbfPedPrvL )->( Recno() )

   if ( dbfPedPrvL )->( dbSeek( cCodArt ) )

      while ( dbfPedPrvL )->CREF == cCodArt .AND. !( dbfPedPrvL )->( eof() )

         nTotVta += nTotLPedPrv( dbfPedPrvL, nDec, nDor )

         ( dbfPedPrvL )->( dbSkip() )

      end

   end

   ( dbfPedPrvL )->( dbGoTo( nRecno ) )

return ( nTotVta )



STATIC FUNCTION QuiPedPrv( lDetail )

   local cPedido

   IIF( lDetail == nil, lDetail := .T., ) ;

   if ( dbfPedPrvT )->lCloPed .AND. !oUser():lAdministrador()
      msgStop( "Solo puede eliminar los pedidos cerrados los administradores." )
      Return .F.
   end

   CursorWait()

   cPedido           := ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed

   if lDetail
      DelDetalle( cPedido )
   end





   if !Empty( ( dbfPedPrvT )->cNumPedCli )
      oStock:SetGeneradoPedCli( ( dbfPedPrvT )->cNumPedCli )
   end

   CursorWe()

Return ( .T. )



Static Function DelDetalle( cPedido )

   local nOrdAnt

   IIF( cPedido == nil, cPedido := ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed, ) ;

   CursorWait()

   nOrdAnt           := ( dbfPedPrvL )->( OrdSetFocus( "nNumPed" ) )

   while ( dbfPedPrvL )->( dbSeek( cPedido ) ) .AND. !( dbfPedPrvL )->( eof() )
      if dbDialogLock( dbfPedPrvL )
         ( dbfPedPrvL )->( dbDelete() )
         ( dbfPedPrvL )->( dbUnLock() )
      end
   end

   ( dbfPedPrvL )->( OrdSetFocus( nOrdAnt ) )

   while ( dbfPedPrvI )->( dbSeek( cPedido ) .AND. !( dbfPedPrvI )->( eof() ) )
      if dbLock( dbfPedPrvI )
         ( dbfPedPrvI )->( dbDelete() )
         ( dbfPedPrvI )->( dbUnLock() )
      end
   end

   while ( dbfPedPrvD )->( dbSeek( cPedido ) .AND. !( dbfPedPrvD )->( eof() ) )
      if dbLock( dbfPedPrvD )
         ( dbfPedPrvD )->( dbDelete() )
         ( dbfPedPrvD )->( dbUnLock() )
      end
   end

   CursorWe()

RETURN NIL



function aItmPedPrv()



















































   local aBase := {  { "cSerPed",   "C",  1,   0, "Serie del pedido",            "",                   "", "( cDbf )"}, { "nNumPed",   "N",  9,   0, "Número del pedido",           "'999999999'",        "", "( cDbf )"}, { "cSufPed",   "C",  2,   0, "Sufijo del pedido",           "",                   "", "( cDbf )"}, { "cTurPed",   "C",  6,   0, "Sesión del pedido",           "",                   "", "( cDbf )"}, { "dFecPed",   "D",  8,   0, "Fecha del pedido",            "",                   "", "( cDbf )"}, { "cCodPrv",   "C", 12,   0, "Codigo del proveedor",        "",                   "", "( cDbf )"}, { "cCodAlm",   "C",  3,   0, "Código de almacen",           "",                   "", "( cDbf )"}, { "cCodCaj",   "C",  3,   0, "Código de caja",              "",                   "", "( cDbf )"}, { "cNomPrv",   "C", 35,   0, "Nombre del proveedor",        "'@!'",               "", "( cDbf )"}, { "cDirPrv",   "C", 35,   0, "Domicilio del proveedor",     "'@!'",               "", "( cDbf )"}, { "cPobPrv",   "C", 25,   0, "Población del proveedor",     "'@!'",               "", "( cDbf )"}, { "cProPrv",   "C", 20,   0, "Provincia del proveedor",     "'@!'",               "", "( cDbf )"}, { "cPosPrv",   "C",  5,   0, "Código postal del proveedor", "",                   "", "( cDbf )"}, { "cDniPrv",   "C", 30,   0, "D.N.I. del proveedor",        "",                   "", "( cDbf )"}, { "dFecEnt",   "D",  8,   0, "Fecha de entrada",            "",                   "", "( cDbf )"}, { "nEstado",   "N",  1,   0, "Estado del pedido",           "",                   "", "( cDbf )"}, { "cSuped",    "C", 10,   0, "Comentario su pedido",        "",                   "", "( cDbf )"}, { "cCodPgo",   "C",  2,   0, "Codigo de la forma de pago",  "",                   "", "( cDbf )"}, { "nBulTos",   "N",  3,   0, "Número de bultos",            "'999'",              "", "( cDbf )"}, { "nPorTes",   "N",  6,   0, "Precio de los portes",        "cPirDivPed",         "", "( cDbf )"}, { "cDtoEsp",   "C", 50,   0, "Descripción descuento especial","",                 "", "( cDbf )"}, { "nDtoEsp",   "N",  5,   2, "Descuento factura",           "'@EZ 99.99'",        "", "( cDbf )"}, { "cDpp",      "C", 50,   0, "Descripción descuento pronto pago","",              "", "( cDbf )"}, { "nDpp",      "N",  5,   2, "Descuento pronto pago",       "'@EZ 99.99'",        "", "( cDbf )"}, { "lRecargo",  "L",  1,   0, "Recargo de equivalencia",     "",                   "", "( cDbf )"}, { "cCondEnt",  "C", 20,   0, "Comentarios del pedido",      "",                   "", "( cDbf )"}, { "cExped",    "C", 20,   0, "Expedición",                  "",                   "", "( cDbf )"}, { "cObserv",   "M", 10,   0, "Observaciones",               "",                   "", "( cDbf )"}, { "cDivPed",   "C",  3,   0, "Codigo de divisa",            "",                   "", "( cDbf )"}, { "nVdvPed",   "N", 10,   4, "Valor de la divisa",          "'@EZ 999,999.9999'", "", "( cDbf )"}, { "lSndDoc",   "L",  1,   0, "Enviar documento",            "",                   "", "( cDbf )"}, { "cDtoUno",   "C", 25,   0, "Descripción de primer descuento personalizado", "", "", "( cDbf )"}, { "nDtoUno",   "N",  5,   2, "Porcentaje de primer descuento personalizado", "",  "", "( cDbf )"}, { "cDtoDos",   "C", 25,   0, "Descripción de segundo descuento personalizado","", "", "( cDbf )"}, { "nDtoDos",   "N",  5,   2, "Porcentaje de segundo descuento personalizado", "", "", "( cDbf )"}, { "lCloPed",   "L",  1,   0, "",                                              "", "", "( cDbf )"}, { "cCodUsr",   "C",  3,   0, "Código de usuario",                             "", "", "( cDbf )"}, { "cNumPedCli","C", 12,   0, "Número del pedido del cliente del que viene",   "", "", "( cDbf )"}, { "lImprimido","L",  1,   0, "Lógico de imprimido del documento",             "", "", "( cDbf )"}, { "dFecImp",   "D",  8,   0, "Última fecha de impresión del documento",       "", "", "( cDbf )"}, { "cHorImp",   "C",  5,   0, "Hora de la última impresión del documento",     "", "", "( cDbf )"}, { "dFecChg",   "D",  8,   0, "Fecha de modificación del documento",           "", "", "( cDbf )"}, { "cTimChg",   "C",  5,   0, "Hora de modificación del documento",            "", "", "( cDbf )"}, { "cCodDlg",   "C",  2,   0, "Código delegación",                             "", "", "( cDbf )"}, { "cSituac",   "C", 20,   0, "Situación del documento",                       "", "", "( cDbf )"}, { "nRegIva",   "N",  1,   0, "Regimen de " + cImp(),                             "", "", "( cDbf )"}, { "nTotNet",   "N", 16,   6, "Total neto",                                    "", "", "( cDbf )"}, { "nTotIva",   "N", 16,   6, "Total " + cImp(),                                     "", "", "( cDbf )"}, { "nTotReq",   "N", 16,   6, "Total recargo equivalencia",                    "", "", "( cDbf )"}, { "nTotPed",   "N", 16,   6, "Total pedido",                                  "", "", "( cDbf )"}, { "cNumAlb",   "C", 12,   0, "Númeo del albarán en el se ha agrupado",        "", "", "( cDbf )"} }

return ( aBase )



function aCalPedPrv()





























   local aCalPedPrv  := {  { "aTotIva[1,1]",                                              "N", 16,  6, "Bruto primer tipo de " + cImp(),    "cPirDivPed",  "!Empty( aTotIva[1,1] ) .and. lEnd" }, { "aTotIva[2,1]",                                              "N", 16,  6, "Bruto segundo tipo de " + cImp(),   "cPirDivPed",  "!Empty( aTotIva[2,1] ) .and. lEnd" }, { "aTotIva[3,1]",                                              "N", 16,  6, "Bruto tercer tipo de " + cImp(),    "cPirDivPed",  "!Empty( aTotIva[3,1] ) .and. lEnd" }, { "aTotIva[1,2]",                                              "N", 16,  6, "Base primer tipo de " + cImp(),     "cPirDivPed",  "!Empty( aTotIva[1,2] ) .and. lEnd" }, { "aTotIva[2,2]",                                              "N", 16,  6, "Base segundo tipo de " + cImp(),    "cPirDivPed",  "!Empty( aTotIva[2,2] ) .and. lEnd" }, { "aTotIva[3,2]",                                              "N", 16,  6, "Base tercer tipo de " + cImp(),     "cPirDivPed",  "!Empty( aTotIva[3,2] ) .and. lEnd" }, { "aTotIva[1,3]",                                              "N",  5,  2, "Porcentaje primer tipo " + cImp(),  "'@R 99.99%'", "!Empty( aTotIva[1,3] ) .and. lEnd" }, { "aTotIva[2,3]",                                              "N",  5,  2, "Porcentaje segundo tipo " + cImp(), "'@R 99.99%'", "!Empty( aTotIva[2,3] ) .and. lEnd" }, { "aTotIva[3,3]",                                              "N",  5,  2, "Porcentaje tercer tipo " + cImp(),  "'@R 99.99%'", "!Empty( aTotIva[3,3] ) .and. lEnd" }, { "aTotIva[1,4]",                                              "N",  5,  2, "Porcentaje primer tipo RE",   "'@R 99.99%'", "!Empty( aTotIva[1,4] ) .and. lEnd" }, { "aTotIva[2,4]",                                              "N",  5,  2, "Porcentaje segundo tipo RE",  "'@R 99.99%'", "!Empty( aTotIva[2,4] ) .and. lEnd" }, { "aTotIva[3,4]",                                              "N",  5,  2, "Porcentaje tercer tipo RE",   "'@R 99.99%'", "!Empty( aTotIva[3,4] ) .and. lEnd" }, { "round( aTotIva[1,2] * aTotIva[1,3] / 100, nDinDivPed )",    "N", 16,  6, "Importe primer tipo " + cImp(),     "cPinDivPed",  "!Empty( aTotIva[1,2] ) .and. lEnd" }, { "round( aTotIva[2,2] * aTotIva[2,3] / 100, nDinDivPed )",    "N", 16,  6, "Importe segundo tipo " + cImp(),    "cPinDivPed",  "!Empty( aTotIva[2,2] ) .and. lEnd" }, { "round( aTotIva[3,2] * aTotIva[3,3] / 100, nDinDivPed )",    "N", 16,  6, "Importe tercer tipo " + cImp(),     "cPinDivPed",  "!Empty( aTotIva[3,2] ) .and. lEnd" }, { "round( aTotIva[1,2] * aTotIva[1,4] / 100, nDinDivPed )",    "N", 16,  6, "Importe primer RE",           "cPinDivPed",  "!Empty( aTotIva[1,2] ) .and. lEnd" }, { "round( aTotIva[2,2] * aTotIva[2,4] / 100, nDinDivPed )",    "N", 16,  6, "Importe segundo RE",          "cPinDivPed",  "!Empty( aTotIva[2,2] ) .and. lEnd" }, { "round( aTotIva[3,2] * aTotIva[3,4] / 100, nDinDivPed )",    "N", 16,  6, "Importe tercer RE",           "cPinDivPed",  "!Empty( aTotIva[3,2] ) .and. lEnd" }, { "nTotBrt",                                                   "N", 16,  6, "Total bruto",                 "cPirDivPed",  "lEnd" }, { "nTotDto",                                                   "N", 16,  6, "Total descuento",             "cPirDivPed",  "lEnd" }, { "nTotDpp",                                                   "N", 16,  6, "Total descuento pronto pago", "cPirDivPed",  "lEnd" }, { "nTotNet",                                                   "N", 16,  6, "Total neto",                  "cPirDivPed",  "lEnd" }, { "nTotIva",                                                   "N", 16,  6, "Total " + cImp(),                   "cPirDivPed",  "lEnd" }, { "nTotReq",                                                   "N", 16,  6, "Total RE",                    "cPirDivPed",  "lEnd" }, { "nTotPed",                                                   "N", 16,  6, "Total pedido",                "cPirDivPed",  "lEnd" }, { "nImpEuros( nTotPed, (cDbf)->CDIVPED, cDbfDiv )",            "N", 16,  6, "Total pedido (Euros)",        "",            "lEnd" }, { "nImpPesetas( nTotPed, (cDbf)->CDIVPED, cDbfDiv )",          "N", 16,  6, "Total pedido (Pesetas)",      "",            "lEnd" }, { "nPagina",                                                   "N",  2,  0, "Número de página",            "'99'",        "" }, { "lEnd",                                                      "L",  1,  0, "Fin del documento",           "",            "" } }

return ( aCalPedPrv )



function aColPedPrv()

   local aColPedPrv  := {}

   aAdd( aColPedPrv,  { "CSERPED", "C",  1,   0, "",                                 "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NNUMPED", "N",  9,   0, "",                                 "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CSUFPED", "C",  2,   0, "",                                 "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CREF",    "C", 18,   0, "Referencia del artículo",          "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CREFPRV", "C", 18,   0, "Referencia del proveedor",         "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CDETALLE","C",250,   0, "Nombre del artículo",              "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NIVA",    "N",  6,   2, "Porcentaje de " + cImp(),                "'@E 99.9'",         "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NCANPED", "N", 16,   6, "Cantidad pedida",                  "MasUnd()",          "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NUNICAJA","N", 16,   6, "Unidades por caja",                "MasUnd()",          "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NPREDIV", "N", 16,   6, "Precio",                           "cPirDivPed",        "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NCANENT", "N", 16,   6, "Cajas recibidas",                  "MasUnd()",          "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NUNIENT", "N", 16,   6, "Unidades recibidas",               "MasUnd()",          "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CUNIDAD", "C",  2,   0, cNombreUnidades(),                  "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "MLNGDES", "M", 10,   0, "Descripción larga",                "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NDTOLIN", "N",  6,   2, "Descuento en lineas",              "'@E 999.99'",       "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NDTOPRM", "N",  6,   2, "Descuento pormociones",            "'@E 999.99'",       "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NDTORAP", "N",  6,   2, "Descuento por rappels",            "'@E 999.99'",       "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CCODPR1", "C", 10,   0, "Código de la primera propiedad",   "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CCODPR2", "C", 10,   0, "Código de la segunda propiedad",   "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CVALPR1", "C", 10,   0, "Valor de la primera propiedad",    "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CVALPR2", "C", 10,   0, "Valor de la segunda propiedad",    "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NFACCNV", "N", 13,   4, "",                                 "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NCTLSTK", "N",  1,   0, "Control de stock (1,2,3)",         "'9'",               "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CALMLIN" ,"C",  3,   0, "Código de almacén" ,               "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "LLOTE",   "L",  1,   0, "",                                 "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NLOTE",   "N",  9,   0, "",                                 "'999999999'",       "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CLOTE",   "C", 12,   0, "Número de lote",                   "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NNUMLIN", "N",  4,   0, "Número de la línea",               "'9999'",            "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NUNDKIT", "N", 16,   6, "Unidades del producto kit",        "MasUnd()",          "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "LKITART", "L",  1,   0, "Línea con escandallo",             "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "LKITCHL", "L",  1,   0, "Línea pertenciente a escandallo",  "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "LKITPRC", "L",  1,   0, "",                                 "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "LIMPLIN", "L",  1,   0, "Imprimir linea",                   "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "LCONTROL","L",  1,   0, "" ,                                "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "MNUMSER", "M", 10,   0, "" ,                                "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "LANULADO","L",  1,   0, "Anular linea",                     "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "DANULADO","D",  8,   0, "Fecha de anulacion",               "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "MANULADO","M",100,   0, "Motivo anulacion",                 "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CCODFAM", "C", 16,   0, "Código de familia",                "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CGRPFAM", "C",  3,   0, "Código del grupo de familia",      "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "NREQ",    "N", 16,   6, "Recargo de equivalencia",          "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "MOBSLIN", "M", 10,   6, "Observaciones de la linea",        "",                  "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "CPEDCLI", "C", 12,   0, "Número del pedido del cliente del que viene",  "",      "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "nPvpRec", "N", 16,   6, "Precio de venta recomendado",      "cPirDivPed",        "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "nNumMed", "N",  1,   0, "Número de mediciones",             "MasUnd()",          "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "nMedUno", "N", 16,   6, "Primera unidad de medición",       "MasUnd()",          "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "nMedDos", "N", 16,   6, "Segunda unidad de medición",       "MasUnd()",          "", "(cDbfCol)" } )
   aAdd( aColPedPrv,  { "nMedTre", "N", 16,   6, "Tercera unidad de medición",       "MasUnd()",          "", "(cDbfCol)" } )

return ( aColPedPrv )



function aCocPedPrv()




   local aCocPedPrv  := {  { "Descrip( cDbfCol )",                                           "C", 50, 0, "Detalle del artículo",       "",            "Descripción", "" }, { "nTotNPedPrv( cDbfCol )",                                       "N", 16, 6, "Total unidades",             "cPicUndPed",  cNombreUnidades(),    "" }, { "nTotUPedPrv( cDbfCol, nDinDivPed, nVdvDivPed )",               "N", 16, 6, "Precio unitario de pedido",  "cPinDivPed",  "Precio",      "" }, { "nTotLPedPrv( cDbfCol, nDinDivPed, nDirDivPed, nVdvDivPed )",   "N", 16, 6, "Total linea de pedido",      "cPirDivPed",  "Total",       "" } }

return ( aCocPedPrv )



Static Function nClrText( dbfTmpLin )

Return ( if ( ( dbfTmpLin )->lKitChl, 8421504, 0 ) )



Function EdtNumSer( mNumSer, nTotUnd, nMode )

   local oDlg
   local oBrwSer
   local oProSer
   local nProSer
   local aNumSer
   local cPreFix  := Space( 18 )
   local oSerIni
   local nSerIni  := 0
   local oSerFin
   local nSerFin  := 0
   local oNumGen
   local nNumGen  := 0

   if nTotUnd == 0
      MsgStop( "No hay unidades para asignar números de serie." )
      Return ( mNumSer )
   end

   IIF( nMode == nil, nMode := 1, ) ;

   nTotUnd        := abs( nTotUnd )
   aNumSer        := Afill( Array( nTotUnd ), Space( 30 ) )

   if nMode <> 1
      aMem2Ser( mNumSer, nTotUnd )
   end

   oDlg = TDialog():New(,,,,, "VtaNumSer",, .F.,,,,,, .F.,,,,,, .F., )





      TGetHlp():ReDefine( 100, { | u | If( PCount()==0, nTotUnd, nTotUnd:= u ) }, oDlg,, MasUnd(),,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )




      TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cPreFix, cPreFix:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )







      oSerIni := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, nSerIni, nSerIni:= u ) }, oDlg,, "99999999999999999999", {||    ( oSerFin:cText( nSerIni + nTotUnd ), .T. )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





      oSerFin := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, nSerFin, nSerFin:= u ) }, oDlg,, "99999999999999999999",,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )






      oNumGen := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, nNumGen, nNumGen:= u ) }, oDlg,, "99999999999999999999",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





      TButton():ReDefine( 500, {||( GenNumSer( cPreFix, aNumSer, nSerIni, nNumGen, oBrwSer ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )

      oBrwSer                 := TXBrowse():New( oDlg )

      oBrwSer:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwSer:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwSer:lHScroll        := .F.
      oBrwSer:lRecordSelector := .T.
      oBrwSer:lFastEdit       := .T.

      oBrwSer:nMarqueeStyle   := 3

      oBrwSer:SetArray( aNumSer, , , .F. )

      oBrwSer:nColSel         := 2

      with object ( oBrwSer:addCol() )
         :cHeader       := "N."
         :bStrData      := {|| Trans( oBrwSer:nArrayAt, "999999999" ) }
         :nWidth        := 60
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
      end

      with object ( oBrwSer:addCol() )
         :cHeader       := "Serie"
         :bEditValue    := {|| aNumSer[ oBrwSer:nArrayAt ] }
         :nWidth        := 240
         :nEditType     := 1
         :bOnPostEdit   := {|o,x| aNumSer[ oBrwSer:nArrayAt ] := x }
      end

      oBrwSer:CreateFromResource( 150 )

      oProSer     := TMeter():ReDefine( 240, { | u | if( pCount() == 0, nProSer, nProSer := u ) }, 10, oDlg, .F., , , .T., ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ), , ( 128 + ( 255 * 256 ) + ( 0 * 65536 ) ) )





      TButton():ReDefine( 510, {||( mNumSer   := mSer2Mem( aNumSer, nTotUnd ), oDlg:End() )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )




      TButton():ReDefine( 520, {||( oDlg:End() )}, oDlg,,, .F.,,,, .F. )

      oDlg:AddFastKey( 116, {|| mNumSer := mSer2Mem( aNumSer, nTotUnd ), oDlg:End() } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

Return ( mNumSer )



Function GenNumSer( cPreFix, aNumSer, nSerIni, nNumGen, oBrwSer )

   local n
   local nChg  := 1

   CursorWait()

   if Empty( nNumGen )
      aEval( aNumSer, {| a, n | aNumSer[ n ] := Padr( Rtrim( cPreFix ) + Ltrim( Str( nSerIni + n - 1 ) ), 30 ) } )
   else
      for n := 1 to len( aNumSer )
         if Empty( aNumSer[ n ] )
            aNumSer[ n ]                     := Padr( Rtrim( cPreFix ) + Ltrim( Str( nSerIni + nChg - 1 ) ), 30 )
            nChg++
         end
         if nChg == nNumGen
            exit
         end
      next
   end

   CursorWE()

   if !Empty( oBrwSer )
      oBrwSer:Refresh()
   end

Return nil



Function aMem2Ser( mNumSer, nTotUnd )

   local n
   local nPosSer
   local aMemSer

   CursorWait()

   aMemSer           := Afill( Array( nTotUnd ), Space( 40 ) )

   for n := 1 to nTotUnd

      nPosSer        := At( ",", mNumSer )
      if nPosSer <> 0
         aMemSer[ n ]:= Padr( SubStr( mNumSer, 1, nPosSer - 1 ), 40 )
         mNumSer     := SubStr( mNumSer, nPosSer + 1 )
      end
   next

   CursorWE()

Return ( aMemSer )



Static Function mSer2Mem( aNumSer, nTotUnd )

   local n
   local mNumSer     := ""

   for n := 1 to nTotUnd
      mNumSer        += AllTrim( aNumSer[ n ] ) + ","
   next

Return ( mNumSer )



Function SynPedPrv( cPath )

   local oError
   local oBlock      := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   local aTotPed

   BEGIN SEQUENCE

   dbUseArea( .T., cDriver(), cPath + "PedPROVT.DBF", cCheckArea( "PedPROVT", @dbfPedPrvT ), .F. )
   ordListAdd( cPath + "PedPROVT.CDX" )

   dbUseArea( .T., cDriver(), cPath + "PedPROVL.DBF", cCheckArea( "PedPROVL", @dbfPedPrvL ), .F. )
   ordListAdd( cPath + "PedPROVL.CDX" )

   dbUseArea( .T., cDriver(), cPath + "PedPRVI.DBF", cCheckArea( "PedPRVI", @dbfPedPrvI ), .F. )
   ordListAdd( cPath + "PedPRVI.CDX" )

   dbUseArea( .T., cDriver(), cPatArt() + "FAMILIAS.DBF", cCheckArea( "FAMILIAS", @dbfFamilia ), .F. )
   ordListAdd( cPatArt() + "FAMILIAS.CDX" )

   dbUseArea( .T., cDriver(), cPatArt() + "ARTICULO.DBF", cCheckArea( "ARTICULO", @dbfArticulo ), .F. )
   ordListAdd( cPatArt() + "ARTICULO.CDX" )

   dbUseArea( .T., cDriver(), cPatArt() + "PROVART.DBF", cCheckArea( "PROVART", @dbfArtPrv ), .F. )
   ordListAdd( cPatArt() + "PROVART.CDX" )

   dbUseArea( .T., cDriver(), cPatDat() + "TIVA.DBF", cCheckArea( "TIVA", @dbfIva ), .T. )
   ordListAdd( cPatDat() + "TIVA.CDX" )

   dbUseArea( .T., cDriver(), cPatDat() + "DIVISAS.DBF", cCheckArea( "DIVISAS", @dbfDiv ), .T. )
   ordListAdd( cPatDat() + "DIVISAS.CDX" )

   while !( dbfPedPrvT )->( eof() )

      if Empty( ( dbfPedPrvT )->cCodCaj )
         ( dbfPedPrvT )->cCodCaj := "000"
      end

      if !( ( dbfPedPrvT )->cSerPed >= "A" .AND. ( dbfPedPrvT )->cSerPed <= "Z" )
         ( dbfPedPrvT )->( dbDelete() )
      end





      if ( dbfPedPrvT )->nTotPed == 0 .AND. dbLock( dbfPedPrvT )

         aTotPed                 := aTotPedPrv( ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed, dbfPedPrvT, dbfPedPrvL, dbfIva, dbfDiv, ( dbfPedPrvT )->cDivPed )

         ( dbfPedPrvT )->nTotNet := aTotPed[1]
         ( dbfPedPrvT )->nTotIva := aTotPed[2]
         ( dbfPedPrvT )->nTotReq := aTotPed[3]
         ( dbfPedPrvT )->nTotPed := aTotPed[4]

         ( dbfPedPrvT )->( dbUnLock() )

      end

      ( dbfPedPrvT )->( dbSkip() )

   end

   while !( dbfPedPrvL )->( eof() )

      if !( dbfPedPrvT )->( dbSeek( ( dbfPedPrvL )->cSerPed + Str( ( dbfPedPrvL )->nNumPed ) + ( dbfPedPrvL )->cSufPed ) )

         ( dbfPedPrvL )->( dbDelete() )

      else

         if Empty( ( dbfPedPrvL )->cLote ) .AND. !Empty( ( dbfPedPrvL )->nLote )
            ( dbfPedPrvL )->cLote   := AllTrim( Str( ( dbfPedPrvL )->nLote ) )
         end

         if !Empty( ( dbfPedPrvL )->cRef ) .AND. Empty( ( dbfPedPrvL )->cCodFam )
            ( dbfPedPrvL )->cCodFam := RetFamArt( ( dbfPedPrvL )->cRef, dbfArticulo )
         end

         if !Empty( ( dbfPedPrvL )->cRef ) .AND. !Empty( ( dbfPedPrvL )->cCodFam )
            ( dbfPedPrvL )->cGrpFam := cGruFam( ( dbfPedPrvL )->cCodFam, dbfFamilia )
         end

         if Empty( ( dbfPedPrvL )->nReq )
            ( dbfPedPrvL )->nReq    := nPReq( dbfIva, ( dbfPedPrvL )->nIva )
         end

      end

      ( dbfPedPrvL )->( dbSkip() )

      SysRefresh()

   end

   while !( dbfPedPrvI )->( eof() )

      if !( dbfPedPrvT )->( dbSeek( ( dbfPedPrvI )->cSerPed + Str( ( dbfPedPrvI )->nNumPed ) + ( dbfPedPrvI )->cSufPed ) )
         ( dbfPedPrvI )->( dbDelete() )
      end

      ( dbfPedPrvI )->( dbSkip() )

      SysRefresh()

   end

   RECOVER USING oError

      msgStop( "Imposible sincronizar pedidos de proveedores" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if !Empty( dbfPedPrvT ) .AND. ( dbfPedPrvT )->( Used() )
      ( dbfPedPrvT )->( dbCloseArea() )
   end

   if !Empty( dbfPedPrvL ) .AND. ( dbfPedPrvL )->( Used() )
      ( dbfPedPrvL )->( dbCloseArea() )
   end

   if !Empty( dbfPedPrvI ) .AND. ( dbfPedPrvI )->( Used() )
      ( dbfPedPrvI )->( dbCloseArea() )
   end

   if !Empty( dbfArticulo ) .AND. ( dbfArticulo )->( Used() )
      ( dbfArticulo )->( dbCloseArea() )
   end

   if !Empty( dbfFamilia ) .AND. ( dbfFamilia )->( Used() )
      ( dbfFamilia )->( dbCloseArea() )
   end

   if !Empty( dbfArtPrv ) .AND. ( dbfArtPrv )->( Used() )
      ( dbfArtPrv )->( dbCloseArea() )
   end

   if !Empty( dbfIva ) .AND. ( dbfIva )->( Used() )
      ( dbfIva )->( dbCloseArea() )
   end

   if !Empty( dbfDiv ) .AND. ( dbfDiv )->( Used() )
      ( dbfDiv )->( dbCloseArea() )
   end

return nil



_HB_CLASS TPedidosProveedorSenderReciver ; UTILITY FUNCTION TPedidosProveedorSenderReciver(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TPedidosProveedorSenderReciver" , {TSenderReciverItem():classh} ) ) ; ;

   _HB_MEMBER CreateData(); IIF( .F., s_oClass:ModMethod( "CreateData", @TPedidosProveedorSenderReciver_CreateData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateData", @TPedidosProveedorSenderReciver_CreateData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER RestoreData(); IIF( .F., s_oClass:ModMethod( "RestoreData", @TPedidosProveedorSenderReciver_RestoreData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "RestoreData", @TPedidosProveedorSenderReciver_RestoreData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SendData(); IIF( .F., s_oClass:ModMethod( "SendData", @TPedidosProveedorSenderReciver_SendData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SendData", @TPedidosProveedorSenderReciver_SendData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ReciveData(); IIF( .F., s_oClass:ModMethod( "ReciveData", @TPedidosProveedorSenderReciver_ReciveData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ReciveData", @TPedidosProveedorSenderReciver_ReciveData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Process(); IIF( .F., s_oClass:ModMethod( "Process", @TPedidosProveedorSenderReciver_Process(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Process", @TPedidosProveedorSenderReciver_Process(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TPedidosProveedorSenderReciver ;



UTILITY STATIC function TPedidosProveedorSenderReciver_CreateData() ; local Self AS CLASS TPedidosProveedorSenderReciver := QSelf() AS CLASS TPedidosProveedorSenderReciver

   local oBlock
   local oError
   local lSnd        := .F.
   local dbfPedPrvT
   local dbfPedPrvL
   local tmpPedPrvT
   local tmpPedPrvL
   local cFileName   := "PedPrv" + StrZero( ::nGetNumberToSend(), 6 ) + "." + RetSufEmp()

   ::oSender:SetText( "Enviando pedidos a proveedores" )

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPROVT.DBF" ), ( cCheckArea( "PEDPROVT", @dbfPedPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPROVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPROVL.DBF" ), ( cCheckArea( "PEDPROVL", @dbfPedPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPROVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end





   CreateFiles( cPatSnd() )
   rxPedPrv( cPatSnd() )

   dbUseArea( .T., ( cDriver() ), ( cPatSnd() + "PEDPROVT.DBF" ), ( cCheckArea( "PEDPROVT", @tmpPedPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatSnd() + "PEDPROVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., ( cDriver() ), ( cPatSnd() + "PEDPROVL.DBF" ), ( cCheckArea( "PEDPROVL", @tmpPedPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatSnd() + "PEDPROVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if !Empty( ::oSender:oMtr )
      ::oSender:oMtr:nTotal := ( dbfPedPrvT )->( lastrec() )
   end

   while !( dbfPedPrvT )->( eof() )

      if ( dbfPedPrvT )->lSndDoc

         lSnd  := .T.

         dbPass( dbfPedPrvT, tmpPedPrvT, .T. )

         ::oSender:SetText( ( dbfPedPrvT )->cSerPed + "/" + AllTrim( Str( ( dbfPedPrvT )->nNumPed ) ) + "/" + Alltrim( ( dbfPedPrvT )->cSufPed ) + "; " + Dtoc( ( dbfPedPrvT )->dFecPed ) + "; " + AllTrim( ( dbfPedPrvT )->cCodPrv ) + "; " + ( dbfPedPrvT )->cNomPrv )

         if ( dbfPedPrvL )->( dbSeek( ( dbfPedPrvT )->CSERPED + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed ) )

            while ( ( dbfPedPrvL )->CSERPED + Str( ( dbfPedPrvL )->nNumPed ) + ( dbfPedPrvL )->cSufPed ) == ( ( dbfPedPrvT )->CSERPED + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed ) .AND. !( dbfPedPrvL )->( eof() )

               dbPass( dbfPedPrvL, tmpPedPrvL, .T. )
               ( dbfPedPrvL )->( dbSkip() )

            end

         end

      end

      ( dbfPedPrvT )->( dbSkip() )

      if !Empty( ::oSender:oMtr )
         ::oSender:oMtr:Set( ( dbfPedPrvT )->( OrdKeyNo() ) )
      end

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfPedPrvT )->( dbCloseArea() )
   ( dbfPedPrvL )->( dbCloseArea() )
   ( tmpPedPrvT )->( dbCloseArea() )
   ( tmpPedPrvL )->( dbCloseArea() )





   if lSnd

      ::oSender:SetText( "Comprimiendo pedidos de proveedores" )

      if ::oSender:lZipData( cFileName )
         ::oSender:SetText( "Ficheros comprimidos" )
      else
         ::oSender:SetText( "ERROR al crear fichero comprimido" )
      end

   else

      ::oSender:SetText( "No hay pedidos de proveedores para enviar" )

   end

Return ( Self )



UTILITY STATIC function TPedidosProveedorSenderReciver_RestoreData() ; local Self AS CLASS TPedidosProveedorSenderReciver := QSelf() AS CLASS TPedidosProveedorSenderReciver

   local oBlock
   local oError
   local dbfPedPrvT

   if ::lSuccesfullSend





      oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
      BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPROVT.DBF" ), ( cCheckArea( "PEDPROVT", @dbfPedPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPROVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

         lSelectAll( nil, dbfPedPrvT, "lSndDoc", .F., .T., .F. )

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

      ( dbfPedPrvT )->( dbCloseArea() )

   end

Return ( Self )



UTILITY STATIC function TPedidosProveedorSenderReciver_SendData() ; local Self AS CLASS TPedidosProveedorSenderReciver := QSelf() AS CLASS TPedidosProveedorSenderReciver

   local cFileName         := "PedPrv" + StrZero( ::nGetNumberToSend(), 6 ) + "." + RetSufEmp()

   if File( cPatOut() + cFileName )

      if ftpSndFile( cPatOut() + cFileName, cFileName, 2000, ::oSender )
         ::lSuccesfullSend := .T.
         ::IncNumberToSend()
         ::oSender:SetText( "Fichero enviado " + cFileName )
      else
         ::oSender:SetText( "ERROR al enviar fichero" )
      end

   end

Return ( Self )



UTILITY STATIC function TPedidosProveedorSenderReciver_ReciveData() ; local Self AS CLASS TPedidosProveedorSenderReciver := QSelf() AS CLASS TPedidosProveedorSenderReciver

   local n
   local aExt        := aRetDlgEmp()





   ::oSender:SetText( "Recibiendo pedidos de proveedores" )

   for n := 1 to len( aExt )
      ftpGetFiles( "PedPrv*." + aExt[ n ], cPatIn(), 2000, ::oSender )
   next

   ::oSender:SetText( "Pedidos de proveedores recibidos" )

Return Self



UTILITY STATIC function TPedidosProveedorSenderReciver_Process() ; local Self AS CLASS TPedidosProveedorSenderReciver := QSelf() AS CLASS TPedidosProveedorSenderReciver

   local m
   local oBlock
   local oError
   local dbfPedPrvT
   local dbfPedPrvL
   local tmpPedPrvT
   local tmpPedPrvL
   local aFiles      := Directory( cPatIn() + "PedPrv*.*" )





   for m := 1 to len( aFiles )

      ::oSender:SetText( "Procesando fichero : " + aFiles[ m, 1 ] )

      oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )

      BEGIN SEQUENCE





      if ::oSender:lUnZipData( cPatIn() + aFiles[ m, 1 ] )

         dbUseArea(.T., cDriver(), cPatSnd() + "PEDPROVT.DBF", cCheckArea( "PEDPROVT", @tmpPedPrvT ), .F., .T. )
         if !( dbfPedPrvT )->( neterr() )
               ( tmpPedPrvT )->( ordListAdd( cPatSnd() + "PEDPROVT.CDX" ) )
         end

         dbUseArea(.T., cDriver(), cPatSnd() + "PEDPROVL.DBF", cCheckArea( "PEDPROVL", @tmpPedPrvL ), .F., .T. )
         if !( dbfPedPrvL )->( neterr() )
               ( tmpPedPrvL )->( ordListAdd( cPatSnd() + "PEDPROVL.CDX" ) )
         end

         dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPROVT.DBF" ), ( cCheckArea( "PEDPROVT", @dbfPedPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
         if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPROVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

         dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPROVL.DBF" ), ( cCheckArea( "PEDPROVL", @dbfPedPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
         if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPROVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

         WHILE ( tmpPedPrvT )->( !eof() )






            if lValidaOperacion( ( tmpPedPrvT )->dFecPed, .F. ) .AND.  !( dbfPedPrvT )->( dbSeek( ( tmpPedPrvT )->cSerPed + Str( ( tmpPedPrvT )->nNumPed ) + ( tmpPedPrvT )->cSufPed ) )

               dbPass( tmpPedPrvT, dbfPedPrvT, .T. )
               ::oSender:SetText( "Añadido     : " + ( tmpPedPrvT )->cSerPed + "/" + AllTrim( Str( ( tmpPedPrvT )->nNumPed ) ) + "/" + AllTrim( ( tmpPedPrvT )->cSufPed ) + "; " + Dtoc( ( tmpPedPrvT )->dFecPed ) + "; " + AllTrim( ( tmpPedPrvT )->cCodPrv ) + "; " + ( tmpPedPrvT )->cNomPrv )

               if ( tmpPedPrvL )->( dbSeek( ( tmpPedPrvT )->CSERPED + Str( ( tmpPedPrvT )->nNumPed ) + ( tmpPedPrvT )->cSufPed ) )

                  while ( ( tmpPedPrvL )->CSERPED + Str( ( tmpPedPrvL )->nNumPed ) + ( tmpPedPrvL )->cSufPed ) == ( ( tmpPedPrvT )->CSERPED + Str( ( tmpPedPrvT )->nNumPed ) + ( tmpPedPrvT )->cSufPed ) .AND. !( tmpPedPrvL )->( eof() )

                     dbPass( tmpPedPrvL, dbfPedPrvL, .T. )
                     ( tmpPedPrvL )->( dbSkip() )

                  end

               end

            else

               ::oSender:SetText( "Desestimado : " + ( tmpPedPrvT )->cSerPed + "/" + AllTrim( Str( ( tmpPedPrvT )->nNumPed ) ) + "/" + AllTrim( ( tmpPedPrvT )->cSufPed ) + "; " + Dtoc( ( tmpPedPrvT )->dFecPed ) + "; " + AllTrim( ( tmpPedPrvT )->cCodPrv ) + "; " + ( tmpPedPrvT )->cNomPrv )

            end

            ( tmpPedPrvT )->( dbSkip() )

         end

         ( dbfPedPrvT )->( dbCloseArea() )
         ( dbfPedPrvL )->( dbCloseArea() )
         ( tmpPedPrvT )->( dbCloseArea() )
         ( tmpPedPrvL )->( dbCloseArea() )

         ::oSender:AppendFileRecive( aFiles[ m, 1 ] )

      end

      RECOVER USING oError

         ( dbfPedPrvT )->( dbCloseArea() )
         ( dbfPedPrvL )->( dbCloseArea() )
         ( tmpPedPrvT )->( dbCloseArea() )
         ( tmpPedPrvL )->( dbCloseArea() )

         ::oSender:SetText( "Error procesando fichero " + aFiles[ m, 1 ] )
         ::oSender:SetText( ErrorMessage( oError ) )

      end

      ErrorBlock( oBlock )

   next

Return Self



static function CambiaAnulado( aGet, aTmp )

   if aTmp[36]

      aGet[37]:cText( GetSysDate() )
      aTmp[38]   := ""

   else

      aGet[37]:cText( Ctod( "" ) )
      aTmp[38]   := ""

   end

return .T.







FUNCTION lSelAll( oBrw, dbf, lSel, lTop, lMeter )

   local nRecAct  := ( dbf )->( recno() )

   IIF( lSel == nil, lSel := .T., ) ;
   IIF( lTop == nil, lTop := .T., ) ;
   IIF( lMeter == nil, lMeter := .F., ) ;

   if lMeter
      CreateWaitMeter( nil, nil, ( dbf )->( OrdKeyCount() ) )
   else
      CursorWait()
   end

   if lTop
      ( dbf )->( dbGoTop() )
   end

   while !( dbf )->( eof() )

      if dbLock( dbf )
         ( dbf )->lSndDoc := lSel
         ( dbf )->( dbUnlock() )
      end

      ( dbf )->( dbSkip() )

      if lMeter
         RefreshWaitMeter( ( dbf )->( OrdKeyNo() ) )
      else
         SysRefresh()
      end

   end

   ( dbf )->( dbGoTo( nRecAct ) )

   if lMeter
      EndWaitMeter()
   else
      CursorWE()
   end

   if !Empty( oBrw )
      oBrw:Refresh()
      oBrw:SetFocus()
   end

RETURN NIL



Static Function TrazaPedidoProveedor( cNumDoc )

   local oDlg
   local oTree

   oDlg = TDialog():New(,,,,, "TrazaDocumentos",, .F.,,,,,, .F.,,,,,, .F., )

      oTree          := TTreeView():Redefine( 100, oDlg  )




      TButton():ReDefine( 560, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )




        TButton():ReDefine( 561, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )



   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( InitTrazaPedidoProveedor( cNumDoc, oTree ) )}, oDlg:bRClicked,,, )

Return nil

Static Function InitTrazaPedidoProveedor( cNumDoc, oTree )

   local n
   local aDocumentsPedidoProveedor  := aDocumentsPedidoProveedor( cNumDoc )

   for n := 1 to len( aDocumentsPedidoProveedor )




      oTree:Add(  aDocumentsPedidoProveedor[ n, 1 ] + " / " +  aDocumentsPedidoProveedor[ n, 2 ] + " / " +  aDocumentsPedidoProveedor[ n, 3 ] + " / " +  aDocumentsPedidoProveedor[ n, 4 ] + " / " +  aDocumentsPedidoProveedor[ n, 5 ] )
   next

Return ( aDocumentsPedidoProveedor )

FUNCTION aDocumentsPedidoProveedor( cNumPed )

   local oBlock
   local oError
   local dbfAlbPrvT
   local aDocuments  := {}

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBPROVT.DBF" ), ( cCheckArea( "ALBPROVT", @dbfAlbPrvT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBPROVT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
   ( dbfAlbPrvT )->( OrdSetFocus( "cNumPed" ) )

   if ( dbfAlbPrvT )->( dbSeek( cNumPed ) )
      while ( dbfAlbPrvT )->cNumPed == cNumPed .AND. !( dbfAlbPrvT )->( eof() )




         aAdd( aDocuments, {  ( dbfAlbPrvT )->cSerAlb + Str( ( dbfAlbPrvT )->nNumAlb ) + ( dbfAlbPrvT )->cSufAlb, Dtoc( ( dbfAlbPrvT )->dFecAlb ), ( dbfAlbPrvT )->cCodPrv, Rtrim( ( dbfAlbPrvT )->cNomPrv ), ( dbfAlbPrvT )->cCodAlm } )
         ( dbfAlbPrvT )->( dbSkip() )
      end
   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfAlbPrvT )->( dbCloseArea() )

Return ( aDocuments )



Function GetCodCli( cNumPed )

   local oBlock
   local oError
   local dbfPedCliT
   local cCodCli

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDCLIT.DBF" ), ( cCheckArea( "PEDCLIT", @dbfPedCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
   ( dbfPedCliT )->( OrdSetFocus( "NNUMPED" ) )

   ( dbfPedCliT )->( dbSeek( cNumPed ) )
   cCodCli := ( dbfPedCliT )->cCodCli

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfPedCliT )->( dbCloseArea() )

Return cCodCli



Function GetNomCli( cNumPed )

   local oBlock
   local oError
   local dbfPedCliT
   local cNomCli

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDCLIT.DBF" ), ( cCheckArea( "PEDCLIT", @dbfPedCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
   ( dbfPedCliT )->( OrdSetFocus( "NNUMPED" ) )

   ( dbfPedCliT )->( dbSeek( cNumPed ) )
   cNomCli := ( dbfPedCliT )->cNomCli

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfPedCliT )->( dbCloseArea() )

Return cNomCli



Static Function nEstadoIncidencia( cNumPed )

   local nEstado  := 0

   if ( dbfPedPrvI )->( dbSeek( cNumPed ) )

      while ( dbfPedPrvI )->cSerPed + Str( ( dbfPedPrvI )->nNumPed ) + ( dbfPedPrvI )->cSufPed == cNumPed .AND. !( dbfPedPrvI )->( Eof() )

         if ( dbfPedPrvI )->lListo
            do case
               case nEstado == 0 .OR. nEstado == 3
                    nEstado := 3
               case nEstado == 1
                    nEstado := 2
            end
         else
            do case
               case nEstado == 0
                    nEstado := 1
               case nEstado == 3
                    nEstado := 2
            end
         end

         ( dbfPedPrvI )->( dbSkip() )

      end

   end

Return ( nEstado )



function lChgImpDoc( dbfT )

   if dbLock( dbfT )
      ( dbfT )->lImprimido := .T.
      ( dbfT )->dFecImp    := GetSysDate()
      ( dbfT )->cHorImp    := SubStr( Time(), 1, 5 )
      ( dbfT )->( dbUnLock() )
   end

Return .T.






Function Generador( oBrwPed )

   local oDlg
   local oPag
   local oBmp
   local oMtr
   local nMtr
   local oBrw
   local oCol
   local oBtnAnt
   local oBtnNxt
   local oProvee
   local cProvee
   local oSayPrv
   local cSayPrv
   local oArtOrg
   local oArtDes
   local oSayArtOrg
   local oSayArtDes
   local cArtOrg        := dbFirst ( dbfArticulo, 1 )
   local cArtDes        := dbLast  ( dbfArticulo, 1 )
   local cSayArtOrg     := dbFirst ( dbfArticulo, 2 )
   local cSayArtDes     := dbLast  ( dbfArticulo, 2 )
   local oCodAlm
   local oNomAlm
   local cCodAlm        := cDefAlm()
   local cNomAlm        := retAlmacen( cCodAlm, dbfAlm )
   local nStockDis      := 4
   local nStockFin      := 1

   CreaTemporal()

   oDlg = TDialog():New(,,,, "Generar pedido a proveedor", "ASS_PEDCLI",, .F.,,,,,, .F.,,,,,, .F., )




   oBmp := TBitmap():ReDefine( 500, "GENERARPEDPRV",, oDlg,,, .F., .F.,,, .F.,,, .F. )


   oPag := TPages():Redefine( 110, oDlg, {"ASS_PEDPRV1", "ASS_PEDCLI2"},,,, )







   oProvee := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cProvee, cProvee:= u ) }, oPag:aDialogs[1],,, {||    cProvee( oProvee, dbfPrv, oSayPrv )}, "N/W*",,,,, .F.,,, .F., .F.,,,,, {|Self|BrwProvee( oProvee, oSayPrv )}, nil, "LUPA",, )





   oSayPrv := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, cSayPrv, cSayPrv:= u ) }, oPag:aDialogs[1],,,, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )






   oArtOrg := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, cArtOrg, cArtOrg:= u ) }, oPag:aDialogs[1],,, {||    cArticulo( oArtOrg, dbfArticulo, oSayArtOrg )},,,,,, .F.,,, .F., .F.,,,,, {|Self|BrwArticulo( oArtOrg, oSayArtOrg )}, nil, "LUPA",, )




   oSayArtOrg := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, cSayArtOrg, cSayArtOrg:= u ) }, oPag:aDialogs[1],,,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )






   oArtDes := TGetHlp():ReDefine( 170, { | u | If( PCount()==0, cArtDes, cArtDes:= u ) }, oPag:aDialogs[1],,, {||    cArticulo( oArtDes, dbfArticulo, oSayArtDes )},,,,,, .F.,,, .F., .F.,,,,, {|Self|BrwArticulo( oArtDes, oSayArtDes )}, nil, "LUPA",, )




   oSayArtDes := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, cSayArtDes, cSayArtDes:= u ) }, oPag:aDialogs[1],,,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )







   oCodAlm := TGetHlp():ReDefine( 190, { | u | If( PCount()==0, cCodAlm, cCodAlm:= u ) }, oPag:aDialogs[1],,, {||    ( cAlmacen( oCodAlm, dbfAlm, oNomAlm ) )}, "N/W*",,,,, .F.,,, .F., .F.,,,,, {|Self|( BrwAlmacen( oCodAlm, oNomAlm ) )}, nil, "LUPA",, )




   oNomAlm := TGetHlp():ReDefine( 200, { | u | If( PCount()==0, cNomAlm, cNomAlm:= u ) }, oPag:aDialogs[1],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )



   TRadMenu():Redefine( { | u | If( PCount()==0, nStockDis, nStockDis:= u ) }, oPag:aDialogs[1],, { 201, 202, 203, 204 },,,,, .F.,, )



   TRadMenu():Redefine( { | u | If( PCount()==0, nStockFin, nStockFin:= u ) }, oPag:aDialogs[ 1 ],, { 212, 213 },,,,, .F.,, )






   oMtr := TMeter():ReDefine( 220, { | u | If( PCount()==0, nMtr, nMtr:= u ) }, ( ( dbfArticulo )->( LastRec() ) ), oPag:aDialogs[ 1 ], .F.,, "Procesando", .F.,,,, )

   oBrw                 := IXBrowse():New( oPag:aDialogs[ 2 ] )

   oBrw:lHScroll        := .F.

   oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
   oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

   oBrw:cAlias          := dbfTmpArt
   oBrw:nMarqueeStyle   := 5
   oBrw:cName           := "Pedido a proveedores.Asistente"
   oBrw:lFastEdit       := .T.
   oBrw:nMarqueeStyle   := 3

      with object ( oBrw:AddCol() )
         :cHeader       := "Se. Seleccionado"
         :bStrData      := {|| "" }
         :bEditValue    := {|| ( dbfTmpArt )->lSelArt }
         :nEditType     := 0
         :nWidth        := 20
         :SetCheck( { "Sel16", "Nil16" } )
      end

      with object ( oBrw:AddCol() )
         :cHeader       := "Código"
         :bEditValue    := {|| ( dbfTmpArt )->cRef }
         :nEditType     := 0
         :nWidth        := 60
      end

      with object ( oBrw:AddCol() )
         :cHeader       := "Detalle"
         :bEditValue    := {|| ( dbfTmpArt )->cDetalle }
         :nEditType     := 0
         :nWidth        := 200
      end

      with object ( oBrw:AddCol() )
         :cHeader       := "Objetivo"
         :bEditValue    := {|| ( dbfTmpArt )->nObjUni }
         :cEditPicture  := MasUnd()
         :nEditType     := 0
         :nWidth        := 65
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
      end

      with object ( oCol := oBrw:AddCol() )
         :cHeader       := "A pedir"
         :bEditValue    := {|| ( dbfTmpArt )->nNumUni }
         :cEditPicture  := MasUnd()
         :nEditType     := 1
         :nWidth        := 65
         :bOnPostEdit   := {|o,x| if( x > 0, ( dbfTmpArt )->nNumUni := x, ), .T. }
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
      end

      with object ( oBrw:AddCol() )
         :cHeader       := "Stock actual"
         :bEditValue    := {|| ( dbfTmpArt )->nStkFis }
         :cEditPicture  := MasUnd()
         :nEditType     := 0
         :nWidth        := 65
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
      end

      with object ( oBrw:AddCol() )
         :cHeader       := "Stock disponible"
         :bEditValue    := {|| ( dbfTmpArt )->nStkDis }
         :cEditPicture  := MasUnd()
         :nEditType     := 0
         :nWidth        := 65
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
      end

   oBrw:CreateFromResource( 100 )

   oBrw:bLDblClick      := {|| oCol:Edit() }




   TButton():ReDefine( 110, {||( oCol:Edit() )}, oPag:aDialogs[2],,, .F.,,,, .F. )




   TButton():ReDefine( 120, {||( SelArt( dbfTmpArt, oBrw ) )}, oPag:aDialogs[2],,, .F.,,,, .F. )




   TButton():ReDefine( 130, {||( SelAllArt( dbfTmpArt, oBrw, .T. ) )}, oPag:aDialogs[2],,, .F.,,,, .F. )




   TButton():ReDefine( 140, {||( SelAllArt( dbfTmpArt, oBrw, .F. ) )}, oPag:aDialogs[2],,, .F.,,,, .F. )




   oBtnAnt := TButton():ReDefine( 401, {||( BtnAnt( oPag, oBtnNxt, oBtnAnt ) )}, oDlg,,, .F.,,,, .F. )




   oBtnNxt := TButton():ReDefine( 402, {||( BtnNxt( oPag, oBtnNxt, oBtnAnt, oDlg, oProvee, cProvee, cArtOrg, cArtDes, nStockDis, nStockFin, oMtr, oBrw, cCodAlm ) )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 403, {||( KillTemporal(), oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( oBtnAnt:Hide(), oBrw:Load() )}, oDlg:bRClicked,,, )

   oBmp:End()

   oBrwPed:Refresh()

RETURN ( nil )






Static Function BtnAnt( oPag, oBtnNxt, oBtnAnt )

   if oPag:nOption == 2





      ( dbfTmpArt )->( __dbZap() )
      oPag:GoPrev()
      SetWindowText( oBtnNxt:hWnd, "Siguien&te >" )

      oBtnAnt:Hide()

   end

RETURN ( .T. )






static function BtnNxt( oPag, oBtnNxt, oBtnAnt, oDlg, oProvee, cProvee, cArtOrg, cArtDes, nStockDis, nStockFin, oMtr, oBrw, cCodAlm )

   do case
      case oPag:nOption == 1





         if Empty( cProvee )
            MsgStop( "Tiene que seleccionar un proveedor para generar el pedido" )
            oProvee:SetFocus()
            Return .F.
         end





         LlenaTemporal( cProvee, cArtOrg, cArtDes, nStockDis, nStockFin, oMtr )

         oBrw:Refresh()

         oPag:GoNext()

         oBtnAnt:Show()

         SetWindowText( oBtnNxt:hWnd, "&Terminar" )

      case oPag:nOption == 2





         CreaPedido( cProvee, cCodAlm )





         KillTemporal()

         oDlg:end( 1 )

   end

RETURN ( .T. )






Static Function CreaTemporal()

   local cDbfArt  := "PTmpArt"
   local cDbfPedL := "PTmpPedL"

   cTmpArt        := cGetNewFileName( cPatTmp() + cDbfArt )
   cTmpPedL       := cGetNewFileName( cPatTmp() + cDbfPedL )

   dbCreate( cTmpArt, aSqlStruct( aColTmpArt() ), cDriver() )
   dbUseArea( .T., cDriver(), cTmpArt, cCheckArea( cDbfArt, @dbfTmpArt ), .F. )
   if !( dbfTmpArt )->( neterr() )
      ( dbfTmpArt )->( ordCondSet( "!Deleted()", {||!Deleted()}  ) )
      ( dbfTmpArt )->( ordCreate( cTmpArt, "cRef", "cRef", {|| Field->CREF } ) )
   end

   dbCreate( cTmpPedL, aSqlStruct( aColPedPrv() ), cDriver() )
   dbUseArea( .T., cDriver(), cTmpPedL, cCheckArea( cDbfPedL, @dbfTmpLin ), .F. )
   if !( dbfTmpLin )->( neterr() )
      ( dbfTmpLin )->( ordCondSet( "!Deleted()", {||!Deleted()}  ) )
      ( dbfTmpLin )->( ordCreate( cTmpPedL, "cRef", "cRef", {|| Field->CREF } ) )
   end

Return nil






Static Function LlenaTemporal( cProvee, cArtOrg, cArtDes, nStockDis, nStockFin, oMtr )

   local nStkFisico
   local nStkDisponible

   ( dbfArticulo )->( dbGoTop() )

   while !( dbfArticulo )->( Eof() )

         nStkFisico                    := oStock:nTotStockAct( ( dbfArticulo )->Codigo, , , , , ( dbfArticulo )->lKitArt, ( dbfArticulo )->nKitStk )
         nStkDisponible                := oStock:nTotStockAct( ( dbfArticulo )->Codigo, , , , , ( dbfArticulo )->lKitArt, ( dbfArticulo )->nKitStk ) - nReservado( ( dbfArticulo )->Codigo )



      if ( dbfArticulo )->cPrvHab == cProvee .AND. ( dbfArticulo )->Codigo >= cArtOrg  .AND. ( dbfArticulo )->Codigo <= cArtDes

         do case
            case nStockDis == 1 .AND. nStkDisponible < 0
               AppTemporal( nStockFin, nStkFisico, nStkDisponible )
            case nStockDis == 2 .AND. nStkDisponible <= 0
               AppTemporal( nStockFin, nStkFisico, nStkDisponible )
            case nStockDis == 3 .AND. nStkDisponible < ( dbfArticulo )->nMinimo
               AppTemporal( nStockFin, nStkFisico, nStkDisponible )
            otherwise
               AppTemporal( nStockFin, nStkFisico, nStkDisponible )
         end

      end

      ( dbfArticulo )->( dbSkip() )

      oMtr:Set( ( dbfArticulo )->( OrdKeyNo() ) )

   end

   oMtr:Set( 0 )

   ( dbfTmpArt )->( dbGoTop() )

Return nil






static function AppTemporal( nStockFin, nStkFisico, nStkDisponible )

   ( dbfTmpArt )->( dbAppend() )

   ( dbfTmpArt )->cRef        := ( dbfArticulo )->Codigo
   ( dbfTmpArt )->cDetalle    := ( dbfArticulo )->Nombre
   ( dbfTmpArt )->nStkFis     := nStkFisico
   ( dbfTmpArt )->nStkDis     := nStkDisponible

   do case
      case nStockFin == 1
         if ( dbfArticulo )->nMinimo   <> 0
            ( dbfTmpArt )->nObjUni     := ( dbfArticulo )->nMinimo
            ( dbfTmpArt )->nNumUni     := nCalculaUnidades( ( dbfArticulo )->nMinimo )
            if nCalculaUnidades( ( dbfArticulo )->nMinimo ) == 0
               ( dbfTmpArt )->lSelArt  := .F.
            else
               ( dbfTmpArt )->lSelArt  := .T.
            end
         else
            ( dbfTmpArt )->nObjUni     := 1
            ( dbfTmpArt )->nNumUni     := nCalculaUnidades( 1 )
            if nCalculaUnidades( 1 ) == 0
               ( dbfTmpArt )->lSelArt  := .F.
            else
               ( dbfTmpArt )->lSelArt  := .T.
            end
         end
      case nStockFin == 2
         if ( dbfArticulo )->nMaximo   <> 0
            ( dbfTmpArt )->nObjUni     := ( dbfArticulo )->nMaximo
            ( dbfTmpArt )->nNumUni     := nCalculaUnidades( ( dbfArticulo )->nMaximo )
            if nCalculaUnidades( ( dbfArticulo )->nMaximo ) == 0
               ( dbfTmpArt )->lSelArt  := .F.
            else
               ( dbfTmpArt )->lSelArt  := .T.
            end
         else
            ( dbfTmpArt )->nObjUni     := 1
            ( dbfTmpArt )->nNumUni     := nCalculaUnidades( 1 )
            if nCalculaUnidades( 1 ) == 0
               ( dbfTmpArt )->lSelArt  := .F.
            else
               ( dbfTmpArt )->lSelArt  := .T.
            end
         end
   end

return ( nil )






Static Function KillTemporal()

   if !Empty( dbfTmpArt ) .AND. ( dbfTmpArt )->( Used() )
      ( dbfTmpArt )->( dbCloseArea() )
   end

   if !Empty( dbfTmpLin ) .AND. ( dbfTmpLin )->( Used() )
      ( dbfTmpLin )->( dbCloseArea() )
   end

   dbfErase( cTmpArt )
   dbfErase( cTmpPedL )

Return nil




Static Function aColTmpArt()

   local aColTmpArt  := {}

      aAdd( aColTmpArt, { "CREF",    "C",   18,  0, "Referencia del artículo",         "",  "", "( cDbfCol )" } )
      aAdd( aColTmpArt, { "CDETALLE","C",  250,  0, "Nombre del artículo",             "",  "", "( cDbfCol )" } )
      aAdd( aColTmpArt, { "LSELART", "L",    1,  0, "Lógico de selección de artículo", "",  "", "( cDbfCol )" } )
      aAdd( aColTmpArt, { "NNUMUNI", "N",   16,  6, "Unidades pedidas",                "",  "", "( cDbfCol )" } )
      aAdd( aColTmpArt, { "NOBJUNI", "N",   16,  6, "Objetivo a llegar",               "",  "", "( cDbfCol )" } )
      aAdd( aColTmpArt, { "NSTKFIS", "N",   16,  6, "Stock fisico",                    "",  "", "( cDbfCol )" } )
      aAdd( aColTmpArt, { "NSTKDIS", "N",   16,  6, "Stock disponible",                "",  "", "( cDbfCol )" } )

return ( aColTmpArt )






Static Function SelArt( dbfTmpArt, oBrw )

   ( dbfTmpArt )->lSelArt := !( dbfTmpArt )->lSelArt

   oBrw:Refresh()

return nil




static function SelAllArt( dbfTmpArt, oBrw, lSel )

   local nRec  := ( dbfTmpArt )->( Recno() )

   ( dbfTmpArt )->( dbGoTop() )
   while !( dbfTmpArt )->( eof() )

      ( dbfTmpArt )->lSelArt := lSel

      ( dbfTmpArt )->( dbSkip() )

   end

   ( dbfTmpArt )->( dbGoTo( nRec ) )

   oBrw:Refresh()

return nil




Static Function nReservado( cCodArt )

   local nTotal := 0

   ( dbfPedCliR )->( dbGoTop() )

   ( dbfPedCliR )->( OrdSetFocus( "cRef" ) )

   if ( dbfPedCliR )->( dbSeek( cCodArt ) )

      while ( dbfPedCliR )->cRef == cCodArt .AND. !( dbfPedCliR )->( Eof() )

         nTotal += nTotRPedCli( ( dbfPedCliR )->cSerPed + Str( ( dbfPedCliR )->nNumPed ) + ( dbfPedCliR )->cSufPed, ( dbfPedCliR )->cRef, ( dbfPedCliR )->cValPr1, ( dbfPedCliR )->cValPr2, dbfPedCliR )

      ( dbfPedCliR )->( dbSkip() )

      end

   end

return ( nTotal )




Static Function CreaPedido( cCodPrv, cCodAlm )

   local cSeriePedido
   local nNumeroPedido
   local cSufijoPedido





   AppTemPedL( cCodAlm )

   if !( dbfTmpLin )->( Eof() )



      ( dbfPrv )->( dbSeek( cCodPrv ) )



      cSeriePedido               := cNewSer( "NPEDPRV" )
      nNumeroPedido              := nNewDoc( cSeriePedido, dbfPedPrvT, "NPEDPRV" )
      cSufijoPedido              := RetSufEmp()

      ( dbfPedPrvT )->( dbAppend())
      ( dbfPedPrvT )->cSerPed    := cSeriePedido
      ( dbfPedPrvT )->nNumPed    := nNumeroPedido
      ( dbfPedPrvT )->cSufPed    := cSufijoPedido
      ( dbfPedPrvT )->cTurPed    := cCurSesion()
      ( dbfPedPrvT )->dFecPed    := GetSysDate()
      ( dbfPedPrvT )->cCodPrv    := cCodPrv
      if !Empty( cCodAlm )
         ( dbfPedPrvT )->cCodAlm := cCodAlm
      else
         ( dbfPedPrvT )->cCodAlm := cDefAlm()
      end
      ( dbfPedPrvT )->cCodCaj    := oUser():cCaja()
      ( dbfPedPrvT )->cNomPrv    := ( dbfPrv )->Titulo
      ( dbfPedPrvT )->cDirPrv    := ( dbfPrv )->Domicilio
      ( dbfPedPrvT )->cPobPrv    := ( dbfPrv )->Poblacion
      ( dbfPedPrvT )->cProPrv    := ( dbfPrv )->Provincia
      ( dbfPedPrvT )->cPosPrv    := ( dbfPrv )->CodPostal
      ( dbfPedPrvT )->cDniPrv    := ( dbfPrv )->Nif
      ( dbfPedPrvT )->dFecEnt    := GetSysDate() + ( dbfPrv )->nPlzEnt
      ( dbfPedPrvT )->nEstado    := 1
      ( dbfPedPrvT )->cDivPed    := cDivEmp()
      ( dbfPedPrvT )->nVdvPed    := nChgDiv( cDivEmp(), dbfDiv )
      ( dbfPedPrvT )->lSndDoc    := .T.
      ( dbfPedPrvT )->cCodUsr    := cCurUsr()
      ( dbfPedPrvT )->( dbRUnLock() )





      while !( dbfTmpLin )->( Eof() )

         ( dbfPedPrvL )->( dbAppend() )

         ( dbfPedPrvL )->cSerPed          := cSeriePedido
         ( dbfPedPrvL )->nNumPed          := nNumeroPedido
         ( dbfPedPrvL )->cSufPed          := cSufijoPedido
         ( dbfPedPrvL )->cRef             := ( dbfTmpLin )->cRef
         ( dbfPedPrvL )->cDetalle         := ( dbfTmpLin )->cDetalle
         ( dbfPedPrvL )->nIva             := ( dbfTmpLin )->nIva
         ( dbfPedPrvL )->nReq             := ( dbfTmpLin )->nReq
         ( dbfPedPrvL )->nCanPed          := ( dbfTmpLin )->nCanPed
         ( dbfPedPrvL )->nUniCaja         := ( dbfTmpLin )->nUniCaja
         ( dbfPedPrvL )->cUniDad          := ( dbfTmpLin )->cUniDad
         ( dbfPedPrvL )->nPreDiv          := ( dbfTmpLin )->nPreDiv
         ( dbfPedPrvL )->lLote            := ( dbfTmpLin )->lLote
         ( dbfPedPrvL )->nLote            := ( dbfTmpLin )->nLote
         ( dbfPedPrvL )->cLote            := ( dbfTmpLin )->cLote
         ( dbfPedPrvL )->cAlmLin          := ( dbfTmpLin )->cAlmLin

         ( dbfPedPrvL )->( dbRUnLock() )

      ( dbfTmpLin )->( dbSkip() )

      end

      MsgInfo( "El pedido a proveedores " + AllTrim( cSeriePedido ) + "/" + AllTrim( Str( nNumeroPedido ) ) + "/" + AllTrim( cSufijoPedido ) + " se ha creado satisfactoriamente", "Información" )

   else

      MsgInfo( "No hay líneas para crear su pedido", "Información" )

   end

return nil




Static function nCalculaUnidades( nObjetivo )

   local nUnidades := 0

   do case
      case ( dbfTmpArt )->nStkFis <= 0
         nUnidades   := Abs( ( dbfTmpArt )->nStkFis ) + nObjetivo
      case ( dbfTmpArt )->nStkFis > 0 .AND. ( dbfTmpArt )->nStkFis < nObjetivo
         nUnidades   := nObjetivo - ( dbfTmpArt )->nStkFis
      case ( dbfTmpArt )->nStkFis > 0 .AND. ( dbfTmpArt )->nStkFis > nObjetivo
         nUnidades   := 0
   end

Return ( nUnidades )




Static Function AppTemPedL( cCodAlm )

   ( dbfTmpArt )->( dbGoTop() )

   while !( dbfTmpArt )->( Eof() )

      ( dbfArticulo )->( dbGotop() )
      ( dbfArticulo )->( dbSeek( ( dbfTmpArt )->cRef ) )
      ( dbfIva )->( dbSeek( ( dbfArticulo )->TipoIva ) )

      if ( dbfTmpArt )->lSelArt .AND. ( dbfTmpArt )->nNumUni <> 0

         ( dbfTmpLin )->( dbAppend() )
         ( dbfTmpLin )->cRef             := ( dbfTmpArt )->cRef
         ( dbfTmpLin )->cDetalle         := ( dbfTmpArt )->cDetalle
         ( dbfTmpLin )->nIva             := ( dbfIva )->TPIva
         ( dbfTmpLin )->nReq             := ( dbfIva )->nRecEq
         ( dbfTmpLin )->nCanPed          := 1
         ( dbfTmpLin )->nUniCaja         := ( dbfTmpArt )->nNumUni
         ( dbfTmpLin )->cUniDad          := ( dbfArticulo )->cUniDad
         ( dbfTmpLin )->nPreDiv          := ( dbfArticulo )->pCosto
         ( dbfTmpLin )->lLote            := ( dbfArticulo )->lLote
         ( dbfTmpLin )->nLote            := ( dbfArticulo )->nLote
         ( dbfTmpLin )->cLote            := ( dbfArticulo )->cLote

         if !Empty( cCodAlm )
            ( dbfTmpLin )->cAlmLin       := cCodAlm
         else
            ( dbfTmpLin )->cAlmLin       := cDefAlm()
         end

         ( dbfTmpLin )->( dbRUnLock() )

      end

   ( dbfTmpArt )->( dbSkip() )

   end

   ( dbfTmpLin )->( dbGoTop() )

Return ( .T. )



function ShowKitCom( dbfMaster, dbfTmpLin, oBrw, cCodPrv, dbfTmpInc, aGet )

   if !Empty( aGet )

      if lUsrMaster() .OR. oUser():lCambiarPrecio()
         aGet[ ( dbfMaster )->( FieldPos( "lRecargo" ) ) ]:HardEnable()
      else
         aGet[ ( dbfMaster )->( FieldPos( "lRecargo" ) ) ]:HardDisable()
      end

      if !Empty( cCodPrv )
         aGet[ ( dbfMaster )->( FieldPos( "cCodPrv" ) ) ]:cText( cCodPrv )
         aGet[ ( dbfMaster )->( FieldPos( "cCodPrv" ) ) ]:lValid()
      end

      aGet[ ( dbfMaster )->( FieldPos( "cCodPrv" ) ) ]:SetFocus()

   end





   if !Empty( dbfTmpInc )

      while !( dbfTmpInc )->( Eof() )
         if ( dbfTmpInc )->lAviso .AND. !( dbfTmpInc )->lListo
            MsgInfo( Trim( ( dbfTmpInc )->mDesInc ), "¡Incidencia!" )
         end
         ( dbfTmpInc )->( dbSkip() )
      end

      ( dbfTmpInc )->( dbGoTop() )

   end

   oBrw:Refresh()

return nil



STATIC FUNCTION ValidaMedicion( aTmp, aGet )

   local cNewUndMed  := aGet[ 13 ]:VarGet





   if ( Empty( cOldUndMed ) .OR. cOldUndMed <> cNewUndMed )

      if oUndMedicion:oDbf:Seek( aTmp[ 13 ] )

         if oUndMedicion:oDbf:nDimension >= 1 .AND. !Empty( oUndMedicion:oDbf:cTextoDim1 )
            if !Empty( aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ] )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim1 )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]:cText( ( dbfArticulo )->nLngArt )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]:Show()
            else
               aTmp[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]  := ( dbfArticulo )->nLngArt
            end
         else
            if !Empty( aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ] )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]:cText( 0 )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]:Hide()
            else
               aTmp[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]  := 0
            end
         end

         if oUndMedicion:oDbf:nDimension >= 2 .AND. !Empty( oUndMedicion:oDbf:cTextoDim2 )
            if !Empty( aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ] )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim2 )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]:cText( ( dbfArticulo )->nAltArt )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]:Show()
            else
               aTmp[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]  := ( dbfArticulo )->nAltArt
            end

         else
            if !Empty( aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ] )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]:cText( 0 )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]:Hide()
            else
                 aTmp[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]  := 0
            end
         end

         if oUndMedicion:oDbf:nDimension >= 3 .AND. !Empty( oUndMedicion:oDbf:cTextoDim3 )
            if !Empty( aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ] )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim3 )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]:cText( ( dbfArticulo ) ->nAncArt )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]:Show()
            else
               aTmp[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]  := ( dbfArticulo )->nAncArt
            end
         else
            if !Empty( aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ] )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]:cText( 0 )
               aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]:Hide()
            else
               aTmp[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]  := 0
            end
         end

      else

         if !Empty( aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ] )
            aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]:Hide()
            aGet[ ( dbfPedPrvL )->( fieldpos( "nMedUno" ) ) ]:cText( 0 )
         end

         if !Empty( aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ] )
            aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]:Hide()
            aGet[ ( dbfPedPrvL )->( fieldpos( "nMedDos" ) ) ]:cText( 0 )
         end

         if !Empty( aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ] )
            aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]:Hide()
            aGet[ ( dbfPedPrvL )->( fieldpos( "nMedTre" ) ) ]:cText( 0 )
         end

      end

      cOldUndMed := cNewUndMed

   end

RETURN .T.


Static Function nTotRecibido( dbfLin, dbfAlbPrvL )

   local nTotRec
   local nTotUni
   local nEstado     := 1

   nTotRec           := nUnidadesRecibidasPedPrv( ( dbfLin )->cSerPed + Str( ( dbfLin )->nNumPed ) + ( dbfLin )->cSufPed, ( dbfLin )->cRef, ( dbfLin )->cValPr1, ( dbfLin )->cValPr2, ( dbfLin )->cRefPrv, ( dbfLin )->cDetalle, dbfAlbPrvL )
   nTotUni           := nTotNPedPrv( dbfLin )

   do case
      case nTotRec == 0
         nEstado     := 1
      case nTotRec < nTotUni
         nEstado     := 2
      case nTotRec >= nTotUni
         nEstado     := 3
   end

RETURN ( nEstado )



Function IsPedPrv( cPath )

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "PedProvT.DBF" )
      dbCreate( cPath + "PedProvT.DBF", aSqlStruct( aItmPedPrv() ), cDriver() )
   end

   if !lExistTable( cPath + "PedProvL.DBF" )
      dbCreate( cPath + "PedProvL.DBF", aSqlStruct( aColPedPrv() ), cDriver() )
   end

   if !lExistTable( cPath + "PedPrvI.Dbf" )
      dbCreate( cPath + "PedPrvI.Dbf", aSqlStruct( aIncPedPrv() ), cDriver() )
   end

   if !lExistTable( cPath + "PedPrvD.Dbf" )
      dbCreate( cPath + "PedPrvD.Dbf", aSqlStruct( aPedPrvDoc() ), cDriver() )
   end




   if !lExistIndex( cPath + "PedProvT.Cdx" ) .OR.  !lExistIndex( cPath + "PedProvL.Cdx" ) .OR.  !lExistIndex( cPath + "PedPrvI.Cdx" )  .OR.  !lExistIndex( cPath + "PedPrvD.Cdx" )
      rxPedPrv( cPath )
   end

Return ( nil )



FUNCTION cDesPedPrv( cPedPrvL )

   IIF( cPedPrvL == nil, cPedPrvL := dbfPedPrvL, ) ;

RETURN ( Descrip( cPedPrvL ) )
#line 8278 ".\Prg\Pedprov.prg"
Static Function DataReport( oFr )





   oFr:ClearDataSets()

   oFr:SetWorkArea(     "Pedidos", ( dbfPedPrvT )->( Select() ), .F., { 1, 1, 0 } )
   oFr:SetFieldAliases( "Pedidos", cItemsToReport( aItmPedPrv() ) )

   oFr:SetWorkArea(     "Lineas de pedidos", ( dbfPedPrvL )->( Select() ) )
   oFr:SetFieldAliases( "Lineas de pedidos", cItemsToReport( aColPedPrv() ) )

   oFr:SetWorkArea(     "Incidencias de pedidos", ( dbfPedPrvI )->( Select() ) )
   oFr:SetFieldAliases( "Incidencias de pedidos", cItemsToReport( aIncPedPrv() ) )

   oFr:SetWorkArea(     "Documentos de pedidos", ( dbfPedPrvD )->( Select() ) )
   oFr:SetFieldAliases( "Documentos de pedidos", cItemsToReport( aPedPrvDoc() ) )

   oFr:SetWorkArea(     "Empresa", ( dbfEmp )->( Select() ) )
   oFr:SetFieldAliases( "Empresa", cItemsToReport( aItmEmp() ) )

   oFr:SetWorkArea(     "Proveedor", ( dbfPrv )->( Select() ) )
   oFr:SetFieldAliases( "Proveedor", cItemsToReport( aItmPrv() ) )

   oFr:SetWorkArea(     "Almacenes", ( dbfAlm )->( Select() ) )
   oFr:SetFieldAliases( "Almacenes", cItemsToReport( aItmAlm() ) )

   oFr:SetWorkArea(     "Formas de pago", ( dbfFpago )->( Select() ) )
   oFr:SetFieldAliases( "Formas de pago", cItemsToReport( aItmFPago() ) )

   oFr:SetWorkArea(     "Usuarios", ( dbfUsr )->( Select() ) )
   oFr:SetFieldAliases( "Usuarios", cItemsToReport( aItmUsr() ) )

   oFr:SetWorkArea(     "Artículos", ( dbfArticulo )->( Select() ) )
   oFr:SetFieldAliases( "Artículos", cItemsToReport( aItmArt() ) )

   oFr:SetWorkArea(     "Código de proveedores", ( dbfArtPrv )->( Select() ) )
   oFr:SetFieldAliases( "Código de proveedores", cItemsToReport( aItmArtPrv() ) )

   oFr:SetWorkArea(     "Unidades de medición",  oUndMedicion:Select() )
   oFr:SetFieldAliases( "Unidades de medición",  cObjectsToReport( oUndMedicion:oDbf ) )

   oFr:SetMasterDetail( "Pedidos", "Lineas de pedidos",        {|| ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed } )
   oFr:SetMasterDetail( "Pedidos", "Incidencias de pedidos",   {|| ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed } )
   oFr:SetMasterDetail( "Pedidos", "Documentos de pedidos",    {|| ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed } )
   oFr:SetMasterDetail( "Pedidos", "Proveedor",                {|| ( dbfPedPrvT )->cCodPrv } )
   oFr:SetMasterDetail( "Pedidos", "Almacenes",                {|| ( dbfPedPrvT )->cCodAlm } )
   oFr:SetMasterDetail( "Pedidos", "Formas de pago",           {|| ( dbfPedPrvT )->cCodPgo } )
   oFr:SetMasterDetail( "Pedidos", "Usuarios",                 {|| ( dbfPedPrvT )->cCodUsr } )
   oFr:SetMasterDetail( "Pedidos", "Empresa",                  {|| cCodigoEmpresaEnUso() } )

   oFr:SetMasterDetail( "Lineas de pedidos", "Artículos",               {|| ( dbfPedPrvL )->cRef } )
   oFr:SetMasterDetail( "Lineas de pedidos", "Código de proveedores",   {|| ( dbfPedPrvT )->cCodPrv + ( dbfPedPrvL )->cRef } )
   oFr:SetMasterDetail( "Lineas de pedidos", "Unidades de medición",    {|| ( dbfPedPrvL )->cUnidad } )

   oFr:SetResyncPair(   "Pedidos", "Lineas de pedidos" )
   oFr:SetResyncPair(   "Pedidos", "Incidencias de pedidos" )
   oFr:SetResyncPair(   "Pedidos", "Documentos de pedidos" )
   oFr:SetResyncPair(   "Pedidos", "Empresa" )
   oFr:SetResyncPair(   "Pedidos", "Proveedor" )
   oFr:SetResyncPair(   "Pedidos", "Almacenes" )
   oFr:SetResyncPair(   "Pedidos", "Formas de pago" )
   oFr:SetResyncPair(   "Pedidos", "Usuarios" )

   oFr:SetResyncPair(   "Lineas de pedidos", "Artículos" )
   oFr:SetResyncPair(   "Lineas de pedidos", "Código de proveedores" )
   oFr:SetResyncPair(   "Lineas de pedidos", "Unidades de medición" )

Return nil



Static Function VariableReport( oFr )

   oFr:DeleteCategory(  "Pedidos" )
   oFr:DeleteCategory(  "Lineas de pedidos" )





   oFr:AddVariable(     "Pedidos",             "Total pedido",                        "GetHbVar('nTotPed')" )
   oFr:AddVariable(     "Pedidos",             "Total bruto",                         "GetHbVar('nTotBrt')" )
   oFr:AddVariable(     "Pedidos",             "Total descuento pronto pago",         "GetHbVar('nTotDpp')" )
   oFr:AddVariable(     "Pedidos",             "Total bruto",                         "GetHbVar('nTotBrt')" )
   oFr:AddVariable(     "Pedidos",             "Total descuento",                     "GetHbVar('nTotDto')" )
   oFr:AddVariable(     "Pedidos",             "Total descuento pronto pago",         "GetHbVar('nTotDpp')" )
   oFr:AddVariable(     "Pedidos",             "Total neto",                          "GetHbVar('nTotNet')" )
   oFr:AddVariable(     "Pedidos",             "Total primer descuento definible",    "GetHbVar('nTotUno')" )
   oFr:AddVariable(     "Pedidos",             "Total segundo descuento definible",   "GetHbVar('nTotDos')" )
   oFr:AddVariable(     "Pedidos",             "Total " + cImp(),                           "GetHbVar('nTotIva')" )
   oFr:AddVariable(     "Pedidos",             "Total RE",                            "GetHbVar('nTotReq')" )
   oFr:AddVariable(     "Pedidos",             "Total retención",                     "GetHbVar('nTotRet')" )
   oFr:AddVariable(     "Pedidos",             "Bruto primer tipo de " + cImp(),            "GetHbArrayVar('aIvaUno',1)" )
   oFr:AddVariable(     "Pedidos",             "Bruto segundo tipo de " + cImp(),           "GetHbArrayVar('aIvaDos',1)" )
   oFr:AddVariable(     "Pedidos",             "Bruto tercer tipo de " + cImp(),            "GetHbArrayVar('aIvaTre',1)" )
   oFr:AddVariable(     "Pedidos",             "Base primer tipo de " + cImp(),             "GetHbArrayVar('aIvaUno',2)" )
   oFr:AddVariable(     "Pedidos",             "Base segundo tipo de " + cImp(),            "GetHbArrayVar('aIvaDos',2)" )
   oFr:AddVariable(     "Pedidos",             "Base tercer tipo de " + cImp(),             "GetHbArrayVar('aIvaTre',2)" )
   oFr:AddVariable(     "Pedidos",             "Porcentaje primer tipo " + cImp(),          "GetHbArrayVar('aIvaUno',3)" )
   oFr:AddVariable(     "Pedidos",             "Porcentaje segundo tipo " + cImp(),         "GetHbArrayVar('aIvaDos',3)" )
   oFr:AddVariable(     "Pedidos",             "Porcentaje tercer tipo " + cImp(),          "GetHbArrayVar('aIvaTre',3)" )
   oFr:AddVariable(     "Pedidos",             "Porcentaje primer tipo RE",           "GetHbArrayVar('aIvaUno',4)" )
   oFr:AddVariable(     "Pedidos",             "Porcentaje segundo tipo RE",          "GetHbArrayVar('aIvaDos',4)" )
   oFr:AddVariable(     "Pedidos",             "Porcentaje tercer tipo RE",           "GetHbArrayVar('aIvaTre',4)" )
   oFr:AddVariable(     "Pedidos",             "Importe primer tipo " + cImp(),             "GetHbArrayVar('aIvaUno',5)" )
   oFr:AddVariable(     "Pedidos",             "Importe segundo tipo " + cImp(),            "GetHbArrayVar('aIvaDos',5)" )
   oFr:AddVariable(     "Pedidos",             "Importe tercer tipo " + cImp(),             "GetHbArrayVar('aIvaTre',5)" )
   oFr:AddVariable(     "Pedidos",             "Importe primer RE",                   "GetHbArrayVar('aIvaUno',6)" )
   oFr:AddVariable(     "Pedidos",             "Importe segundo RE",                  "GetHbArrayVar('aIvaDos',6)" )
   oFr:AddVariable(     "Pedidos",             "Importe tercer RE",                   "GetHbArrayVar('aIvaTre',6)" )

   oFr:AddVariable(     "Lineas de pedidos",   "Detalle del artículo",                "CallHbFunc('cDesPedPrv')" )
   oFr:AddVariable(     "Lineas de pedidos",   "Total unidades artículo",             "CallHbFunc('nTotNPedPrv')" )
   oFr:AddVariable(     "Lineas de pedidos",   "Precio unitario del artículo",        "CallHbFunc('nTotUPedPrv')" )
   oFr:AddVariable(     "Lineas de pedidos",   "Total línea de pedido",               "CallHbFunc('nTotLPedPrv')" )

Return nil



Static Function MailingReport( oFr )





   oFr:AddVariable(     "Pedidos",             "Total pedido",                        "GetHbVar('nTotPed')" )
   oFr:AddVariable(     "Pedidos",             "Total bruto",                         "GetHbVar('nTotBrt')" )
   oFr:AddVariable(     "Pedidos",             "Total descuento pronto pago",         "GetHbVar('nTotDpp')" )
   oFr:AddVariable(     "Pedidos",             "Total bruto",                         "GetHbVar('nTotBrt')" )
   oFr:AddVariable(     "Pedidos",             "Total descuento",                     "GetHbVar('nTotDto')" )
   oFr:AddVariable(     "Pedidos",             "Total descuento pronto pago",         "GetHbVar('nTotDpp')" )
   oFr:AddVariable(     "Pedidos",             "Total neto",                          "GetHbVar('nTotNet')" )
   oFr:AddVariable(     "Pedidos",             "Total primer descuento definible",    "GetHbVar('nTotUno')" )
   oFr:AddVariable(     "Pedidos",             "Total segundo descuento definible",   "GetHbVar('nTotDos')" )
   oFr:AddVariable(     "Pedidos",             "Total " + cImp(),                           "GetHbVar('nTotIva')" )
   oFr:AddVariable(     "Pedidos",             "Total RE",                            "GetHbVar('nTotReq')" )
   oFr:AddVariable(     "Pedidos",             "Total retención",                     "GetHbVar('nTotRet')" )
   oFr:AddVariable(     "Pedidos",             "Bruto primer tipo de " + cImp(),            "GetHbArrayVar('aIvaUno',1)" )
   oFr:AddVariable(     "Pedidos",             "Bruto segundo tipo de " + cImp(),           "GetHbArrayVar('aIvaDos',1)" )
   oFr:AddVariable(     "Pedidos",             "Bruto tercer tipo de " + cImp(),            "GetHbArrayVar('aIvaTre',1)" )
   oFr:AddVariable(     "Pedidos",             "Base primer tipo de " + cImp(),             "GetHbArrayVar('aIvaUno',2)" )
   oFr:AddVariable(     "Pedidos",             "Base segundo tipo de " + cImp(),            "GetHbArrayVar('aIvaDos',2)" )
   oFr:AddVariable(     "Pedidos",             "Base tercer tipo de " + cImp(),             "GetHbArrayVar('aIvaTre',2)" )
   oFr:AddVariable(     "Pedidos",             "Porcentaje primer tipo " + cImp(),          "GetHbArrayVar('aIvaUno',3)" )
   oFr:AddVariable(     "Pedidos",             "Porcentaje segundo tipo " + cImp(),         "GetHbArrayVar('aIvaDos',3)" )
   oFr:AddVariable(     "Pedidos",             "Porcentaje tercer tipo " + cImp(),          "GetHbArrayVar('aIvaTre',3)" )
   oFr:AddVariable(     "Pedidos",             "Porcentaje primer tipo RE",           "GetHbArrayVar('aIvaUno',4)" )
   oFr:AddVariable(     "Pedidos",             "Porcentaje segundo tipo RE",          "GetHbArrayVar('aIvaDos',4)" )
   oFr:AddVariable(     "Pedidos",             "Porcentaje tercer tipo RE",           "GetHbArrayVar('aIvaTre',4)" )
   oFr:AddVariable(     "Pedidos",             "Importe primer tipo " + cImp(),             "GetHbArrayVar('aIvaUno',5)" )
   oFr:AddVariable(     "Pedidos",             "Importe segundo tipo " + cImp(),            "GetHbArrayVar('aIvaDos',5)" )
   oFr:AddVariable(     "Pedidos",             "Importe tercer tipo " + cImp(),             "GetHbArrayVar('aIvaTre',5)" )
   oFr:AddVariable(     "Pedidos",             "Importe primer RE",                   "GetHbArrayVar('aIvaUno',6)" )
   oFr:AddVariable(     "Pedidos",             "Importe segundo RE",                  "GetHbArrayVar('aIvaDos',6)" )
   oFr:AddVariable(     "Pedidos",             "Importe tercer RE",                   "GetHbArrayVar('aIvaTre',6)" )

   oFr:AddVariable(     "Lineas de pedidos",   "Detalle del artículo",                "CallHbFunc('cDesPedPrv')" )
   oFr:AddVariable(     "Lineas de pedidos",   "Total unidades artículo",             "CallHbFunc('nTotNPedPrv')" )
   oFr:AddVariable(     "Lineas de pedidos",   "Precio unitario del artículo",        "CallHbFunc('nTotUPedPrv')" )
   oFr:AddVariable(     "Lineas de pedidos",   "Total línea de pedido",               "CallHbFunc('nTotLPedPrv')" )

Return nil



Function DesignReportPedPrv( oFr, dbfDoc )

   local lOpen    := .F.
   local lFlag    := .F.





   if lOpenFiles
      lFlag       := .T.
   else
      if Openfiles()
         lFlag    := .T.
         lOpen    := .T.
      else
         lFlag    := .F.
      end
   end

   if lFlag





      DataReport( oFr )





      if !Empty( ( dbfDoc )->mReport )

         oFr:LoadFromBlob( ( dbfDoc )->( Select() ), "mReport")

      else

         oFr:SetProperty(     "Report",            "ScriptLanguage", "PascalScript" )







         oFr:SetProperty(     "Report.ScriptText", "Text", +  "procedure DetalleOnMasterDetail(Sender: TfrxComponent);"   + Chr(13) + Chr(10) +  "begin"                                                     + Chr(13) + Chr(10) +  "CallHbFunc('nTotPedPrv');"                                 + Chr(13) + Chr(10) +  "end;"                                                      + Chr(13) + Chr(10) +  "begin"                                                     + Chr(13) + Chr(10) +  "end." )

         oFr:AddPage(         "MainPage" )

         oFr:AddBand(         "CabeceraDocumento", "MainPage", 2 )
         oFr:SetProperty(     "CabeceraDocumento", "Top", 0 )
         oFr:SetProperty(     "CabeceraDocumento", "Height", 200 )

         oFr:AddBand(         "CabeceraColumnas",  "MainPage", 6 )
         oFr:SetProperty(     "CabeceraColumnas",  "Top", 200 )
         oFr:SetProperty(     "CabeceraColumnas",  "Height", 0 )
         oFr:SetProperty(     "CabeceraColumnas",  "StartNewPage", .T. )
         oFr:SetObjProperty(  "CabeceraColumnas",  "DataSet", "Pedidos" )

         oFr:AddBand(         "DetalleColumnas",   "MainPage", 7  )
         oFr:SetProperty(     "DetalleColumnas",   "Top", 230 )
         oFr:SetProperty(     "DetalleColumnas",   "Height", 28 )
         oFr:SetObjProperty(  "DetalleColumnas",   "DataSet", "Lineas de pedidos" )
         oFr:SetProperty(     "DetalleColumnas",   "OnMasterDetail", "DetalleOnMasterDetail" )

         oFr:AddBand(         "PieDocumento",      "MainPage", 3 )
         oFr:SetProperty(     "PieDocumento",      "Top", 930 )
         oFr:SetProperty(     "PieDocumento",      "Height", 110 )

      end





      VariableReport( oFr )





      oFr:DesignReport()





      oFr:DestroyFr()





      if lOpen
         CloseFiles()
      end

   else

      Return .F.

   end

Return .T.



Function PrintReportPedPrv( nDevice, nCopies, cPrinter, dbfDoc )

   local oFr
   local cFilePdf       := cPatTmp() + "PedidoProveedor" + StrTran( ( dbfPedPrvT )->cSerPed + Str( ( dbfPedPrvT )->nNumPed ) + ( dbfPedPrvT )->cSufPed, " ", "" ) + ".Pdf"

   IIF( nDevice == nil, nDevice := 2, ) ;
   IIF( nCopies == nil, nCopies := 1, ) ;
   IIF( cPrinter == nil, cPrinter := PrnGetName(), ) ;

   SysRefresh()

   oFr                  := frReportManager():New()

   oFr:LoadLangRes(     "Spanish.Xml" )

   oFr:SetIcon( 1 )

   oFr:SetTitle(        "Diseñador de documentos" )





   oFr:SetEventHandler( "Designer", "OnSaveReport", {|| oFr:SaveToBlob( ( dbfDoc )->( Select() ), "mReport" ) } )





   DataReport( oFr )





   if !Empty( ( dbfDoc )->mReport )

      oFr:LoadFromBlob( ( dbfDoc )->( Select() ), "mReport")





      VariableReport( oFr )





      oFr:PrepareReport()





      do case
         case nDevice == 2

            oFr:ShowPreparedReport()

         case nDevice == 1

            oFr:PrintOptions:SetPrinter( cPrinter )
            oFr:PrintOptions:SetCopies( nCopies )
            oFr:PrintOptions:SetShowDialog( .F. )
            oFr:Print()

         case nDevice == 3

            oFr:PrintOptions:SetShowDialog( .F. )
            oFr:SetProperty(  "PDFExport", "DefaultPath",      cPatTmp() )
            oFr:SetProperty(  "PDFExport", "FileName",         cFilePdf )
            oFr:SetProperty(  "PDFExport", "ShowDialog",       .F. )
            oFr:SetProperty(  "PDFExport", "EmbeddedFonts",    .T. )
            oFr:SetProperty(  "PDFExport", "PrintOptimized",   .T. )
            oFr:SetProperty(  "PDFExport", "Outline",          .T. )
            oFr:SetProperty(  "PDFExport", "OpenAfterExport",  .T. )
            oFr:DoExport(     "PDFExport" )

         case nDevice == 6

            oFr:SetProperty(  "PDFExport", "ShowDialog",       .F. )
            oFr:SetProperty(  "PDFExport", "DefaultPath",      cPatTmp() )
            oFr:SetProperty(  "PDFExport", "FileName",         cFilePdf )
            oFr:SetProperty(  "PDFExport", "EmbeddedFonts",    .T. )
            oFr:SetProperty(  "PDFExport", "PrintOptimized",   .T. )
            oFr:SetProperty(  "PDFExport", "Outline",          .T. )
            oFr:SetProperty(  "PDFExport", "OpenAfterExport",  .F. )
            oFr:DoExport(     "PDFExport" )

            if file( cFilePdf )

               with object ( TGenMailing():New() )

                  :SetTypeDocument( "nPedPrv" )
                  :SetDe(           uFieldEmpresa( "cNombre" ) )
                  :SetCopia(        uFieldEmpresa( "cCcpMai" ) )
                  :SetAdjunto(      cFilePdf )
                  :SetPara(         RetFld( ( dbfPedPrvT )->cCodPrv, dbfPrv, "cMeiInt" ) )
                  :SetAsunto(       "Envio de pedido de proveedor número " + ( dbfPedPrvT )->cSerPed + "/" + Alltrim( Str( ( dbfPedPrvT )->nNumPed ) ) )
                  :SetMensaje(      "Adjunto le remito nuestro pedido de proveedor " + ( dbfPedPrvT )->cSerPed + "/" + Alltrim( Str( ( dbfPedPrvT )->nNumPed ) ) + Space( 1 ) )
                  :SetMensaje(      "de fecha " + Dtoc( ( dbfPedPrvT )->dfecPed ) + Space( 1 ) )
                  :SetMensaje(      Chr(13)+Chr(10) )
                  :SetMensaje(      Chr(13)+Chr(10) )
                  :SetMensaje(      "Reciba un cordial saludo." )

                  :GeneralResource( dbfPedPrvT, aItmFacRec() )

               end

            end

      end

   end





   oFr:DestroyFr()

Return .T.



Static Function YearComboBoxChange()

     if oWndBrw:oWndBar:lAllYearComboBox()
        DestroyFastFilter( dbfPedPrvT )
      CreateUserFilter( "", dbfPedPrvT, .F., , , "all" )
     else
        DestroyFastFilter( dbfPedPrvT )
      CreateUserFilter( "Year( Field->dFecPed ) == " + oWndBrw:oWndBar:cYearComboBox(), dbfPedPrvT, .F., , , "Year( Field->dFecPed ) == " + oWndBrw:oWndBar:cYearComboBox() )
     end

     ( dbfPedPrvT )->( dbGoTop() )

     oWndBrw:Refresh()

Return nil
