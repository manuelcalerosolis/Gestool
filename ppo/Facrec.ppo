#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 232 ".\Prg\Facrec.prg"
memvar cDbf
memvar cDbfCol
memvar cDbfCob
memvar cCliente
memvar cDbfCli
memvar cDivisa
memvar cDbfDiv
memvar cFPago
memvar cDbfPgo
memvar cIva
memvar cDbfIva
memvar cAgente
memvar cDbfAge
memvar cTvta
memvar cDbfTvt
memvar cObras
memvar cDbfUsr
memvar cDbfObr
memvar cDbfPedT
memvar cDbfPedL
memvar cDbfAlbT
memvar cDbfAlbL
memvar cDbfAntT
memvar cDbfAlbP
memvar cDbfTrn
memvar aImpVto
memvar aDatVto
memvar aTotIva
memvar nTotIvm
memvar aTotIvm
memvar nTotAge
memvar nTotTrn
memvar nTotAnt
memvar nTotCos
memvar nTotRnt
memvar aIvaUno
memvar aIvaDos
memvar aIvaTre
memvar aIvmUno
memvar aIvmDos
memvar aIvmTre
memvar nPctRnt
memvar nTotDif
memvar aTotTip
memvar cCtaCli
memvar nTotBrt
memvar nTotDto
memvar nTotDpp
memvar nTotUno
memvar nTotDos
memvar nTotNet
memvar nTotIva
memvar nTotReq
memvar nTotFac
memvar nTotImp
memvar nTotPnt
memvar nTotRet
memvar nTotCob
memvar nTotPes
memvar nTotArt
memvar nTotPage
memvar nVdv
memvar nVdvDivFac
memvar cPicUndFac
memvar cPouDivFac
memvar cPorDivFac
memvar cPpvDivFac
memvar nDouDivFac
memvar nRouDivFac
memvar nDpvDivFac
memvar cCodPgo
memvar nTotCaj
memvar lFacRec
memvar lAntCli
memvar nNumArt
memvar nNumCaj
memvar nTotalDto

memvar lEnd
memvar nRow
memvar nPagina
memvar oReport





static oWndBrw
static oBrwIva
static dbfRuta
static dbfTikCliT
static dbfInci
static dbfFacRecT
static dbfFacRecL
static dbfFacRecI
static dbfFacRecD
static dbfFacRecS
static dbfFacCliT
static dbfFacCliL
static dbfFacCliS
static dbfAlbCliL
static dbfAlbCliS
static dbfAlbCliT
static dbfAlbCliP
static dbfPedCliT
static dbfPedCliL
static dbfPreCliT
static dbfPreCliL
static dbfPedPrvL
static dbfFacCliP
static dbfAntCliT
static dbfTmpLin
static dbfTmpInc
static dbfTmpDoc
static dbfTmpAnt
static dbfTmpPgo
static dbfTmpSer
static dbfIva
static dbfCount
static dbfClient
static dbfCliInc
static dbfArtPrv
static dbfFPago
static dbfAgent
static dbfTVta
static dbfPromoT
static dbfPromoL
static dbfPromoC
static dbfAlm
static dbfPro
static dbfFlt
static dbfTblPro
static dbfArticulo
static dbfCodebar
static dbfTarPreL
static dbfTarPreS
static dbfClientAtp
static dbfOferta
static dbfDiv
static dbfObrasT
static dbfFamilia
static dbfKit
static dbfDoc
static dbfArtDiv
static dbfCliBnc
static dbfCajT
static dbfUsr
static dbfDelega
static dbfAgeCom
static dbfEmp
static dbfTblCnv
static dbfAlbPrvL
static dbfAlbPrvS
static dbfFacPrvL
static dbfFacPrvS
static dbfRctPrvL
static dbfRctPrvS
static dbfTikCliL
static dbfTikCliS
static dbfProLin
static dbfProMat
static dbfProSer
static dbfMatSer
static dbfHisMov
static dbfHisMovS
static oStock
static oCtaRem
static oBandera
static oTrans
static oUndMedicion
static cTmpLin
static cTmpInc
static cTmpDoc
static cTmpAnt
static cTmpPgo
static cTmpSer
static oGetTotal
static oGetNet
static oGetTotPnt
static oGetTotIvm
static oGetIva
static oGetReq
static oGetAge
static oGetTotPg
static oGetPag
static oGetPdt
static oGetPes
static oGetDif
static cPouDiv
static cPinDiv
static cPorDiv
static cPpvDiv
static cPicUnd
static nVdvDiv
static nDouDiv
static nRouDiv
static nDpvDiv
static oNewImp
static oTipArt
static oGrpFam
static oGetRnt
static oGetTrn
static nTotOld
static cCodDiv
static oBanco

static oTotalLinea
static nTotalLinea         := 0
static oRentabilidadLinea
static cRentabilidadLinea  := ""
static oComisionLinea
static nComisionLinea      := 0

static aTip                := {}
static aNumAlb             := {}
static oFont
static oMenu
static cOldCodCli          := ""
static cOldCodArt          := ""
static cOldPrpArt          := ""
static cOldUndMed          := ""
static lOpenFiles          := .F.
static lExternal           := .F.
static cFiltroUsuario      := ""

static bEdtRec             := { |aTmp, aGet, dbfFacRecT, oBrw, bWhen, bValid, nMode, aNumDoc| EdtRec( aTmp, aGet, dbfFacRecT, oBrw, bWhen, bValid, nMode, aNumDoc ) }
static bEdtDet             := { |aTmp, aGet, dbfFacRecT, oBrw, bWhen, bValid, nMode, aTmpFac| EdtDet( aTmp, aGet, dbfFacRecT, oBrw, bWhen, bValid, nMode, aTmpFac ) }
static bEdtInc             := { |aTmp, aGet, dbfFacRecI, oBrw, bWhen, bValid, nMode, aTmpLin| EdtInc( aTmp, aGet, dbfFacRecI, oBrw, bWhen, bValid, nMode, aTmpLin ) }
static bEdtDoc             := { |aTmp, aGet, dbfFacRecD, oBrw, bWhen, bValid, nMode, aTmpLin| EdtDoc( aTmp, aGet, dbfFacRecD, oBrw, bWhen, bValid, nMode, aTmpLin ) }









STATIC FUNCTION GenFacRec( nDevice, cCaption, cCodDoc, cPrinter, nCopies )

   local oInf
   local oDevice
   local cNumFac

   if ( dbfFacRecT )->( Lastrec() ) == 0
      return nil
   end

   cNumFac              := ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac

   IIF( nDevice == nil, nDevice := 1, ) ;
   IIF( cCaption == nil, cCaption := "Imprimiendo facturas rectificativas a clientes", ) ;
   IIF( cCodDoc == nil, cCodDoc := cFormatoDocumento( ( dbfFacRecT )->cSerie, "nFacRec", dbfCount ), ) ;
   IIF( nCopies == nil, nCopies := if( nCopiasDocumento( ( dbfFacRecT )->cSerie, "nFacRec", dbfCount ) == 0, Max( Retfld( ( dbfFacRecT )->cCodCli, dbfClient, "CopiasF" ), 1 ), nCopiasDocumento( ( dbfFacRecT )->cSerie, "nFacRec", dbfCount ) ), ) ;

   if Empty( cCodDoc )
      cCodDoc           := cFirstDoc( "FR", dbfDoc )
   end

   if !lExisteDocumento( cCodDoc, dbfDoc )
      return nil
   end





   if !Empty( oAuditor() )
      if nDevice == 1
         oAuditor():AddEvent( "Impresa factura rectificativa",    cNumFac, "14" )
      else
         oAuditor():AddEvent( "Previsualizada factura rectificativa",  cNumFac, "14" )
      end
   end





   if lVisualDocumento( cCodDoc, dbfDoc )

      PrintReportFacRec( nDevice, nCopies, cPrinter, dbfDoc )

   else





      nTotFacRec( cNumFac, dbfFacRecT, dbfFacRecL, dbfIva, dbfDiv, nil, nil, .T. )





      private oReport      := oInf
      private cDbf         := dbfFacRecT
      private cDbfCol      := dbfFacRecL
      private cCliente     := dbfClient
      private cDbfCli      := dbfClient
      private cDivisa      := dbfDiv
      private cDbfDiv      := dbfDiv
      private cFPago       := dbfFPago
      private cDbfPgo      := dbfFPago
      private cIva         := dbfIva
      private cDbfIva      := dbfIva
      private cAgente      := dbfAgent
      private cDbfAge      := dbfAgent
      private cTvta        := dbfTVta
      private cDbfTvt      := dbfTVta
      private cObras       := dbfObrasT
      private cDbfUsr      := dbfUsr
      private cDbfObr      := dbfObrasT
      private cDbfPedT     := dbfPedCliT
      private cDbfPedL     := dbfPedCliL
      private cDbfAlbT     := dbfAlbCliT
      private cDbfAlbL     := dbfAlbCliL
      private cDbfAlbP     := dbfAlbCliP
      private cDbfTrn      := oTrans:GetAlias()
      private aImpVto      := {}
      private aDatVto      := {}
      private aTotTip      := aClone( aTip )
      private nVdv         := nVdvDiv
      private nVdvDivFac   := nVdvDiv
      private cPicUndFac   := cPicUnd
      private cPouDivFac   := cPouDiv
      private cPorDivFac   := cPorDiv
      private cPpvDivFac   := cPpvDiv
      private nDouDivFac   := nDouDiv
      private nRouDivFac   := nRouDiv
      private nDpvDivFac   := nDpvDiv
      private cCodPgo      := ( dbfFacRecT )->cCodPago

      private nTotArt      := nNumArt
      private nTotCaj      := nNumCaj

      private lFacRec      := .T.
      private lAntCli      := .F.





      if ( dbfFacCliP )->( dbSeek( cNumFac ) )

         while ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == cNumFac .AND. ( dbfFacCliP )->( !eof() )

            aAdd( aImpVto, ( dbfFacCliP )->nImporte )
            aAdd( aDatVto, if( Empty( ( dbfFacCliP )->dFecVto ), ( dbfFacCliP )->dPreCob,  ( dbfFacCliP )->dFecVto ) )

            ( dbfFacCliP )->( dbSkip() )

         end

      end





      ( dbfClient )->( dbSeek( ( dbfFacRecT )->cCodCli ) )
      ( dbfAgent  )->( dbSeek( ( dbfFacRecT )->cCodAge ) )
      ( dbfFPago  )->( dbSeek( ( dbfFacRecT )->cCodPago) )
      ( dbfDiv    )->( dbSeek( ( dbfFacRecT )->cDivFac ) )
      ( dbfUsr    )->( dbSeek( ( dbfFacRecT )->cCodUsr ) )
      ( dbfObrasT )->( dbSeek( ( dbfFacRecT )->cCodCli + ( dbfFacRecT )->cCodObr ) )

      oTrans:oDbf:Seek( ( dbfFacRecT )->cCodTrn )





      if ( dbfFacRecL )->( dbSeek( cNumFac ) )

         nTotPage             := nTotLFacRec( dbfFacRecL )





         if !Empty( cPrinter )
            oDevice           := TPrinter():New( cCaption, .F., .T., cPrinter )
            oInf := RptBegin({}, {}, {}, {}, {}, .F.,,,, .F.,, oDevice, cCaption,,, )
         else
            oInf := RptBegin({}, {}, {}, {}, {}, .F.,,,, .T.,,, cCaption,,, )
         end





         if !Empty( oInf ) .AND. oInf:lCreated
            oInf:lAutoland    := .F.
            oInf:lFinish      := .F.
            oInf:lNoCancel    := .T.
            oInf:bSkip        := {|| FacRecReportSkipper( cNumFac, dbfFacRecL ) }

            oInf:oDevice:lPrvModal  := .T.

            do case
            case nDevice == 1

               oInf:oDevice:SetCopies( nCopies )

               oInf:bPreview  := {| o | PrintPreview( o ) }

            case nDevice == 3

               oInf:bPreview  := {| o | PrintPdf( o ) }

            end

            SetMargin( cCodDoc, oInf )
            PrintColum( cCodDoc, oInf )
         end

         RptEnd()

         if !Empty( oInf )




            oInf:Activate({||         ( !( dbfFacRecL )->lImpLin )}, {||       ( ( ( dbfFacRecL )->cSerie + Str( ( dbfFacRecL )->nNumFac ) + ( dbfFacRecL )->cSufFac = cNumFac .AND. !( dbfFacRecL )->( eof() ) ) )},,,, {||  ( ePage( oInf, cCodDoc ) )},,,,,,,, )

            if nDevice == 1
               oInf:oDevice:end()
            end

         end

         oInf                 := nil

      end

   end

   lChgImpDoc( dbfFacReCT )

Return nil



Static Function FacRecReportSkipper( cNumFac, dbfFacRecL )

   if ( dbfFacRecL )->cSerie + Str( ( dbfFacRecL )->nNumFac ) + ( dbfFacRecL )->cSufFac = cNumFac .AND. !( dbfFacRecL )->( eof() )

      ( dbfFacRecL )->( dbSkip() )

      nTotPage              += nTotLFacRec( dbfFacRecL )

   end

Return nil



Static Function EPage( oInf, cCodDoc )

   private nPagina      := oInf:nPage
   private lEnd         := oInf:lFinish
   private nRow         := oInf:nRow





   PrintItems( cCodDoc, oInf )

RETURN NIL



STATIC FUNCTION OpenFiles( lExt )

   local oError
   local oBlock

   if lOpenFiles
      MsgStop( "Imposible abrir ficheros de facturas rectificativas a clientes" )
      Return ( .F. )
   end

   IIF( lExt == nil, lExt := .F., ) ;

   lExternal            := lExt

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      lOpenFiles        := .T.

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacRecT.DBF" ), ( cCheckArea( "FacRecT", @dbfFacRecT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacRecT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacRecL.DBF" ), ( cCheckArea( "FacRecL", @dbfFacRecL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacRecL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacRecI.DBF" ), ( cCheckArea( "FacRecI", @dbfFacRecI ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacRecI.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacRecD.DBF" ), ( cCheckArea( "FacRecD", @dbfFacRecD ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacRecD.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacRecS.DBF" ), ( cCheckArea( "FacRecS", @dbfFacRecS ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacRecS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacCliT.DBF" ), ( cCheckArea( "FacCliT", @dbfFacCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacCliT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacCliL.DBF" ), ( cCheckArea( "FacCliL", @dbfFacCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacCliL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacCliS.DBF" ), ( cCheckArea( "FacCliS", @dbfFacCliS ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacCliS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacCliP.DBF" ), ( cCheckArea( "FacCliP", @dbfFacCliP ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacCliP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ( dbfFacCliP )->( OrdSetFocus( "rNumFac" ) )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBCLIT.DBF" ), ( cCheckArea( "ALBCLIT", @dbfAlbCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBCLIL.DBF" ), ( cCheckArea( "ALBCLIL", @dbfAlbCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBCLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBCLIS.DBF" ), ( cCheckArea( "ALBCLIS", @dbfAlbCliS ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBCLIS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBCLIP.DBF" ), ( cCheckArea( "ALBCLIP", @dbfAlbCliP ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBCLIP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDCLIT.DBF" ), ( cCheckArea( "PEDCLIT", @dbfPedCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDCLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDCLIL.DBF" ), ( cCheckArea( "PEDCLIT", @dbfPedCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDCLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PRECLIT.DBF" ), ( cCheckArea( "PRECLIT", @dbfPreCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PRECLIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PRECLIL.DBF" ), ( cCheckArea( "PRECLIT", @dbfPreCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PRECLIL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TIKET.DBF" ), ( cCheckArea( "TIKET", @dbfTikCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TIKET.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatCli() + "CLIENT.DBF" ), ( cCheckArea( "CLIENT", @dbfClient ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatCli() + "CLIENT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatCli() + "CliInc.Dbf" ), ( cCheckArea( "CliInc", @dbfCliInc ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatCli() + "CliInc.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "PROVART.DBF" ), ( cCheckArea( "PROVART", @dbfArtPrv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "PROVART.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatCli() + "CliAtp.Dbf" ), ( cCheckArea( "CLIATP", @dbfClientAtp ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatCli() + "CliAtp.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatCli() + "AGENTES.DBF" ), ( cCheckArea( "AGENTES", @dbfAgent ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatCli() + "AGENTES.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ARTICULO.DBF" ), ( cCheckArea( "ARTICULO", @dbfArticulo ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ARTICULO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ArtCodebar.Dbf" ), ( cCheckArea( "CODEBAR", @dbfCodebar ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ArtCodebar.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "FAMILIAS.DBF" ), ( cCheckArea( "FAMILIAS", @dbfFamilia ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "FAMILIAS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ARTKIT.DBF" ), ( cCheckArea( "ARTTIK", @dbfKit ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ARTKIT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "TARPREL.DBF" ), ( cCheckArea( "TARPREL", @dbfTarPreL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "TARPREL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "TARPRES.DBF" ), ( cCheckArea( "TARPRES", @dbfTarPreS ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "TARPRES.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "PROMOT.DBF" ), ( cCheckArea( "PROMOL", @dbfPromoT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "PROMOT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "PROMOL.DBF" ), ( cCheckArea( "PROMOL", @dbfPromoL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "PROMOL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "PROMOC.DBF" ), ( cCheckArea( "PROMOC", @dbfPromoC ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "PROMOC.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIVA.DBF" ), ( cCheckArea( "TIVA", @dbfIva ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TIVA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatGrp() + "FPAGO.DBF" ), ( cCheckArea( "FPAGO", @dbfFPago ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatGrp() + "FPAGO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TVTA.DBF" ), ( cCheckArea( "TVTA", @dbfTVta ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TVTA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "DIVISAS.DBF" ), ( cCheckArea( "DIVISAS", @dbfDiv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "DIVISAS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatCli() + "ObrasT.Dbf" ), ( cCheckArea( "OBRAST", @dbfObrasT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatCli() + "ObrasT.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "OFERTA.DBF" ), ( cCheckArea( "OFERTA", @dbfOferta ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "OFERTA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RDOCUMEN.DBF" ), ( cCheckArea( "RDOCUMEN", @dbfDoc ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RDOCUMEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "CTIPO" )

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "PRO.DBF" ), ( cCheckArea( "PRO", @dbfPro ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "PRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "TBLPRO.DBF" ), ( cCheckArea( "TBLPRO", @dbfTblPro ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "TBLPRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatCli() + "RUTA.DBF" ), ( cCheckArea( "RUTA", @dbfRuta ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatCli() + "RUTA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ARTDIV.DBF" ), ( cCheckArea( "ARTDIV", @dbfArtDiv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ARTDIV.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "Cajas.Dbf" ), ( cCheckArea( "CAJAS", @dbfCajT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "Cajas.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatAlm() + "Almacen.DBF" ), ( cCheckArea( "Almacen", @dbfAlm ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatAlm() + "Almacen.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "USERS.DBF" ), ( cCheckArea( "USERS", @dbfUsr ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "USERS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "NCOUNT.DBF" ), ( cCheckArea( "NCOUNT", @dbfCount ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "NCOUNT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TIPINCI.DBF" ), ( cCheckArea( "TIPINCI", @dbfInci ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TIPINCI.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "DELEGA.DBF" ), ( cCheckArea( "DELEGA", @dbfDelega ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "DELEGA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "CNFFLT.DBF" ), ( cCheckArea( "CNFFLT", @dbfFlt ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "CNFFLT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatGrp() + "AGECOM.DBF" ), ( cCheckArea( "AGECOM", @dbfAgeCom ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatGrp() + "AGECOM.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "EMPRESA.DBF" ), ( cCheckArea( "EMPRESA", @dbfEmp ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "EMPRESA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TBLCNV.DBF" ), ( cCheckArea( "TBLCNV", @dbfTblCnv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TBLCNV.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TIKEL.DBF" ), ( cCheckArea( "TIKEL", @dbfTikCliL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TIKEL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "CSTKFAST" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TIKES.DBF" ), ( cCheckArea( "TIKES", @dbfTikCliS ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TIKES.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBPROVL.DBF" ), ( cCheckArea( "ALBPROVL", @dbfAlbPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBPROVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cStkFast" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALBPRVS.DBF" ), ( cCheckArea( "ALBPRVS", @dbfAlbPrvS ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALBPRVS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACPRVL.DBF" ), ( cCheckArea( "FACPRVL", @dbfFacPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FACPRVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cRef" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FACPRVS.DBF" ), ( cCheckArea( "FACPRVS", @dbfFacPrvS ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FACPRVS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvL.DBF" ), ( cCheckArea( "RctPrvL", @dbfRctPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cRef" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RctPrvS.DBF" ), ( cCheckArea( "RctPrvS", @dbfRctPrvS ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RctPrvS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PROLIN.DBF" ), ( cCheckArea( "PROLIN", @dbfProLin ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PROLIN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cCodArt" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PROMAT.DBF" ), ( cCheckArea( "PROMAT", @dbfProMat ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PROMAT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cCodArt" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ProSer.DBF" ), ( cCheckArea( "ProSer", @dbfProSer ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ProSer.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "MatSer.DBF" ), ( cCheckArea( "MatSer", @dbfMatSer ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "MatSer.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "HISMOV.DBF" ), ( cCheckArea( "HISMOV", @dbfHisMov ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "HISMOV.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cRefMov" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "MOVSER.DBF" ), ( cCheckArea( "MOVSER", @dbfHisMovS ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "MOVSER.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PEDPROVL.DBF" ), ( cCheckArea( "PedPrvL", @dbfPedPrvL ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PEDPROVL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ordSetFocus( "cRef" )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "AntCliT.Dbf" ), ( cCheckArea( "AntCliT", @dbfAntCliT ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "AntCliT.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatCli() + "CliBnc.Dbf" ), ( cCheckArea( "CLIBNC", @dbfCliBnc ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatCli() + "CliBnc.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      oBandera          := TBandera():New()

      oStock            := TStock():Create( cPatGrp() )
      if !oStock:lOpenFiles()
         lOpenFiles     := .F.
      else
      oStock:cKit       := dbfKit

      oStock:cPedCliT   := dbfPedCliT
      oStock:cPedCliL   := dbfPedCliL

      oStock:cAlbCliT   := dbfAlbCliT
      oStock:cAlbCliL   := dbfAlbCliL
      oStock:cAlbCliS   := dbfAlbCliS

      oStock:cFacCliT   := dbfFacCliT
      oStock:cFacCliL   := dbfFacCliL
      oStock:cFacCliS   := dbfFacCliS
      oStock:cFacCliP   := dbfFacCliP

      oStock:cFacRecT   := dbfFacRecT
      oStock:cFacRecL   := dbfFacRecL
      oStock:cFacRecS   := dbfFacRecS

      oStock:cTikT      := dbfTikCliT
      oStock:cTikL      := dbfTikCliL
      oStock:cTikS      := dbfTikCliS

      oStock:cAntCliT   := dbfAntCliT

      oStock:cPedPrvL   := dbfPedPrvL
      oStock:cAlbPrvL   := dbfAlbPrvL
      oStock:cAlbPrvS   := dbfAlbPrvS

      oStock:cFacPrvL   := dbfFacPrvL
      oStock:cFacPrvS   := dbfFacPrvS

      oStock:cRctPrvL   := dbfRctPrvL
      oStock:cRctPrvS   := dbfRctPrvS

      oStock:cProducL   := dbfProLin
      oStock:cProducM   := dbfProMat
      oStock:cProducS   := dbfProSer
      oStock:cProducP   := dbfMatSer

      oStock:cHisMov    := dbfHisMov
      oStock:cHisMovS   := dbfHisMovS

      end

      oCtaRem           := TCtaRem():Create( cPatCli() )
      if !oCtaRem:OpenFiles()
         lOpenFiles     := .F.
      end

      oNewImp           := TNewImp():Create( cPatEmp() )
      if !oNewImp:OpenFiles()
         lOpenFiles     := .F.
      end

      oTrans            := TTrans():Create( cPatCli() )
      if !oTrans:OpenFiles()
         lOpenFiles     := .F.
      end

      oTipArt           := TTipArt():Create( cPatArt() )
      if !oTipArt:OpenFiles()
         lOpenFiles     := .F.
      end

      oGrpFam           := TGrpFam():Create( cPatArt() )
      if !oGrpFam:OpenFiles()
         lOpenFiles     := .F.
      end

      oUndMedicion      := UniMedicion():Create( cPatGrp() )
      if !oUndMedicion:OpenFiles()
         lOpenFiles     := .F.
      end

      oBanco           := TBancos():Create()
      if !oBanco:OpenFiles()
         lOpenFiles     := .F.
      end





      public nTotFac    := 0
      public nTotBrt    := 0
      public nTotDto    := 0
      public nTotDPP    := 0
      public nTotNet    := 0
      public nTotIva    := 0
      public nTotIvm    := 0
      public nTotAge    := 0
      public nTotReq    := 0
      public nTotPnt    := 0
      public nTotUno    := 0
      public nTotDos    := 0
      public nTotRet    := 0
      public nTotTrn    := 0
      public nTotAnt    := 0
      public nTotCos    := 0
      public nTotPes    := 0
      public nTotRnt    := 0
      public nPctRnt    := 0
      public nTotDif    := 0

      public aTotIva    := { { 0,0,nil,0,0,0,0,0,0 }, { 0,0,nil,0,0,0,0,0,0 }, { 0,0,nil,0,0,0,0,0,0 } }
      public aIvaUno    := aTotIva[ 1 ]
      public aIvaDos    := aTotIva[ 2 ]
      public aIvaTre    := aTotIva[ 3 ]

      public aTotIvm    := { { 0,0,0 }, { 0,0,0 }, { 0,0,0 }, }
      public aIvmUno    := aTotIvm[ 1 ]
      public aIvmDos    := aTotIvm[ 2 ]
      public aIvmTre    := aTotIvm[ 3 ]

      public aImpVto    := {}
      public aDatVto    := {}

      public nNumArt    := 0
      public nNumCaj    := 0
      public cCtaCli    := ""





      if oUser():lFiltroVentas()
         cFiltroUsuario    := "Field->cCodUsr == '" + oUser():cCodigo() + "' .and. Field->cCodCaj == '" + oUser():cCaja() + "'"
      end


   RECOVER USING oError

      lOpenFiles        := .F.

      msgStop( ErrorMessage( oError ), "Imposible abrir todas las bases de datos" )

   end
   ErrorBlock( oBlock )

   if !lOpenFiles
      CloseFiles()
   end

RETURN ( lOpenFiles )



STATIC FUNCTION CloseFiles()

   DestroyFastFilter( dbfFacRecT, .T., .T. )

   if !Empty( oFont )
      oFont:end()
   end

   if !Empty( dbfFacRecT )
      ( dbfFacRecT )->( dbCloseArea() )
   end

   if !Empty( dbfIva )
      ( dbfIva     )->( dbCloseArea() )
   end

   if !Empty( dbfFPago )
      ( dbfFPago   )->( dbCloseArea() )
   end

   if !Empty( dbfAgent )
      ( dbfAgent   )->( dbCloseArea() )
   end

   if !Empty( dbfClient )
      ( dbfClient     )->( dbCloseArea() )
   end

   if !Empty( dbfFacRecL )
      ( dbfFacRecL )->( dbCloseArea() )
   end

   if !Empty( dbfFacRecS )
      ( dbfFacRecS )->( dbCloseArea() )
   end

   if !Empty( dbfFacRecI )
      ( dbfFacRecI )->( dbCloseArea() )
   end

   if !Empty( dbfFacRecD )
      ( dbfFacRecD )->( dbCloseArea() )
   end

   if !Empty( dbfFacCliT )
      ( dbfFacCliT )->( dbCloseArea() )
   end

   if !Empty( dbfFacCliL )
      ( dbfFacCliL )->( dbCloseArea() )
   end

   if !Empty( dbfFacCliS )
      ( dbfFacCliS )->( dbCloseArea() )
   end

   if !Empty( dbfFacCliP )
      ( dbfFacCliP )->( dbCloseArea() )
   end

   if !Empty( dbfAlbCliT )
      ( dbfAlbCliT )->( dbCloseArea() )
   end

   if !Empty( dbfAlbCliL )
      ( dbfAlbCliL )->( dbCloseArea() )
   end

   if !Empty( dbfAlbCliS )
      ( dbfAlbCliS )->( dbCloseArea() )
   end

   if !Empty( dbfAlbCliP )
      ( dbfAlbCliP )->( dbCloseArea() )
   end

   if !Empty( dbfPedCliT )
      ( dbfPedCliT )->( dbCloseArea() )
   end

   if !Empty( dbfPedCliL )
      ( dbfPedCliL )->( dbCloseArea() )
   end

   if !Empty( dbfPreCliT )
      ( dbfPreCliT )->( dbCloseArea() )
   end

   if !Empty( dbfPreCliL )
      ( dbfPreCliL )->( dbCloseArea() )
   end

   if !Empty( dbfTikCliT )
      ( dbfTikCliT )->( dbCloseArea() )
   end

   if !Empty( dbfArticulo )
      ( dbfArticulo )->( dbCloseArea() )
   end

   if dbfCodebar <> nil
      ( dbfCodebar )->( dbCloseArea() )
   end

   if !Empty( dbfFamilia )
      ( dbfFamilia )->( dbCloseArea() )
   end

   if !Empty( dbfKit )
      ( dbfKit     )->( dbCloseArea() )
   end

   if !Empty( dbfTarPreL )
      ( dbfTarPreL )->( dbCloseArea() )
   end

   if !Empty( dbfTarPreS )
      ( dbfTarPreS )->( dbCloseArea() )
   end

   if !Empty( dbfPromoT )
      ( dbfPromoT  )->( dbCloseArea() )
   end

   if !Empty( dbfPromoL )
      ( dbfPromoL  )->( dbCloseArea() )
   end

   if !Empty( dbfPromoC )
      ( dbfPromoC  )->( dbCloseArea() )
   end

   if !Empty( dbfClientAtp )
      ( dbfClientAtp  )->( dbCloseArea() )
   end

   if !Empty( dbfTVta )
   ( dbfTVta    )->( dbCloseArea() )
   end

   if !Empty( dbfAlm )
   ( dbfAlm    )->( dbCloseArea() )
   end

   if !Empty( dbfDiv )
   ( dbfDiv     )->( dbCloseArea() )
   end

   if !Empty( dbfObrasT )
   ( dbfObrasT  )->( dbCloseArea() )
   end

   if !Empty( dbfOferta )
      ( dbfOferta  )->( dbCloseArea() )
   end

   if !Empty( dbfDoc )
      ( dbfDoc     )->( dbCloseArea() )
   end

   if !Empty( dbfPro )
      ( dbfPro     )->( dbCloseArea() )
   end

   if !Empty( dbfTblPro )
      ( dbfTblPro  )->( dbCloseArea() )
   end

   if !Empty( dbfRuta )
      ( dbfRuta    )->( dbCloseArea() )
   end

   if !Empty( dbfArtDiv )
      ( dbfArtDiv  )->( dbCloseArea() )
   end

   if !Empty( dbfCajT )
      ( dbfCajT    )->( dbCloseArea() )
   end

   if !Empty( dbfUsr )
      ( dbfUsr     )->( dbCloseArea() )
   end

   if !Empty( dbfCount )
      ( dbfCount   )->( dbCloseArea() )
   end

   if dbfInci <> nil
      ( dbfInci )->( dbCloseArea() )
   end

   if dbfArtPrv <> nil
      ( dbfArtPrv )->( dbCloseArea() )
   end

   if !Empty( dbfDelega )
      ( dbfDelega )->( dbCloseArea() )
   end

   if !Empty( dbfAgeCom )
      ( dbfAgeCom )->( dbCloseArea() )
   end

   if !Empty( dbfFlt )
      ( dbfFlt )->( dbCloseArea() )
   end

   if !Empty( dbfEmp )
      ( dbfEmp )->( dbCloseArea() )
   end

   if !Empty( dbfTblCnv )
      ( dbfTblCnv )->( dbCloseArea() )
   end

   if !Empty( dbfAlbPrvL )
      ( dbfAlbPrvL )->( dbCloseArea() )
   end

   if !Empty( dbfAlbPrvS )
      ( dbfAlbPrvS )->( dbCloseArea() )
   end

   if !Empty( dbfFacPrvL )
      ( dbfFacPrvL )->( dbCloseArea() )
   end

   if !Empty( dbfFacPrvS )
      ( dbfFacPrvS )->( dbCloseArea() )
   end

   if !Empty( dbfRctPrvL )
      ( dbfRctPrvL )->( dbCloseArea() )
   end

   if !Empty( dbfRctPrvS )
      ( dbfRctPrvS )->( dbCloseArea() )
   end

   if !Empty( dbfTikCliL )
      ( dbfTikCliL )->( dbCloseArea() )
   end

   if !Empty( dbfTikCliS )
      ( dbfTikCliS )->( dbCloseArea() )
   end

   if !Empty( dbfProLin )
      ( dbfProLin )->( dbCloseArea() )
   end

   if !Empty( dbfProMat )
      ( dbfProMat )->( dbCloseArea() )
   end

   if !Empty( dbfProSer )
      ( dbfProSer )->( dbCloseArea() )
   end

   if !Empty( dbfMatSer )
      ( dbfMatSer )->( dbCloseArea() )
   end

   if !Empty( dbfHisMov )
      ( dbfHisMov )->( dbCloseArea() )
   end

   if dbfHisMovS <> nil
      ( dbfHisMovS )->( dbCloseArea() )
   end

   if dbfCliInc <> nil
      ( dbfCliInc )->( dbCloseArea() )
   end

   if dbfPedPrvL <> nil
      ( dbfPedPrvL )->( dbCloseArea() )
   end

   if !Empty( dbfAntCliT )
      ( dbfAntCliT )->( dbCloseArea() )
   end

   if !Empty( dbfCliBnc )
      ( dbfCliBnc )->( dbClosearea() )
   end

   if !Empty( oStock )
      oStock:end()
   end

   if !Empty( oCtaRem )
      oCtaRem:end()
   end

   if !Empty( oNewImp )
      oNewImp:end()
   end

   if !Empty( oTipArt )
      oTipArt:end()
   end

   if !Empty( oGrpFam )
      oGrpFam:end()
   end

   if !Empty( oTrans )
      oTrans:End()
   end

   if !Empty( oUndMedicion )
      oUndMedicion:end()
   end

   if !Empty( oBanco )
      oBanco:End()
   end

   dbfIva      := nil
   dbfFPago    := nil
   dbfAgent    := nil
   dbfClient   := nil
   dbfFacRecL  := nil
   dbfFacRecT  := nil
   dbfFacRecD  := nil
   dbfFacRecS  := nil
   dbfFacCliT  := nil
   dbfFacCliL  := nil
   dbfFacCliP  := nil
   dbfAlbCliT  := nil
   dbfAlbCliL  := nil
   dbfAlbCliS  := nil
   dbfPedCliT  := nil
   dbfPedCliL  := nil
   dbfPreCliT  := nil
   dbfPreCliL  := nil
   dbfTikCliT  := nil
   dbfArticulo := nil
   dbfCodebar  := nil
   dbfFamilia  := nil
   dbfKit      := nil
   dbfTarPreL  := nil
   dbfTarPreS  := nil
   dbfPromoT   := nil
   dbfPromoL   := nil
   dbfPromoC   := nil
   dbfAlm      := nil
   dbfClientAtp:= nil
   dbfTVta     := nil
   dbfDiv      := nil
   oBandera    := nil
   dbfObrasT   := nil
   dbfDoc      := nil
   dbfOferta   := nil
   dbfPro      := nil
   dbfTblPro   := nil
   dbfRuta     := nil
   dbfArtDiv   := nil
   dbfCajT     := nil
   dbfUsr      := nil
   dbfInci     := nil
   dbfArtPrv   := nil
   dbfDelega   := nil
   dbfFlt      := nil
   dbfAgeCom   := nil
   dbfEmp      := nil
   dbfTblCnv   := nil
   dbfAlbPrvL  := nil
   dbfAlbPrvS  := nil
   dbfFacPrvL  := nil
   dbfFacPrvS  := nil
   dbfRctPrvL  := nil
   dbfRctPrvS  := nil

   dbfTikCliL  := nil
   dbfTikCliS  := nil
   dbfProLin   := nil
   dbfProMat   := nil
   dbfHisMov   := nil
   dbfCliInc   := nil
   dbfPedPrvL  := nil
   dbfCliBnc   := nil

   oStock      := nil
   oNewImp     := nil
   oTrans      := nil
   oTipArt     := nil
   oGrpFam     := nil
   oUndMedicion:= nil
   oBanco      := nil

   oWndBrw     := nil

   lOpenFiles  := .F.

RETURN .T.



FUNCTION FacRec( oMenuItem, oWnd, cCodCli, cCodArt, cCodPed, aNumDoc )

   local oRpl
   local oSnd
   local oImp
   local oPrv
   local oDel
   local oPdf
   local oMail
   local oDup
   local oBtnEur
   local lEuro          := .F.
   local nLevel
   local oRotor
   local oLiq

   IIF( oMenuItem == nil, oMenuItem := "01082", ) ;
   IIF( oWnd == nil, oWnd := oWnd(), ) ;
   IIF( aNumDoc == nil, aNumDoc := Array(3), ) ;
   IIF( cCodCli == nil, cCodCli := "", ) ;
   IIF( cCodArt == nil, cCodArt := "", ) ;
   IIF( cCodPed == nil, cCodPed := "", ) ;

   nLevel            := nLevelUsr( oMenuItem )
   if nAnd( nLevel, 1 ) <> 0
      msgStop( "Acceso no permitido." )
      Return Nil
   end





   if oWnd <> nil
      SysRefresh(); oWnd:CloseAll(); SysRefresh()
   end

   if !OpenFiles()
      Return .F.
   end




















   oWndBrw := TShell():New( 0, 0, 22, 80, "Facturas rectificativas",, oWnd,,, .F.,,, ( dbfFacRecT ),,,,, {"Número", "Fecha", "Código", "Nombre", "Obra", "Sesión", "Agente", "Pago"}, {||( WinAppRec( oWndBrw:oBrw, bEdtRec, dbfFacRecT, cCodCli, cCodArt, aNumDoc ) )}, {||( WinEdtRec( oWndBrw:oBrw, bEdtRec, dbfFacRecT, cCodCli, cCodArt, aNumDoc ) )}, {||( WinDelRec( oWndBrw:oBrw, dbfFacRecT, {|| QuiFacRec() } ) )}, {||( WinDupRec( oWndBrw:oBrw, bEdtRec, dbfFacRecT, cCodCli, cCodArt, aNumDoc ) )}, nil, nLevel, "Document_delete_16", ( 104 + ( 0 * 256 ) + ( 63 * 65536 ) ),,, .T. )

      oWndBrw:lFechado     := .T.

      oWndBrw:bChgIndex    := {|| if( oUser():lFiltroVentas(), CreateFastFilter( cFiltroUsuario, dbfFacRecT, .F., , cFiltroUsuario ), CreateFastFilter( "", dbfFacRecT, .F. ) ) }

      oWndBrw:SetYearComboBoxChange( {|| YearComboBoxChange() } )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Sesión cerrada"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfFacRecT )->lCloFac }
         :nWidth           := 20
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "Zoom16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Cobrado"
         :nHeadBmpNo       := 4
         :bStrData         := {|| "" }
         :bBmpData         := {|| nChkPagFacRec( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, dbfFacRecT, dbfFacCliP ) }
         :nWidth           := 20
         :AddResource( "Bullet_Square_Green_16" )
         :AddResource( "Bullet_Square_Yellow_16" )
         :AddResource( "Bullet_Square_Red_16" )
         :AddResource( "ChgPre16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Contabilizado"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfFacRecT )->lConTab }
         :nWidth           := 20
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "BmpConta16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Envio"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfFacRecT )->lSndDoc }
         :nWidth           := 20
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "Lbl16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Entregado"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| !Empty( ( dbfFacRecT )->dFecEnt ) }
         :nWidth           := 20
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "document_ok_16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Incidencia"
         :nHeadBmpNo       := 4
         :bStrData         := {|| "" }
         :bBmpData         := {|| nEstadoIncidencia( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac ) }
         :nWidth           := 20
         :lHide            := .T.
         :AddResource( "Bullet_Square_Red_16" )
         :AddResource( "Bullet_Square_Yellow_16" )
         :AddResource( "Bullet_Square_Green_16" )
         :AddResource( "informacion_16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Impreso"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfFacRecT )->lImprimido }
         :nWidth           := 20
         :lHide            := .T.
         :SetCheck( { "Sel16", "Nil16" } )
         :AddResource( "IMP16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Número"
         :cSortOrder       := "nNumFac"
         :bEditValue       := {|| ( dbfFacRecT )->cSerie + "/" + Alltrim( Str( ( dbfFacRecT )->nNumFac ) ) + "/" + ( dbfFacRecT )->cSufFac }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Delegación"
         :bEditValue       := {|| ( dbfFacRecT )->cCodDlg }
         :nWidth           := 20
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Sesión"
         :cSortOrder       := "cTurFac"
         :bEditValue       := {|| ( dbfFacRecT )->cTurFac }
         :nWidth           := 40
         :lHide            := .T.
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Fecha"
         :cSortOrder       := "dFecFac"
         :bEditValue       := {|| Dtoc( ( dbfFacRecT )->dFecFac ) }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Caja"
         :bEditValue       := {|| ( dbfFacRecT )->cCodCaj }
         :nWidth           := 40
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Usuario"
         :bEditValue       := {|| ( dbfFacRecT )->cCodUsr }
         :nWidth           := 40
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodCli"
         :bEditValue       := {|| AllTrim( ( dbfFacRecT )->cCodCli ) }
         :nWidth           := 70
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cNomCli"
         :bEditValue       := {|| AllTrim( ( dbfFacRecT )->cNomCli ) }
         :nWidth           := 180
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Población"
         :bEditValue       := {|| AllTrim( ( dbfFacRecT )->cPobCli ) }
         :nWidth           := 180
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Agente"
         :cSortOrder       := "cCodAge"
         :bEditValue       := {|| ( dbfFacRecT )->cCodAge }
         :nWidth           := 50
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
         :bLDClickData     := {|| oWndBrw:RecEdit() }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Pago"
         :cSortOrder       := "cCodPago"
         :bEditValue       := {|| ( dbfFacRecT )->cCodPago }
         :nWidth           := 40
         :lHide            := .T.
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
         :bLDClickData     := {|| oWndBrw:RecEdit() }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Ruta"
         :bEditValue       := {|| ( dbfFacRecT )->cCodRut }
         :nWidth           := 40
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Almacén"
         :bEditValue       := {|| ( dbfFacRecT )->cCodAlm }
         :nWidth           := 60
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Obra"
         :cSortOrder       := "cCodObr"
         :bEditValue       := {|| ( dbfFacRecT )->cCodObr }
         :nWidth           := 50
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Base"
         :bEditValue       := {|| ( dbfFacRecT )->nTotNet }
         :cEditPicture     := cPorDiv( ( dbfFacRecT )->cDivFac, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := cImp()
         :bEditValue       := {|| ( dbfFacRecT )->nTotIva }
         :cEditPicture     := cPorDiv( ( dbfFacRecT )->cDivFac, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "R.E."
         :bEditValue       := {|| ( dbfFacRecT )->nTotReq }
         :cEditPicture     := cPorDiv( ( dbfFacRecT )->cDivFac, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :lHide            := .T.
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Total"
         :bEditValue       := {|| ( dbfFacRecT )->nTotFac }
         :cEditPicture     := cPorDiv( ( dbfFacRecT )->cDivFac, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Div."
         :bEditValue       := {|| cSimDiv( if( lEuro, cDivChg(), ( dbfFacRecT )->cDivFac ), dbfDiv ) }
         :nWidth           := 30
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      oWndBrw:CreateXFromCode()





   oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

   oWndBrw:AddSeaBar()








   oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







   oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )







   oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdtRec, dbfFacRecT ) )}, "(Z)oom", "Z",,, 8,, .F. )







   oDel := oWndBrw:NewAt( "DEL",,, {||( WinDelRec( oWndBrw:oBrw, dbfFacRecT, {|| QuiFacRec() } ) )}, "(E)liminar", "E",, {|This|This:Toggle()}, 16,, .F. )







      oWndBrw:NewAt( "DEL",,, {||( DelSerie( oWndBrw ) )}, "Series",,,, 16, oDel, .F. )







   oImp := oWndBrw:NewAt( "IMP",,, {||( GenFacRec( 1 ), oWndBrw:Refresh() )}, "(I)mprimir", "I",, {|This|This:Toggle()}, 32,, .F. )


      lGenFacRec( oWndBrw:oBrw, oImp, 1 )





   oWndBrw:NewAt( "SERIE1",,, {||( PrnSerie(), oWndBrw:Refresh() )}, "Imp(r)imir series", "R",,, 32,, .F. )







   oPrv := oWndBrw:NewAt( "PREV1",,, {||( GenFacRec( 2 ), oWndBrw:Refresh() )}, "(P)revisualizar", "P",, {|This|This:Toggle()}, 32,, .F. )


      lGenFacRec( oWndBrw:oBrw, oPrv, 2 )






   oPdf := oWndBrw:NewAt( "DOCLOCK",,, {||( GenFacRec( 3 ) )}, "Pd(f)", "F",, {|This|This:Toggle()}, 32,, .F. )


      lGenFacRec( oWndBrw:oBrw, oPdf, 3 )





   oMail := oWndBrw:NewAt( "Mail",,, {||( GenFacRec( 6 ) )}, "Correo electrónico",,, {|This|This:Toggle()}, 32,, .F. )


      lGenFacRec( oWndBrw:oBrw, oMail, 6 )




   oLiq := oWndBrw:NewAt( "Money2_",,, {||( lLiquida( oWndBrw:oBrw ) )}, "Cobrar",,,, 4,, .F. )







      oWndBrw:NewAt( "Money2_",,, {||( aGetSelRec( oWndBrw, {|| lLiquida( oWndBrw:oBrw, ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac ) }, "Liquidar series de facturas", .T., nil, .T., nil ) )}, "Cobrar series",,,, 4, oLiq, .F. )






   oWndBrw:NewAt( "BMPCONTA",,, {||( aGetSelRec( oWndBrw, {|lChk1, lChk2, oTree| CntFacRec( lChk1, lChk2, nil, .T., oTree, nil, nil, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfClient, dbfDiv, dbfArticulo, dbfFPago, dbfIva, oNewImp ) }, "Contabilizar facturas rectificativas", .F., "Simular resultados", .F., "Contabilizar recibos", {|| oDiario() }, {|| cDiario() } ) )}, "(C)ontabilizar", "C",,, 4,, .F. )

   if oUser():lAdministrador()






      oWndBrw:NewAt( "CHGSTATE",,, {||( aGetSelRec( oWndBrw, {| lChk1 | if( ( dbfFacRecT )->( dbRLock() ), ( ( dbfFacRecT )->lContab := lChk1, ( dbfFacRecT )->( dbUnlock() ) ), ) }, "Cambiar estado", .F., "Contabilizado", .T. ) )}, "Cambiar es(t)ado", "T",,, 4,, .F. )

   end








   oSnd := oWndBrw:NewAt( "LBL",, "Seleccionar albaranes para ser enviados", {||lSnd( oWndBrw, dbfFacRecT )}, "En(v)iar", "V",, {|This|This:Toggle()}, 4,, .F. )







      oWndBrw:NewAt( "LBL",,, {||( lSelectAll( oWndBrw, dbfFacRecT, "lSndDoc", .T., .T., .T. ) )}, "Todos",,,, 4, oSnd, .F. )







      oWndBrw:NewAt( "LBL",,, {||( lSelectAll( oWndBrw, dbfFacRecT, "lSndDoc", .F., .T., .T. ) )}, "Ninguno",,,, 4, oSnd, .F. )







      oWndBrw:NewAt( "LBL",,, {||( lSelectAll( oWndBrw, dbfFacRecT, "lSndDoc", .T., .F., .T. ) )}, "Abajo",,,, 4, oSnd, .F. )






   oBtnEur := oWndBrw:NewAt( "BAL_EURO",,, {||( lEuro := !lEuro, oWndBrw:Refresh() )}, "M(o)neda", "O",,, 8,, .F. )

   if oUser():lAdministrador()






      oRpl := oWndBrw:NewAt( "BMPCHG",,, {||( TDlgFlt():New( aItmFacRec(), dbfFacRecT ):ChgFields(), oWndBrw:Refresh() )}, "Cambiar campos",,, {|This|This:Toggle()}, 4,, .F. )







         oWndBrw:NewAt( "BMPCHG",,, {||( TDlgFlt():New( aColFacRec(), dbfFacRecL ):ChgFields(), oWndBrw:Refresh() )}, "Lineas",,,, 4, oRpl, .F. )

   end






   oRotor := oWndBrw:NewAt( "ROTOR",,, {||( oRotor:Expand() )}, "Rotor",,, {|This|This:Toggle()},,, .F. )






      oWndBrw:NewAt( "USER1_",,, {||( EdtCli( ( dbfFacRecT )->cCodCli ) )}, "Modificar cliente",,,,, oRotor, .F. )






      oWndBrw:NewAt( "INFO",,, {||( InfCliente( ( dbfFacRecT )->cCodCli ) )}, "Informe de cliente",,,,, oRotor, .F. )






      oWndBrw:NewAt( "WORKER",,, {||( EdtObras( ( dbfFacRecT )->cCodCli, ( dbfFacRecT )->cCodObr, dbfObrasT ) )}, "Modificar obra",,,,, oRotor, .F. )




   oWndBrw:NewAt( "END",,, {||( oWndBrw:End() )}, "(S)alir", "S",,,,, .F. )





   if !oUser():lFiltroVentas()
      oWndBrw:oActiveFilter:aTField       := aItmFacRec()
      oWndBrw:oActiveFilter:cDbfFilter    := dbfFlt
      oWndBrw:oActiveFilter:cTipFilter    := "14"
   end

   oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp )

   if !Empty( cCodCli ) .OR. !Empty( cCodArt ) .OR. !Empty( aNumDoc[ 1 ] ) .OR. !Empty( aNumDoc[ 2 ] ) .OR. !Empty( aNumDoc[ 3 ] )
      oWndBrw:RecAdd()
      cCodCli        := nil
      cCodArt        := nil
      aNumDoc        := Array( 3 )
   end

Return .T.



STATIC FUNCTION EdtRec( aTmp, aGet, dbfFacRecT, oBrw, cCodCli, cCodArt, nMode, aNumDoc )

   local oDlg
    local oFld
   local oBrwLin
   local oBrwInc
   local oBrwDoc
   local oBrwPgo
   local oSay              := Array( 12 )
   local cSay              := Array( 12 )
   local oSayLabels        := Array( 9 )
   local oBmpDiv
   local oBmpEmp
   local nOrd
   local oBtnKit
   local oTlfCli
   local cTlfCli
   local oRieCli
   local nRieCli
   local oGetMasDiv
   local cGetMasDiv        := ""
   local cSerie
   local oSayGetRnt
   local oBmpGeneral

   IIF( cSerie == nil, cSerie := cNewSer( "nFacRec", dbfCount ), ) ;
   IIF( aNumDoc == nil, aNumDoc := Array( 3 ), ) ;

   do case
   case nMode == 1

      if !lCurSesion()
         MsgStop( "No hay sesiones activas, imposible añadir documentos" )
         Return .F.
      end

      if !lCajaOpen( oUser():cCaja() ) .AND. !oUser():lAdministrador()
         msgStop( "Esta caja " + oUser():cCaja() + " esta cerrada." )
         Return .F.
      end

      aTmp[ 4    ]  := cCurSesion()
      aTmp[ 26    ]  := cToD("")
      aTmp[ 7    ]  := oUser():cAlmacen()
      aTmp[ 8    ]  := oUser():cCaja()
      aTmp[ 32   ]  := cDefFpg()
      aTmp[ 58    ]  := cDivEmp()
      aTmp[ 59    ]  := nChgDiv( aTmp[ 58 ], dbfDiv )
      aTmp[ 3    ]  := RetSufEmp()
      aTmp[ 57    ]  := .T.
      aTmp[ 64    ]  := cProCnt()
      aTmp[ 76    ]  := cCurUsr()
      aTmp[ 21    ]  := cDefVta()
      aTmp[ 83    ]  := oUser():cDelegacion()
      aTmp[ 56    ]  := uFieldEmpresa( "lIvaInc" )
      aTmp[ 84    ]  := Padr( "Gastos", 250 )

      if !Empty( cCodCli )
         aTmp[ 6 ]  := cCodCli
      end

      aTmp[ 35    ]  := nIva( dbfIva, cDefIva() )

   case nMode == 4

      if !lCurSesion()
         MsgStop( "No hay sesiones activas, imposible añadir documentos" )
         Return .F.
      end

      if !lCajaOpen( oUser():cCaja() ) .AND. !oUser():lAdministrador()
         msgStop( "Esta caja " + oUser():cCaja() + " esta cerrada." )
         Return .F.
      end

      aTmp[ 5  ]    := GetSysDate()
      aTmp[ 37  ]    := ""
      aTmp[ 28  ]    := .F.
      aTmp[ 72  ]    := .F.
      aTmp[ 25  ]    := .F.
      aTmp[ 57  ]    := .T.

   case nMode == 2

      if aTmp[ 72 ] .AND. !oUser():lAdministrador()
         msgStop( "Solo puede modificar las facturas cerradas los administradores." )
         return .F.
      end


      if aTmp[ 25 ] .AND. !ApoloMsgNoYes(  "La modificación de esta factura puede provocar descuadres contables." + Chr(13)+Chr(10) + "¿ Desea continuar ?", "Factura ya contabilizada" )
         return .F.
      end

   end





   cOldCodCli              := aTmp[6]





   nOrd                    := ( dbfFacRecT )->( ordSetFocus( 1 ) )





   if Empty( Rtrim( aTmp[ 1 ] ) )
      aTmp[ 1 ]      := cSerie
   end

   if Empty( aTmp[18] )
      aTmp[ 18 ]     := Max( uFieldEmpresa( "nPreVta" ), 1 )
   end

   if Empty( aTmp[ 58 ] )
      aTmp[ 58 ]     := cDivEmp()
   end

   if Empty( aTmp[ 39 ] )
      aTmp[ 39 ]     := Padr( "General", 50 )
   end

   if Empty( aTmp[ 41 ] )
      aTmp[ 41 ]        := Padr( "Pronto pago", 50 )
   end





   nRieCli                 := oStock:nRiesgo( aTmp[ 6 ] )

   if Empty( aTmp[ 87 ] )
      aTmp[ 87 ]     := RetFld( aTmp[ 6 ], dbfClient, "Telefono" )
   end

   if BeginTrans( aTmp, nMode )
      Return .F.
   end

   cPicUnd                 := MasUnd()
   cPouDiv                 := cPouDiv( aTmp[ 58 ], dbfDiv )
   cPorDiv                 := cPorDiv( aTmp[ 58 ], dbfDiv )
   cPinDiv                 := cPinDiv( aTmp[ 58 ], dbfDiv )
   nDouDiv                 := nDouDiv( aTmp[ 58 ], dbfDiv )
   nRouDiv                 := nRouDiv( aTmp[ 58 ], dbfDiv )
   cPpvDiv                 := cPpvDiv( aTmp[ 58 ], dbfDiv )
   nDpvDiv                 := nDpvDiv( aTmp[ 58 ], dbfDiv )

   oFont                   := TFont():New( "Arial", 8, 26, .F., .T. )





   cSay[ 2 ]               := RetFld( aTmp[ 7 ], dbfAlm )
   cSay[ 4 ]               := RetFld( aTmp[ 32], dbfFPago )
   cSay[ 8 ]               := RetFld( aTmp[ 20 ], dbfRuta )
   cSay[ 3 ]               := RetFld( aTmp[ 19 ], dbfAgent )
   cSay[ 5 ]               := RetFld( aTmp[ 21 ], dbfTarPreS )
   cSay[ 7 ]               := RetFld( aTmp[ 6 ] + aTmp[ 22 ], dbfObrasT, "cNomObr" )
   cSay[ 9 ]               := oTrans:cNombre( aTmp[ 70 ] )
   cSay[ 10]               := RetFld( aTmp[ 8 ], dbfCajT )
   cSay[ 11]               := RetFld( aTmp[ 76 ], dbfUsr, "cNbrUse" )
   cSay[ 12]               := RetFld( cCodEmp() + aTmp[ 83 ], dbfDelega, "cNomDlg" )





   InitTarifaCabecera( aTmp[ 18 ] )





   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "facturas rectificativas", "FacCli",, .F.,,,,,, .F.,,,,,, .F., )
















      oFld := TFolder():ReDefine( 400, {"&Factura", "Da&tos", "&Incidencias", "D&ocumentos"}, { "FACREC_01","FACREC_02","PEDCLI_3","PEDCLI_4" }, oDlg,,,,, .F., )









      oBmpGeneral := TBitmap():ReDefine( 990, "factura_rectificativa_48_alpha",, oFld:aDialogs[1],,, .F., .F.,,, .F.,,, .T. )





      oBmpGeneral := TBitmap():ReDefine( 990, "folder2_red_alpha_48",, oFld:aDialogs[2],,, .F., .F.,,, .F.,,, .T. )





      oBmpGeneral := TBitmap():ReDefine( 990, "information_48_alpha",, oFld:aDialogs[3],,, .F., .F.,,, .F.,,, .T. )





      oBmpGeneral := TBitmap():ReDefine( 990, "address_book2_alpha_48",, oFld:aDialogs[4],,, .F., .F.,,, .F.,,, .T. )







        aGet[6] := TGetHlp():ReDefine( 170, { | u | If( PCount()==0, aTmp[6], aTmp[6]:= u ) }, oFld:aDialogs[1],,, {||    ( loaCli( aGet, aTmp, nMode, oRieCli ), RecalculaTotal( aTmp ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwClient( aGet[ 6 ], aGet[ 9 ] ), ::lValid() )}, nil, "LUPA",, )




      aGet[ 9 ] := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, aTmp[ 9 ], aTmp[ 9 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 .AND. ( !aTmp[ 16 ] .OR. oUser():lAdministrador() ) )},, .F., .F.,,,,,, nil,,, )

      if uFieldEmpresa( "nCifRut" ) == 1





      aGet[ 15 ] := TGetHlp():ReDefine( 181, { | u | If( PCount()==0, aTmp[ 15 ], aTmp[ 15 ]:= u ) }, oFld:aDialogs[1],,, {||    ( CheckCif( aGet[ 15 ] ) )},,,,,, .F., {||     ( nMode <> 3 .AND. ( !aTmp[ 16 ] .OR. oUser():lAdministrador() ) )},, .F., .F.,,,,,, nil,,, )

      else






      aGet[ 15 ] := TGetHlp():ReDefine( 181, { | u | If( PCount()==0, aTmp[ 15 ], aTmp[ 15 ]:= u ) }, oFld:aDialogs[1],, "@R 999999999-9", {||    ( CheckRut( aGet[ 15 ] ) )},,,,,, .F., {||     ( nMode <> 3 .AND. ( !aTmp[ 16 ] .OR. oUser():lAdministrador() ) )},, .F., .F.,,,,,, nil,,, )

      end






      aGet[ 10 ] := TGetHlp():ReDefine( 183, { | u | If( PCount()==0, aTmp[ 10 ], aTmp[ 10 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 .AND. ( !aTmp[ 16 ] .OR. oUser():lAdministrador() ) )},, .F., .F.,,,,, {|Self|GoogleMaps( aTmp[ 10 ], Rtrim( aTmp[ 11 ] ) + Space( 1 ) + Rtrim( aTmp[ 12 ] ) )}, nil, "Environnment_View_16",, )





      aGet[14] := TGetHlp():ReDefine( 184, { | u | If( PCount()==0, aTmp[14], aTmp[14]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. ( !aTmp[ 16 ] .OR. oUser():lAdministrador() ) )},, .F., .F.,,,,,, nil,,, )





      aGet[11] := TGetHlp():ReDefine( 185, { | u | If( PCount()==0, aTmp[11], aTmp[11]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. ( !aTmp[ 16 ] .OR. oUser():lAdministrador() ) )},, .F., .F.,,,,,, nil,,, )





      aGet[12] := TGetHlp():ReDefine( 186, { | u | If( PCount()==0, aTmp[12], aTmp[12]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. ( !aTmp[ 16 ] .OR. oUser():lAdministrador() ) )},, .F., .F.,,,,,, nil,,, )





      aGet[87] := TGetHlp():ReDefine( 187, { | u | If( PCount()==0, aTmp[87], aTmp[87]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. ( !aTmp[ 16 ] .OR. oUser():lAdministrador() ) )},, .F., .F.,,,,,, nil,,, )





      oRieCli := TGetHlp():ReDefine( 182, { | u | If( PCount()==0, nRieCli, nRieCli:= u ) }, oFld:aDialogs[1],, cPorDiv,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )









      aGet[ 18 ] := TGetHlp():ReDefine( 171, { | u | If( PCount()==0, aTmp[ 18 ], aTmp[ 18 ]:= u ) }, oFld:aDialogs[1],, "9", {||    ( ChangeTarifaCabecera( aTmp[ 18 ], dbfTmpLin, oBrwLin ) )},,,,,, .F., {||     ( nMode <> 3 .AND. ( lUsrMaster() .OR. oUser():lCambiarPrecio() ) )},, .F., .T.,,, {||      1}, {||      6},, nil,,, )










      aGet[ 92 ] := TGetHlp():ReDefine( 410, { | u | If( PCount()==0, aTmp[ 92 ], aTmp[ 92 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwBncCli( aGet[ 92 ], aGet[ 93 ], aGet[ 94 ], aGet[ 95 ], aGet[ 96 ], aTmp[ 6 ] ) )}, nil, "LUPA",, )






      aGet[ 93 ] := TGetHlp():ReDefine( 420, { | u | If( PCount()==0, aTmp[ 93 ], aTmp[ 93 ]:= u ) }, oFld:aDialogs[1],, "9999", {||    ( lCalcDC( aTmp[ 93 ], aTmp[ 94 ], aTmp[ 95 ], aTmp[ 96 ], aGet[ 95 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      aGet[ 94 ] := TGetHlp():ReDefine( 421, { | u | If( PCount()==0, aTmp[ 94 ], aTmp[ 94 ]:= u ) }, oFld:aDialogs[1],, "9999", {||    ( lCalcDC( aTmp[ 93 ], aTmp[ 94 ], aTmp[ 95 ], aTmp[ 96], aGet[ 95 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      aGet[ 95 ] := TGetHlp():ReDefine( 422, { | u | If( PCount()==0, aTmp[ 95 ], aTmp[ 95 ]:= u ) }, oFld:aDialogs[1],, "99", {||    ( lCalcDC( aTmp[ 93 ], aTmp[ 94 ], aTmp[ 95 ], aTmp[ 96 ], aGet[ 95 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      aGet[ 96 ] := TGetHlp():ReDefine( 423, { | u | If( PCount()==0, aTmp[ 96 ], aTmp[ 96 ]:= u ) }, oFld:aDialogs[1],, "9999999999", {||    ( lCalcDC( aTmp[ 93 ], aTmp[ 94 ], aTmp[ 95 ], aTmp[ 96 ], aGet[ 95 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )













      aGet[ 58 ] := TGetHlp():ReDefine( 190, { | u | If( PCount()==0, aTmp[ 58 ], aTmp[ 58 ]:= u ) }, oFld:aDialogs[1],, "@!", {||    ( cDivOut( aGet[ 58 ], oBmpDiv, aTmp[ 59 ], @cPouDiv, @nDouDiv, @cPorDiv, @nRouDiv, @cPpvDiv, @nDpvDiv, oGetMasDiv, dbfDiv, oBandera ) )}, "N/W*",,,,, .F., {||     ( nMode == 1 .AND. ( dbfTmpLin )->( LastRec() ) == 0 )},, .F., .F.,,,,, {|Self|BrwDiv( aGet[ 58 ], oBmpDiv, aTmp[ 59 ], dbfDiv, oBandera )}, nil, "LUPA",, )




        oBmpDiv := TBitmap():ReDefine( 191, "BAN_EURO",, oFld:aDialogs[1],,, .F., .F.,,, .F.,,, .F. )





      aGet[ 76 ] := TGetHlp():ReDefine( 125, { | u | If( PCount()==0, aTmp[ 76 ], aTmp[ 76 ]:= u ) }, oFld:aDialogs[2],,, {||    ( SetUsuario( aGet[ 76 ], oSay[ 11 ], nil, dbfUsr ) )},,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )




      oSay[ 11 ] := TGetHlp():ReDefine( 126, { | u | If( PCount()==0, cSay[ 11 ], cSay[ 11 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )








      aGet[56] := TCheckBox():ReDefine( 200, { | u | If( PCount()==0, aTmp[56], aTmp[56]:= u ) }, oFld:aDialogs[1],,,,,,, .F., {||     ( ( dbfTmpLin )->( LastRec() ) == 0 )}, .F. )












      aGet[21] := TGetHlp():ReDefine( 210, { | u | If( PCount()==0, aTmp[21], aTmp[21]:= u ) }, oFld:aDialogs[1],,, {||    ( cTarifa( aGet[21], oSay[ 5 ] ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. oUser():lAdministrador() )},, .F., .F.,,,,, {|Self|( BrwTarifa( aGet[21], oSay[ 5 ] ) )}, nil, "LUPA",, )




      oSay[ 5 ] := TGetHlp():ReDefine( 211, { | u | If( PCount()==0, cSay[ 5 ], cSay[ 5 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )












        aGet[22] := TGetHlp():ReDefine( 220, { | u | If( PCount()==0, aTmp[22], aTmp[22]:= u ) }, oFld:aDialogs[1],,, {||    ( cObras( aGet[22], oSay[ 7 ], aTmp[6], dbfObrasT ) )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( brwObras( aGet[22], oSay[ 7 ], aTmp[6], dbfObrasT ) )}, nil, "LUPA",, )




      oSay[ 7 ] := TGetHlp():ReDefine( 221, { | u | If( PCount()==0, cSay[ 7 ], cSay[ 7 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )












        aGet[7] := TGetHlp():ReDefine( 230, { | u | If( PCount()==0, aTmp[7], aTmp[7]:= u ) }, oFld:aDialogs[1],,, {||    ( cAlmacen( aGet[7], , oSay[ 2 ] ) )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwAlmacen( aGet[7], oSay[ 2 ] ) )}, nil, "LUPA",, )






      oSay[ 2 ] := TGetHlp():ReDefine( 231, { | u | If( PCount()==0, cSay[ 2 ], cSay[ 2 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( ExpAlmacen( aTmp[ 7 ], dbfTmpLin, oBrwLin ) )}, nil, "Bot",, )












      aGet[ 32 ] := TGetHlp():ReDefine( 240, { | u | If( PCount()==0, aTmp[ 32 ], aTmp[ 32 ]:= u ) }, oFld:aDialogs[1],, "@!", {||    ( cFPago( aGet[ 32 ], dbfFPago, oSay[ 4 ] ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwFPago( aGet[ 32 ], oSay[ 4 ] ) )}, nil, "LUPA",, )





      oSay[ 4 ] := TGetHlp():ReDefine( 241, { | u | If( PCount()==0, cSay[ 4 ], cSay[ 4 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )











      aGet[ 19 ] := TGetHlp():ReDefine( 250, { | u | If( PCount()==0, aTmp[ 19 ], aTmp[ 19 ]:= u ) }, oFld:aDialogs[1],,, {||    ( cAgentes( aGet[19], dbfAgent, oSay[ 3 ], aGet[23], dbfAgeCom ) )},,,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwAgentes( aGet[19], oSay[ 3 ] ) )}, nil, "LUPA",, )






      oSay[ 3 ] := TGetHlp():ReDefine( 251, { | u | If( PCount()==0, cSay[ 3 ], cSay[ 3 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( !Empty( aTmp[ 19 ] ) .AND. nMode <> 3 )},, .F., .F.,,,,, {|Self|( ExpAgente( aTmp[ 19 ], aTmp[ 23 ], dbfTmpLin, oBrwLin ), RecalculaTotal( aTmp ) )}, nil, "Bot",, )







      aGet[ 23 ] := TGetHlp():ReDefine( 252, { | u | If( PCount()==0, aTmp[ 23 ], aTmp[ 23 ]:= u ) }, oFld:aDialogs[1],, "@E 99.99", {||    ( RecalculaTotal( aTmp ) )},,,,,, .F., {||     ( !Empty( aTmp[ 19 ] ) .AND. nMode <> 3 )},, .F., .T.,,,,,, nil,,, )




      oGetAge := TGetHlp():ReDefine( 253, { | u | If( PCount()==0, nTotAge, nTotAge:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )












        aGet[20] := TGetHlp():ReDefine( 260, { | u | If( PCount()==0, aTmp[20], aTmp[20]:= u ) }, oFld:aDialogs[1],,, {||    ( cRuta( aGet[20], dbfRuta, oSay[ 8 ] ) )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwRuta( aGet[20 ], dbfRuta, oSay[ 8 ] ) )}, nil, "LUPA",, )





      oSay[ 8 ] := TGetHlp():ReDefine( 261, { | u | If( PCount()==0, cSay[ 8 ], cSay[ 8 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )









        TButton():ReDefine( 500, {||( AppDeta( oBrwLin, bEdtDet, aTmp, .F. ) )}, oFld:aDialogs[1],,, .F., {||     ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 501, {||( EdtDeta( oBrwLin, bEdtDet, aTmp, .F., nMode ) )}, oFld:aDialogs[1],,, .F., {||     ( nMode <> 3 )},,, .F. )






        TButton():ReDefine( 502, {||( WinDelRec( oBrwLin, dbfTmpLin, {|| DelDeta() }, {|| RecalculaTotal( aTmp ) } ) )}, oFld:aDialogs[1],,, .F., {||     ( nMode <> 3 )},,, .F. )



        TButton():ReDefine( 503, {||( WinZooRec( oBrwLin, bEdtDet, dbfTmpLin, .F., nMode, aTmp ) )}, oFld:aDialogs[1],,, .F.,,,, .F. )





      TButton():ReDefine( 515, {||( AppDeta( oBrwLin, bEdtDet, aTmp, .T. ) )}, oFld:aDialogs[1],,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 524, {||( DbSwapUp( dbfTmpLin, oBrwLin ), RecalculaTotal( aTmp ) )}, oFld:aDialogs[1],,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 525, {||( DbSwapDown( dbfTmpLin, oBrwLin ), RecalculaTotal( aTmp ) )}, oFld:aDialogs[1],,, .F., {||         ( nMode <> 3 )},,, .F. )




      oBtnKit := TButton():ReDefine( 526, {||( ShowKit( dbfFacRecT, dbfTmpLin, oBtnKit, oBrwLin, .T. ) )}, oFld:aDialogs[1],,, .F.,,,, .F. )





      oBrwLin                 := IXBrowse():New( oFld:aDialogs[1] )

      oBrwLin:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwLin:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwLin:cAlias          := dbfTmpLin

      oBrwLin:nMarqueeStyle   := 6
      oBrwLin:cName           := "Rectificativa.Detalle"

      oBrwLin:CreateFromResource( 1 )

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Oferta"
         :bStrData            := {|| "" }
         :bEditValue          := {|| ( dbfTmpLin )->lLinOfe }
         :nWidth              := 46
         :SetCheck( { "Star_Red_16", "Nil16" } )
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Número"
         :bEditValue          := {|| ( dbfTmpLin )->nNumLin }
         :cEditPicture        := "9999"
         :nWidth              := 52
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Código"
         :bEditValue          := {|| ( dbfTmpLin )->cRef }
         :nWidth              := 50
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "C. Barras"
         :bEditValue          := {|| cCodigoBarrasDefecto( ( dbfTmpLin )->cRef, dbfCodeBar ) }
         :nWidth              := 100
         :lHide               := .T.
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Descripción"
         :bEditValue          := {|| Descrip( dbfTmpLin ) }
         :nWidth              := 254
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Código proveedor"
         :bEditValue          := {|| AllTrim( ( dbfTmpLin )->cCodPrv ) }
         :nWidth              := 50
         :lHide               := !( IsMuebles() )
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Nombre proveedor"
         :bEditValue          := {|| AllTrim( ( dbfTmpLin )->cNomPrv ) }
         :nWidth              := 150
         :lHide               := !( IsMuebles() )
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Referencia proveedor"
         :bEditValue          := {|| AllTrim( ( dbfTmpLin )->cRefPrv ) }
         :nWidth              := 50
         :lHide               := !( IsMuebles() )
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Prop. 1"
         :bEditValue          := {|| ( dbfTmpLin )->cValPr1 }
         :nWidth              := 40
         :lHide               := .T.
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Prop. 2"
         :bEditValue          := {|| ( dbfTmpLin )->cValPr2 }
         :nWidth              := 40
         :lHide               := .T.
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Lote"
         :bEditValue          := {|| ( dbfTmpLin )->cLote }
         :nWidth              := 60
         :lHide               := .T.
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Caducidad"
         :bEditValue          := {|| Dtoc( ( dbfTmpLin )->dFecCad ) }
         :nWidth              := 60
         :lHide               := .T.
      end


      with object ( oBrwLin:AddCol() )
         :cHeader             := cNombreUnidades()
         :bEditValue          := {|| nTotNFacRec( dbfTmpLin ) }
         :cEditPicture        := cPicUnd
         :nWidth              := 60
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Unidad de medición"
         :bEditValue          := {|| ( dbfTmpLin )->cUnidad }
         :nWidth              := 100
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Alm."
         :bEditValue          := {|| ( dbfTmpLin )->cAlmLin }
         :nWidth              := 40
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Precio"
         :bEditValue          := {|| nTotUFacRec( dbfTmpLin, nDouDiv ) }
         :cEditPicture        := cPouDiv
         :nWidth              := 80
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "% Dto."
         :bEditValue          := {|| ( dbfTmpLin )->nDto }
         :cEditPicture        := "@E 999.99"
         :nWidth              := 60
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Dto. Lin."
         :bEditValue          := {|| nDtoUFacRec( dbfTmpLin, nDouDiv ) }
         :cEditPicture        := cPouDiv
         :nWidth              := 50
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
         :lHide               := .T.
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "% Prm."
         :bEditValue          := {|| ( dbfTmpLin )->nDtoPrm }
         :cEditPicture        := "@E 999.99"
         :nWidth              := 40
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
         :lHide               := .T.
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "% Age"
         :bEditValue          := {|| ( dbfTmpLin )->nComAge }
         :cEditPicture        := "@E 999.99"
         :nWidth              := 40
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
         :lHide               := .T.
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "% " + cImp()
         :bEditValue          := {|| ( dbfTmpLin )->nIva }
         :cEditPicture        := "@E 999.9"
         :nWidth              := 40
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Portes"
         :bEditValue          := {|| nTrnUFacRec( dbfTmpLin, nDpvDiv ) }
         :cEditPicture        := cPpvDiv
         :nWidth              := 70
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
         :lHide               := .T.
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "P. verde"
         :bEditValue          := {|| nPntUFacRec( dbfTmpLin, nDpvDiv ) }
         :cEditPicture        := cPpvDiv
         :nWidth              := 70
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
         :lHide               := .T.
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Total"
         :bEditValue          := {|| nTotLFacRec( dbfTmpLin, nDouDiv, nRouDiv, nil, .T., aTmp[ 97 ], .T., cPorDiv ) }
         :nWidth              := 80
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Grt."
         :bEditValue          := {|| ( dbfTmpLin )->nMesGrt }
         :cEditPicture        := "99"
         :nWidth              := 40
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
         :lHide               := .T.
      end

      with object ( oBrwLin:AddCol() )
         :cHeader             := "Fecha"
         :bEditValue          := {|| Dtoc( ( dbfTmpLin )->dFecha ) }
         :nWidth              := 40
         :lHide               := .T.
      end

      with object ( oBrwLin:AddCol() )
         :cHeader          := "No imp."
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfTmpLin )->lImpLin }
         :nWidth           := 20
         :lHide            := .T.
         :SetCheck( { "Sel16", "Nil16" } )
      end

      if nMode <> 3
         oBrwLin:bLDblClick  := {|| EdtDeta( oBrwLin, bEdtDet, aTmp ) }
      end









     aGet[ 39 ] := TGetHlp():ReDefine( 299, { | u | If( PCount()==0, aTmp[ 39 ], aTmp[ 39 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )








     aGet[40 ] := TGetHlp():ReDefine( 300, { | u | If( PCount()==0, aTmp[ 40 ], aTmp[ 40 ]:= u ) }, oFld:aDialogs[1],, "@E 999.99", {||    ( RecalculaTotal( aTmp ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )




     aGet[ 41 ] := TGetHlp():ReDefine( 309, { | u | If( PCount()==0, aTmp[ 41 ], aTmp[ 41 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )








        aGet[ 42 ] := TGetHlp():ReDefine( 310, { | u | If( PCount()==0, aTmp[ 42 ], aTmp[ 42 ]:= u ) }, oFld:aDialogs[1],, "@E 999.99", {||    ( RecalculaTotal( aTmp ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )










        aGet[ 43 ] := TGetHlp():ReDefine( 320, { | u | If( PCount()==0, aTmp[ 43 ], aTmp[ 43 ]:= u ) }, oFld:aDialogs[1],, "@!",, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )








        aGet[ 44 ] := TGetHlp():ReDefine( 330, { | u | If( PCount()==0, aTmp[ 44 ], aTmp[ 44 ]:= u ) }, oFld:aDialogs[1],, "@E 999.99", {||    ( RecalculaTotal( aTmp ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )






        aGet[ 45 ] := TGetHlp():ReDefine( 340, { | u | If( PCount()==0, aTmp[ 45 ], aTmp[ 45 ]:= u ) }, oFld:aDialogs[1],, "@!",, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )








        aGet[ 46 ] := TGetHlp():ReDefine( 350, { | u | If( PCount()==0, aTmp[ 46 ], aTmp[ 46 ]:= u ) }, oFld:aDialogs[1],, "@E 999.99", {||    ( RecalculaTotal( aTmp ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )




      aGet[ 84 ] := TGetHlp():ReDefine( 411, { | u | If( PCount()==0, aTmp[ 84 ], aTmp[ 84 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )









      aGet[ 35 ] := TGetHlp():ReDefine( 412, { | u | If( PCount()==0, aTmp[ 35 ], aTmp[ 35 ]:= u ) }, oFld:aDialogs[1],, "@E 99.9", {||    ( lTiva( dbfIva, aTmp[ 35 ] ) .AND. RecalculaTotal( aTmp ) )},,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .F.,,,,, {|Self|( BrwIva( aGet[ 35 ], dbfIva, , .T. ) )}, nil, "LUPA",, )







      aGet[ 36 ] := TGetHlp():ReDefine( 400, { | u | If( PCount()==0, aTmp[ 36 ], aTmp[ 36 ]:= u ) }, oFld:aDialogs[1],, cPorDiv, {||    ( RecalculaTotal( aTmp ) )},,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( RecalculaTotal( aTmp ) ) }, .F., .F.,,,,,, nil,,, )





      oBrwIva                        := IXBrowse():New( oFld:aDialogs[1] )

      oBrwIva:bClrSel                := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwIva:bClrSelFocus           := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwIva:SetArray( aTotIva, , , .F. )

      oBrwIva:nMarqueeStyle          := 6
      oBrwIva:lRecordSelector        := .F.
      oBrwIva:lHScroll               := .F.

      oBrwIva:CreateFromResource( 370 )

      with object ( oBrwIva:AddCol() )
         :cHeader          := "Base"
         if uFieldEmpresa( "lIvaImpEsp" )
            :bStrData      := {|| if( aTotIva[ oBrwIva:nArrayAt, 3 ] <> nil, Trans( ( aTotIva[ oBrwIva:nArrayAt, 2 ] + aTotIva[ oBrwIva:nArrayAt, 6 ] ), cPorDiv ), "" ) }
         else
            :bStrData      := {|| if( aTotIva[ oBrwIva:nArrayAt, 3 ] <> nil, Trans( aTotIva[ oBrwIva:nArrayAt, 2 ], cPorDiv ), "" ) }
         end
         :nWidth           := 90
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oBrwIva:AddCol() )
         :cHeader          := "%" + cImp()
         :bStrData         := {|| if( !IsNil( aTotIva[ oBrwIva:nArrayAt, 3 ] ), aTotIva[ oBrwIva:nArrayAt, 3 ], "" ) }
         :bEditValue       := {|| aTotIva[ oBrwIva:nArrayAt, 3 ] }
         :nWidth           := 58
         :cEditPicture     := "@E 999.99"
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :nFootStrAlign    := 1
         :nEditType        := 1
         :bEditWhen        := {|| !IsNil( aTotIva[ oBrwIva:nArrayAt, 3 ] ) }
         :bOnPostEdit      := {|o,x| EdtIva( o, x, aTotIva[ oBrwIva:nArrayAt, 3 ], dbfTmpLin, dbfIva, oBrwLin ), RecalculaTotal( aTmp ) }
      end

      with object ( oBrwIva:AddCol() )
         :cHeader          := cImp()
         :bStrData         := {|| if( aTotIva[ oBrwIva:nArrayAt, 3 ] <> nil, Trans( aTotIva[ oBrwIva:nArrayAt, 8 ], cPorDiv ), "" ) }
         :nWidth           := 64
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oBrwIva:AddCol() )
         :cHeader          := "% R.E."
         :bStrData         := {|| if( aTotIva[ oBrwIva:nArrayAt, 3 ] <> nil .AND. aTmp[ 54 ], Trans( aTotIva[ oBrwIva:nArrayAt, 4 ], "@E 999.99"), "" ) }
         :nWidth           := 58
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oBrwIva:AddCol() )
         :cHeader          := "R.E."
         :bStrData         := {|| if( aTotIva[ oBrwIva:nArrayAt, 3 ] <> nil .AND. aTmp[ 54 ], Trans( aTotIva[ oBrwIva:nArrayAt, 9 ], cPorDiv ), "" ) }
         :nWidth           := 64
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end








      oGetNet := TSay():ReDefine( 401, {|| nTotNet}, oFld:aDialogs[1],,,, .F.,, .F., .F. )



      oGetTrn := TSay():ReDefine( 402, {|| nTotTrn}, oFld:aDialogs[1],,,, .F.,, .F., .F. )



      oGetIva := TSay():ReDefine( 405, {|| nTotIva}, oFld:aDialogs[1],,,, .F.,, .F., .F. )





      aGet[ 54 ] := TCheckBox():ReDefine( 406, { | u | If( PCount()==0, aTmp[ 54 ], aTmp[ 54 ]:= u ) }, oFld:aDialogs[1],, {||( RecalculaTotal( aTmp ) )},,,,, .F., {||     ( nMode <> 3 )}, .F. )



      oGetReq := TSay():ReDefine( 407, {|| nTotReq}, oFld:aDialogs[1],,,, .F.,, .F., .F. )




      oGetTotal := TSay():ReDefine( 485, {|| nTotFac}, oFld:aDialogs[1],,,, .F., oFont, .F., .F. )





      aGet[ 97 ] := TCheckBox():ReDefine( 409, { | u | If( PCount()==0, aTmp[ 97 ], aTmp[ 97 ]:= u ) }, oFld:aDialogs[1],, {||( RecalculaTotal( aTmp ), oBrwLin:Refresh() )},,,,, .F., {||     ( nMode <> 3 )}, .F. )



      oGetTotPnt := TSay():ReDefine( 404, {|| nTotPnt}, oFld:aDialogs[1],,,, .F.,, .F., .F. )



      oGetTotIvm := TSay():ReDefine( 403, {|| nTotIvm}, oFld:aDialogs[1],,,, .F.,, .F., .F. )




      oGetMasDiv := TSay():ReDefine( 488, {|| cGetMasDiv}, oFld:aDialogs[1],,,, .F., oFont, .F., .F. )










      aGet[ 1 ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ 1 ], aTmp[ 1 ]:= u ) }, oFld:aDialogs[1],, "@!", {||    ( aTmp[1] >= "A" .AND. aTmp[1] <= "Z" )}, "N/W*",,,,, .F., {||     ( nMode == 1 .OR. nMode == 4 )},, .F., .T., {||    ( UpSerie( aGet[ 1 ] ) )}, {||  ( DwSerie( aGet[ 1 ] ) )},,,, nil,,, )

         aGet[ 1 ]:bLostFocus := {|| aGet[ 64 ]:cText( cProCnt( aTmp[ 1 ] ) ) }





        aGet[2] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[2], aTmp[2]:= u ) }, oFld:aDialogs[1],, "999999999",,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )





        aGet[3] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[3], aTmp[3]:= u ) }, oFld:aDialogs[1],, "@!",,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )






      aGet[ 5 ] := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTmp[ 5 ], aTmp[ 5 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         ( nMode <> 3 )},, .F., .T.,,,,, {|Self|aGet[ 5 ]:cText( Calendario( aTmp[ 5 ] ) )}, nil,,, )








      aGet[ 37 ] := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, aTmp[ 37 ], aTmp[ 37 ]:= u ) }, oFld:aDialogs[1],, "@R #/#########/##", {||    ( cFacCli( aGet, aTmp, oBrwLin, oBrwIva, nMode ), RecalculaTotal( aTmp ) )},,,,,, .F., {||     ( nMode == 1 .OR. nMode == 4 )},, .F., .F.,,,,, {|Self|( BrwFacCli( aGet[ 37 ], aGet[ 56 ] ) )}, nil, "LUPA",, )









      aGet[ 85 ] := TComboBox():ReDefine( 100, { | u | If( PCount()==0, aTmp[ 85 ], aTmp[ 85 ]:= u ) }, {       "01. Número factura", "02. Serie factura", "03. Fecha expedición", "04. Nombre y apellidos / Razón social del emisor", "05. Nombre y apellidos / Razón social del receptor", "06. Identificación fiscal del emisor obligatoria", "07. Identificación fiscal del receptor", "08. Domicilio emisor obligatorio", "09. Domicilio receptor", "10. Detalle operación", "11. Porcentaje impositivo a aplicar", "12. Cuota tributaria a aplicar", "13. Fecha / Periodo a aplicar", "14. Clase de factura", "15. Literales legales", "16. Base imponible", "80. Cálculo de cuotas repercutidas", "81. Cálculo de cuotas retenidas", "82. Base imponible modificada por devolución de envases / embalajes", "83. Base imponible modificada por descuentos y bonificaciones", "84. Base imponible modificada por resolución firme, judicial o administrativa", "85. Base imponible modificada cuotas repercutidas no satisfechas. Auto de declaración de concurso" }, oFld:aDialogs[ 2 ],,,,,,, .F., {||     ( nMode <> 3 )},,,,, )





      aGet[ 86 ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ 86 ], aTmp[ 86 ]:= u ) }, oFld:aDialogs[ 2 ],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )








      aGet[ 83 ] := TGetHlp():ReDefine( 300, { | u | If( PCount()==0, aTmp[ 83 ], aTmp[ 83 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )




      oSay[ 12 ] := TGetHlp():ReDefine( 301, { | u | If( PCount()==0, cSay[ 12 ], cSay[ 12 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )








      aGet[ 70 ] := TGetHlp():ReDefine( 235, { | u | If( PCount()==0, aTmp[ 70 ], aTmp[ 70 ]:= u ) }, oFld:aDialogs[2],,, {||    ( LoadTrans( aTmp, aGet[ 70 ], aGet[ 71 ], oSay[ 9 ] ) )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oTrans:Buscar( aGet[ 70 ] ), .T. )}, nil, "LUPA",, )





      oSay[ 9 ] := TGetHlp():ReDefine( 236, { | u | If( PCount()==0, cSay[ 9 ], cSay[ 9 ]:= u ) }, oFld:aDialogs[2],,,, "N/W*",,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )





      aGet[ 71 ] := TGetHlp():ReDefine( 237, { | u | If( PCount()==0, aTmp[ 71 ], aTmp[ 71 ]:= u ) }, oFld:aDialogs[2],, ( MasUnd() ),,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )












      aGet[ 8 ] := TGetHlp():ReDefine( 165, { | u | If( PCount()==0, aTmp[ 8 ], aTmp[ 8 ]:= u ) }, oFld:aDialogs[2],,, {||    cCajas( aGet[ 8 ], dbfCajT, oSay[ 10 ] )}, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwCajas( aGet[ 8 ], oSay[ 10 ] ) )}, nil, "LUPA",, )





      oSay[ 10 ] := TGetHlp():ReDefine( 166, { | u | If( PCount()==0, cSay[ 10 ], cSay[ 10 ]:= u ) }, oFld:aDialogs[2],,,, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )









      aGet[64] := TGetHlp():ReDefine( 170, { | u | If( PCount()==0, aTmp[64], aTmp[64]:= u ) }, oFld:aDialogs[2],, "@R ###.######", {||    ( ChkProyecto( aTmp[64], oSay[ 6 ] ), .T. )}, "N/W*",,,,, .F., {||     ( nLenCuentaContaplus() <> 0 .AND. nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwProyecto( aGet[64], oSay[ 6 ] ) )}, nil, "LUPA",, )




      oSay[ 6 ] := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, cSay[ 6 ], cSay[ 6 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )






      aGet[ 33 ] := TGetHlp():ReDefine( 128, { | u | If( PCount()==0, aTmp[ 33 ], aTmp[ 33 ]:= u ) }, oFld:aDialogs[2],, "999",,,,,,, .F., {||         ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )






      aGet[ 27 ] := TGetHlp():ReDefine( 181, { | u | If( PCount()==0, aTmp[ 27 ], aTmp[ 27 ]:= u ) }, oFld:aDialogs[2],, "@!",, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )











      aGet[ 26 ] := TGetHlp():ReDefine( 162, { | u | If( PCount()==0, aTmp[ 26 ], aTmp[ 26 ]:= u ) }, oFld:aDialogs[2],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,, {|Self|aGet[26]:cText( Calendario( aTmp[26] ) )}, nil,,, )





      aGet[60] := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, aTmp[60], aTmp[60]:= u ) }, oFld:aDialogs[2],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[61] := TGetHlp():ReDefine( 161, { | u | If( PCount()==0, aTmp[61], aTmp[61]:= u ) }, oFld:aDialogs[2],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[29] := TGetHlp():ReDefine( 230, { | u | If( PCount()==0, aTmp[29], aTmp[29]:= u ) }, oFld:aDialogs[2],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      aGet[ 80 ] := TCheckBox():ReDefine( 120, { | u | If( PCount()==0, aTmp[ 80 ], aTmp[ 80 ]:= u ) }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )}, .F. )




      aGet[ 81 ] := TGetHlp():ReDefine( 121, { | u | If( PCount()==0, aTmp[ 81 ], aTmp[ 81 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )},, .F., .F.,,,,,, nil,,, )




      aGet[ 82 ] := TGetHlp():ReDefine( 122, { | u | If( PCount()==0, aTmp[ 82 ], aTmp[ 82 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 .AND. lUsrMaster() )},, .F., .F.,,,,,, nil,,, )






      aGet[30] := TMultiGet():ReDefine( 240, { | u | If( PCount()==0, aTmp[30], aTmp[30]:= u ) }, oFld:aDialogs[2],, "N/W*",,,,, .F., {||     ( nMode <> 3 )}, .F.,, )






      oBrwPgo                 := IXBrowse():New( oFld:aDialogs[2] )

      oBrwPgo:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwPgo:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwPgo:cAlias          := dbfTmpPgo
      oBrwPgo:cName           := "Factura rectificativa.Pagos"

      oBrwPgo:nMarqueeStyle   := 6

      oBrwPgo:CreateFromResource( 260 )

      with object ( oBrwPgo:AddCol() )
         :cHeader             := "Cr. Sesión cerrada"
         :bStrData            := {|| "" }
         :bEditValue          := {|| ( dbfTmpPgo )->lCloPgo }
         :nWidth              := 20
         :lHide               := .T.
         :SetCheck( { "Sel16", "Nil16" } )
      end

      with object ( oBrwPgo:AddCol() )
         :cHeader             := "Co. Cobrado"
         :bStrData            := {|| "" }
         :bBmpData            := {|| nEstadoRecibo( dbfTmpPgo ) }
         :nWidth              := 20
         :AddResource( "Cnt16" )
         :AddResource( "Sel16" )
         :AddResource( "UndoRed16" )
      end

      with object ( oBrwPgo:AddCol() )
         :cHeader             := "Contabilizado"
         :bStrData            := {|| "" }
         :bEditValue          := {|| ( dbfTmpPgo )->lConPgo }
         :nWidth              := 70
         :SetCheck( { "Sel16", "Nil16" } )
      end

      with object ( oBrwPgo:AddCol() )
         :cHeader             := "Sesión"
         :bEditValue          := {|| Rtrim( ( dbfTmpPgo )->cTurRec ) }
         :nWidth              := 40
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
      end

      with object ( oBrwPgo:AddCol() )
         :cHeader             := "Expedido"
         :bEditValue          := {|| DtoC( ( dbfTmpPgo )->dPreCob ) }
         :nWidth              := 76
      end

      with object ( oBrwPgo:AddCol() )
         :cHeader             := "Cobro"
         :bEditValue          := {|| DtoC( ( dbfTmpPgo )->dEntrada ) }
         :nWidth              := 76
      end

      with object ( oBrwPgo:AddCol() )
         :cHeader             := "Descripción"
         :bEditValue          := {|| ( dbfTmpPgo )->cDescrip }
         :nWidth              := 190
      end

      with object ( oBrwPgo:AddCol() )
         :cHeader             := "Div."
         :bEditValue          := {|| cSimDiv( ( dbfTmpPgo )->cDivPgo, dbfDiv ) }
         :nWidth              := 30
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
         :lHide               := .T.
      end

      with object ( oBrwPgo:AddCol() )
         :cHeader             := "Importe"
         :bEditValue          := {|| ( dbfTmpPgo )->nImporte }
         :cEditPicture        := cPorDiv
         :nWidth              := 70
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
      end

      if nMode == 2
         oBrwPgo:bLDblClick   := {|| ExtEdtRecCli( dbfTmpPgo, dbfFacCliT, dbfFacCliL, nil, dbfFPago, dbfAgent, dbfCajT, dbfIva, dbfDiv, oCtaRem, oBanco, .T. ), oBrwPgo:Refresh(), RecalculaTotal( aTmp ) }
      end





      TButton():ReDefine( 501, {||( ExtEdtRecCli( dbfTmpPgo, dbfFacCliT, dbfFacCliL, nil, dbfFPago, dbfAgent, dbfCajT, dbfIva, dbfDiv, oCtaRem, oBanco, .T. ), oBrwPgo:Refresh(), RecalculaTotal( aTmp ) )}, oFld:aDialogs[2],,, .F., {||     ( nMode == 2 )},,, .F. )





      TButton():ReDefine( 502, {||( ExtDelRecCli( dbfTmpPgo ), oBrwPgo:Refresh(), RecalculaTotal( aTmp ) )}, oFld:aDialogs[2],,, .F., {||     ( nMode == 2 )},,, .F. )





      TButton():ReDefine( 506, {||( VisRecCli( ( dbfTmpPgo )->cSerie + Str( ( dbfTmpPgo )->nNumFac ) + ( dbfTmpPgo )->cSufFac + Str( ( dbfTmpPgo )->nNumRec ) + ( dbfTmpPgo )->cTipRec, .F. ) )}, oFld:aDialogs[2],,, .F., {||     ( nMode == 2 )},,, .F. )





      TButton():ReDefine( 505, {||( PrnRecCli( ( dbfTmpPgo )->cSerie + Str( ( dbfTmpPgo )->nNumFac ) + ( dbfTmpPgo )->cSufFac + Str( ( dbfTmpPgo )->nNumRec ) + ( dbfTmpPgo )->cTipRec, .F. ) )}, oFld:aDialogs[2],,, .F., {||     ( nMode == 2 )},,, .F. )



      oSayGetRnt := TSay():ReDefine( 800,, oFld:aDialogs[1],,,, .F.,, .F., .F. )



      oGetRnt := TGetHlp():ReDefine( 408, { | u | If( PCount()==0, nTotRnt, nTotRnt:= u ) }, oFld:aDialogs[1],,,,,,,,, .F.,,, .F., .F.,,,,,, nil,,, )








      oGetTotPg := TSay():ReDefine( 455, {|| nTotFac}, oFld:aDialogs[2],,,, .F.,, .F., .F. )



      oGetPag := TSay():ReDefine( 460, {|| 0}, oFld:aDialogs[2],,,, .F.,, .F., .F. )



      oGetPdt := TSay():ReDefine( 480, {|| 0}, oFld:aDialogs[2],,,, .F.,, .F., .F. )





      oGetPes := TGetHlp():ReDefine( 570, { | u | If( PCount()==0, nTotPes, nTotPes:= u ) }, oFld:aDialogs[2],, ( MasUnd() ),,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )





      oGetDif := TGetHlp():ReDefine( 580, { | u | If( PCount()==0, nTotDif, nTotDif:= u ) }, oFld:aDialogs[2],, ( MasUnd() ),,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )





      oBrwInc                 := IXBrowse():New( oFld:aDialogs[ 3 ] )

      oBrwInc:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwInc:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwInc:cAlias          := dbfTmpInc

      oBrwInc:nMarqueeStyle   := 6
      oBrwInc:cName           := "Factura rectificativa.Incidencia"

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Resuelta"
            :bStrData         := {|| "" }
            :bEditValue       := {|| ( dbfTmpInc )->lListo }
            :nWidth           := 64
            :SetCheck( { "Sel16", "Cnt16" } )
         end

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Código"
            :bEditValue       := {|| ( dbfTmpInc )->cCodTip }
            :nWidth           := 80
         end

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Incidencia"
            :bEditValue       := {|| cNomInci( ( dbfTmpInc )->cCodTip, dbfInci ) }
            :nWidth           := 200
         end

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Fecha"
            :bEditValue       := {|| Dtoc( ( dbfTmpInc )->dFecInc ) }
            :nWidth           := 90
         end

         with object ( oBrwInc:AddCol() )
            :cHeader          := "Descripción"
            :bEditValue       := {|| ( dbfTmpInc )->mDesInc }
            :nWidth           := 450
         end

         if nMode <> 3
            oBrwInc:bLDblClick   := {|| WinEdtRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) }
         else
            oBrwInc:bLDblClick   := {|| WinZooRec( oBrwInc, bEdtInc, dbfTmpInc ) }
         end

         oBrwInc:CreateFromResource( 210 )





      TButton():ReDefine( 500, {||( WinAppRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) )}, oFld:aDialogs[ 3 ],,, .F., {||         ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 501, {||( WinEdtRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) )}, oFld:aDialogs[ 3 ],,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 502, {||( WinDelRec( oBrwInc, dbfTmpInc ) )}, oFld:aDialogs[ 3 ],,, .F., {||         ( nMode <> 3 )},,, .F. )




        TButton():ReDefine( 503, {||( WinZooRec( oBrwInc, bEdtInc, dbfTmpInc ) )}, oFld:aDialogs[ 3 ],,, .F.,,,, .F. )




      oBrwDoc                 := TXBrowse():New( oFld:aDialogs[ 4 ] )

      oBrwDoc:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwDoc:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwDoc:cAlias          := dbfTmpDoc

      oBrwDoc:nMarqueeStyle   := 6
      oBrwDoc:nRowHeight      := 40
      oBrwDoc:nDataLines      := 2

      with object ( oBrwDoc:AddCol() )
         :cHeader          := "Documento"
         :bEditValue       := {|| Rtrim( ( dbfTmpDoc )->cNombre ) + Chr(13)+Chr(10) + Space( 5 ) + Rtrim( ( dbfTmpDoc )->cRuta ) }
         :nWidth           := 900
      end

      if nMode <> 3
         oBrwDoc:bLDblClick   := {|| ShellExecute( oDlg:hWnd, "open", Rtrim( ( dbfTmpDoc )->cRuta ) ) }
      end

      oBrwDoc:CreateFromResource( 210 )





      TButton():ReDefine( 500, {||( WinAppRec( oBrwDoc, bEdtDoc, dbfTmpDoc, nil, nil, aTmp ) )}, oFld:aDialogs[ 4 ],,, .F., {||         ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 501, {||( WinEdtRec( oBrwDoc, bEdtDoc, dbfTmpDoc, nil, nil, aTmp ) )}, oFld:aDialogs[ 4 ],,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 502, {||( WinDelRec( oBrwDoc, dbfTmpDoc ) )}, oFld:aDialogs[ 4 ],,, .F., {||         ( nMode <> 3 )},,, .F. )




        TButton():ReDefine( 503, {||( WinZooRec( oBrwDoc, bEdtDoc, dbfTmpDoc ) )}, oFld:aDialogs[ 4 ],,, .F.,,,, .F. )




      TButton():ReDefine( 504, {||( ShellExecute( oDlg:hWnd, "open", Rtrim( ( dbfTmpDoc )->cRuta ) ) )}, oFld:aDialogs[ 4 ],,, .F.,,,, .F. )










      TButton():ReDefine( 3, {||( RecFacRec( aTmp ), oBrwLin:Refresh(), RecalculaTotal( aTmp ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 4, {||( if( EndTrans( aTmp, aGet, oBrw, oBrwLin, oBrwPgo, aNumAlb, nMode, oDlg, oFld ), GenFacRec( 1 ), ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 1, {||( EndTrans( aTmp, aGet, oBrw, oBrwLin, oBrwPgo, aNumAlb, nMode, oDlg, oFld ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 2, {||( If( ExitNoSave( nMode, dbfTmpLin ), oDlg:end(), ) )}, oDlg,,, .F.,,,, .T. )

      oSayLabels[ 1 ] := TGroup():ReDefine( 700,, oFld:aDialogs[ 1 ],,,, .T. )
      oSayLabels[ 2 ] := TSay():ReDefine( 703,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 3 ] := TSay():ReDefine( 704,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 4 ] := TSay():ReDefine( 705,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 5 ] := TSay():ReDefine( 706,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 6 ] := TSay():ReDefine( 708,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 7 ] := TSay():ReDefine( 709,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 8 ] := TSay():ReDefine( 710,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )
      oSayLabels[ 9 ] := TSay():ReDefine( 712,, oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )









      oBmpEmp := TBitmap():ReDefine( 500,, "Bmp\ImgFacRec.bmp", oDlg,,, .F., .F.,,, .F.,,, .F. )





   if nMode <> 3

      oFld:aDialogs[1]:AddFastKey( 113, {|| AppDeta( oBrwLin, bEdtDet, aTmp, .F. ) } )
      oFld:aDialogs[1]:AddFastKey( 114, {|| EdtDeta( oBrwLin, bEdtDet, aTmp, .F., nMode ) } )
      oFld:aDialogs[1]:AddFastKey( 115, {|| WinDelRec( oBrwLin, dbfTmpLin, {|| DelDeta() }, {|| RecalculaTotal( aTmp ) } ) } )

      oFld:aDialogs[2]:AddFastKey( 114, {|| ExtEdtRecCli( dbfTmpPgo, dbfFacCliT, dbfFacCliL, nil, dbfIva, dbfDiv, oCtaRem, oBanco ), RecalculaTotal( aTmp ) } )
      oFld:aDialogs[2]:AddFastKey( 115, {|| ExtDelRecCli( dbfTmpPgo ), RecalculaTotal( aTmp ) } )

      oFld:aDialogs[3]:AddFastKey( 113, {|| WinAppRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) } )
      oFld:aDialogs[3]:AddFastKey( 114, {|| WinEdtRec( oBrwInc, bEdtInc, dbfTmpInc, nil, nil, aTmp ) } )
      oFld:aDialogs[3]:AddFastKey( 115, {|| WinDelRec( oBrwInc, dbfTmpInc ) } )

      oFld:aDialogs[4]:AddFastKey( 113, {|| WinAppRec( oBrwDoc, bEdtDoc, dbfTmpDoc, nil, nil, aTmp ) } )
      oFld:aDialogs[4]:AddFastKey( 114, {|| WinEdtRec( oBrwDoc, bEdtDoc, dbfTmpDoc, nil, nil, aTmp ) } )
      oFld:aDialogs[4]:AddFastKey( 115, {|| WinDelRec( oBrwDoc, dbfTmpDoc ) } )

      oDlg:AddFastKey( 65,                {|| if( GetKeyState( 17 ), CreateInfoArticulo(), ) } )
      oDlg:AddFastKey( 116,             {|| EndTrans( aTmp, aGet, oBrw, oBrwLin, oBrwPgo, aNumAlb, nMode, oDlg, oFld ) } )
      oDlg:AddFastKey( 117,             {|| if( EndTrans( aTmp, aGet, oBrw, oBrwLin, oBrwPgo, aNumAlb, nMode, oDlg, oFld ), GenFacRec( 1 ), ) } )

   end

   oDlg:AddFastKey( 112, {|| ChmHelp( "Facturas_rectificativa" ) } )

   do case
      case nMode == 1 .AND. lRecogerUsuario() .AND. Empty( cCodArt )
         oDlg:bStart := {|| if( lGetUsuario( aGet[ 76 ], dbfUsr ), , oDlg:End() ) }

      case nMode == 1 .AND. lRecogerUsuario() .AND. !Empty( cCodArt )
         oDlg:bStart := {|| if( lGetUsuario( aGet[ 76 ], dbfUsr ), AppDeta( oBrwLin, bEdtDet, aTmp, .F., cCodArt ), oDlg:End() ) }

      case nMode == 1 .AND. !lRecogerUsuario() .AND. !Empty( cCodArt )
         oDlg:bStart := {|| AppDeta( oBrwLin, bEdtDet, aTmp, .F., cCodArt ) }

      otherwise
         oDlg:bStart := {|| ShowKit( dbfFacRecT, dbfTmpLin, oBtnKit, oBrwLin, .F., dbfTmpInc, aTmp[ 6 ], dbfClient, oRieCli, nil, aGet, oSayGetRnt ) }

   end









   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|(   EdtRecMenu( aTmp, oDlg ), if( !Empty( cCodCli ), aGet[ 6 ]:lValid(), ), SetDialog( oSayGetRnt, oGetRnt ), oBrwLin:Load(), oBrwPgo:Load(), oBrwInc:Load(), RecalculaTotal( aTmp ) )}, oDlg:bRClicked,,, )

   EndEdtRecMenu()

   oFont:end()

   oBmpEmp:end()

   oBmpDiv:end()

   oBmpGeneral:End()





   ( dbfFacRecT )->( ordSetFocus( nOrd ) )

   oBrwLin:CloseData()





   KillTrans( oBrwLin, oBrwInc, oBrwPgo )

RETURN ( oDlg:nResult == 1 )



STATIC FUNCTION SetDialog( oSayGetRnt, oGetRnt )

   if !lAccArticulo() .OR. oUser():lNotRentabilidad()

      if !Empty( oSayGetRnt )
         oSayGetRnt:Hide()
      end

      if !Empty( oGetRnt )
         oGetRnt:Hide()
      end

   end

Return .T.



FUNCTION nBrtLFacRec( uTmpLin, nDec, nRec, nVdv, cPorDiv )

   local nCalculo    := 0

   IIF( nDec == nil, nDec := 2, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo          := nTotUFacRec( uTmpLin, nDec, nVdv, cPorDiv )
   nCalculo          *= nTotNFacRec( uTmpLin )

   nCalculo          := Round( nCalculo / nVdv, nRec )

Return ( if( cPorDiv <> nil, Trans( nCalculo, cPorDiv ), nCalculo ) )







FUNCTION nIvaUFacRec( dbfTmpLin, nDec, nVdv )

   local nCalculo

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo       := nTotUFacRec( dbfTmpLin, nDec, nVdv )

   if !( dbfTmpLin )->lIvaLin
      nCalculo    := nCalculo * ( dbfTmpLin )->nIva / 100
   else
      nCalculo    -= nCalculo / ( 1 + ( dbfTmpLin )->nIva / 100 )
   end

   if nVdv <> 0
      nCalculo    := nCalculo / nVdv
   end

RETURN ( Round( nCalculo, nDec ) )






FUNCTION nIncUFacRec( dbfTmpLin, nDec, nVdv )

   local nCalculo

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo       := nTotUFacRec( dbfTmpLin, nDec, nVdv )

   if !( dbfTmpLin )->lIvaLin
      nCalculo    += nCalculo * ( dbfTmpLin )->nIva / 100
   end

    IF nVdv <> 0
      nCalculo    := nCalculo / nVdv
    end

RETURN ( Round( nCalculo, nDec ) )



FUNCTION nDtoUFacRec( dbfTmpLin, nDec, nVdv )

   local nCalculo := ( dbfTmpLin )->nDtoDiv

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

    IF nVdv <> 0
      nCalculo    := ( dbfTmpLin )->nDtoDiv / nVdv
    end

RETURN ( round( nCalculo, nDec ) )







STATIC FUNCTION EdtDet( aTmp, aGet, dbfFacRecL, oBrw, lTotLin, cCodArtEnt, nMode, aTmpFac )

    local oDlg
   local oFld
   local oBtn
    local oGet2
   local cGet2    := ""
   local oGet3
   local cGet3    := ""
   local oSayPr1
   local oSayPr2
   local cSayPr1  := ""
   local cSayPr2  := ""
   local oSayVp1
   local oSayVp2
   local cSayVp1  := ""
   local cSayVp2  := ""
   local oSayAlm
   local cSayAlm  := ""
   local bmpImage
   local oStkAct
   local nStkAct  := 0
   local oBtnSer
   local oSayGrp
   local cSayGrp  := ""
   local oSayFam
   local cSayFam  := ""
   local cCodArt  := Padr( aTmp[ 4 ], 32 )

   do case
   case nMode == 1
      aTmp[ 12  ] := 1
      aTmp[ 20   ] := GetSysDate()
      aTmp[ 1  ] := aTmpFac[ 1  ]
      aTmp[ 2 ] := aTmpFac[ 2 ]
      aTmp[ 25  ] := lTotLin
      aTmp[ 38  ] := aTmpFac[ 7 ]
      aTmp[ 39  ] := aTmpFac[ 56 ]
      aTmp[ 71  ] := aTmpFac[ 18 ]
      if !Empty( cCodArtEnt )
         cCodArt        := Padr( cCodArtEnt, 32 )
      end

   case nMode == 2
      aTmp[ 6 ] := Round( aTmp[ 6 ], nDouDiv )
      aTmp[ 7  ] := Round( aTmp[ 7  ], nDpvDiv )
      aTmp[ 32  ] := Round( aTmp[ 32  ], nDouDiv )
      lTotLin           := aTmp[ 25 ]

   case nMode == 5
      aTmp[ 32  ] := Round( aTmp[ 32  ], nDouDiv )
      lTotLin           := aTmp[ 25 ]

   end





   cOldCodArt           := aTmp[ 4 ]
   cOldPrpArt           := aTmp[ 27 ] + aTmp[ 28 ] + aTmp[ 29 ] + aTmp[ 30 ]
   cOldUndMed           := aTmp[ 16 ]



   if nMode <> 1
      cSayGrp           := RetFld( aTmp[ 54  ], oGrpFam:GetAlias() )
      cSayFam           := RetFld( aTmp[ 53 ], dbfFamilia )
   end





   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "lineas de facturas rectificativas de clientes", "LFacCli",, .F.,,,,,, .F.,,,,,, .F., )



      oFld := TFolder():ReDefine( 400, {"&General",    "Da&tos",    "&Observaciones"}, { "LFacCli_1","LFacCli_7","LFacCli_3" }, oDlg,,,,, .F., )








      aGet[4] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, cCodArt, cCodArt:= u ) }, oFld:aDialogs[1],,, {||    ( loaArt( aGet, bmpImage, aTmp, aTmpFac, oStkAct, oSayPr1, oSayPr2, oSayVp1, oSayVp2, nMode ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwArticulo( aGet[4], aGet[5] ) )}, nil, "LUPA",, )





        aGet[5] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[5], aTmp[5]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( ( lModDes() .OR. Empty( aTmp[ 5 ] ) ) .AND. nMode <> 3 .AND. nMode <> 5 )},, .F., .F.,,,,,, nil,,, )






      aGet[22] := TMultiGet():ReDefine( 111, { | u | If( PCount()==0, aTmp[22], aTmp[22]:= u ) }, oFld:aDialogs[1],, "N/W*",,,,, .F., {||     ( ( lModDes() .OR. Empty( aTmp[ 22 ] ) ) .AND. nMode <> 3 .AND. nMode <> 5 )}, .F.,, )












      aGet[ 44 ] := TGetHlp():ReDefine( 112, { | u | If( PCount()==0, aTmp[ 44 ], aTmp[ 44 ]:= u ) }, oFld:aDialogs[1],, "999999999",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,, 113, )

      aGet[ 44 ]:bValid   := {|| lValidLote( aTmp, aGet, oStkAct ) }






      aGet[ 45 ] := TGetHlp():ReDefine( 340, { | u | If( PCount()==0, aTmp[ 45 ], aTmp[ 45 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         ( nMode <> 3 )},, .F., .T.,,,,,, nil,, 341, )















      aGet[29] := TGetHlp():ReDefine( 270, { | u | If( PCount()==0, aTmp[29], aTmp[29]:= u ) }, oFld:aDialogs[1],,, {||    ( if( lPrpAct( aTmp[ 29 ], oSayVp1, aTmp[ 27 ], dbfTblPro ), loaArt( aGet, bmpImage, aTmp, aTmpFac, oStkAct, oSayPr1, oSayPr2, oSayVp1, oSayVp2, nMode, .F. ), .F. ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. nMode <> 5 )},, .F., .F.,,,,, {|Self|( brwPrpAct( aGet[29], oSayVp1, aTmp[27 ] ) )}, nil, "LUPA",, )

         aGet[ 29 ]:bChange   := {|| aGet[ 29 ]:Assign(), if( !uFieldEmpresa( "lNStkAct" ), oStock:nPutStockActual( aTmp[ 4 ], aTmp[ 38 ], aTmp[ 29 ], aTmp[ 30 ], aTmp[ 44 ], aTmp[ 46 ], aTmp[ 35 ], oStkAct ), ) }



      oSayPr1 := TSay():ReDefine( 271, {|| cSayPr1}, oFld:aDialogs[1],,,, .F.,, .F., .F. )





      oSayVp1 := TGetHlp():ReDefine( 272, { | u | If( PCount()==0, cSayVp1, cSayVp1:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )










      aGet[30] := TGetHlp():ReDefine( 280, { | u | If( PCount()==0, aTmp[30], aTmp[30]:= u ) }, oFld:aDialogs[1],,, {||    ( if( lPrpAct( aTmp[ 30 ], oSayVp2, aTmp[ 28 ], dbfTblPro ), loaArt( aGet, bmpImage, aTmp, aTmpFac, oStkAct, oSayPr1, oSayPr2, oSayVp1, oSayVp2, nMode, .F. ), .F. ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. nMode <> 5 )},, .F., .F.,,,,, {|Self|( brwPrpAct( aGet[ 30 ], oSayVp2, aTmp[ 28 ] ) )}, nil, "LUPA",, )

         aGet[ 30 ]:bChange   := {|| aGet[ 30 ]:Assign(), if( !uFieldEmpresa( "lNStkAct" ), oStock:nPutStockActual( aTmp[ 4 ], aTmp[ 38 ], aTmp[ 29 ], aTmp[ 30 ], aTmp[ 44 ], aTmp[ 46 ], aTmp[ 35 ], oStkAct ), ) }



      oSayPr2 := TSay():ReDefine( 281, {|| cSayPr2}, oFld:aDialogs[1],,,, .F.,, .F., .F. )





      oSayVp2 := TGetHlp():ReDefine( 282, { | u | If( PCount()==0, cSayVp2, cSayVp2:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )










      aGet[ 8 ] := TGetHlp():ReDefine( 350, { | u | If( PCount()==0, aTmp[ 8 ], aTmp[ 8 ]:= u ) }, oFld:aDialogs[1],, cPouDiv, {||    ( lCalcDeta( aTmp, aTmpFac ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ) ) }, .F., .T.,,,,,, nil,, 351, )






      if "MUEBLES" $ cParamsMain()





         aGet[ 64 ] := TGetHlp():ReDefine( 500, { | u | If( PCount()==0, aTmp[ 64 ], aTmp[ 64 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,, 501, )

      end










      aGet[ 11 ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ 11 ], aTmp[ 11 ]:= u ) }, oFld:aDialogs[1],, "@E 99.99", {||    ( lTiva( dbfIva, aTmp[ 11 ], @aTmp[ 55 ] ) )}, "N/W*",,,,, .F., {||     ( lModIva() .AND. nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ) ) }, .F., .F.,,,,, {|Self|( BrwIva( aGet[ 11 ], dbfIva, , .T. ) )}, nil, "LUPA",, )










      aGet[ 41 ] := TGetHlp():ReDefine( 125, { | u | If( PCount()==0, aTmp[ 41 ], aTmp[ 41 ]:= u ) }, oFld:aDialogs[1],, cPouDiv,, "N/W*",,,,, .F., {||     ( uFieldEmpresa( "lModImp" ) .AND. nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ) ) }, .F., .T.,,,,, {|Self|( oNewImp:nBrwImp( aGet[ 41 ] ) )}, nil,, 126, )









        aGet[12] := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTmp[12], aTmp[12]:= u ) }, oFld:aDialogs[1],, cPicUnd, {||    ( lCalcDeta( aTmp, aTmpFac ), loaArt( aGet, bmpImage, aTmp, aTmpFac, oStkAct, oSayPr1, oSayPr2, oSayVp1, oSayVp2, nMode, .F. ) )},,,,,, .F., {||     ( nMode <> 3 .AND. lUseCaj() .AND. !lTotLin .AND. nMode <> 5 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ), loaArt( aGet, bmpImage, aTmp, aTmpFac, oStkAct, oSayPr1, oSayPr2, oSayVp1, oSayVp2, nMode, .F. ) ) }, .F., .T.,,,,,, nil,, 131, )









        aGet[18] := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTmp[18], aTmp[18]:= u ) }, oFld:aDialogs[1],, cPicUnd, {||    ( lCalcDeta( aTmp, aTmpFac ), loaArt( aGet, bmpImage, aTmp, aTmpFac, oStkAct, oSayPr1, oSayPr2, oSayVp1, oSayVp2, nMode, .F. ) )},,,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin .AND. nMode <> 5 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ), loaArt( aGet, bmpImage, aTmp, aTmpFac, oStkAct, oSayPr1, oSayPr2, oSayVp1, oSayVp2, nMode, .F. ) ) }, .F., .T.,,,,,, nil,, 141, )








      aGet[ 16 ] := TGetHlp():ReDefine( 170, { | u | If( PCount()==0, aTmp[ 16 ], aTmp[ 16 ]:= u ) }, oFld:aDialogs[1],,, {||    ( oUndMedicion:Existe( aGet[ 16 ], aGet[ 16 ]:oHelpText, "cNombre" ), ValidaMedicion( aTmp, aGet ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oUndMedicion:Buscar( aGet[ 16 ] ), ValidaMedicion( aTmp, aGet ) )}, nil, "LUPA",, 171 )











      aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ] := TGetHlp():ReDefine( 520, { | u | If( PCount()==0, aTmp[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ], aTmp[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:= u ) }, oFld:aDialogs[1],, MasUnd(),,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ) ) }, .F., .T.,,,,,, nil,, 521, )

         aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:oSay:SetColor( 8388608 )









      aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ] := TGetHlp():ReDefine( 530, { | u | If( PCount()==0, aTmp[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ], aTmp[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:= u ) }, oFld:aDialogs[1],, MasUnd(),,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ) ) }, .F., .T.,,,,,, nil,, 531, )

         aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:oSay:SetColor( 8388608 )









      aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ] := TGetHlp():ReDefine( 540, { | u | If( PCount()==0, aTmp[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ], aTmp[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:= u ) }, oFld:aDialogs[1],, MasUnd(),,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ) ) }, .F., .T.,,,,,, nil,, 541, )

         aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:oSay:SetColor( 8388608 )

if "MUEBLES" $ cParamsMain()







      TBtnBmp():ReDefine( 155, "Money2_16",,,,, {|Self|( DesgPnt( cCodArt, aTmp, aTmp[ 71 ], aGet[ 6 ], aGet[ 36 ], nMode ), lCalcDeta( aTmp, aTmpFac ) )}, oFld:aDialogs[1], .F.,, .F., "Desglose de puntos",,,,, !.T.,, .F.,,, .F., !.F. )

end








      aGet[ 6 ] := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, aTmp[ 6 ], aTmp[ 6 ]:= u ) }, oFld:aDialogs[1],, cPouDiv, {||    ( lCalcDeta( aTmp, aTmpFac ) )},,,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin .AND. nMode <> 5 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ) ) }, .F., .T.,,,,,, nil,,, )










      aGet[ 71 ] := TGetHlp():ReDefine( 156, { | u | If( PCount()==0, aTmp[ 71 ], aTmp[ 71 ]:= u ) }, oFld:aDialogs[1],, "9", {||    ( aTmp[ 71 ] >= 1 .AND. aTmp[ 71 ] <= 6 )},,,,,, .F., {||     ( nMode <> 3 .AND. ( lUsrMaster() .OR. oUser():lCambiarPrecio() ) )}, {|nKey,nFlags,Self| ( ChangeTarifa( aTmp, aGet, aTmpFac ), lCalcDeta( aTmp, aTmpFac ) ) }, .F., .T.,,, {||      1}, {||      6},, nil,,, )

      aGet[ 6 ]:bHelp := {|| DesgPnt( cCodArt, aTmp, aTmp[ 71 ], aGet[ 6 ], aGet[ 36 ], nMode ), lCalcDeta( aTmp, aTmpFac ) }










      aGet[7] := TGetHlp():ReDefine( 151, { | u | If( PCount()==0, aTmp[7], aTmp[7]:= u ) }, oFld:aDialogs[1],, cPpvDiv, {||    ( lCalcDeta( aTmp, aTmpFac ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin .AND. nMode <> 5 )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ) ) }, .F., .T.,,,,,, nil,, 152, )





      aGet[ 31 ] := TGetHlp():ReDefine( 295, { | u | If( PCount()==0, aTmp[ 31 ], aTmp[ 31 ]:= u ) }, oFld:aDialogs[1],, "@E 999,999.999999",,,,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin .AND. nMode <> 5 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 14 ] := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, aTmp[ 14 ], aTmp[ 14 ]:= u ) }, oFld:aDialogs[1],, "@E 999,999.999999",,,,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin .AND. nMode <> 5 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 65 ] := TGetHlp():ReDefine( 400, { | u | If( PCount()==0, aTmp[ 65 ], aTmp[ 65 ]:= u ) }, oFld:aDialogs[1],, "@E 999,999.999999",,,,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin .AND. nMode <> 5 )},, .F., .F.,,,,,, nil,,, )





      aGet[ 66 ] := TGetHlp():ReDefine( 410, { | u | If( PCount()==0, aTmp[ 66 ], aTmp[ 66 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin .AND. nMode <> 5 )},, .F., .F.,,,,,, nil,,, )




      aGet[ 74 ] := TCheckBox():ReDefine( 411, { | u | If( PCount()==0, aTmp[ 74 ], aTmp[ 74 ]:= u ) }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 )}, .F. )




      aGet[ 15 ] := TGetHlp():ReDefine( 175, { | u | If( PCount()==0, aTmp[ 15 ], aTmp[ 15 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin .AND. nMode <> 5 )},, .F., .F.,,,,,, nil,,, )











      aGet[ 32 ] := TGetHlp():ReDefine( 260, { | u | If( PCount()==0, aTmp[ 32 ], aTmp[ 32 ]:= u ) }, oFld:aDialogs[1],, cPouDiv, {||    ( aTmp[32] >= 0 )}, ( 255 + ( 0 * 256 ) + ( 0 * 65536 ) ),,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ) ) }, .F., .T.,,, {||      0},,, nil,, 261, )









        aGet[9] := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, aTmp[9], aTmp[9]:= u ) }, oFld:aDialogs[1],, "@E 999.99", {||    ( lCalcDeta( aTmp, aTmpFac ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ) ) }, .F., .T.,,,,,, nil,,, )









        aGet[10] := TGetHlp():ReDefine( 190, { | u | If( PCount()==0, aTmp[10], aTmp[10]:= u ) }, oFld:aDialogs[1],, "@E 999.99", {||    ( lCalcDeta( aTmp, aTmpFac ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ) ) }, .F., .T.,,,,,, nil,,, )








        aGet[17] := TGetHlp():ReDefine( 200, { | u | If( PCount()==0, aTmp[17], aTmp[17]:= u ) }, oFld:aDialogs[1],, "@E 999.99", {||    ( lCalcDeta( aTmp, aTmpFac ) )},,,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin )}, {|nKey,nFlags,Self| ( lCalcDeta( aTmp, aTmpFac ) ) }, .F., .T.,,,,,, nil,,, )





      oComisionLinea := TGetHlp():ReDefine( 201, { | u | If( PCount()==0, nComisionLinea, nComisionLinea:= u ) }, oFld:aDialogs[ 1 ],, cPorDiv,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )






      oTotalLinea := TGetHlp():ReDefine( 220, { | u | If( PCount()==0, nTotalLinea, nTotalLinea:= u ) }, oFld:aDialogs[1],, cPorDiv,, "N/W*",,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )







      aGet[ 51 ] := TGetHlp():ReDefine( 205, { | u | If( PCount()==0, aTmp[ 51 ], aTmp[ 51 ]:= u ) }, oFld:aDialogs[1],,, {||    ( oTipArt:lValid( aGet[ 51 ], oGet3 ) )},,,,,, .F., {||     ( nMode <> 3 .AND. nMode <> 5 .AND. !lTotLin )},, .F., .F.,,,,, {|Self|( oTipArt:Buscar( aGet[ 51 ] ) )}, nil, "LUPA",, )





      oGet3 := TGetHlp():ReDefine( 206, { | u | If( PCount()==0, cGet3, cGet3:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( .F. )},, .F., .F.,,,,,, nil,,, )









      aGet[ 21 ] := TGetHlp():ReDefine( 290, { | u | If( PCount()==0, aTmp[ 21 ], aTmp[ 21 ]:= u ) }, oFld:aDialogs[1],,, {||    ( cTVta( aGet[21], dbfTVta, oGet2 ) )},,,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin )},, .F., .F.,,,,, {|Self|( BrwTVta( aGet[21], dbfTVta, oGet2 ) )}, nil, "LUPA", 292, )




        oGet2 := TGetHlp():ReDefine( 291, { | u | If( PCount()==0, cGet2, cGet2:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||         ( .F. )},, .F., .F.,,,,,, nil,,, )








      aGet[ 38 ] := TGetHlp():ReDefine( 300, { | u | If( PCount()==0, aTmp[ 38 ], aTmp[ 38 ]:= u ) }, oFld:aDialogs[1],,, {||    ( cAlmacen( aGet[ 38 ], , oSayAlm ), if( !uFieldEmpresa( "lNStkAct" ), oStock:lPutStockActual( aTmp[ 4 ], aTmp[ 38 ], aTmp[ 29 ], aTmp[ 30 ], aTmp[ 44 ], aTmp[ 46 ], aTmp[ 35 ], oStkAct ), .T. ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwAlmacen( aGet[38], oSayAlm ) )}, nil, "LUPA",, )




      oSayAlm := TGetHlp():ReDefine( 301, { | u | If( PCount()==0, cSayAlm, cSayAlm:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )






      oStkAct := TGetHlp():ReDefine( 310, { | u | If( PCount()==0, nStkAct, nStkAct:= u ) }, oFld:aDialogs[1],, cPicUnd,, "N/W*",,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )








      aGet[36] := TGetHlp():ReDefine( 320, { | u | If( PCount()==0, aTmp[36], aTmp[36]:= u ) }, oFld:aDialogs[1],, cPouDiv,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,, 321, )





      aGet[49] := TGetHlp():ReDefine( 330, { | u | If( PCount()==0, aTmp[49], aTmp[49]:= u ) }, oFld:aDialogs[1],, "99",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )











      aGet[34] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[34], aTmp[34]:= u ) }, oFld:aDialogs[2],, "9999",, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )




      aGet[26] := TCheckBox():ReDefine( 110, { | u | If( PCount()==0, aTmp[26], aTmp[26]:= u ) }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 )}, .F. )







      aGet[20] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[20], aTmp[20]:= u ) }, oFld:aDialogs[2],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 .AND. !lTotLin )},, .F., .T.,,,,, {|Self|aGet[20]:cText( Calendario( aTmp[20] ) )}, nil,,, )




      aGet[13] := TCheckBox():ReDefine( 130, { | u | If( PCount()==0, aTmp[13], aTmp[13]:= u ) }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 )}, .F. )






      aGet[37] := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTmp[37], aTmp[37]:= u ) }, oFld:aDialogs[2],, cPouDiv,, "N/W*",,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )







      aGet[ 59 ] := TGetHlp():ReDefine( 220, { | u | If( PCount()==0, aTmp[ 59 ], aTmp[ 59 ]:= u ) }, oFld:aDialogs[ 2 ],,,,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( ChgBmp( aGet[ 59 ], bmpImage ) ) }, .F., .F.,,,,, {|Self|( GetBmp( aGet[ 59 ], bmpImage ) )}, nil, "LUPA",, )









      aGet[ 54 ] := TGetHlp():ReDefine( ( 150 ), { | u | If( PCount()==0, aTmp[ 54 ], aTmp[ 54 ]:= u ) }, oFld:aDialogs[ 2 ],,, {||    ( oSayGrp:cText( RetFld( aTmp[ 54  ], oGrpFam:GetAlias() ) ), .T. )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oGrpFam:Buscar( aGet[ 54 ] ) )}, nil, "LUPA",, )




      oSayGrp := TGetHlp():ReDefine( ( 151 ), { | u | If( PCount()==0, cSayGrp, cSayGrp:= u ) }, oFld:aDialogs[ 2 ],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )







      aGet[ 53 ] := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, aTmp[ 53 ], aTmp[ 53 ]:= u ) }, oFld:aDialogs[2],,, {||    ( oSayFam:cText( RetFld( aTmp[ 53  ], dbfFamilia ) ), .T. )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwFamilia( aGet[ 53 ], oSayFam ) )}, nil, "LUPA",, )




      oSayFam := TGetHlp():ReDefine( 161, { | u | If( PCount()==0, cSayFam, cSayFam:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||         ( .F. )},, .F., .F.,,,,,, nil,,, )




      aGet[ 47 ] := TCheckBox():ReDefine( 330, { | u | If( PCount()==0, aTmp[ 47 ], aTmp[ 47 ]:= u ) }, oFld:aDialogs[ 2 ],,,,,,, .F., {||     ( nMode <> 3 )}, .F. )




      aGet[ 48 ] := TCheckBox():ReDefine( 340, { | u | If( PCount()==0, aTmp[ 48 ], aTmp[ 48 ]:= u ) }, oFld:aDialogs[ 2 ],,,,,,, .F., {||     ( nMode <> 3 )}, .F. )




      aGet[ 35 ] := TRadMenu():Redefine( { | u | If( PCount()==0, aTmp[ 35 ], aTmp[ 35 ]:= u ) }, oFld:aDialogs[ 2 ],, { 350, 351, 352 },,,,, .F., {||     ( nMode <> 3 )}, )





      aGet[ 56 ] := TMultiGet():ReDefine( 100, { | u | If( PCount()==0, aTmp[ 56 ], aTmp[ 56 ]:= u ) }, oFld:aDialogs[3],,,,,,, .F., {||     ( nMode <> 3 )}, .F.,, )





      aGet[ 72 ] := TMultiGet():ReDefine( 110, { | u | If( PCount()==0, aTmp[ 72 ], aTmp[ 72 ]:= u ) }, oFld:aDialogs[3],,,,,,, .F., {||     ( nMode <> 3 )}, .F.,, )

if "MUEBLES" $ cParamsMain()





    aGet[ 57 ] := TGetHlp():ReDefine( 800, { | u | If( PCount()==0, aTmp[ 57 ], aTmp[ 57 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )





    aGet[ 58 ] := TGetHlp():ReDefine( 801, { | u | If( PCount()==0, aTmp[ 58 ], aTmp[ 58 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )

end





      bmpImage := TBitmap():ReDefine( 220,, ( cFileBitmap( cPatImg(), aTmp[ 59 ] ) ), oDlg,, { |nRow,nCol,nKeyFlags| ( bmpImage:lStretch := !bmpImage:lStretch, bmpImage:Refresh() ) }, .F., .F.,,, .F.,,, .F. )

         bmpImage:SetColor( , GetSysColor( 15 ) )





      TButton():ReDefine( 1, {||SaveDeta( aTmp, aTmpFac, aGet, oGet2, oBrw, oDlg, oSayPr1, oSayPr2, oSayVp1, oSayVp2, bmpImage, nMode, oTotalLinea, oStkAct, nStkAct, cCodArt, oBtn, oBtnSer )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )




      TButton():ReDefine( 9, {||( ChmHelp( "Añadir_v" ) )}, oDlg,,, .F.,,,, .F. )




      oBtnSer := TButton():ReDefine( 552, {||( EditarNumeroSerie( aTmp, oStock, nMode ) )}, oDlg,,, .F.,,,, .F. )

   if nMode <> 3
      oDlg:AddFastKey( 117, {|| oBtnSer:Click() } )
      oDlg:AddFastKey( 116, {|| SaveDeta( aTmp, aTmpFac, aGet, oGet2, oBrw, oDlg, oSayPr1, oSayPr2, oSayVp1, oSayVp2, bmpImage, nMode, oTotalLinea, oStkAct, nStkAct, cCodArt, oBtn, oBtnSer ) } )
   end

   oDlg:AddFastKey( 112, {|| ChmHelp( "Añadir_v" ) } )

   oDlg:bStart    := {|| SetDlgMode( aTmp, aGet, oGet2, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oStkAct, nMode, oTotalLinea, aTmpFac ) }




   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted := {|hDC,cPS|( lCalcDeta( aTmp, aTmpFac ) )}, .T.,,, {|Self|( EdtDetMenu( aGet[ 4 ], oDlg ) )}, oDlg:bRClicked,,, )

   EndDetMenu()

   bmpImage:End()

RETURN ( oDlg:nResult == 1 )






STATIC FUNCTION SetDlgMode( aTmp, aGet, oGet2, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oStkAct, nMode, oTotal, aTmpFac )

   if !lUseCaj()
      aGet[ 12 ]:Hide()
   else
      aGet[ 12 ]:SetText( cNombreCajas() )
   end

   aGet[ 18 ]:SetText( cNombreUnidades() )

   if aGet[ 41 ] <> nil
      if !uFieldEmpresa( "lUseImp" )
         aGet[ 41 ]:Hide()
         aGet[ 74 ]:Hide()
      else
         if !uFieldEmpresa( "lModImp" )
            aGet[ 41 ]:Disable()
         end
         if !uFieldEmpresa( "LIVAIMPESP" )
            aGet[ 74 ]:Disable()
         end
      end
   end

   if !lTipMov()
      aGet[ 21 ]:hide()
        oGet2:hide()
   end

   if !uFieldEmpresa( "lUsePor" )
      aGet[ 8 ]:Hide()
   end

   if !uFieldEmpresa( "lUsePnt" ) .OR. !aTmpFac[ 97 ]
      aGet[ 7 ]:Hide()
   end

   if aGet[ 32 ] <> nil
      if !uFieldEmpresa( "lDtoLin" )
         aGet[ 32 ]:Hide()
      end
   end

   do case
   case nMode == 1

      aTmp[ 4    ]  := Space( 32 )
      aTmp[ 39 ]  := aTmpFac[ 56 ]

      aGet[ 12 ]:cText( 1 )
      aGet[ 18]:cText( 1 )
      aGet[ 21 ]:cText( cDefVta() )
      aGet[ 34 ]:cText( nLastNum( dbfTmpLin ) )
      aGet[ 38 ]:cText( aTmpFac[ 7 ])

      aGet[ 5]:Show()
      aGet[ 22 ]:Hide()
      aGet[ 44   ]:Hide()
      aGet[ 45 ]:Hide()

      if aTmpFac[ 63 ] <= 1
      aGet[ 11    ]:cText( nIva( dbfIva, cDefIva() ) )
      end

      if !Empty( oStkAct )

         if !uFieldEmpresa( "lNStkAct" )
            oStkAct:Show()
            oStkAct:cText( 0 )
         else
            oStkAct:Hide()
         end

      end

   case ( nMode == 2 .OR. nMode == 3 )

      if aTmp[42]
         aGet[ 44   ]:Show()
         aGet[ 45 ]:Show()
      else
         aGet[ 44   ]:Hide()
         aGet[ 45 ]:Hide()
      end

      if !Empty( aTmp[ 4 ] )

         aGet[ 5 ]:show()
         aGet[ 22  ]:hide()

      else

         if !aTmp[ 13 ]
            aGet[5]:hide()
            aGet[22 ]:show()
         else
            aGet[5]:show()
            aGet[22 ]:hide()
         end

      end

      if oStkAct <> nil

         oStock:nPutStockActual( aTmp[ 4 ], aTmp[ 38 ], aTmp[ 29 ], aTmp[ 30 ], aTmp[ 44 ], aTmp[ 46 ], aTmp[ 35 ], oStkAct )

         if uFieldEmpresa( "lNStkAct" )
            oStkAct:Hide()
         end

      end

   end

   IF !Empty( aTmp[ 27 ] )
      aGet[ 29 ]:Show()
      oSayPr1:Show()
      oSayVp1:Show()
      oSayPr1:SetText( retProp( aTmp[ 27 ], dbfPro ) )
      aGet[ 29 ]:lValid()
   ELSE
      aGet[29 ]:hide()
      oSayPr1:hide()
      oSayVp1:hide()
   end

   IF !Empty( aTmp[ 28 ] )
      aGet[ 30 ]:Show()
      oSayPr2:Show()
      oSayVp2:Show()
      oSayPr2:SetText( retProp(  aTmp[ 28 ], dbfPro ) )
      aGet[ 30 ]:lValid()
   ELSE
      aGet[ 30 ]:hide()
      oSayPr2:hide()
      oSayVp2:hide()
   end

   oTotal:cText( 0 )





   if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ] )
      aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:Hide()
   end

   if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ] )
      aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:Hide()
   end

   if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ] )
      aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:Hide()
   end

   if oUndMedicion:oDbf:Seek( aTmp[ 16 ] )

      if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ] ) .AND. oUndMedicion:oDbf:nDimension >= 1 .AND. !Empty( oUndMedicion:oDbf:cTextoDim1 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim1 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:Show()
      end

      if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ] ) .AND. oUndMedicion:oDbf:nDimension >= 2 .AND. !Empty( oUndMedicion:oDbf:cTextoDim2 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim2 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:Show()
      end

      if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ] ) .AND. oUndMedicion:oDbf:nDimension >= 3 .AND. !Empty( oUndMedicion:oDbf:cTextoDim3 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim3 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:Show()
      end

   end



   if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ] )
      aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:Hide()
   end

   if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ] )
      aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:Hide()
   end

   if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ] )
      aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:Hide()
   end

   if oUndMedicion:oDbf:Seek(  aTmp[ 16 ] )

      if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ] ) .AND. oUndMedicion:oDbf:nDimension >= 1 .AND. !Empty( oUndMedicion:oDbf:cTextoDim1 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim1 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:Show()
      end

      if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ] ) .AND. oUndMedicion:oDbf:nDimension >= 2 .AND. !Empty( oUndMedicion:oDbf:cTextoDim2 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim2 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:Show()
      end

      if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ] ) .AND. oUndMedicion:oDbf:nDimension >= 3 .AND. !Empty( oUndMedicion:oDbf:cTextoDim3 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim3 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:Show()
      end

   end





   if Empty( aTmp[ 71 ] )
      aGet[ 71 ]:cText( aTmpFac[ 18 ] )
   end

   if !uFieldEmpresa( "lPreLin" )
      aGet[ 71 ]:Hide()
   else
      aGet[ 71 ]:Show()
   end





   aGet[ 21 ]:lValid()
   aGet[ 51 ]:lValid()
   aGet[ 38 ]:lValid()
   aGet[ 4    ]:SetFocus()

   if !lAccArticulo() .OR. oUser():lNotCostos()

      if !Empty( aGet[ 36 ] )
         aGet[ 36 ]:Hide()
      end

   end





   if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ] )
      aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:Hide()
   end

   if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ] )
      aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:Hide()
   end

   if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ] )
      aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:Hide()
   end

   if oUndMedicion:oDbf:Seek(  aTmp[ 16 ] )

      if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ] ) .AND. oUndMedicion:oDbf:nDimension >= 1 .AND. !Empty( oUndMedicion:oDbf:cTextoDim1 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim1 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:Show()
      end

      if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ] ) .AND. oUndMedicion:oDbf:nDimension >= 2 .AND. !Empty( oUndMedicion:oDbf:cTextoDim2 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim2 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:Show()
      end

      if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ] ) .AND. oUndMedicion:oDbf:nDimension >= 3 .AND. !Empty( oUndMedicion:oDbf:cTextoDim3 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim3 )
         aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:Show()
      end

   end





   if ( Empty( aTmp[ 6 ] ) .OR. lUsrMaster() .OR. oUser():lCambiarPrecio() ) .AND. nMode <> 3
      aGet[ 6 ]:HardEnable()
      aGet[ 8  ]:HardEnable()
      aGet[ 7  ]:HardEnable()
      aGet[ 9     ]:HardEnable()
      aGet[ 10  ]:HardEnable()
      aGet[ 32  ]:HardEnable()
   else
      aGet[ 6 ]:HardDisable()
      aGet[ 8  ]:HardDisable()
      aGet[ 7  ]:HardDisable()
      aGet[ 9     ]:HardDisable()
      aGet[ 10  ]:HardDisable()
      aGet[ 32  ]:HardDisable()
   end

RETURN NIL






STATIC FUNCTION SaveDeta(  aTmp, aTmpFac, aGet, oGet2, oBrw, oDlg, oSayPr1, oSayPr2, oSayVp1, oSayVp2, bmpImage, nMode, oTotal, oStkAct, nStkAct, cCodArt, oBtn, oBtnSer )

   local aXbyStr
   local nTotUnd  := 0
   local nRec     := ( dbfTmpLin )->( RecNo() )
   local aClo     := aClone( aTmp )

   if !aGet[ 4 ]:lValid()
      return nil
   end

   if !lMoreIva( aTmp[11] )
      Return nil
   end

   if Empty( aTmp[ 38 ] ) .AND. !Empty( aTmp[ 4 ] )
      msgStop( "Código de almacén no puede estar vacío", "Atención" )
      Return nil
   end

   if !cAlmacen( aGet[ 38 ], dbfAlm )
      Return nil
   end





   if ( nMode == 1 ) .AND. RetFld( aTmp[ 4 ], dbfArticulo, "lNumSer" ) .AND. !( dbfTmpSer )->( dbSeek( Str( aTmp[ 34 ], 4 ) + aTmp[ 4 ] ) )
      MsgStop( "Tiene que introducir números de serie para este artículo." )
      oBtnSer:Click()
      Return nil
   end





   if nMode == 5

      ( dbfTmpLin )->( dbGoTop() )
      while !( dbfTmpLin )->( eof() )

         if ( dbfTmpLin )->lSel
            aEval( aTmp, {| cFld, n | if( !Empty( aTmp[ n ] ), ( dbfTmpLin )->( FieldPut( n, aTmp[ n ] ) ), ) } )
         end

         ( dbfTmpLin )->( dbSkip() )

      end

      ( dbfTmpLin )->( dbGoTo( nRec ) )

      oBrw:Refresh()

      oDlg:end( 1 )

      Return nil

   end





   if !lMoreIva( aTmp[11] )
      return nil
   end

   if !Empty( aTmp[ 4 ] ) .AND. aTmp[ 50 ]

      nTotUnd     := nTotNFacRec( aTmp ) - nTotNFacRec( dbfTmpLin )

      if nTotUnd <> 0 .AND. nStkAct - nTotUnd < 0

         MsgStop( "No hay stock suficiente." )
         return nil

      end



































   end

   aTmp[ 55 ]  := nPReq( dbfIva, aTmp[ 11 ] )

   if nMode == 1

      aTmp[ 4 ]  := cCodArt

      if aTmp[ 42 ]
         GraLotArt( aTmp[ 4 ], dbfArticulo, aTmp[ 44 ] )
      end





      aXbYStr        := nXbYAtipica( aTmp[ 4 ], aTmpFac[ 6 ], aTmp[ 12 ], aTmp[ 18 ], aTmpFac[ 5 ], dbfClientAtp )

      if aXbYStr[ 1 ] == 0





         if !aTmp[ 73 ]

            aXbyStr              := nXbYOferta( aTmp[ 4 ], aTmpFac[ 6 ], aTmpFac[ 79 ], aTmp[ 12 ], aTmp[ 18 ], aTmpFac[ 5 ], dbfOferta, 1 )

            if aXbYStr[ 1 ] <> 0
               aTmp[ 73 ]  := .T.
            end

         end





         if !aTmp[ 73 ]

            aXbyStr              := nXbYOferta( RetFld( aTmp[ 4 ], dbfArticulo, "FAMILIA", "CODIGO" ), aTmpFac[ 6 ], aTmpFac[ 79 ], aTmp[ 12 ], aTmp[ 18 ], aTmpFac[ 5 ], dbfOferta, 2 )

            if aXbYStr[ 1 ] <> 0
               aTmp[ 73 ]  := .T.
            end

         end





         if !aTmp[ 73 ]

            aXbyStr              := nXbYOferta( RetFld( aTmp[ 4 ], dbfArticulo, "CCODTIP", "CODIGO" ), aTmpFac[ 6 ], aTmpFac[ 79 ], aTmp[ 12 ], aTmp[ 18 ], aTmpFac[ 5 ], dbfOferta, 3 )

            if aXbYStr[ 1 ] <> 0
               aTmp[ 73 ]  := .T.
            end

         end





         if !aTmp[ 73 ]

            aXbyStr              := nXbYOferta( RetFld( aTmp[ 4 ], dbfArticulo, "CCODCATE", "CODIGO" ), aTmpFac[ 6 ], aTmpFac[ 79 ], aTmp[ 12 ], aTmp[ 18 ], aTmpFac[ 5 ], dbfOferta, 4 )

            if aXbYStr[ 1 ] <> 0
               aTmp[ 73 ]  := .T.
            end

         end





         if !aTmp[ 73 ]

            aXbyStr              := nXbYOferta( RetFld( aTmp[ 4 ], dbfArticulo, "CCODTEMP", "CODIGO" ), aTmpFac[ 6 ], aTmpFac[ 79 ], aTmp[ 12 ], aTmp[ 18 ], aTmpFac[ 5 ], dbfOferta, 5 )

            if aXbYStr[ 1 ] <> 0
               aTmp[ 73 ]  := .T.
            end

         end





         if !aTmp[ 73 ]

            aXbyStr              := nXbYOferta( RetFld( aTmp[ 4 ], dbfArticulo, "CCODFAB", "CODIGO" ), aTmpFac[ 6 ], aTmpFac[ 79 ], aTmp[ 12 ], aTmp[ 18 ], aTmpFac[ 5 ], dbfOferta, 6 )

            if aXbYStr[ 1 ] <> 0
               aTmp[ 73 ]  := .T.
            end

         end

      end





      if aXbYStr[ 1 ] <> 0 .AND. aXbYStr[ 2 ] <> 0





         if aXbYStr[ 1 ] == 1





            aTmp[ 12  ] -= aXbYStr[ 2 ]
            aClo              := aClone( aTmp )

            WinGather( aTmp, , dbfTmpLin, oBrw, nMode, nil, .F. )





            AppKit( aClo, aTmpFac, dbfTmpLin, dbfArticulo, dbfKit )





            aTmp[ 12  ] := aXbYStr[ 2 ]
            aTmp[ 6 ] := 0
            aClo              := aClone( aTmp )

            WinGather( aTmp, aGet, dbfTmpLin, oBrw, nMode )





            AppKit( aClo, aTmpFac, dbfTmpLin, dbfArticulo, dbfKit )

         else





            aTmp[ 18 ] -= aXbYStr[ 2 ]
            aClo              := aClone( aTmp )

            WinGather( aTmp, , dbfTmpLin, oBrw, nMode, nil, .F. )





            AppKit( aClo, aTmpFac, dbfTmpLin, dbfArticulo, dbfKit )





            aTmp[ 18 ] := aXbYStr[ 2 ]
            aTmp[ 6 ] := 0
            aClo              := aClone( aTmp )

            WinGather( aTmp, aGet, dbfTmpLin, oBrw, nMode )





            AppKit( aClo, aTmpFac, dbfTmpLin, dbfArticulo, dbfKit )

         end

      else





         WinGather( aTmp, aGet, dbfTmpLin, oBrw, nMode )





         AppKit( aClo, aTmpFac, dbfTmpLin, dbfArticulo, dbfKit )

      end



   else























      WinGather( aTmp, aGet, dbfTmpLin, oBrw, nMode )

   end





   bmpImage:Hide()

   if !Empty( bmpImage:hBitmap )
      PalBmpFree( bmpImage:hBitmap, bmpImage:hPalette )
   endif

   cOldCodArt     := ""
   cOldUndMed     := ""

   if !Empty( aGet[ 16 ] )
      aGet[ 16 ]:lValid()
   end

   if nMode == 1 .AND. lEntCon()

      RecalculaTotal( aTmpFac )

      SetDlgMode( aTmp, aGet, oGet2, oSayPr1, oSayPr2, oSayVp1, oSayVp2, oStkAct, nMode, oTotal, aTmpFac )

      SysRefresh()

      if !Empty( aGet[ 4 ] )
         aGet[ 4 ]:SetFocus()
      end

      if !Empty( aGet[ 74 ] )
         aGet[ 74 ]:Refresh()
      end

   else

      oDlg:end( 1 )

   end

RETURN NIL



Static Function EdtInc( aTmp, aGet, dbfFacRecI, oBrw, bWhen, bValid, nMode, aTmpFac )

   local oDlg
   local oNomInci
   local cNomInci

   if !Empty( aTmp[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ] )
      cNomInci := cNomInci( aTmp[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ], dbfInci )
   end

   if nMode == 1
      aTmp[ 1   ] := aTmpFac[ 1  ]
      aTmp[ 2  ] := aTmpFac[ 2 ]
      aTmp[ 3  ] := aTmpFac[ 3 ]
      if "MUEBLES" $ cParamsMain()
         aTmp[ ( dbfTmpInc )->( FieldPos( "lAviso" ) ) ]  := .T.
      end
   end

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "incidencias de facturas rectificativas", "INCIDENCIA",, .F.,,,,,, .F.,,,,,, .F., )








      aGet[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ]:= u ) }, oDlg,,, {||    ( cTipInci( aGet[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ], dbfInci, oNomInci ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwIncidencia( dbfInci, aGet[ ( dbfTmpInc )->( FieldPos( "cCodTip" ) ) ], oNomInci ) )}, nil, "LUPA",, )




      oNomInci := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, cNomInci, cNomInci:= u ) }, oDlg,,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )





      TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "dFecInc" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "dFecInc" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





      TMultiGet():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "mDesInc" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "mDesInc" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||     ( nMode <> 3 )}, .F.,, )




      TCheckBox():ReDefine( 140, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "lListo" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "lListo" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||         ( nMode <> 3 )}, .F. )




      TCheckBox():ReDefine( 150, { | u | If( PCount()==0, aTmp[ ( dbfTmpInc )->( FieldPos( "lAviso" ) ) ], aTmp[ ( dbfTmpInc )->( FieldPos( "lAviso" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||         ( nMode <> 3 )}, .F. )





      TButton():ReDefine( 1, {||( WinGather( aTmp, nil, dbfTmpInc, oBrw, nMode ), oDlg:end( 1 ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

      if nMode <> 3
         oDlg:AddFastKey( 116, {|| WinGather( aTmp, nil, dbfTmpInc, oBrw, nMode ), oDlg:end( 1 ) } )
      end

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

Return ( oDlg:nResult == 1 )



Static Function EdtDoc( aTmp, aGet, dbfFacRecD, oBrw, bWhen, bValid, nMode, aTmpLin )

   local oDlg
   local oRuta
   local oNombre
   local oObservacion

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "documento de pedidos a proveedor", "DOCUMENTOS",, .F.,,,,,, .F.,,,,,, .F., )




      oNombre := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ ( dbfTmpDoc )->( FieldPos( "cNombre" ) ) ], aTmp[ ( dbfTmpDoc )->( FieldPos( "cNombre" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      oRuta := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfTmpDoc )->( FieldPos( "cRuta" ) ) ], aTmp[ ( dbfTmpDoc )->( FieldPos( "cRuta" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oRuta:cText( cGetFile( "Doc ( *.* ) | " + "*.*", "Seleccione el nombre del fichero" ) ) )}, nil, "FOLDER",, )





      oObservacion := TMultiGet():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( dbfTmpDoc )->( FieldPos( "mObsDoc" ) ) ], aTmp[ ( dbfTmpDoc )->( FieldPos( "mObsDoc" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||     ( nMode <> 3 )}, .F.,, )





      TButton():ReDefine( 1, {||( WinGather( aTmp, nil, dbfTmpDoc, oBrw, nMode ), oDlg:end( 1 ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| WinGather( aTmp, nil, dbfTmpDoc, oBrw, nMode ), oDlg:end( 1 ) } )
   end

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

Return ( oDlg:nResult == 1 )



STATIC FUNCTION AppKit( aClo, aTmpFac, dbfTmpLin, dbfArticulo, dbfKit )

   local nRec        := ( dbfTmpLin )->( RecNo() )
   local nNumLin     := ( dbfTmpLin )->nNumLin
   local nUnidades   := 0
   local nStkActual  := 0

   if aClo[ 46 ] .AND. ( dbfKit )->( dbSeek( aClo[ 4 ] ) )

      while ( dbfKit )->cCodKit == aClo[ 4 ] .AND. !( dbfKit )->( eof() )

         if ( dbfArticulo )->( dbSeek( ( dbfKit )->cRefKit ) )

            ( dbfTmpLin )->( dbAppend() )

            if lKitAsociado( aClo[ 4 ], dbfArticulo )
               ( dbfTmpLin )->nNumLin  := nLastNum( dbfTmpLin )
               ( dbfTmpLin )->lKitChl  := .F.
            else
               ( dbfTmpLin )->nNumLin  := nNumLin
               ( dbfTmpLin )->lKitChl  := .T.
            end

            ( dbfTmpLin )->cRef        := ( dbfKit      )->cRefKit
            ( dbfTmpLin )->nPreUnit    := ( dbfKit      )->nPreKit
            ( dbfTmpLin )->cDetalle    := ( dbfArticulo )->Nombre
            ( dbfTmpLin )->nPntVer     := ( dbfArticulo )->nPntVer1
            ( dbfTmpLin )->nPesokg     := ( dbfArticulo )->nPesoKg
            ( dbfTmpLin )->cPesokg     := ( dbfArticulo )->cUndDim
            ( dbfTmpLin )->cUnidad     := ( dbfArticulo )->cUnidad
            ( dbfTmpLin )->nCtlStk     := ( dbfArticulo )->nCtlStock
            ( dbfTmpLin )->cCodImp     := ( dbfArticulo )->cCodImp
            ( dbfTmpLin )->lLote       := ( dbfarticulo )->lLote
            ( dbfTmpLin )->nLote       := ( dbfarticulo )->nLote
            ( dbfTmpLin )->cLote       := ( dbfarticulo )->cLote
            ( dbfTmpLin )->nPvpRec     := ( dbfArticulo )->PvpRec

            ( dbfTmpLin )->nCosDiv     := nCosto( nil, dbfArticulo, dbfKit )
            ( dbfTmpLin )->nValImp     := oNewImp:nValImp( ( dbfArticulo )->cCodImp )

            if ( dbfArticulo )->lFacCnv
               ( dbfTmpLin )->nFacCnv  := ( dbfArticulo )->nFacCnv
            end

            ( dbfTmpLin )->cSerie      := aClo[ 1  ]
            ( dbfTmpLin )->nNumFac     := aClo[ 2 ]
            ( dbfTmpLin )->cSufFac     := aClo[ 3 ]
            ( dbfTmpLin )->nCanEnt     := aClo[ 12 ]
            ( dbfTmpLin )->dFecha      := aClo[ 20  ]
            ( dbfTmpLin )->cTipMov     := aClo[ 21 ]
            ( dbfTmpLin )->nNumLin     := aClo[ 34 ]
            ( dbfTmpLin )->cAlmLin     := aClo[ 38 ]
            ( dbfTmpLin )->lIvaLin     := aClo[ 39 ]
            ( dbfTmpLin )->nComAge     := aClo[ 17 ]
            ( dbfTmpLin )->nUniCaja    := aClo[ 18] * ( dbfKit )->nUndKit





            if !Empty( aClo[ 11 ] )
               ( dbfTmpLin )->nIva     := nIva( dbfIva, ( dbfArticulo )->TipoIva )
               ( dbfTmpLin )->nReq     := nReq( dbfIva, ( dbfArticulo )->TipoIva )
            else
               ( dbfTmpLin )->nIva     := 0
               ( dbfTmpLin )->nReq     := 0
            end





            ( dbfTmpLin )->lImpLin     := lImprimirComponente( aClo[ 4 ], dbfArticulo )
            ( dbfTmpLin )->lKitPrc     := lPreciosComponentes( aClo[ 4 ], dbfArticulo )

            if ( dbfTmpLin )->lKitPrc
               ( dbfTmpLin )->nPreUnit := nRetPreArt( aClo[ 71 ], aTmpFac[ 58 ], aTmpFac[ 56 ], dbfArticulo, dbfDiv, dbfKit, dbfIva )
            end

            if lStockComponentes( aClo[ 4 ], dbfArticulo )
               ( dbfTmpLin )->nCtlStk  := ( dbfArticulo )->nCtlStock
            else
               ( dbfTmpLin )->nCtlstk  := 3
            end





            if ( dbfKit )->lAplDto
               ( dbfTmpLin )->nDto     := aClo[ 9    ]
               ( dbfTmpLin )->nDtoPrm  := aClo[ 10 ]
               ( dbfTmpLin )->nDtoDiv  := aClo[ 32 ]
            end





            if ( dbfArticulo)->lMsgVta .AND. !uFieldEmpresa( "lNStkAct" )

               nStkActual     := oStock:nStockAlmacen( ( dbfKit )->cRefKit, ( dbfTmpLin )->cAlmLin )
               nUnidades      := aClo[ 18 ] * ( dbfKit )->nUndKit

               do case
                  case nStkActual - nUnidades < 0



                        MsgStop( "No hay stock suficiente para realizar la venta" + Chr(13)+Chr(10) +  "del componente " + AllTrim( ( dbfKit )->cRefKit ) + " - " + AllTrim( ( dbfArticulo )->Nombre ), "¡Atención!" )

                  case nStkActual - nUnidades < ( dbfArticulo)->nMinimo






                        MsgStop( "El stock del componente " + AllTrim( ( dbfKit )->cRefKit ) + " - " + AllTrim( ( dbfArticulo )->Nombre ) + Chr(13)+Chr(10) +  "está bajo minimo." + Chr(13)+Chr(10) +  "Unidades a vender : " + AllTrim( Trans( nUnidades, MasUnd() ) ) + Chr(13)+Chr(10) +  "Stock minimo : " + AllTrim( Trans( ( dbfArticulo)->nMinimo, MasUnd() ) ) + Chr(13)+Chr(10) +  "Stock actual : " + AllTrim( Trans( nStkActual, MasUnd() ) ), "¡Atención!" )
               end

            end

         end

         ( dbfKit )->( dbSkip() )

      end

      ( dbfTmpLin )->( dbGoTo( nRec ) )

   end

RETURN NIL







STATIC FUNCTION AppDeta( oBrwDet, bEdtDet, aTmp, lTot, cCodArt )

   IIF( lTot == nil, lTot := .F., ) ;

   if ( Empty( aNumAlb ) ) .OR. lTot

      WinAppRec( oBrwDet, bEdtDet, dbfTmpLin, lTot, cCodArt, aTmp )

   else


      MsgStop( "No se pueden añadir registros a una factura que" + Chr(13)+Chr(10) +  "proviene de albaranes." )

   end

RETURN RecalculaTotal( aTmp )






STATIC FUNCTION EdtDeta( oBrwDet, bEdtDet, aTmp, lTot, nFacMod )






   if ( dbfTmpLin )->lSel
      WinMulRec( oBrwDet, bEdtDet, dbfTmpLin, lTot, nFacMod, aTmp )
   else
      WinEdtRec( oBrwDet, bEdtDet, dbfTmpLin, lTot, nFacMod, aTmp )
   end










RETURN RecalculaTotal( aTmp )






STATIC FUNCTION DelDeta()

   CursorWait()

   while ( dbfTmpSer )->( dbSeek( Str( ( dbfTmpLin )->nNumLin, 4 ) ) )
      ( dbfTmpSer )->( dbDelete() )
   end

   if ( dbfTmpLin )->lKitArt
      dbDelKit( , dbfTmpLin, ( dbfTmpLin )->nNumLin )
   end

   CursorWE()

RETURN ( .T. )



STATIC FUNCTION PrnSerie()

    local oDlg
   local oFmtDoc
   local cFmtDoc     := cFormatoDocumento( ( dbfFacRecT )->cSerie, "nFacRec", dbfCount )
   local oSayFmt
   local cSayFmt
   local oSerIni
   local oSerFin
   local nRecno      := ( dbfFacRecT )->( Recno() )
   local nOrdAnt     := ( dbfFacRecT )->( OrdSetFocus( 1 ) )
   local cSerIni     := ( dbfFacRecT )->cSerie
   local cSerFin     := ( dbfFacRecT )->cSerie
   local nDocIni     := ( dbfFacRecT )->nNumFac
   local nDocFin     := ( dbfFacRecT )->nNumFac
   local cSufIni     := ( dbfFacRecT )->cSufFac
   local cSufFin     := ( dbfFacRecT )->cSufFac
   local oPrinter
   local cPrinter    := PrnGetName()
   local lCopiasPre  := .T.
   local lInvOrden   := .F.
   local oNumCop
   local nNumCop     := if( nCopiasDocumento( ( dbfFacRecT )->cSerie, "nFacRec", dbfCount ) == 0, Max( Retfld( ( dbfFacRecT )->cCodCli, dbfClient, "CopiasF" ), 1 ), nCopiasDocumento( ( dbfFacRecT )->cSerie, "nFacRec", dbfCount ) )

   if Empty( cFmtDoc )
      cFmtDoc           := cSelPrimerDoc( "FR" )
   end

   cSayFmt           := cNombreDoc( cFmtDoc )

   oDlg = TDialog():New(,,,, "Imprimir series de facturas rectificativas", "IMPSERDOC",, .F.,,,,,, .F.,,,,,, .F., )









   oSerIni := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, cSerIni, cSerIni:= u ) }, oDlg,, "@!", {||    ( cSerIni >= "A" .AND. cSerIni <= "Z"  )},,,,,, .T.,,, .F., .T., {||    ( UpSerie( oSerIni ) )}, {||  ( DwSerie( oSerIni ) )},,,, nil,,, )









   oSerFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cSerFin, cSerFin:= u ) }, oDlg,, "@!", {||    ( cSerFin >= "A" .AND. cSerFin <= "Z"  )},,,,,, .T.,,, .F., .T., {||    ( UpSerie( oSerFin ) )}, {||  ( DwSerie( oSerFin ) )},,,, nil,,, )





   TGetHlp():ReDefine( 120, { | u | If( PCount()==0, nDocIni, nDocIni:= u ) }, oDlg,, "999999999",,,,,,, .F.,,, .F., .T.,,,,,, nil,,, )





   TGetHlp():ReDefine( 130, { | u | If( PCount()==0, nDocFin, nDocFin:= u ) }, oDlg,, "999999999",,,,,,, .F.,,, .F., .T.,,,,,, nil,,, )




   TGetHlp():ReDefine( 140, { | u | If( PCount()==0, cSufIni, cSufIni:= u ) }, oDlg,, "##",,,,,,, .F.,,, .F., .F.,,,,,, nil,,, )




   TGetHlp():ReDefine( 150, { | u | If( PCount()==0, cSufFin, cSufFin:= u ) }, oDlg,, "##",,,,,,, .F.,,, .F., .F.,,,,,, nil,,, )



   TCheckBox():ReDefine( 500, { | u | If( PCount()==0, lInvOrden, lInvOrden:= u ) }, oDlg,,,,,,, .F.,, .F. )



   TCheckBox():ReDefine( 170, { | u | If( PCount()==0, lCopiasPre, lCopiasPre:= u ) }, oDlg,,,,,,, .F.,, .F. )









   oNumCop := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, nNumCop, nNumCop:= u ) }, oDlg,, "999999999", {||    nNumCop > 0},,,,,, .F., {||     !lCopiasPre},, .F., .T.,,, {||      1}, {||      99999},, nil,,, )







   oFmtDoc := TGetHlp():ReDefine( 90, { | u | If( PCount()==0, cFmtDoc, cFmtDoc:= u ) }, oDlg,,, {||    ( cDocumento( oFmtDoc, oSayFmt, dbfDoc ) )}, "N/W*",,,,, .F.,,, .F., .F.,,,,, {|Self|( BrwDocumento( oFmtDoc, oSayFmt, "FR" ) )}, nil, "LUPA",, )





   oSayFmt := TGetHlp():ReDefine( 91, { | u | If( PCount()==0, cSayFmt, cSayFmt:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )

   TBtnBmp():ReDefine( 92, "Printer_pencil_16",,,,,{|| EdtDocumento( cFmtDoc ) }, oDlg, .F., , .F.,  )




   oPrinter := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, cPrinter, cPrinter:= u ) }, oDlg,,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )

   TBtnBmp():ReDefine( 161, "Printer_preferences_16",,,,,{|| PrinterPreferences( oPrinter ) }, oDlg, .F., , .F.,  )





   TButton():ReDefine( 1, {||(  StartPrint( SubStr( cFmtDoc, 1, 3 ), cSerIni + Str( nDocIni, 9 ) + cSufIni, cSerFin + Str( nDocFin, 9 ) + cSufFin, oDlg, cPrinter, lCopiasPre, nNumCop, lInvOrden ), oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )





   TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   oDlg:bStart := { || oSerIni:SetFocus() }

   oDlg:AddFastKey( 116, {|| StartPrint( SubStr( cFmtDoc, 1, 3 ), cSerIni + Str( nDocIni, 9 ) + cSufIni, cSerFin + Str( nDocFin, 9 ) + cSufFin, oDlg, cPrinter, lCopiasPre, nNumCop, lInvOrden ), oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   (dbfFacRecT)->( dbGoTo( nRecNo ) )
   (dbfFacRecT)->( ordSetFocus( nOrdAnt ) )

    oWndBrw:oBrw:refresh()

RETURN NIL



STATIC FUNCTION StartPrint( cFmtDoc, cDocIni, cDocFin, oDlg, cPrinter, lCopiasPre, nNumCop, lInvOrden )

   local nCopyClient

   oDlg:disable()

   if !lInvOrden

      ( dbfFacRecT )->( dbSeek( cDocIni, .T. ) )


      while ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + (dbfFacRecT)->cSufFac >= cDocIni .AND.  ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + (dbfFacRecT)->cSufFac <= cDocFin

            lChgImpDoc( dbfFacRecT )

         if lCopiasPre

            nCopyClient := if( nCopiasDocumento( ( dbfFacRecT )->cSerie, "nFacRec", dbfCount ) == 0, Max( Retfld( ( dbfFacRecT )->cCodCli, dbfClient, "CopiasF" ), 1 ), nCopiasDocumento( ( dbfFacRecT )->cSerie, "nFacRec", dbfCount ) )

            GenFacRec( 1, "Imprimiendo documento : " + ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, cFmtDoc, cPrinter, nCopyClient )

         else

            GenFacRec( 1, "Imprimiendo documento : " + ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, cFmtDoc, cPrinter, nNumCop )

         end

      ( dbfFacRecT )->( dbSkip() )

      end

   else

      ( dbfFacRecT )->( dbSeek( cDocFin ) )



      while ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac >= cDocIni .AND. ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac <= cDocFin .AND. !( dbfFacRecT )->( Bof() )

            lChgImpDoc( dbfFacRecT )

         if lCopiasPre

            nCopyClient := if( nCopiasDocumento( ( dbfFacRecT )->cSerie, "nFacRec", dbfCount ) == 0, Max( Retfld( ( dbfFacRecT )->cCodCli, dbfClient, "CopiasF" ), 1 ), nCopiasDocumento( ( dbfFacRecT )->cSerie, "nFacRec", dbfCount ) )

            GenFacRec( 1, "Imprimiendo documento : " + ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, cFmtDoc, cPrinter, nCopyClient )

         else

            GenFacRec( 1, "Imprimiendo documento : " + ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, cFmtDoc, cPrinter, nNumCop )

         end

      ( dbfFacRecT )->( dbSkip( -1 ) )

      end

   end

   oDlg:enable()

RETURN NIL







STATIC FUNCTION lCalcDeta( aTmp, aTmpFac, lTotal )

   local nBase
   local nCosto
   local nMargen
   local nCalculo
   local nUnidades
   local nRentabilidad

   IIF( lTotal == nil, lTotal := .F., ) ;

   nCalculo       := aTmp[ 6 ]
   nCalculo       -= aTmp[ 32  ]

   nUnidades      := nTotNFacRec( aTmp )





   if !aTmp[ 39 ]
      if aTmp[ 74 ]
         nCalculo += aTmp[ 41 ] * NotCero( aTmp[ 65 ] )
      else
         nCalculo += aTmp[ 41 ]
      end
   end

   nCalculo       *= nUnidades





   if aTmp[ 8 ] <> 0
      nCalculo    += nUnidades * aTmp[ 8 ]
   end





   if aTmp[ 9    ] <> 0
      nCalculo    -= nCalculo * aTmp[ 9    ] / 100
   end

   if aTmp[ 10 ] <> 0
      nCalculo    -= nCalculo * aTmp[ 10 ] / 100
   end





   nCosto            := nUnidades * aTmp[ 36 ]

   if aTmp[ 39 ] .AND. aTmp[ 11 ] <> 0
      nBase          := nCalculo - Round( nCalculo / ( 100 / aTmp[ 11 ] + 1 ), nRouDiv )
   else
      nBase          := nCalculo
   end

   nMargen           := nBase - nCosto

   if nCalculo == 0
      nRentabilidad  := 0
   else
      nRentabilidad  := nRentabilidad( nCalculo, 0, nCosto )
   end





   if aTmpFac[ 97 ]
      nCalculo       += nUnidades * aTmp[ 7 ]
   end





   if !Empty( oTotalLinea )
      oTotalLinea:cText( nCalculo )
   end

   if !Empty( oRentabilidadLinea )
      oRentabilidadLinea:cText( AllTrim( Trans( nMargen, cPorDiv ) + AllTrim( cSimDiv( cCodDiv, dbfDiv ) ) + " : " + AllTrim( Trans( nRentabilidad, "999.99" ) ) + "%" ) )
   end

   if !Empty( oComisionLinea )
      oComisionLinea:cText( Round( ( nBase * aTmp[ 17 ] / 100 ), nRouDiv ) )
   end

RETURN ( if( !lTotal, .T., nCalculo ) )



FUNCTION nIvaLFacRec( dbfFacT, dbfLin, nDec, nRouDec, nVdv, lDto, lPntVer, lImpTrn, cPouDiv )

   local nCalculo := nImpLFacRec( dbfFacT, dbfLin, nDec, nRouDec, nVdv )


      nCalculo    := nCalculo * ( dbfLin )->nIva / 100




RETURN ( if( cPouDiv <> NIL, Trans( nCalculo, cPouDiv ), nCalculo ) )






FUNCTION nIncLFacRec( dbfLin, nDec, nRouDec, nVdv, lDto, lPntVer, lImpTrn, cPorDiv )

   local nCalculo := nTotLFacRec( dbfLin, nDec, nRouDec, nVdv, lDto, lPntVer, lImpTrn )

   if !( dbfLin )->lIvaLin
      nCalculo    += nCalculo * ( dbfLin )->nIva / 100
   end

RETURN ( if( cPorDiv <> NIL, Trans( nCalculo, cPorDiv ), nCalculo ) )







FUNCTION nPntUFacRec( cFacRecL, nDec, nVdv )

   local nCalculo

   IIF( cFacRecL == nil, cFacRecL := dbfFacRecL, ) ;
   IIF( nDec == nil, nDec := nDouDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo          := ( cFacRecL )->nPntVer

   if nVdv <> 0
      nCalculo       := nCalculo / nVdv
   end

RETURN ( Round( nCalculo, nDec ) )






FUNCTION nPntLFacRec( cFacRecL, nDec, nVdv )

   local nPntVer

   IIF( cFacRecL == nil, cFacRecL := dbfFacRecL, ) ;
   IIF( nDec == nil, nDec := nDouDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;





   nPntVer           := nPntUFacRec( cFacRecL, nDec, nVdv ) * nTotNFacRec( cFacRecL )

RETURN ( Round( nPntVer, nDec ) )



FUNCTION nTrnUFacRec( dbfTmpLin, nDec, nVdv )

    local nCalculo

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo       := ( dbfTmpLin )->nImpTrn

    IF nVdv <> 0
      nCalculo    := nCalculo / nVdv
    end

RETURN ( Round( nCalculo, nDec ) )



FUNCTION nTrnLFacRec( dbfLin, nDec, nRou, nVdv )

   local nImpTrn

   IIF( dbfLin == nil, dbfLin := dbfFacRecL, ) ;
   IIF( nDec == nil, nDec := 2, ) ;
   IIF( nRou == nil, nRou := 2, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;





   nImpTrn           := nTrnUFacRec( dbfLin, nDec ) * nTotNFacRec( dbfLin )

   IF nVdv <> 0
      nImpTrn        := nImpTrn / nVdv
    end

RETURN ( Round( nImpTrn, nRou ) )



FUNCTION nComLFacRec( dbfFacRecT, dbfFacRecL, nDecOut, nDerOut )

   local nImpLFacRec  := nImpLFacRec( dbfFacRecT, dbfFacRecL, nDecOut, nDerOut, , .F., .T., .F., .F. )

RETURN ( nImpLFacRec * ( dbfFacRecL )->nComAge / 100 )



FUNCTION aTotFacRec( cFactura, dbfFacRecT, dbfFacRecL, dbfIva, dbfDiv, cDivRet )

   nTotFacRec( cFactura, dbfFacRecT, dbfFacRecL, dbfIva, dbfDiv, nil, cDivRet )

RETURN ( { nTotNet, nTotIva, nTotReq, nTotFac, nTotPnt, nTotTrn, nTotAge, aTotIva, nTotCos, nTotIvm, nTotRnt, nTotRet } )







FUNCTION nNetFacRec( cFactura, dbfFact, dbfLine, dbfIva, dbfDiv )

   nTotFacRec( cFactura, dbfFact, dbfLine, dbfIva, dbfDiv )

RETURN nTotNet



FUNCTION nCosLFacRec( dbfLine, nDec, nRec, nVdv, cPouDiv )

   local nCalculo       := 0

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nRec == nil, nRec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   if !( dbfLine )->lKitChl
      nCalculo          := nTotNFacRec( dbfLine )
      nCalculo          *= ( dbfLine )->nCosDiv
   end

   if nVdv <> 0
      nCalculo          := nCalculo / nVdv
   end

   nCalculo             := Round( nCalculo, nRec )

RETURN ( if( cPouDiv <> nil, Trans( nCalculo, cPouDiv ), nCalculo ) )







FUNCTION nTotFacRec( cFactura, cFacRecT, cFacRecL, cIva, cDiv, aTmp, cDivRet, lPic, lExcCnt )

   local nRec
   local bCondition
    local lRecargo
    local nDtoUno
    local nDtoDos
    local nDtoEsp
   local nPctRet
   local nDtoPP
   local nPorte
   local nIvaMan
   local nManObr
   local lIvaInc
   local nKgsTrn
   local nTotArt           := 0
   local nTotLin           := 0
   local nTotUnd           := 0
   local aTotalDto         := { 0, 0, 0 }
   local aTotalDPP         := { 0, 0, 0 }
   local aTotalUno         := { 0, 0, 0 }
   local aTotalDos         := { 0, 0, 0 }
   local nDescuentosLineas := 0
   local lPntVer           := .F.

   IIF( cFacRecT == nil, cFacRecT := dbfFacRecT, ) ;
   IIF( cFacRecL == nil, cFacRecL := dbfFacRecL, ) ;
   IIF( cIva == nil, cIva := cIva, ) ;
   IIF( cDiv == nil, cDiv := cDiv, ) ;
   IIF( cFactura == nil, cFactura := ( cFacRecT )->cSerie + Str( ( cFacRecT )->nNumFac ) + ( cFacRecT )->cSufFac, ) ;
   IIF( lPic == nil, lPic := .F., ) ;

   public nTotFac          := 0
   public nTotBrt          := 0
   public nTotDto          := 0
   public nTotDPP          := 0
   public nTotNet          := 0
   public nTotIva          := 0
   public nTotIvm          := 0
   public nTotAge          := 0
   public nTotReq          := 0
   public nTotPnt          := 0
   public nTotUno          := 0
   public nTotDos          := 0
   public nTotRet          := 0
   public nTotTrn          := 0
   public nTotAnt          := 0
   public nTotCos          := 0
   public nTotPes          := 0
   public nTotRnt          := 0
   public nPctRnt          := 0
   public nTotDif          := 0
   public cCtaCli          := cClientCuenta( ( cFacRecT )->cCodCli )

   public aTotIva          := { { 0,0,nil,0,0,0,0,0,0 }, { 0,0,nil,0,0,0,0,0,0 }, { 0,0,nil,0,0,0,0,0,0 } }
   public aIvaUno          := aTotIva[ 1 ]
   public aIvaDos          := aTotIva[ 2 ]
   public aIvaTre          := aTotIva[ 3 ]

   public aTotIvm          := { { 0,0,0 }, { 0,0,0 }, { 0,0,0 }, }
   public aIvmUno          := aTotIvm[ 1 ]
   public aIvmDos          := aTotIvm[ 2 ]
   public aIvmTre          := aTotIvm[ 3 ]

   public aImpVto          := {}
   public aDatVto          := {}

   public nNumArt          := 0
   public nNumCaj          := 0

   public nTotalDto        := 0

   nRec                    := ( cFacRecL )->( Recno() )

   if aTmp <> nil
      nDtoUno              := aTmp[ 44 ]
      nDtoDos              := aTmp[ 46 ]
      lRecargo             := aTmp[ 54]
      nDtoEsp              := aTmp[ 40 ]
      nDtoPP               := aTmp[ 42    ]
      nPorte               := aTmp[ 34 ]
      nIvaMan              := aTmp[ 35 ]
      nManObr              := aTmp[ 36 ]
      lIvaInc              := aTmp[ 56 ]
      cCodDiv              := aTmp[ 58 ]
      nPctRet              := aTmp[ 75 ]
      nKgsTrn              := aTmp[ 71 ]
      lPntVer              := aTmp[ 97 ]
      bCondition           := {|| ( cFacRecL )->( !eof() ) }
      ( cFacRecL )->( dbGoTop() )
   else
      nDtoUno              := ( cFacRecT )->nDtoUno
      nDtoDos              := ( cFacRecT )->nDtoDos
      nDtoEsp              := ( cFacRecT )->nDtoEsp
      nDtoPP               := ( cFacRecT )->nDpp
      lRecargo             := ( cFacRecT )->lRecargo
      nPorte               := ( cFacRecT )->nPorTes
      nIvaMan              := ( cFacRecT )->nIvaMan
      nManObr              := ( cFacRecT )->nManObr
      lIvaInc              := ( cFacRecT )->lIvaInc
      cCodDiv              := ( cFacRecT )->cDivFac
      nPctRet              := ( cFacRecT )->nPctRet
      nKgsTrn              := ( cFacRecT )->nKgsTrn
      lPntVer              := ( cFacRecT )->lOperPV
      bCondition           := {|| ( cFacRecL )->cSerie + Str( ( cFacRecL )->nNumFac ) + ( cFacRecL )->cSufFac == cFactura .AND. !( cFacRecL)->( eof() ) }
      ( cFacRecL )->( dbSeek( cFactura ) )
   end





   cPouDiv                 := cPouDiv( cCodDiv, cDiv )
   cPorDiv                 := cPorDiv( cCodDiv, cDiv )
   cPpvDiv                 := cPpvDiv( cCodDiv, cDiv )
   nDouDiv                 := nDouDiv( cCodDiv, cDiv )
   nRouDiv                 := nRouDiv( cCodDiv, cDiv )
   nDpvDiv                 := nDpvDiv( cCodDiv, cDiv )

   while Eval( bCondition )

      if lValLine( cFacRecL )



         if ( lExcCnt == nil                             .OR. ( lExcCnt .AND. ( cFacRecL )->nCtlStk <> 2 )  .OR. ( !lExcCnt .AND. ( cFacRecL )->nCtlStk == 2 ) )

            if ( cFacRecL )->lTotLin





               if ( cFacRecL )->nPreUnit <> nTotLin .OR. ( cFacRecL )->nUniCaja <> nTotUnd

                  if ( cFacRecL )->( dbRLock() )
                     ( cFacRecL )->nPreUnit := nTotLin
                     ( cFacRecL )->nUniCaja := nTotUnd
                     ( cFacRecL )->( dbUnLock() )
                  end

               end





               nTotLin           := 0
               nTotUnd           := 0

            else

               nTotArt           := nTotLFacRec( cFacRecL, nDouDiv, nRouDiv, , , .F., .F. )
               nTotTrn           := nTrnLFacRec( cFacRecL, nDouDiv )
               nTotIvm           := nTotIFacRec( cFacRecL, nDouDiv, nRouDiv )
               nTotPnt           := if( lPntVer, nPntLFacRec( cFacRecL, nDpvDiv ), 0 )
               nTotCos           += nCosLFacRec( cFacRecL, nDouDiv, nRouDiv )
               nTotPes           += nPesLFacRec( cFacRecL )
               nDescuentosLineas += nTotDtoLFacRec( cFacRecL, nDouDiv )

               if aTmp <> nil
                  nTotAge        += nComLFacRec( aTmp, cFacRecL, nDouDiv, nRouDiv )
               else
                  nTotAge        += nComLFacRec( cFacRecT, cFacRecL, nDouDiv, nRouDiv )
               end





               nTotLin           += nTotArt

               nNumArt           += nTotNFacRec( cFacRecL )
               nNumCaj           += ( cFacRecL )->nCanEnt





               do case
               case aTotIva[ 1, 3 ] == nil .OR. aTotIva[ 1, 3 ] == ( cFacRecL )->nIva
                  aTotIva[ 1, 3 ]      := ( cFacRecL )->nIva
                  aTotIva[ 1, 4 ]      := ( cFacRecL )->nReq
                  aTotIva[ 1, 1 ]      += nTotArt
                  aTotIva[ 1, 6 ]      += nTotIvm
                  aTotIva[ 1, 7 ]      += nTotTrn
                  aTotIva[ 1, 5 ]      += nTotPnt

               case aTotIva[ 2, 3 ] == nil .OR. aTotIva[ 2, 3 ] == ( cFacRecL )->nIva
                  aTotIva[ 2, 3 ]      := ( cFacRecL )->nIva
                  aTotIva[ 2, 4 ]      := ( cFacRecL )->nReq
                  aTotIva[ 2, 1 ]      += nTotArt
                  aTotIva[ 3, 6 ]      += nTotIvm
                  aTotIva[ 3, 7 ]      += nTotTrn
                  aTotIva[ 2, 5 ]      += nTotPnt

               case aTotIva[ 3, 3 ] == nil .OR. aTotIva[ 3, 3 ] == ( cFacRecL )->nIva
                  aTotIva[ 3, 3 ]      := ( cFacRecL )->nIva
                  aTotIva[ 3, 4 ]      := ( cFacRecL )->nReq
                  aTotIva[ 3, 1 ]      += nTotArt
                  aTotIva[ 3, 6 ]      += nTotIvm
                  aTotIva[ 3, 7 ]      += nTotTrn
                  aTotIva[ 3, 5 ]      += nTotPnt

               end



                if ( cFacRecL )->nValImp <> 0

                  do case
                     case aTotIvm[ 1, 2 ] == 0 .OR. aTotIvm[ 1, 2 ] == ( cFacRecL )->nValImp
                        aTotIvm[ 1, 1 ]      += nTotNFacRec ( cFacRecL ) * if( ( cFacRecL )->lVolImp, NotCero( ( cFacRecL )->nVolumen ), 1 )
                        aTotIvm[ 1, 2 ]      := ( cFacRecL )->nValImp
                        aTotIvm[ 1, 3 ]      := aTotIvm[ 1, 1 ] * aTotIvm[ 1, 2 ]

                     case aTotIvm[ 2, 2 ] == 0 .OR. aTotIvm[ 2, 2 ] == ( cFacRecL )->nValImp
                        aTotIvm[ 2, 1 ]      += nTotNFacRec( cFacRecL ) * if( ( cFacRecL )->lVolImp, NotCero( ( cFacRecL )->nVolumen ), 1 )
                        aTotIvm[ 2, 2 ]      := ( cFacRecL )->nValImp
                        aTotIvm[ 2, 3 ]      := aTotIvm[ 2, 1 ] * aTotIvm[ 2, 2 ]

                     case aTotIvm[ 3, 2 ] == 0 .OR. aTotIvm[ 3, 2 ] == ( cFacRecL )->nValImp
                        aTotIvm[ 3, 1 ]      += nTotNFacRec( cFacRecL ) * if( ( cFacRecL )->lVolImp, NotCero( ( cFacRecL )->nVolumen ), 1 )
                        aTotIvm[ 3, 2 ]      := ( cFacRecL )->nValImp
                        aTotIvm[ 3, 3 ]      := aTotIvm[ 3, 1 ] * aTotIvm[ 3, 2 ]

                  end

                end

            end

         else





            nTotLin  := 0
            nTotUnd  := 0

         end

      end

      ( cFacRecL )->( dbSkip() )

   end

   ( cFacRecL )->( dbGoTo( nRec ) )





   aTotIva           := aSort( aTotIva,,, {|x,y| abs( x[1] ) > abs( y[1] ) } )

   aTotIva[ 1, 2 ]         := Round( aTotIva[ 1, 1 ], nRouDiv )
   aTotIva[ 2, 2 ]         := Round( aTotIva[ 2, 1 ], nRouDiv )
   aTotIva[ 3, 2 ]         := Round( aTotIva[ 3, 1 ], nRouDiv )

   nTotBrt           := aTotIva[ 1, 2 ] + aTotIva[ 2, 2 ] + aTotIva[ 3, 2 ]





   if nDtoEsp  <> 0

      aTotalDto[1]   := Round( aTotIva[ 1, 2 ] * nDtoEsp / 100, nRouDiv )
      aTotalDto[2]   := Round( aTotIva[ 2, 2 ] * nDtoEsp / 100, nRouDiv )
      aTotalDto[3]   := Round( aTotIva[ 3, 2 ] * nDtoEsp / 100, nRouDiv )

      nTotDto        := aTotalDto[1] + aTotalDto[2] + aTotalDto[3]

        aTotIva[ 1, 2 ]        -= aTotalDto[1]
        aTotIva[ 2, 2 ]        -= aTotalDto[2]
        aTotIva[ 3, 2 ]        -= aTotalDto[3]

   end





    IF nDtoPP    <> 0

      aTotalDPP[1]   := Round( aTotIva[ 1, 2 ] * nDtoPP / 100, nRouDiv )
      aTotalDPP[2]   := Round( aTotIva[ 2, 2 ] * nDtoPP / 100, nRouDiv )
      aTotalDPP[3]   := Round( aTotIva[ 3, 2 ] * nDtoPP / 100, nRouDiv )

      nTotDPP        := aTotalDPP[1] + aTotalDPP[2] + aTotalDPP[3]

        aTotIva[ 1, 2 ]        -= aTotalDPP[1]
        aTotIva[ 2, 2 ]        -= aTotalDPP[2]
        aTotIva[ 3, 2 ]        -= aTotalDPP[3]

    end

    IF nDtoUno <> 0

      aTotalUno[1]   := Round( aTotIva[ 1, 2 ] * nDtoUno / 100, nRouDiv )
      aTotalUno[2]   := Round( aTotIva[ 2, 2 ] * nDtoUno / 100, nRouDiv )
      aTotalUno[3]   := Round( aTotIva[ 3, 2 ] * nDtoUno / 100, nRouDiv )

      nTotUno        := aTotalUno[1] + aTotalUno[2] + aTotalUno[3]

        aTotIva[ 1, 2 ]        -= aTotalUno[1]
        aTotIva[ 2, 2 ]        -= aTotalUno[2]
        aTotIva[ 3, 2 ]        -= aTotalUno[3]

    end

    IF nDtoDos <> 0

      aTotalDos[1]   := Round( aTotIva[ 1, 2 ] * nDtoDos / 100, nRouDiv )
      aTotalDos[2]   := Round( aTotIva[ 2, 2 ] * nDtoDos / 100, nRouDiv )
      aTotalDos[3]   := Round( aTotIva[ 3, 2 ] * nDtoDos / 100, nRouDiv )

      nTotDos        := aTotalDos[1] + aTotalDos[2] + aTotalDos[3]

        aTotIva[ 1, 2 ]        -= aTotalDos[1]
        aTotIva[ 2, 2 ]        -= aTotalDos[2]
        aTotIva[ 3, 2 ]        -= aTotalDos[3]

    end





   if nManObr <> 0

      do case
      case aTotIva[ 1, 3 ] == nil .OR. aTotIva[ 1, 3 ] == nIvaMan

         aTotIva[ 1, 3 ]   := nIvaMan
         aTotIva[ 1, 2 ]   += nManObr

      case aTotIva[ 2, 3 ] == nil .OR. aTotIva[ 2, 3 ] == nIvaMan

         aTotIva[ 2, 3 ]   := nIvaMan
         aTotIva[ 2, 2 ]   += nManObr

      case aTotIva[ 3, 3 ] == nil .OR. aTotIva[ 3, 3 ] == nIvaMan

         aTotIva[ 3, 3 ]   := nIvaMan
         aTotIva[ 3, 2 ]   += nManObr

      end

   end





   aTotIva[ 1, 2 ]         += aTotIva[ 1, 7 ]
   aTotIva[ 2, 2 ]         += aTotIva[ 2, 7 ]
   aTotIva[ 3, 2 ]         += aTotIva[ 3, 7 ]





   aTotIva[ 1, 2 ]         += aTotIva[ 1, 5 ]
   aTotIva[ 2, 2 ]         += aTotIva[ 2, 5 ]
   aTotIva[ 3, 2 ]         += aTotIva[ 3, 5 ]





   if uFieldEmpresa( "lIvaImpEsp" )
      aTotIva[ 1, 2 ]      += aTotIva[ 1, 6 ]
      aTotIva[ 2, 2 ]      += aTotIva[ 2, 6 ]
      aTotIva[ 3, 2 ]      += aTotIva[ 3, 6 ]
   end





   if lIvaInc

      if aTotIva[ 1, 3 ] <> 0
         aTotIva[ 1, 8 ]   := if( aTotIva[ 1, 3 ] <> nil, Round( aTotIva[ 1, 2 ] / ( 100 / aTotIva[ 1, 3 ] + 1 ), nRouDiv ), 0 )
      end
      if aTotIva[ 2, 3 ] <> 0
         aTotIva[ 2, 8 ]   := if( aTotIva[ 2, 3 ] <> nil, Round( aTotIva[ 2, 2 ] / ( 100 / aTotIva[ 2, 3 ] + 1 ), nRouDiv ), 0 )
      end
      if aTotIva[ 3, 3 ] <> 0
         aTotIva[ 3, 8 ]   := if( aTotIva[ 3, 3 ] <> nil, Round( aTotIva[ 3, 2 ] / ( 100 / aTotIva[ 3, 3 ] + 1 ), nRouDiv ), 0 )
      end

      if lRecargo
         if aTotIva[ 1, 4 ] <> 0
            aTotIva[ 1, 9 ]   := if( aTotIva[ 1, 3 ] <> NIL, Round( aTotIva[ 1, 2 ] / ( 100 / aTotIva[ 1, 4 ] + 1 ), nRouDiv ), 0 )
         end
         if aTotIva[ 3, 4 ] <> 0
            aTotIva[ 2, 9 ]   := if( aTotIva[ 2, 3 ] <> NIL, Round( aTotIva[ 2, 2 ] / ( 100 / aTotIva[ 2, 4 ] + 1 ), nRouDiv ), 0 )
         end
         if aTotIva[ 3, 4 ] <> 0
            aTotIva[ 3, 9 ]   := if( aTotIva[ 3, 3 ] <> NIL, Round( aTotIva[ 3, 2 ] / ( 100 / aTotIva[ 3, 4 ] + 1 ), nRouDiv ), 0 )
         end
      end

      aTotIva[ 1, 2 ]      -= aTotIva[ 1, 8 ]
      aTotIva[ 2, 2 ]      -= aTotIva[ 2, 8 ]
      aTotIva[ 3, 2 ]      -= aTotIva[ 3, 8 ]

      aTotIva[ 1, 2 ]      -= aTotIva[ 1, 9 ]
      aTotIva[ 2, 2 ]      -= aTotIva[ 2, 9 ]
      aTotIva[ 3, 2 ]      -= aTotIva[ 3, 9 ]

   else

      aTotIva[ 1, 8 ]      := if( aTotIva[ 1, 3 ] <> NIL, Round( aTotIva[ 1, 2 ] * aTotIva[ 1, 3 ] / 100, nRouDiv ), 0 )
      aTotIva[ 2, 8 ]      := if( aTotIva[ 2, 3 ] <> NIL, Round( aTotIva[ 2, 2 ] * aTotIva[ 2, 3 ] / 100, nRouDiv ), 0 )
      aTotIva[ 3, 8 ]      := if( aTotIva[ 3, 3 ] <> NIL, Round( aTotIva[ 3, 2 ] * aTotIva[ 3, 3 ] / 100, nRouDiv ), 0 )





      if lRecargo
         aTotIva[ 1, 9 ]   := if( aTotIva[ 1, 3 ] <> NIL, Round( aTotIva[ 1, 2 ] * aTotIva[ 1, 4 ] / 100, nRouDiv ), 0 )
         aTotIva[ 2, 9 ]   := if( aTotIva[ 2, 3 ] <> NIL, Round( aTotIva[ 2, 2 ] * aTotIva[ 2, 4 ] / 100, nRouDiv ), 0 )
         aTotIva[ 3, 9 ]   := if( aTotIva[ 3, 3 ] <> NIL, Round( aTotIva[ 3, 2 ] * aTotIva[ 3, 4 ] / 100, nRouDiv ), 0 )
      end

   end





   nTotNet           := Round( aTotIva[ 1, 2 ] + aTotIva[ 2, 2 ] + aTotIva[ 3, 2 ], nRouDiv )

   nTotNet           += nPorte





   nTotPnt           := Round( aTotIva[ 1, 5 ] + aTotIva[ 2, 5 ] + aTotIva[ 3, 5 ], nRouDiv )



   nTotIvm           := Round( aTotIvm[ 1, 3 ] + aTotIvm[ 2, 3 ] + aTotIvm[ 3, 3 ], nRouDiv )





   nTotIva           := Round( aTotIva[ 1, 8 ] + aTotIva[ 2, 8 ] + aTotIva[ 3, 8 ], nRouDiv )





   nTotReq           := Round( aTotIva[ 1, 9 ] + aTotIva[ 2, 9 ] + aTotIva[ 3, 9 ], nRouDiv )





   nTotImp           := Round( nTotIva + nTotReq + nTotIvm, nRouDiv )





   nTotRet           := Round( nTotNet * nPctRet / 100, nRouDiv )





   nTotRnt           := Round(         nTotNet - nManObr - nTotAge - nTotPnt - nTotCos, nRouDiv )

   nPctRnt           := nRentabilidad( nTotNet - nManObr - nTotAge - nTotPnt, 0, nTotCos )





   nTotFac           := Round( nTotNet + nTotImp - nTotRet, nRouDiv )





   nTotAge           := Round( nTotAge, nRouDiv )





   if nKgsTrn <> 0
      nTotDif        := nKgsTrn - nTotPes
   else
      nTotDif        := 0
   end





   nTotalDto         := nDescuentosLineas + nTotDto + nTotDpp + nTotUno + nTotDos





   if cDivRet <> nil .AND. cDivRet <> cCodDiv
      nTotNet     := nCnv2Div( nTotNet, cCodDiv, cDivRet, cDiv )
      nTotIva     := nCnv2Div( nTotIva, cCodDiv, cDivRet, cDiv )
      nTotReq     := nCnv2Div( nTotReq, cCodDiv, cDivRet, cDiv )
      nTotFac     := nCnv2Div( nTotFac, cCodDiv, cDivRet, cDiv )
      nTotRet     := nCnv2Div( nTotRet, cCodDiv, cDivRet, cDiv )
      nTotPnt     := nCnv2Div( nTotPnt, cCodDiv, cDivRet, cDiv )
      nTotTrn     := nCnv2Div( nTotTrn, cCodDiv, cDivRet, cDiv )
      nTotAnt     := nCnv2Div( nTotAnt, cCodDiv, cDivRet, cDiv )
      cPorDiv     := cPorDiv( cDivRet, cDiv )
   end

RETURN ( if( lPic, Trans( nTotFac, cPorDiv ), nTotFac ) )



STATIC FUNCTION RecalculaTotal( aTmp )

   local nPagFacCli     := nPagFacRec( nil, dbfFacRecT, dbfTmpLin, dbfTmpPgo, dbfIva, dbfDiv, nil, .T. )
   local nTotFacCli     := nTotFacRec( nil, dbfFacRecT, dbfTmpLin, dbfIva, dbfDiv, aTmp, nil, .F. )





   if oBrwIva <> nil
      oBrwIva:Refresh()
   end

   if oGetAge <> nil
      oGetAge:SetText( Trans( nTotAge, cPorDiv ) )
   end

   if oGetNet <> nil
      oGetNet:SetText( Trans( nTotNet, cPorDiv ) )
   end

   IF oGetIva <> nil
      oGetIva:SetText( Trans( nTotIva, cPorDiv ) )
   end

   IF oGetReq <> nil
      oGetReq:SetText( Trans( nTotReq, cPorDiv ) )
   end

   IF oGetTotal <> nil
      oGetTotal:SetText( Trans( nTotFac, cPorDiv ) )
   end

   IF oGetTotPg <> nil
      oGetTotPg:SetText( Trans( nTotFac, cPorDiv ) )
   end

   IF oGetTotIvm <> nil
      oGetTotIvm:SetText( Trans( nTotIvm, cPorDiv ) )
   end

   IF oGetTotPnt <> nil
      oGetTotPnt:SetText( Trans( nTotPnt, cPorDiv ) )
   end

   IF oGetTrn <> nil
      oGetTrn:SetText( Trans( nTotTrn, cPorDiv ) )
   end





   if oGetPag <> nil
      oGetPag:SetText( Trans( nPagFacCli, cPorDiv ) )
   end

   if oGetPdt <> nil
      oGetPdt:SetText( Trans( nTotFacCli - nPagFacCli, cPorDiv ) )
   end

   if oGetPes <> nil
      oGetPes:cText( nTotPes )
   end

   if oGetPes <> nil
      oGetPes:cText( nTotPes )
   end

   if oGetDif <> nil
      oGetDif:cText( nTotDif )
   end

Return .T.



STATIC FUNCTION lMoreIva( nCodIva )





   IF aTotIva[ 1, 3 ] == nil .OR. aTotIva[ 2, 3 ] == nil .OR. aTotIva[ 3, 3 ] == nil
        RETURN .T.
    end

    IF aTotIva[ 1, 3 ] == nCodIva .OR. aTotIva[ 2, 3 ] == nCodIva .OR. aTotIva[ 3, 3 ] == nCodIva
        RETURN .T.
    end

   MsgStop( "Factura con más de 3 tipos de " + cImp() )

RETURN .F.







STATIC FUNCTION LoaArt( aGet, bmpImage, aTmp, aTmpFac, oStkAct, oSayPr1, oSayPr2, oSayVp1, oSayVp2, nMode, lFocused )

    local nDtoAge
   local nImpAtp
   local nImpOfe
   local nCosPro
   local cCodArt     := aGet[ 4 ]:varGet()
   local cCodFam
   local lChgCodArt  := ( Rtrim( cOldCodArt ) <> Rtrim( cCodArt ) )
   local nPrePro     := 0
   local cPrpArt
   local nPosComa
   local cProveedor
   local nTarOld     := aTmp[ 71 ]
   local nNumDto     := 0

   IIF( lFocused == nil, lFocused := .T., ) ;

   if Empty( cCodArt )

      if lRetCodArt()
         MsgStop( "No se pueden añadir líneas sin codificar" )
         return .F.
      end

      if Empty( aTmp[ 11 ] )
         aGet[11    ]:bWhen   := {|| .T. }
      end

        aGet[5]:cText( Space( 50 ) )
      aGet[5]:bWhen   := {|| .T. }
      aGet[5]:Hide()

      if !Empty( aGet[ 22 ] )
          aGet[ 22 ]:Show()
      end

      if lFocused .AND. !Empty( aGet[ 22 ] )
        aGet[ 22 ]:SetFocus()
      end

      aGet[29 ]:Hide()
      oSayPr1:Hide()
      oSayVp1:Hide()

      aGet[30 ]:Hide()
      oSayPr2:Hide()
      oSayVp2:Hide()

      Return .T.

   end

   IF lModIva()
      aGet[11    ]:bWhen   := {|| .T. }
   ELSE
      aGet[11    ]:bWhen   := {|| .F. }
   end





   if "," $ cCodArt
      nPosComa                := At( ",", cCodArt )
      cProveedor              := RJust( Left( cCodArt, nPosComa - 1 ), "0", RetNumCodPrvEmp() )
      cCodArt                 := cSeekProveedor( cCodArt, dbfArtPrv )
   else
      cCodArt                 := cSeekCodebar( cCodArt, dbfCodebar, dbfArticulo )
   end





   if ( dbfArticulo )->( dbSeek( cCodArt ) ) .OR. ( dbfArticulo )->( dbSeek( Upper( cCodArt ) ) )

      if ( lChgCodArt )

         if ( dbfArticulo )->lObs
            MsgStop( "Artículo catalogado como obsoleto" )
            return .F.
         end

         cCodArt := ( dbfArticulo )->Codigo

         aTmp[ 4   ] := cCodArt
         aGet[ 4   ]:cText( cCodArt )

         if ( dbfArticulo )->lMosCom .AND. !Empty( ( dbfArticulo )->mComent )
            MsgStop( Trim( ( dbfArticulo )->mComent ) )
         end

         if !Empty( cProveedor )
            aTmp[ 57 ]  := cProveedor
            aTmp[ 58 ]  := AllTrim( RetProvee( cProveedor ) )
            aTmp[ 64 ]  := Padr( cRefPrvArt( cCodArt, Padr( cProveedor, 12 ) , dbfArtPrv ), 18 )
            if "MUEBLES" $ cParamsMain()
               aGet[ 57 ]:cText( cProveedor )
               aGet[ 58 ]:cText( AllTrim( RetProvee( cProveedor ) ) )
               aGet[ 64 ]:cText( Padr( cRefPrvArt( cCodArt, Padr( cProveedor, 12 ) , dbfArtPrv ), 18 ) )
            end
         else
            aTmp[ 57 ]  := (dbfArticulo)->cPrvHab
            aTmp[ 58 ]  := AllTrim( RetProvee( (dbfArticulo)->cPrvHab ) )
            aTmp[ 64 ]  := Padr( cRefPrvArt( cCodArt, (dbfArticulo)->cPrvHab, dbfArtPrv ), 18 )
            if "MUEBLES" $ cParamsMain()
               aGet[ 57 ]:cText( (dbfArticulo)->cPrvHab )
               aGet[ 58 ]:cText( AllTrim( RetProvee( (dbfArticulo)->cPrvHab ) ) )
               aGet[ 64 ]:cText( Padr( cRefPrvArt( cCodArt, (dbfArticulo)->cPrvHab, dbfArtPrv ), 18 ) )
            end
         end

         aGet[5]:show()
         aGet[22 ]:hide()

         aGet[5]:cText( (dbfArticulo)->NOMBRE  )





         if !Empty( aGet[ 72 ] )
            aGet[ 72 ]:cText( ( dbfArticulo )->Descrip )
         else
            aTmp[ 72 ]     := ( dbfArticulo )->Descrip
         end






         if !Empty( aGet[ 14 ] )
            aGet[ 14  ]:cText( ( dbfArticulo )->nPesoKg )
         else
            aGet[ 14  ] := ( dbfArticulo )->nPesoKg
         end

         if !Empty( aGet[ 15 ] )
             aGet[ 15 ]:cText( ( dbfArticulo )->cUndDim )
         else
             aGet[ 15 ] := ( dbfArticulo )->cUndDim
         end

         if !Empty( aGet[ 16 ] )
             aGet[ 16 ]:cText( ( dbfArticulo )->cUnidad )
             aGet[ 16 ]:lValid()
         else
             aTmp[ 16 ] := ( dbfArticulo )->cUnidad
         end

         if !Empty( aGet[51 ] )
            aGet[ 51 ]:cText( ( dbfArticulo )->cCodTip )
         else
            aTmp[ 51 ]  := ( dbfArticulo )->cCodTip
         end






         if ( dbfArticulo )->lFacCnv
            aTmp[ 31 ]  := ( dbfArticulo )->nFacCnv
         end






         if ( dbfArticulo )->lLote

            if !Empty( aGet[ 44 ] )
               aGet[ 44 ]:Show()
               aGet[ 44 ]:cText( ( dbfArticulo )->cLote )
               aGet[ 44 ]:lValid()
            else
               aTmp[ 44 ] := ( dbfArticulo )->cLote
            end

            aTmp[ 42 ]    := ( dbfArticulo )->lLote

            if !Empty( aGet[ 45 ] )
               aGet[ 45 ]:Show()
            end

         else

            if !Empty( aGet[ 44 ] )
               aGet[ 44 ]:Hide()
            end

            if !Empty( aGet[ 45 ] )
               aGet[ 45 ]:Hide()
            end

         end





         cCodFam              := ( dbfArticulo )->Familia
         if !Empty( cCodFam )
            aTmp[53]    := cCodFam
            aTmp[54]    := cGruFam( cCodFam, dbfFamilia )
            aGet[53]:cText( cCodFam )
            aGet[54]:cText( cGruFam( cCodFam, dbfFamilia ) )
            aGet[53]:lValid()
            aGet[54]:lValid()
         else
            aGet[53]:cText( Space(8) )
            aGet[54]:cText( Space(3) )
            aGet[53]:lValid()
            aGet[54]:lValid()

         end





         if ( dbfArticulo )->lKitArt

            aTmp[ 46 ]     := ( dbfArticulo )->lKitArt
            aTmp[ 26 ]     := lImprimirCompuesto( ( dbfArticulo )->Codigo, dbfArticulo )
            aTmp[ 48 ]     := lPreciosCompuestos( ( dbfArticulo )->Codigo, dbfArticulo )

            if lStockCompuestos( ( dbfArticulo )->Codigo, dbfArticulo )

               if aGet[ 35 ] <> nil
                  aGet[ 35 ]:SetOption( ( dbfArticulo )->nCtlStock )
               else
                  aTmp[ 35 ]  := ( dbfArticulo )->nCtlStock
               end

            else

               if aGet[ 35 ] <> nil
                  aGet[ 35 ]:SetOption( 3 )
               else
                  aTmp[ 35 ]  := 3
               end

            end

         else

            aTmp[ 26 ]     := .F.

            if aGet[ 35 ] <> nil
               aGet[ 35 ]:SetOption( ( dbfArticulo )->nCtlStock )
            else
               aTmp[ 35 ]  := ( dbfArticulo )->nCtlStock
            end

         end





         if aTmpFac[63] <= 1
            aGet[ 11 ]:cText( nIva( dbfIva, ( dbfArticulo )->TIPOIVA ) )
            aTmp[ 55 ]        := nReq( dbfIva, ( dbfArticulo )->TipoIva )
         end





         if !Empty( ( dbfArticulo )->cCodImp )
            aTmp[ 40 ]  := ( dbfArticulo )->cCodImp
            aGet[ 41 ]:cText( oNewImp:nValImp( ( dbfArticulo )->cCodImp, aTmpFac[56], aTmp[11] ) )

            aTmp[ 74 ]     := RetFld( ( dbfArticulo )->cCodImp, oNewImp:oDbf:cAlias, "lIvaVol" )

            if !Empty( aGet[ 74 ] )
               aGet[ 74 ]:Refresh()
            end

         end

         if (dbfArticulo)->nCajEnt <> 0
            aGet[12 ]:cText( (dbfArticulo)->nCajEnt )
         end

         if ( dbfArticulo )->nUniCaja <> 0
            aGet[18]:cText( ( dbfArticulo )->nUniCaja )
         end





         aGet[49 ]:cText( ( dbfArticulo )->nMesGrt )





         aGet[17 ]:cText( aTmpFac[ 23 ] )





         if oStkAct <> nil .AND. !uFieldEmpresa( "lNStkAct" ) .AND. aTmp[ 35 ] <= 1
            oStock:nPutStockActual( cCodArt, aTmp[ 38 ], , , , aTmp[ 46 ], aTmp[ 35 ], oStkAct )
         end

         aTmp[ 50 ]     := ( dbfArticulo )->lNotVta





         if !uFieldEmpresa( "lCosAct" )
            nCosPro              := oStock:nCostoMedio( aTmp[ 4 ], aTmp[ 38 ], aTmp[ 27 ], aTmp[ 29 ], aTmp[ 28 ], aTmp[ 30 ] )
            if nCosPro == 0
               nCosPro           := nCosto( aTmp[ 4 ], dbfArticulo, dbfKit, .F., , dbfDiv )
            end
         else
            nCosPro              := nCosto( aTmp[ 4 ], dbfArticulo, dbfKit, .F., , dbfDiv )
         end

         if aGet[ 36 ] <> nil
            aGet[ 36 ]:cText( nCosPro )
         else
            aTmp[ 36 ]  := nCosPro
         end





         nNumDto              := RetFld( aTmpFac[ 6 ], dbfClient, "nDtoArt" )

         if nNumDto <> 0

            do case
               case nNumDto == 1

                  if !Empty( aGet[ 9 ] )
                     aGet[ 9 ]:cText( ( dbfArticulo )->nDtoArt1 )
                     aTmp[ 9 ]     := ( dbfArticulo )->nDtoArt1
                  else
                     aTmp[ 9 ]     := ( dbfArticulo )->nDtoArt1
                  end

               case nNumDto == 2

                  if !Empty( aGet[ 9 ] )
                     aGet[ 9 ]:cText( ( dbfArticulo )->nDtoArt2 )
                     aTmp[ 9 ]     := ( dbfArticulo )->nDtoArt2
                  else
                     aTmp[ 9 ]     := ( dbfArticulo )->nDtoArt2
                  end

               case nNumDto == 3

                  if !Empty( aGet[ 9 ] )
                     aGet[ 9]:cText( ( dbfArticulo )->nDtoArt3 )
                     aTmp[ 9 ]     := ( dbfArticulo )->nDtoArt3
                  else
                     aTmp[ 9 ]     := ( dbfArticulo )->nDtoArt3
                  end

               case nNumDto == 4

                  if !Empty( aGet[ 9 ] )
                     aGet[ 9 ]:cText( ( dbfArticulo )->nDtoArt4 )
                     aTmp[ 9 ]     := ( dbfArticulo )->nDtoArt4
                  else
                     aTmp[ 9 ]     := ( dbfArticulo )->nDtoArt4
                  end

               case nNumDto == 5

                  if !Empty( aGet[ 9 ] )
                     aGet[ 9 ]:cText( ( dbfArticulo )->nDtoArt5 )
                     aTmp[ 9 ]     := ( dbfArticulo )->nDtoArt5
                  else
                     aTmp[ 9 ]     := ( dbfArticulo )->nDtoArt5
                  end

               case nNumDto == 6

                  if !Empty( aGet[ 9 ] )
                     aGet[ 9]:cText( ( dbfArticulo )->nDtoArt6 )
                     aTmp[ 9 ]     := ( dbfArticulo )->nDtoArt6
                  else
                     aTmp[ 9 ]     := ( dbfArticulo )->nDtoArt6
                  end

            end

         end





         if aTmp[ 9 ] == 0

            if !Empty( aGet[ 9 ] )
               aGet[ 9 ]:cText( nDescuentoFamilia( cCodFam, dbfFamilia ) )
            else
               aTmp[ 9 ]     := nDescuentoFamilia( cCodFam, dbfFamilia )
            end

         end





         if !Empty( aGet[ 59 ] )
            aGet[ 59 ]:cText( ( dbfArticulo )->cImagen )
         else
            aTmp[ 59 ]     := ( dbfArticulo )->cImagen
         end

         if !Empty( bmpImage )
            if !Empty( aTmp[ 59 ] )
               bmpImage:Show()
               bmpImage:LoadBmp( cFileBitmap( cPatImg(), aTmp[ 59 ] ) )
            else
               bmpImage:Hide()
            end
         end





         aTmp[ 27 ]  := ( dbfArticulo )->cCodPrp1
         aTmp[ 28 ]  := ( dbfArticulo )->cCodPrp2

         if !Empty( aTmp[ 27 ] )
            aGet[ 29 ]:Show()
            if lFocused
               aGet[ 29 ]:SetFocus()
            end
            oSayPr1:SetText( retProp( ( dbfArticulo )->cCodPrp1, dbfPro ) )
            oSayPr1:Show()
            oSayVp1:Show()
         else
            aGet[ 29 ]:hide()
            oSayPr1:hide()
            oSayVp1:hide()
         end

         if !Empty( aTmp[ 28 ] )
            aGet[ 30 ]:Show()
            oSayPr2:SetText( retProp( ( dbfArticulo )->cCodPrp2, dbfPro ) )
            oSayPr2:Show()
            oSayVp2:Show()
         else
            aGet[ 30 ]:hide()
            oSayPr2:Hide()
            oSayVp2:Hide()
         end

      end





      cPrpArt              := aTmp[ 27 ] + aTmp[ 28 ] + aTmp[ 29 ] + aTmp[ 30 ]

      if ( lChgCodArt ) .OR. ( cPrpArt <> cOldPrpArt )



         if nMode == 1
            cCodFam        := RetFamArt( cCodArt, dbfArticulo )
         else
            cCodFam        := aTmp[53]
         end

if "MUEBLES" $ cParamsMain()
         aTmp[ 60 ]     := ( dbfArticulo )->pCosto
         aTmp[ 61 ]     := ( dbfArticulo )->nPuntos
         aTmp[ 62 ]     := ( dbfArticulo )->nDtoPnt
         aTmp[ 63 ]     := 0
end



         aGet[ 7 ]:cText( ( dbfArticulo )->nPntVer1 )
         aTmp[ 37 ]   := ( dbfArticulo )->PvpRec





         if !Empty( aGet[ 16 ] )
            aGet[ 16 ]:cText( ( dbfArticulo )->cUnidad )
         else
            aTmp[ 16 ]  := ( dbfArticulo )->cUnidad
         end



         nPrePro           := nPrePro( aTmp[ 4 ], aTmp[ 27 ], aTmp[ 29 ], aTmp[ 28 ], aTmp[ 30 ], aTmp[ 71 ], aTmpFac[ 56 ], dbfArtDiv, dbfTarPreL, aTmpFac[21] )

         if nPrePro == 0
            aGet[6]:cText( nRetPreArt( aTmp[ 71 ], aTmpFac[ 58 ], aTmpFac[ 56 ], dbfArticulo, dbfDiv, dbfKit, dbfIva, , aGet[ 71 ] ) )
         else
            aGet[6]:cText( nPrePro )
         end



         if !Empty( aTmpFac[ 21 ] )


            nImpOfe  := RetPrcTar( cCodArt, aTmpFac[ 21 ], aTmp[ 27 ], aTmp[ 28 ], aTmp[ 29 ], aTmp[ 30 ], dbfTarPreL, aTmp[ 71 ] )
            if nImpOfe <> 0
               aGet[6]:cText( nImpOfe )
            end


            nImpOfe  := RetPctTar( cCodArt, cCodFam, aTmpFac[ 21 ], aTmp[ 27 ], aTmp[ 28 ], aTmp[ 29 ], aTmp[ 30 ], dbfTarPreL )
            if nImpOfe <> 0
               aGet[9   ]:cText( nImpOfe )
            end


            nImpOfe  := RetLinTar( cCodArt, cCodFam, aTmpFac[21], aTmp[27], aTmp[28], aTmp[29], aTmp[30], dbfTarPreL )
            if nImpOfe <> 0
               aGet[32]:cText( nImpOfe )
            end


            nImpOfe  := RetComTar( cCodArt, cCodFam, aTmpFac[21], aTmp[27], aTmp[28], aTmp[29], aTmp[30], aTmpFac[19], dbfTarPreL, dbfTarPreS )
            if nImpOfe <> 0
               aGet[17]:cText( nImpOfe )
            end



            nImpOfe  := RetDtoPrm( cCodArt, cCodFam, aTmpFac[21], aTmp[27], aTmp[28], aTmp[29], aTmp[30], aTmpFac[5], dbfTarPreL )
            if nImpOfe  <> 0
               aGet[10]:cText( nImpOfe )
            end



            nDtoAge     := RetDtoAge( cCodArt, cCodFam, aTmpFac[21], aTmp[27], aTmp[28], aTmp[29], aTmp[30], aTmpFac[5], aTmpFac[19], dbfTarPreL, dbfTarPreS )
            if nDtoAge  <> 0
               aGet[ 17 ]:cText( nDtoAge )
            end

         end




         do case

         case lSeekAtpArt( aTmpFac[ 6 ] + cCodArt, aTmp[ 27 ] + aTmp[ 28 ], aTmp[ 29 ] + aTmp[ 30 ], aTmpFac[ 5 ], dbfClientAtp ) .AND.  ( dbfClientAtp )->lAplFac

            nImpAtp     := nImpAtp( nTarOld, dbfClientAtp, , , aGet[ 71 ] )
            if nImpAtp  <> 0
               aGet[ 6 ]:cText( nImpAtp )
            end





            nImpAtp     := nDtoAtp( nTarOld, dbfClientAtp )
            if nImpAtp  <> 0
               aGet[ 9 ]:cText( nImpAtp )
            end





            if ( dbfClientAtp )->nDprArt <> 0
               aGet[10 ]:cText( ( dbfClientAtp )->NDPRART )
            end

            if ( dbfClientAtp )->nComAge <> 0
               aGet[17 ]:cText( ( dbfClientAtp )->NCOMAGE )
            end

            if ( dbfClientAtp )->nDtoDiv <> 0
               aGet[32 ]:cText( ( dbfClientAtp )->nDtoDiv )
            end




         case lSeekAtpFam( aTmpFac[ 6 ] + aTmp[ 53 ], aTmpFac[ 5 ], dbfClientAtp ) .AND.  ( dbfClientAtp )->lAplFac

            if ( dbfClientAtp )->nDtoArt <> 0
               aGet[9    ]:cText( ( dbfClientAtp )->NDTOART )
            end

            if ( dbfClientAtp )->NDPRART <> 0
               aGet[10 ]:cText( ( dbfClientAtp )->NDPRART )
            end

            if ( dbfClientAtp )->NCOMAGE <> 0
               aGet[17 ]:cText( ( dbfClientAtp )->NCOMAGE )
            end

            if ( dbfClientAtp )->nDtoDiv <> 0
               aGet[32 ]:cText( ( dbfClientAtp )->nDtoDiv )
            end

         end






















         ValidaMedicion( aTmp, aGet )

      end





      lBuscaOferta( cCodArt, aGet, aTmp, aTmpFac, dbfOferta, dbfArticulo, dbfDiv, dbfKit, dbfIva  )





      cOldPrpArt  := cPrpArt
      cOldCodArt  := cCodArt





      if Empty( aTmp[ 6 ] ) .OR. lUsrMaster() .OR. oUser():lCambiarPrecio()
         aGet[ 6 ]:HardEnable()
         aGet[ 8  ]:HardEnable()
         aGet[ 7  ]:HardEnable()
         aGet[ 9     ]:HardEnable()
         aGet[ 10  ]:HardEnable()
         aGet[ 32  ]:HardEnable()
      else
         aGet[ 6 ]:HardDisable()
         aGet[ 8  ]:HardDisable()
         aGet[ 7  ]:HardDisable()
         aGet[ 9     ]:HardDisable()
         aGet[ 10  ]:HardDisable()
         aGet[ 32  ]:HardDisable()
      end

   else

      MsgStop( "Artículo no encontrado" )
      Return .F.

   end

RETURN .T.







STATIC FUNCTION loaCli( aGet, aTmp, nMode, oRieCli, oTlfCli )

   local lValid      := .T.
   local cNewCodCli  := aGet[ 6 ]:varGet()
   local lChgCodCli  := ( Empty( cOldCodCli ) .OR. cOldCodCli <> cNewCodCli )

   if Empty( cNewCodCli )
      Return .T.
   elseif At( ".", cNewCodCli ) <> 0
      cNewCodCli     := PntReplace( aGet[ 6 ], "0", RetNumCodCliEmp() )
   else
      cNewCodCli     := Rjust( cNewCodCli, "0", RetNumCodCliEmp() )
   end

   if ( dbfClient )->( dbSeek( cNewCodCli ) )





      aGet[ 6 ]:cText( ( dbfClient )->Cod )

      if oTlfCli <> nil
         oTlfCli:SetText( ( dbfClient )->Telefono )
      end

      if ( dbfClient )->nColor <> 0
         aGet[9]:SetColor( , ( dbfClient )->nColor )
      end

      if Empty( aGet[9]:varGet() ) .OR. lChgCodCli
         aGet[9]:cText( ( dbfClient )->Titulo )
      end

      if Empty( aGet[10]:varGet() ) .OR. lChgCodCli
         aGet[10]:cText( ( dbfClient )->Domicilio )
      end

      if Empty( aGet[ 87 ]:varGet() ) .OR. lChgCodCli
         aGet[ 87 ]:cText( ( dbfClient )->Telefono )
      end

      if Empty( aGet[11]:varGet() ) .OR. lChgCodCli
         aGet[11]:cText( ( dbfClient )->Poblacion )
      end

      if Empty( aGet[12]:varGet() ) .OR. lChgCodCli
         aGet[12]:cText( ( dbfClient )->Provincia )
      end

      if Empty( aGet[14]:varGet() ) .OR. lChgCodCli
         aGet[14]:cText( ( dbfClient )->CodPostal )
      end

      if Empty( aGet[ 15 ]:varGet() ) .OR. lChgCodCli
         aGet[ 15 ]:cText( ( dbfClient )->Nif )
      end

      if Empty( aTmp[ 79 ] ) .OR. lChgCodCli
         aTmp[ 79 ]  := ( dbfClient )->cCodGrp
      end

      if lChgCodCli
         aTmp[ 16 ]  := ( dbfClient )->lModDat
      end

      if ( lChgCodCli )
         aTmp[ 97 ]  := ( dbfClient )->lPntVer
      end

      if nMode == 1

         aTmp[63 ]   := ( dbfClient )->nRegIva





         if Empty( aTmp[ 1 ] )

            if !Empty( ( dbfClient )->Serie )
               aGet[ 1 ]:cText( ( dbfClient )->Serie )
            end

         else



            if !Empty( ( dbfClient )->Serie )               .AND. aTmp[ 1 ] <> ( dbfClient )->Serie      .AND. ApoloMsgNoYes( "La serie del cliente seleccionado es distinta a la anterior.", "¿Desea cambiar la serie?" )
               aGet[ 1 ]:cText( ( dbfClient )->Serie )
            end

         end

         if ( Empty( aGet[7]:varGet() ) .OR. lChgCodCli ) .AND. !Empty( ( dbfClient )->cCodAlm )
            aGet[7]:cText( ( dbfClient )->cCodAlm )
            aGet[7]:lValid()
         end

         if ( Empty( aGet[21]:varGet() ) .OR. lChgCodCli ) .AND. !Empty( ( dbfClient )->cCodTar )
            aGet[21]:cText( ( dbfClient )->CCODTAR )
            aGet[21]:lValid()
         end

         if ( Empty( aGet[32]:varGet() ) .OR. lChgCodCli ) .AND. !Empty( ( dbfClient )->CodPago )

            aGet[32]:cText( (dbfClient)->CODPAGO )
            aGet[32]:lValid()





            if RetFld( aTmp[ 32 ], dbfFPago, "LUTLBNC" )

               if lBancoDefecto( ( dbfClient )->Cod, dbfCliBnc )

                  if !Empty( aGet[ 92 ] )
                     aGet[ 92 ]:cText( ( dbfCliBnc )->cCodBnc )
                     aGet[ 92 ]:lValid()
                  end

                  if !Empty( aGet[ 93 ] )
                     aGet[ 93 ]:cText( ( dbfCliBnc )->cEntBnc )
                     aGet[ 93 ]:lValid()
                  end

                  if !Empty( aGet[ 94 ] )
                     aGet[ 94 ]:cText( ( dbfCliBnc )->cSucBnc )
                     aGet[ 94 ]:lValid()
                  end

                  if !Empty( aGet[ 95 ] )
                     aGet[ 95 ]:cText( ( dbfCliBnc )->cDigBnc )
                     aGet[ 95 ]:lValid()
                  end

                  if !Empty( aGet[ 96 ] )
                     aGet[ 96 ]:cText( ( dbfCliBnc )->cCtaBnc )
                     aGet[ 96 ]:lValid()
                  end

               end

            end

         end

         if ( Empty( aGet[19]:varGet() ) .OR. lChgCodCli ) .AND. !Empty( ( dbfClient )->cAgente )
            aGet[19]:cText( (dbfClient)->CAGENTE )
            aGet[19]:lValid()
         end

         if ( Empty( aGet[20]:varGet() ) .OR. lChgCodCli ) .AND. !Empty( ( dbfClient )->cCodRut )
            aGet[20]:cText( ( dbfClient)->CCODRUT )
            aGet[20]:lValid()
         end

         if ( Empty( aGet[ 18 ]:varGet() ) .OR. lChgCodCli ) .AND. !Empty( ( dbfClient )->nTarifa )
            aGet[ 18 ]:cText( ( dbfClient )->nTarifa )
         end

         if !Empty( aGet[ 70 ] ) .AND. ( Empty( aGet[ 70 ]:varGet() ) .OR. lChgCodCli ) .AND. !Empty( ( dbfClient )->cCodTrn )
            aGet[ 70 ]:cText( ( dbfClient )->cCodTrn )
            aGet[ 70 ]:lValid()
         end

         if lChgCodCli

            aGet[ 54 ]:Click( ( dbfClient )->lReq )

            aGet[ 97  ]:Click( ( dbfClient )->lPntVer )











            if !Empty( aGet[ 75 ] )
               aGet[ 75  ]:cText( ( dbfClient )->nPctRet )
            else
               aTmp[ 75  ] := ( dbfClient )->nPctRet
            end





            aGet[ 39 ]:cText( ( dbfClient )->cDtoEsp )

            aGet[ 40 ]:cText( ( dbfClient )->nDtoEsp )

            aGet[ 41    ]:cText( ( dbfClient )->cDpp    )

            aGet[ 42    ]:cText( ( dbfClient )->nDpp    )

            aGet[ 43 ]:cText( ( dbfClient )->cDtoUno )

            aGet[ 45 ]:cText( ( dbfClient )->cDtoDos )

            aGet[ 44 ]:cText( ( dbfClient )->nDtoCnt )

            aGet[ 46 ]:cText( ( dbfClient )->nDtoRap )

         end

      end

      if ( dbfClient )->lMosCom .AND. !Empty( ( dbfClient )->mComent ) .AND. lChgCodCli
         MsgStop( Trim( ( dbfClient )->mComent ) )
      end

      if !Empty( oRieCli ) .AND. lChgCodCli
         oStock:SetRiesgo( cNewCodCli, oRieCli, ( dbfClient )->Riesgo )
      end

      ShowInciCliente( ( dbfClient )->Cod, dbfCliInc )

      cOldCodCli  := ( dbfClient )->Cod

      lValid      := .T.

   else

        msgStop( "Cliente no encontrado" )

      lValid      := .F.

   end

RETURN lValid







FUNCTION mkFacRec( cPath, oMeter, nLenCodCli )

   if oMeter <> nil
        oMeter:cText    := "Generando Bases"
        sysrefresh()
    end

   CreateFiles( cPath, .T. )

RETURN NIL






FUNCTION rxFacRec( cPath, oMeter )

   local dbfFacRecT
   local dbfFacRecL
   local dbfFacRecI
   local dbfFacRecD

   IIF( cPath == nil, cPath := cPatEmp(), ) ;









   if !lExistTable( cPath + "FacRecT.Dbf" )   .OR. !lExistTable( cPath + "FacRecL.Dbf" )   .OR. !lExistTable( cPath + "FacRecI.Dbf" )   .OR. !lExistTable( cPath + "FacRecD.Dbf" )   .OR. !lExistTable( cPath + "FacRecS.Dbf" )
      CreateFiles( cPath, .F. )
   end

   fEraseIndex( cPath + "FacRecT.Cdx" )
   fEraseIndex( cPath + "FacRecL.Cdx" )
   fEraseIndex( cPath + "FacRecI.Cdx" )
   fEraseIndex( cPath + "FacRecD.Cdx" )
   fEraseIndex( cPath + "FacRecS.Cdx" )

   dbUseArea( .T., cDriver(), cPath + "FacRecL.DBF", cCheckArea( "FacRecL", @dbfFacRecL ), .F. )
   if !( dbfFacRecL )->( neterr() )
      ( dbfFacRecL )->( __dbPack() )

      ( dbfFacRecL )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecL )->( ordCreate( cPath + "FacRecL.CDX", "NNUMFAC", "CSERIE + Str(NNUMFAC) + CSUFFAC", {|| Field->CSERIE + Str( Field->NNUMFAC ) + Field->CSUFFAC }, ) )

      ( dbfFacRecL )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecL )->( ordCreate( cPath + "FacRecL.CDX", "CFACREF", "CSERIE + Str(NNUMFAC) + CSUFFAC + CREF", {|| Field->CSERIE + Str( Field->NNUMFAC ) + Field->CSUFFAC + Field->CREF }, ) )

      ( dbfFacRecL )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecL )->( ordCreate( cPath + "FacRecL.CDX", "CREF", "CREF", {|| Field->CREF }, ) )

      ( dbfFacRecL )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecL )->( ordCreate( cPath + "FacRecL.CDX", "Lote", "cLote", {|| Field->cLote }, ) )

      ( dbfFacRecL)->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
      ( dbfFacRecL )->( ordCreate( cPath + "FacRecL.Cdx", "iNumFac", "'FACTURA RECTIFICATIVA         ' + cSerie + Str( nNumFac ) + cSufFac", {|| "FACTURA RECTIFICATIVA         " + Field->cSerie + Str( Field->nNumFac ) + Field->cSufFac } ) )

      ( dbfFacRecL )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de facturas rectificativas de clientes" )
   end

   dbUseArea( .T., cDriver(), cPath + "FacRecI.DBF", cCheckArea( "FacRecI", @dbfFacRecI ), .F. )
   if !( dbfFacRecI )->( neterr() )
      ( dbfFacRecI )->( __dbPack() )

      ( dbfFacRecI )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfFacRecI )->( ordCreate( cPath + "FacRecI.Cdx", "nNumFac", "cSerie + STR( nNumFac ) + cSufFac", {|| Field->cSerie + Str( Field->nNumFac ) + Field->cSufFac } ) )

      ( dbfFacRecI )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de facturas rectificativas de clientes" )
   end

   dbUseArea( .T., cDriver(), cPath + "FacRecD.DBF", cCheckArea( "FacRecD", @dbfFacRecD ), .F. )
   if !( dbfFacRecD )->( neterr() )
      ( dbfFacRecD )->( __dbPack() )

      ( dbfFacRecD )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfFacRecD )->( ordCreate( cPath + "FacRecD.Cdx", "nNumFac", "cSerFac + STR( nNumFac ) + cSufFac", {|| Field->cSerFac + Str( Field->nNumFac ) + Field->cSufFac } ) )

      ( dbfFacRecD )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de facturas rectificativas de clientes" )
   end

   dbUseArea( .T., cDriver(), cPath + "FacRecT.DBF", cCheckArea( "FacRecT", @dbfFacRecT ), .F. )
   if !( dbfFacRecT )->( neterr() )
      ( dbfFacRecT )->( __dbPack() )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "NNUMFAC", "CSERIE + Str(NNUMFAC) + CSUFFAC", {|| Field->cSerie + Str( Field->nNumFac ) + Field->cSufFac }, ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "DFECFAC", "DFECFAC", {|| Field->DFECFAC } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "CCODCLI", "CCODCLI", {|| Field->CCODCLI } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "CNOMCLI", "Upper( CNOMCLI )", {|| Upper( Field->CNOMCLI ) } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "CCODOBR", "CCODOBR", {|| Field->CCODOBR } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "CTURFAC", "CTURFAC + CSUFFAC + CCODCAJ", {|| Field->CTURFAC + Field->CSUFFAC + Field->CCODCAJ } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "cCodAge", "cCodAge", {|| Field->cCodAge } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "CCODRUT", "CCODRUT", {|| Field->CCODRUT } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "cCodPago", "cCodPago", {|| Field->cCodPago } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "CPOBCLI", "CPOBCLI + CNOMCLI", {|| Field->CPOBCLI + Field->CNOMCLI } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "CDOCORG", "CDOCORG", {|| Field->CDOCORG } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "CAGEFEC", "CCODAGE + DtoS( DFECFAC )", {|| Field->CCODAGE + DtoS( Field->DFECFAC ) } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "NNUMLIQ", "Str( NNUMLIQ ) + CSUFLIQ", {|| Str( Field->NNUMLIQ ) + Field->CSUFLIQ } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ))
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "CABNFAC", "CABNFAC", {|| Field->CABNFAC } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ))
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "lSndDoc", "lSndDoc", {|| Field->lSndDoc } ) )

      ( dbfFacRecT )->( ordCondSet("!Deleted()", {|| !Deleted() } ))
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.CDX", "cNumDoc", "cNumDoc", {|| Field->cNumDoc } ) )

      ( dbfFacRecT )->( ordCondSet( "!Deleted()", {||!Deleted()}  ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.Cdx", "cCodUsr", "Field->cCodUsr + Dtos( Field->dFecCre ) + Field->cTimCre", {|| Field->cCodUsr + Dtos( Field->dFecCre ) + Field->cTimCre } ) )

      ( dbfFacRecT )->( ordCondSet( "!Deleted()", {||!Deleted()}  ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.Cdx", "cNumFac", "Field->cNumFac", {|| Field->cNumFac } ) )

      ( dbfFacRecT )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecT.Cdx", "iNumFac", "'FACTURA RECTIFICATIVA         ' + cSerie + Str( nNumFac ) + cSufFac", {|| "FACTURA RECTIFICATIVA         " + Field->cSerie + Str( Field->nNumFac ) + Field->cSufFac } ) )

      ( dbfFacRecT )->( dbCloseArea() )

   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de facturas rectificativas de clientes" )
   end

   dbUseArea( .T., cDriver(), cPath + "FacRecS.Dbf", cCheckArea( "FacRecS", @dbfFacRecT ), .F. )

   if !( dbfFacRecT )->( neterr() )
      ( dbfFacRecT )->( __dbPack() )

      ( dbfFacRecT )->( ordCondSet( "!Deleted()", {||!Deleted()}  ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecS.Cdx", "nNumFac", "cSerFac + Str( nNumFac ) + cSufFac + Str( nNumLin )", {|| Field->cSerFac + Str( Field->nNumFac ) + Field->cSufFac + Str( Field->nNumLin ) } ) )

      ( dbfFacRecT )->( ordCondSet( "!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecS.Cdx", "cRefSer", "cRef + cAlmLin + cNumSer", {|| Field->cRef + Field->cAlmLin + Field->cNumSer } ) )

      ( dbfFacRecT )->( ordCondSet( "!Deleted()", {|| !Deleted() } ) )
      ( dbfFacRecT )->( ordCreate( cPath + "FacRecS.CDX", "cNumSer", "cNumSer", {|| Field->cNumSer } ) )

      ( dbfFacRecT )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de números de series de facturas rectificativas de clientes" )
   end

Return nil







STATIC FUNCTION BeginTrans( aTmp, nMode )

   local oError
   local oBlock
   local lErrors  := .F.
   local cDbfLin  := "FCliL"
   local cDbfInc  := "FCliI"
   local cDbfDoc  := "FCliD"
   local cDbfAnt  := "FCliA"
   local cDbfPgo  := "FCliP"
   local cDbfSer  := "FCliS"
   local cFac     := aTmp[ 1 ] + Str( aTmp[ 2 ] ) + aTmp[ 3 ]

   CursorWait()

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   cTmpLin        := cGetNewFileName( cPatTmp() + cDbfLin )
   cTmpInc        := cGetNewFileName( cPatTmp() + cDbfInc )
   cTmpDoc        := cGetNewFileName( cPatTmp() + cDbfDoc )
   cTmpAnt        := cGetNewFileName( cPatTmp() + cDbfAnt )
   cTmpPgo        := cGetNewFileName( cPatTmp() + cDbfPgo )
   cTmpSer        := cGetNewFileName( cPatTmp() + cDbfSer )





   aNumAlb        := {}





   do case
   case nMode == 1 .OR. nMode == 4

      nTotOld     := 0

   case nMode == 2

      nTotOld     := nTotFac

   end





   dbCreate( cTmpLin, aSqlStruct( aColFacRec() ), cLocalDriver() )
   dbUseArea( .T., cLocalDriver(), cTmpLin, cCheckArea( cDbfLin, @dbfTmpLin ), .F. )
   if !NetErr()

      ( dbfTmpLin )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
      ( dbfTmpLin )->( OrdCreate( cTmpLin, "nNumLin", "Str( nNumLin, 4 )", {|| Str( Field->nNumLin ) } ) )

      ( dbfTmpLin )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
      ( dbfTmpLin )->( OrdCreate( cTmpLin, "Recno", "Str( Recno() )", {|| Str( Recno() ) } ) )

      if ( dbfFacRecL )->( dbSeek( cFac ) )
         while ( ( dbfFacRecL )->CSERIE + Str( ( dbfFacRecL )->NNUMFAC ) + ( dbfFacRecL )->CSUFFAC ) == cFac .AND. !( dbfFacRecL )->( eof() )
            dbPass( dbfFacRecL, dbfTmpLin, .T. )
            ( dbfFacRecL )->( DbSkip() )
         end
      endif

      ( dbfTmpLin )->( dbGoTop() )

   else

      lErrors     := .T.

   end





   dbCreate( cTmpInc, aSqlStruct( aIncFacRec() ), cLocalDriver() )
   dbUseArea( .T., cLocalDriver(), cTmpInc, cCheckArea( cDbfInc, @dbfTmpInc ), .F. )
   if !NetErr()
      ( dbfTmpInc )->( ordCondSet( "!Deleted()", {||!Deleted() } ) )
      ( dbfTmpInc )->( ordCreate( cTmpInc, "Recno", "Recno()", {|| Recno() } ) )

      if ( dbfFacRecI )->( dbSeek( cFac ) )
         while ( ( dbfFacRecI )->cSerie + Str( ( dbfFacRecI )->nNumFac ) + ( dbfFacRecI )->cSufFac == cFac ) .AND. ( dbfFacRecI )->( !eof() )
            dbPass( dbfFacRecI, dbfTmpInc, .T. )
            ( dbfFacRecI )->( dbSkip() )
         end
      end

      ( dbfTmpInc )->( dbGoTop() )

   else

      lErrors     := .T.

   end





   dbCreate( cTmpDoc, aSqlStruct( aFacRecDoc() ), cLocalDriver() )
   dbUseArea( .T., cLocalDriver(), cTmpDoc, cCheckArea( cDbfDoc, @dbfTmpDoc ), .F. )
   if !NetErr()
      ( dbfTmpDoc )->( ordCondSet( "!Deleted()", {||!Deleted() } ) )
      ( dbfTmpDoc )->( ordCreate( cTmpDoc, "Recno", "Recno()", {|| Recno() } ) )

      if ( dbfFacRecD )->( dbSeek( cFac ) )
         while ( ( dbfFacRecD )->cSerFac + Str( ( dbfFacRecD )->nNumFac ) + ( dbfFacRecD )->cSufFac == cFac ) .AND. ( dbfFacRecD )->( !eof() )
            dbPass( dbfFacRecD, dbfTmpDoc, .T. )
            ( dbfFacRecD )->( dbSkip() )
         end
      end

      ( dbfTmpDoc )->( dbGoTop() )

   else

      lErrors     := .T.

   end





   dbCreate( cTmpSer, aSqlStruct( aSerFacRec() ), cLocalDriver() )
   dbUseArea( .T., cLocalDriver(), cTmpSer, cCheckArea( cDbfSer, @dbfTmpSer ), .F. )

   if !( dbfTmpSer )->( NetErr() )

      ( dbfTmpSer )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
      ( dbfTmpSer )->( OrdCreate( cTmpSer, "nNumLin", "Str( nNumLin, 4 ) + cRef", {|| Str( Field->nNumLin, 4 ) + Field->cRef } ) )

      if ( dbfFacRecS )->( dbSeek( cFac ) )
         while ( ( dbfFacRecS )->cSerFac + Str( ( dbfFacRecS )->nNumFac ) + ( dbfFacRecS )->cSufFac == cFac ) .AND. !( dbfFacRecS )->( eof() )
            dbPass( dbfFacRecS, dbfTmpSer, .T. )
            ( dbfFacRecS )->( dbSkip() )
         end
      end

      ( dbfTmpSer )->( dbGoTop() )

      oStock:SetTmpFacRecS( dbfTmpSer )

   end





   dbCreate( cTmpPgo, aSqlStruct( aItmRecCli() ), cLocalDriver() )
   dbUseArea( .T., cLocalDriver(), cTmpPgo, cCheckArea( cDbfPgo, @dbfTmpPgo ), .F. )

   if !NetErr()

      ( dbfTmpPgo )->( ordCondSet("!Deleted()", {|| !Deleted() } ) )
      ( dbfTmpPgo )->( ordCreate( cTmpPgo , "cRecDev", "cRecDev", {|| Field->cRecDev } ) )

      ( dbfTmpPgo )->( ordCondSet( "!Deleted()", {||!Deleted() } ) )
      ( dbfTmpPgo )->( ordCreate( cTmpPgo, "nNumFac", "cSerie + Str( nNumFac ) + cSufFac + Str( nNumRec ) + cTipRec", {|| Field->cSerie + Str( Field->nNumFac ) + Field->cSufFac + Str( Field->nNumRec ) + Field->cTipRec } ) )

      if ( dbfFacCliP )->( dbSeek( cFac ) ) .AND. nMode <> 4
         while ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == cFac .AND. ( dbfFacCliP )->( !eof() )
            dbPass( dbfFacCliP, dbfTmpPgo, .T. )
            ( dbfFacCliP )->( dbSkip() )
         end
      end

      ( dbfTmpPgo  )->( dbGoTop() )

   else

      lErrors     := .T.

   end

   RECOVER USING oError

      msgStop( "Imposible crear tablas temporales." + Chr(13)+Chr(10) + ErrorMessage( oError ) )

      KillTrans()

      lErrors     := .T.

   end

   ErrorBlock( oBlock )

   CursorWE()

Return ( lErrors )






STATIC FUNCTION EndTrans( aTmp, aGet, oBrw, oBrwDet, oBrwPgo, aNumAlb, nMode, oDlg, oFld )

   local n
   local cSerFac
   local nNumFac
   local cSufFac
   local dFecFac
   local oError
   local oBlock

   if Empty( aTmp[ 1 ] )
      aTmp[ 1 ]   := "A"
   end

   cSerFac              := aTmp[ 1  ]
   nNumFac              := aTmp[ 2 ]
   cSufFac              := aTmp[ 3 ]
   dFecFac              := aTmp[ 5 ]





   if !lValidaOperacion( aTmp[5] )
      Return .F.
   end





   if ( nMode == 1 .OR. nMode == 4 ) .AND. Empty( aTmp[ 37 ] )
      MsgStop( "Debe de indicar la factura que quiere rectificar." )
      aGet[ 37 ]:SetFocus()
      return .F.
   end

   if lCliBlq( aTmp[ 6 ], dbfClient )
      msgStop( "Cliente bloqueado, no se pueden realizar operaciones de venta" )
      aGet[ 6 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 9 ] )
      msgStop( "Nombre de cliente no puede estar vacio." )
      aGet[ 9 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 10 ] )
      msgStop( "Domicilio de cliente no puede estar vacio." )
      aGet[ 10 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 15 ] )
      msgStop( "D.N.I. / C.I.F. de cliente no puede estar vacio." )
      aGet[ 15 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 7 ] )
      msgStop( "Almacén no puede estar vacio." )
      aGet[ 7 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 32 ] )
      msgStop( "Forma de pago no puede estar vacia." )
      aGet[ 32 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 58 ] )
      MsgStop( "No puede almacenar documento sin código de divisa." )
      aGet[ 58 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 19 ] ) .AND. lRecogerAgentes()
      msgStop( "Agente no puede estar vacio." )
      aGet[ 19 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 22 ] ) .AND. lObras()
      MsgStop( "Debe de introducir una obra." )
      aGet[ 22 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 85 ] )
      MsgStop( "Debe indicar un motivo para la factura rectificativa." )
      oFld:SetOption( 2 )
      aGet[ 85 ]:SetFocus()
      return .F.
   end

   if Empty( aTmp[ 86 ] )
      MsgStop( "Debe indicar una causa por la que se emite la factura rectificativa." )
      oFld:SetOption( 2 )
      aGet[ 86 ]:SetFocus()
      return .F.
   end

   if ( dbfTmpLin )->( eof() )
      MsgStop( "No puede almacenar un documento sin lineas." )
      return .F.
   end

   if lPasNil() .AND. ( nMode == 1 .OR. nMode == 4 )

      ( dbfTmpLin )->( dbGoTop() )
      while !( dbfTmpLin )->( eof() )

         if !( dbfTmpLin )->lControl .AND. ( dbfTmpLin )->nPreUnit == 0 .AND. !( dbfTmpLin )->lKitPrc
            if !ApoloMsgNoYes( "El artículo " + Rtrim( ( dbfTmpLin )->cRef ) + " - " + Rtrim( Descrip( dbfTmpLin ) ) + " no esta valorado.", "¿Desea continuar archivando la factura?" )
               return .F.
            end
         end

         ( dbfTmpLin )->( dbSkip() )

      end

   end





   CursorWait()

   oDlg:Disable()

   oMsgText( "Archivando" )

   aTmp[ 77 ]     := GetSysDate()
   aTmp[ 78 ]     := Time()





   ( dbfTmpLin )->( dbClearFilter() )





   do case
   case ( nMode == 1 .OR. nMode == 4 )





      nNumFac           := nNewDoc( cSerFac, dbfFacRecT, "nFacRec", , dbfCount )
      aTmp[ 2 ]  := nNumFac
      aTmp[ 28 ]  := !Empty( aNumAlb )

   case ( nMode == 2 )







      while ( dbfFacRecL )->( dbSeek( cSerFac + Str( nNumFac ) + cSufFac ) ) .AND. !( dbfFacRecL )->( eof() )
         if dbLock( dbfFacRecL )
            ( dbfFacRecL )->( dbDelete() )
            ( dbfFacRecL )->( dbUnLock() )
         end
      end





      while ( dbfFacRecI )->( dbSeek( cSerFac + Str( nNumFac ) + cSufFac ) ) .AND. !( dbfFacRecI )->( eof() )
         if dbLock( dbfFacRecI )
            ( dbfFacRecI )->( dbDelete() )
            ( dbfFacRecI )->( dbUnLock() )
         end
      end





      while ( dbfFacRecD )->( dbSeek( cSerFac + Str( nNumFac ) + cSufFac ) ) .AND. !( dbfFacRecD )->( eof() )
         if dbLock( dbfFacRecD )
            ( dbfFacRecD )->( dbDelete() )
            ( dbfFacRecD )->( dbUnLock() )
         end
      end





      while ( dbfFacRecS )->( dbSeek( cSerFac + Str( nNumFac ) + cSufFac ) ) .AND. !( dbfFacRecS )->( eof() )
         if dbLock( dbfFacRecS )
            ( dbfFacRecS )->( dbDelete() )
            ( dbfFacRecS )->( dbUnLock() )
         end
      end





      while ( dbfFacCliP )->( dbSeek( cSerFac + Str( nNumFac ) + cSufFac ) .AND. !( dbfFacCliP )->( eof() ) )
         if dbLock( dbfFacCliP )
            ( dbfFacCliP )->( dbDelete() )
            ( dbfFacCliP )->( dbUnLock() )
         end
      end

   end





   oMsgProgress()
   oMsgProgress():SetRange( 0, ( dbfTmpLin )->( LastRec() ) )





   ( dbfTmpLin )->( dbGoTop() )
   while ( dbfTmpLin )->( !eof() )

      if ( dbfTmpLin )->dFecFac <> aTmp[ 5 ]
         ( dbfTmpLin )->dFecFac := aTmp[ 5 ]
      end

      dbPass( dbfTmpLin, dbfFacRecL, .T., cSerFac, nNumFac, cSufFac )

      ( dbfTmpLin )->( dbSkip() )

      oMsgProgress():Deltapos(1)

   end





   ( dbfTmpInc )->( dbGoTop() )
   while ( dbfTmpInc )->( !eof() )
      dbPass( dbfTmpInc, dbfFacRecI, .T., cSerFac, nNumFac, cSufFac )
      ( dbfTmpInc )->( dbSkip() )
   end





   ( dbfTmpDoc )->( dbGoTop() )
   while ( dbfTmpDoc )->( !eof() )
      dbPass( dbfTmpDoc, dbfFacRecD, .T., cSerFac, nNumFac, cSufFac )
      ( dbfTmpDoc )->( dbSkip() )
   end





   ( dbfTmpSer )->( dbGoTop() )
   while ( dbfTmpSer )->( !eof() )
      dbPass( dbfTmpSer, dbfFacRecS, .T., cSerFac, nNumFac, cSufFac, dFecFac )
      ( dbfTmpSer )->( dbSkip() )
   end





   ( dbfTmpPgo )->( dbGoTop() )
   while ( dbfTmpPgo )->( !eof() )

      if ( dbfTmpPgo )->cCodCli <> aTmp[ 6 ]
         ( dbfTmpPgo )->cCodCli := aTmp[ 6 ]
      end

      if ( dbfTmpPgo )->cNomCli <> aTmp[ 9 ]
         ( dbfTmpPgo )->cNomCli := aTmp[ 9 ]
      end

      dbPass( dbfTmpPgo, dbfFacCliP, .T., cSerFac, nNumFac, cSufFac )

      ( dbfTmpPgo )->( dbSkip() )

   end





   aTmp[ 88 ]  := nTotNet
   aTmp[ 89 ]  := nTotIva
   aTmp[ 90 ]  := nTotReq
   aTmp[ 91 ]  := nTotFac





   WinGather( aTmp, , dbfFacRecT, , nMode )





   if len( aNumAlb ) > 0
      for n := 1 to len( aNumAlb )
         if ( dbfAlbCliT )->( dbSeek( aNumAlb[n] ) )
            if dbLock( dbfAlbCliT )
               delRiesgo( nTotAlbCli( aNumAlb[ n ], dbfAlbCliT, dbfAlbCliL, dbfIva, dbfDiv ), ( dbfAlbCliT )->cCodCli, dbfClient )
               ( dbfAlbCliT )->lFacturado := .T.
               ( dbfAlbCliT )->cNumFac    := cSerFac + Str( nNumFac ) + cSufFac
               ( dbfAlbCliT )->( dbUnlock() )

            end
         end
      next
   end











   GenPgoFacRec( cSerFac + Str( nNumFac ) + cSufFac, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfClient, dbfFPago, dbfDiv, dbfIva, nMode )





   ChkLqdFacRec( nil, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfIva, dbfDiv )





   dbCommitAll()





   oMsgText()

   EndProgress()

   oDlg:Enable()
   oDlg:end( 1 )

   CursorWE()

Return .T.



Static Function KillTrans( oBrwDet, oBrwInc, oBrwPgo )





   if !Empty( dbfTmpLin ) .AND. ( dbfTmpLin )->( Used() )
      ( dbfTmpLin )->( dbCloseArea() )
   end

   if !Empty( dbfTmpInc ) .AND. ( dbfTmpInc )->( Used() )
      ( dbfTmpInc )->( dbCloseArea() )
   end

   if !Empty( dbfTmpDoc ) .AND. ( dbfTmpDoc )->( Used() )
      ( dbfTmpDoc )->( dbCloseArea() )
   end

   if !Empty( dbfTmpAnt ) .AND. ( dbfTmpAnt )->( Used() )
      ( dbfTmpAnt )->( dbCloseArea() )
   end

   if !Empty( dbfTmpPgo ) .AND. ( dbfTmpPgo )->( Used() )
      ( dbfTmpPgo )->( dbCloseArea() )
   end

   if !Empty( dbfTmpSer ) .AND. ( dbfTmpSer )->( Used() )
      ( dbfTmpSer )->( dbCloseArea() )
   end

   dbfTmpLin      := nil
   dbfTmpInc      := nil
   dbfTmpDoc      := nil
   dbfTmpAnt      := nil
   dbfTmpPgo      := nil
   dbfTmpSer      := nil

   dbfErase( cTmpLin )
   dbfErase( cTmpInc )
   dbfErase( cTmpDoc )
   dbfErase( cTmpAnt )
   dbfErase( cTmpPgo )
   dbfErase( cTmpSer )

RETURN NIL






STATIC FUNCTION CreateFiles( cPath, lReindex )

   IIF( lReindex == nil, lReindex := .T., ) ;

   if !lExistTable( cPath + "FacRecT.DBF" )
      dbCreate( cPath + "FacRecT.DBF", aSqlStruct( aItmFacRec() ), cDriver() )
   end

   if !lExistTable( cPath + "FacRecL.DBF" )
      dbCreate( cPath + "FacRecL.DBF", aSqlStruct( aColFacRec() ), cDriver() )
   end

   if !lExistTable( cPath + "FacRecI.DBF" )
      dbCreate( cPath + "FacRecI.DBF", aSqlStruct( aIncFacRec() ), cDriver() )
   end

   if !lExistTable( cPath + "FacRecD.DBF" )
      dbCreate( cPath + "FacRecD.DBF", aSqlStruct( aFacRecDoc() ), cDriver() )
   end

   if !lExistTable( cPath + "FacRecS.Dbf" )
      dbCreate( cPath + "FacRecS.Dbf", aSqlStruct( aSerFacRec() ), cDriver() )
   end

   if lReindex
      rxFacRec( cPath )
   end

RETURN NIL






FUNCTION dFecFacRec( cFacRec, dbfFacRecT )

   local aStatus
    local dFecFac    := CtoD("")

   if IsObject( dbfFacRecT )

      dbfFacRecT:GetStatus( .T. )

      if dbfFacRecT:Seek( cFacRec )
         dFecFac  := dbfFacRecT:dFecFac
      end

      dbfFacRecT:SetStatus()

   else

      aStatus     := aGetStatus( dbfFacRecT, .T. )

      if ( dbfFacRecT )->( dbSeek( cFacRec ) )
         dFecFac  := ( dbfFacRecT )->dFecFac
      end

      SetStatus( dbfFacRecT, aStatus )

   end

RETURN ( dFecFac )






FUNCTION cCliFacRec( cFacRec, uFacRecT )

   local cCodCli  := ""

   do case
      case ValType( uFacRecT ) == "C"
         if (uFacRecT)->( dbSeek( cFacRec ) )
            cCodCli     := (uFacRecT)->CCODCLI
         end
      case ValType( uFacRecT ) == "O"
         if uFacRecT:Seek( cFacRec )
            cCodCli     := uFacRecT:cCodCli
         end
   end

RETURN ( cCodCli )







FUNCTION cNbrFacRec( cFacRec, dbfFacRecT )

   local cNomCli  := ""

   if ( dbfFacRecT )->( dbSeek( cFacRec ) )
      cNomCli     := ( dbfFacRecT )->CNOMCLI
    end

RETURN ( cNomCli )







FUNCTION cPgoFacRec( cFacRec, dbfFacRecT )

   local cCodPgo  := ""

   if ValType( dbfFacRecT ) == "O"
      if dbfFacRecT:Seek( cFacRec )
         cCodPgo  := dbfFacRecT:cCodPago
      end
   else
      if ( dbfFacRecT )->( dbSeek( cFacRec ) )
         cCodPgo  := ( dbfFacRecT )->cCodPago
      end
   end

RETURN ( cCodPgo )



FUNCTION cProFacRec( cFacRec, dbfFacRecT )

   local cCodPro  := ""

   if ( dbfFacRecT )->( dbSeek( cFacRec ) )
      cCodPro     := ( dbfFacRecT )->CCODPRO
    end

RETURN ( cCodPro )






FUNCTION lConFacRec( cFacRec, dbfFacRecT )

   local lConFac  := .F.

   if ( dbfFacRecT )->( dbSeek( cFacRec ) )
      lConFac     := ( dbfFacRecT )->lContab
    end

RETURN ( lConFac )






FUNCTION cAgeFacRec( cFacRec, dbfFacRecT )

   local cCliFac  := ""

   if ValType( dbfFacRecT ) == "O"
      if dbfFacRecT:Seek( cFacRec )
         cCliFac  := dbfFacRecT:cCodAge
      end
   else
      if ( dbfFacRecT )->( dbSeek( cFacRec ) )
         cCliFac  := ( dbfFacRecT )->cCodAge
      end
   end

RETURN ( cCliFac )



static function lGenFacRec( oBrw, oBtn, nDevice )

   local bAction

   IIF( nDevice == nil, nDevice := 1, ) ;

   if Empty( oBtn )
      return nil
   end

   if !( dbfDoc )->( dbSeek( "FR" ) )








         oWndBrw:NewAt( "DOCUMENT",,, {||( msgStop( "No hay facturas rectificativas de clientes predefinidas" ) )}, "No hay documentos", "N",,, 4, oBtn, .F. )

   ELSE

      WHILE ( dbfDoc )->CTIPO == "FR" .AND. !( dbfDoc )->( eof() )

         bAction  := bGenFacRec( nDevice, "Imprimiendo facturas rectificativas de clientes", ( dbfDoc )->CODIGO )

         oWndBrw:NewAt( "Document", , , bAction, Rtrim( ( dbfDoc )->cDescrip ) , , , , , oBtn )

         ( dbfDoc )->( dbSkip() )

      end

   end

   SysRefresh()

return nil



static function bGenFacRec( nDevice, cTitle, cCodDoc )

   local bGen
   local nDev  := by( nDevice )
   local cTit  := by( cTitle  )
   local cCod  := by( cCodDoc )

   if nDev == 1
      bGen     := {|| GenFacRec( nDev, cTit, cCod ) }
   else
      bGen     := {|| GenFacRec( nDev, cTit, cCod ) }
   end

return ( bGen )




































function nTotDFacRec( cCodArt, dbfFacRecL, cCodAlm )

   local nOrd     := ( dbfFacRecL )->( OrdSetFocus( "cRef" ) )
   local nRec     := ( dbfFacRecL )->( Recno() )
   local nTotVta  := 0

   if ( dbfFacRecL )->( dbSeek( cCodArt ) )

      while ( dbfFacRecL )->CREF == cCodArt .AND. !( dbfFacRecL )->( eof() )

         if !( dbfFacRecL )->LTOTLIN
            if cCodAlm <> nil
               if cCodAlm == ( dbfFacRecL )->cAlmLin
                  nTotVta  += nTotNFacRec( dbfFacRecL ) * NotCero( ( dbfFacRecL )->nFacCnv )
               end
            else
               nTotVta     += nTotNFacRec( dbfFacRecL ) * NotCero( ( dbfFacRecL )->nFacCnv )
            end
         end

         ( dbfFacRecL )->( dbSkip() )

      end

   end

   ( dbfFacRecL )->( OrdSetFocus( nOrd  ) )
   ( dbfFacRecL )->( dbGoTo( nRec ) )

return ( nTotVta )



FUNCTION nVolLFacRec( dbfLin )

   local nCalculo    := 0

   if !( dbfLin )->lTotLin
      nCalculo       := nTotNFacRec( dbfLin ) * ( dbfLin )->nVolumen
   end

RETURN ( nCalculo )






STATIC FUNCTION nTotFFacRec( cFacRecL, nDec, nRouDec, nVdv, lDto, lPntVer, lImpTrn, cPorDiv )

   local nCalculo := 0

   nCalculo       += nTotLFacRec( cFacRecL, nDec, nRouDec, nVdv, lDto, lPntVer, lImpTrn )
   nCalculo       += nTotIFacRec( cFacRecL, nDec, nRouDec, nVdv )

return ( if( cPorDiv <> nil, Trans( nCalculo, cPorDiv ), nCalculo ) )



FUNCTION nTotPFacRec( cFacRecL, nDec, nVdv, cPorDiv )

   local nCalculo

   IIF( cFacRecL == nil, cFacRecL := dbfFacRecL, ) ;
   IIF( nDec == nil, nDec := nDouDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   if ( cFacRecL )->lTotLin

      nCalculo       := nTotUFacRec( cFacRecL, nDec )

   else





      nCalculo       := nTotUFacRec( cFacRecL, nDec )
      nCalculo       -= Round( ( cFacRecL )->nDtoDiv , nDec )

      if ( cFacRecL )->nDto <> 0
         nCalculo    -= nCalculo * ( cFacRecL )->nDto / 100
      end

      if ( cFacRecL )->nDtoPrm <> 0
         nCalculo    -= nCalculo * ( cFacRecL )->nDtoPrm / 100
      end

   end

   nCalculo          := Round( nCalculo / nVdv, nDec )

RETURN ( if( cPorDiv <> nil, Trans( nCalculo, cPorDiv ), nCalculo ) )






FUNCTION nDtoLFacRec( cFacRecL, nDec, nVdv, cPorDiv )

   local nCalculo    := 0

   IIF( cFacRecL == nil, cFacRecL := dbfFacRecL, ) ;
   IIF( nDec == nil, nDec := nDouDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;





   if ( cFacRecL )->nDto <> 0
      nCalculo       := nTotUFacRec( cFacRecL, nDec ) * ( cFacRecL )->nDto / 100
      nCalculo       := Round( nCalculo / nVdv, nDec )
   end

RETURN ( if( cPorDiv <> nil, Trans( nCalculo, cPorDiv ), nCalculo ) )



Function nTotDtoLFacRec( cFacRecL, nDec, nVdv, cPorDiv )

   local nCalculo

   IIF( cFacRecL == nil, cFacRecL := dbfFacRecL, ) ;
   IIF( nDec == nil, nDec := nDouDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   nCalculo          := nDtoLFacRec( cFacRecL, nDec, nVdv ) * nTotNFacRec( cFacRecL )

   if nVdv <> 0
      nCalculo       := nCalculo / nVdv
   end

   nCalculo          := Round( nCalculo, nDec )

RETURN ( if( cPorDiv <> nil, Trans( nCalculo, cPorDiv ), nCalculo ) )



FUNCTION sTotLFacRec( dbfLin, nDec, nRou, nVdv, lDto, lPntVer, lImpTrn, cPorDiv )

   local uTotLFacRec
   local nTotLFacRec := nTotLFacRec( dbfLin, nDec, nRou, nVdv, lDto, lPntVer, lImpTrn )

   if nTotLFacRec == 0 .AND. !( dbfLin )->lControl
      uTotLFacRec    := "S/C"
   else
      uTotLFacRec    := if( cPorDiv <> NIL, Trans( nTotLFacRec, cPorDiv ), nTotLFacRec )
   end

RETURN ( uTotLFacRec )



FUNCTION nTotIFacRec( dbfLin, nDec, nRouDec, nVdv, cPorDiv )

   local nCalculo    := 0

   IIF( dbfLin == nil, dbfLin := dbfFacRecL, ) ;
   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nRouDec == nil, nRouDec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   if !( dbfLin )->lTotLin





      nCalculo       := Round( ( dbfLin )->nValImp, nDec )





      nCalculo       *= nTotNFacRec( dbfLin )

      if ( dbfLin )->lVolImp
         nCalculo    *= NotCero( ( dbfLin )->nVolumen )
      end

      nCalculo       := Round( nCalculo / nVdv, nRouDec )

   end

RETURN ( if( cPorDiv <> nil, Trans( nCalculo, cPorDiv ), nCalculo ) )



FUNCTION nImpUFacRec( uFacRecT, uFacRecL, nDec, nVdv, lIva )

   local lIvaInc
   local nCalculo

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;
   IIF( lIva == nil, lIva := .F., ) ;

   nCalculo       := nTotUFacRec( uFacRecL, nDec, nVdv )

   if IsArray( uFacRecT )

      nCalculo    -= Round( nCalculo * uFacRecT[ 40 ]  / 100, nDec )
      nCalculo    -= Round( nCalculo * uFacRecT[ 42    ]  / 100, nDec )
      nCalculo    -= Round( nCalculo * uFacRecT[ 44 ]  / 100, nDec )
      nCalculo    -= Round( nCalculo * uFacRecT[ 46 ]  / 100, nDec )
      lIvaInc     := uFacRecT[ 56 ]

   else

      nCalculo    -= Round( nCalculo * ( uFacRecT )->nDtoEsp / 100, nDec )
      nCalculo    -= Round( nCalculo * ( uFacRecT )->nDpp    / 100, nDec )
      nCalculo    -= Round( nCalculo * ( uFacRecT )->nDtoUno / 100, nDec )
      nCalculo    -= Round( nCalculo * ( uFacRecT )->nDtoDos / 100, nDec )
      lIvaInc     := ( uFacRecT )->lIvaInc

   end

   if IsArray( uFacRecL )

      if lIva .AND. uFacRecL[ 11 ] <> 0
         if !lIvaInc
            nCalculo    += nCalculo * uFacRecL[ 11 ] / 100
         end
      else
         if lIvaInc .AND. uFacRecL[ 11 ] <> 0
            nCalculo    -= Round( nCalculo / ( 100 / uFacRecL[ 11 ] + 1 ), nDec )
         end
      end

   else

      if lIva .AND. ( uFacRecL )->nIva <> 0
         if !lIvaInc
            nCalculo    += nCalculo * ( uFacRecL )->nIva / 100
         end
      else
         if lIvaInc .AND. ( uFacRecL )->nIva <> 0
            nCalculo    -= Round( nCalculo / ( 100 / ( uFacRecL )->nIva + 1 ), nDec )
         end
      end

   end

RETURN ( Round( nCalculo, nDec ) )







FUNCTION nImpLFacRec( uFacRecT, dbfFacRecL, nDec, nRou, nVdv, lIva, lDto, lPntVer, lImpTrn, cPouDiv )

   local lIvaInc
   local nCalculo

   IIF( nDec == nil, nDec := 0, ) ;
   IIF( nRou == nil, nRou := 0, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;
   IIF( lIva == nil, lIva := .F., ) ;
   IIF( lDto == nil, lDto := .T., ) ;
   IIF( lPntVer == nil, lPntVer := .F., ) ;
   IIF( lImpTrn == nil, lImpTrn := .F., ) ;

   nCalculo       := nTotLFacRec( dbfFacRecL, nDec, nRou, nVdv, .T., lPntVer, lImpTrn )

   if ValType( uFacRecT ) == "A"
      nCalculo    -= Round( nCalculo * uFacRecT[ 40 ]  / 100, nRou )
      nCalculo    -= Round( nCalculo * uFacRecT[ 42    ]  / 100, nRou )
      nCalculo    -= Round( nCalculo * uFacRecT[ 44 ]  / 100, nRou )
      nCalculo    -= Round( nCalculo * uFacRecT[ 46 ]  / 100, nRou )
      lIvaInc     := uFacRecT[ 56 ]
   else
      nCalculo    -= Round( nCalculo * ( uFacRecT )->nDtoEsp / 100, nRou )
      nCalculo    -= Round( nCalculo * ( uFacRecT )->nDpp    / 100, nRou )
      nCalculo    -= Round( nCalculo * ( uFacRecT )->nDtoUno / 100, nRou )
      nCalculo    -= Round( nCalculo * ( uFacRecT )->nDtoDos / 100, nRou )
      lIvaInc     := ( uFacRecT )->lIvaInc
   end

   if lIva .AND. ( dbfFacRecL )->nIva <> 0
      if !lIvaInc
         nCalculo += nCalculo * ( dbfFacRecL )->nIva / 100
      end
   else
      if lIvaInc .AND. ( dbfFacRecL )->nIva <> 0
         nCalculo -= Round( nCalculo / ( 100 / ( dbfFacRecL )->nIva + 1 ), nRou )
      end
   end

RETURN ( if( cPouDiv <> nil, Trans( nCalculo, cPouDiv ), nCalculo ) )






FUNCTION nNetLFacRec( dbfFacRecL, nDec, nRou, nVdv, lDto, lPntVer, lImpTrn, cPouDiv )

   local nCalculo

   IIF( nDec == nil, nDec := 2, ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;
   IIF( lDto == nil, lDto := .T., ) ;
   IIF( lPntVer == nil, lPntVer := .T., ) ;

   nCalculo       := nTotLFacRec( dbfFacRecL, nDec, nRou, nVdv, lDto, lPntVer, lImpTrn )

   if ( dbfFacRecL )->nIva <> 0 .AND. ( dbfFacRecL )->lIvaLin
      if nRou <> nil
         nCalculo -= Round( nCalculo / ( 100 / ( dbfFacRecL )->nIva + 1 ), nRou )
      else
         nCalculo -= ( nCalculo / ( 100 / ( dbfFacRecL )->nIva + 1 ) )
      end
   end

RETURN ( if( cPouDiv <> NIL, Trans( nCalculo, cPouDiv ), nCalculo ) )



function nVtaFacRec( cCodCli, dDesde, dHasta, dbfFacRecT, dbfFacRecL, dbfIva, dbfDiv, nYear )

   local nCon     := 0
   local nOrd     := ( dbfFacRecT )->( OrdSetFocus( "CCODCLI" ) )
   local nRec     := ( dbfFacRecT )->( Recno() )





   if ( dbfFacRecT )->( dbSeek( cCodCli ) )

      while ( dbfFacRecT )->cCodCli = cCodCli .AND. !( dbfFacRecT )->( Eof() )



         if ( dDesde == nil .OR. ( dbfFacRecT )->DFECFAC >= dDesde ) .AND. ( dHasta == nil .OR. ( dbfFacRecT )->DFECFAC <= dHasta ) .AND. ( nYear == nil .OR. Year( ( dbfFacRecT )->dFecFac ) == nYear )

            nCon  += nTotFacRec( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, dbfFacRecT, dbfFacRecL, dbfIva, dbfDiv, nil, cDivEmp(), .F. )

         end

         ( dbfFacRecT )->( dbSkip() )

         SysRefresh()

      end

   end

   ( dbfFacRecT )->( OrdSetFocus( nOrd ) )
   ( dbfFacRecT )->( dbGoTo( nRec ) )

return nCon



static function QuiFacRec()

   local nOrdAnt
   local cSerDoc     := ( dbfFacRecT )->cSerie
   local nNumDoc     := ( dbfFacRecT )->nNumFac
   local cSufDoc     := ( dbfFacRecT )->cSufFac

   if ( dbfFacRecT )->lCloFac .AND. !oUser():lAdministrador()
      msgStop( "Solo puede eliminar facturas cerradas los administradores." )
      return .F.
   end





   DelRiesgo( nTotFac, ( dbfFacRecT )->cCodCli, dbfClient )





   nOrdAnt     := ( dbfFacRecL )->( OrdSetFocus( "nNumFac" ) )

   while ( dbfFacRecL )->( dbSeek( cSerDoc + Str( nNumDoc ) + cSufDoc ) ) .AND. !( dbfFacRecL )->( eof() )
      if dbDialogLock( dbfFacRecL )
         ( dbfFacRecL )->( dbDelete() )
         ( dbfFacRecL )->( dbUnLock() )
      end

      ( dbfFacRecL )->( dbSkip() )
   end

   ( dbfFacRecL )->( OrdSetFocus( nOrdAnt ) )





   nOrdAnt     := ( dbfFacCliP )->( OrdSetFocus( "nNumFac" ) )

   if ( dbfFacCliP )->( dbSeek( cSerDoc + Str( nNumDoc ) + cSufDoc ) )

      while cSerDoc + Str( nNumDoc ) + cSufDoc == ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac .AND. !( dbfFacCliP )->( eof() )

         if ( dbfFacCliP )->cTipRec == "R"

            if dbDialogLock( dbfFacCliP )
               ( dbfFacCliP )->( dbDelete() )
               ( dbfFacCliP )->( dbUnLock() )
            end

         end

         ( dbfFacCliP )->( dbSkip() )

      end

   end

   ( dbfFacCliP )->( OrdSetFocus( nOrdAnt ) )





   nOrdAnt     := ( dbfFacRecI )->( OrdSetFocus( "nNumFac" ) )

   while ( dbfFacRecI )->( dbSeek( cSerDoc + Str( nNumDoc ) + cSufDoc ) ) .AND. !( dbfFacRecI )->( eof() )
      if dbDialogLock( dbfFacRecI )
         ( dbfFacRecI )->( dbDelete() )
         ( dbfFacRecI )->( dbUnLock() )
      end

      ( dbfFacRecI )->( dbSkip() )
   end

   ( dbfFacRecI )->( OrdSetFocus( nOrdAnt ) )





   nOrdAnt     := ( dbfFacRecD )->( OrdSetFocus( "nNumFac" ) )

   while ( dbfFacRecD )->( dbSeek( cSerDoc + Str( nNumDoc ) + cSufDoc ) ) .AND. !( dbfFacRecD )->( eof() )
      if dbDialogLock( dbfFacRecD )
         ( dbfFacRecD )->( dbDelete() )
         ( dbfFacRecD )->( dbUnLock() )
      end

      ( dbfFacRecD )->( dbSkip() )
   end

   ( dbfFacRecD )->( OrdSetFocus( nOrdAnt ) )





   nOrdAnt     := ( dbfFacRecS )->( OrdSetFocus( "nNumFac" ) )

   while ( dbfFacRecS )->( dbSeek( cSerDoc + Str( nNumDoc ) + cSufDoc ) ) .AND. !( dbfFacRecS )->( eof() )
      if dbDialogLock( dbfFacRecS )
         ( dbfFacRecS )->( dbDelete() )
         ( dbfFacRecS )->( dbUnLock() )
      end

      ( dbfFacRecS )->( dbSkip() )
   end

   ( dbfFacRecS )->( OrdSetFocus( nOrdAnt ) )





   nPutDoc( cSerDoc, nNumDoc, cSufDoc, dbfFacRecT, "nFacRec", , dbfCount )





   if oWndBrw <> nil
      oWndBrw:Refresh()
   end

return .T.






FUNCTION nTotNFacRec( uDbf )

   local nTotUnd

   IIF( uDbf == nil, uDbf := dbfFacRecL, ) ;

   do case
   case ValType( uDbf ) == "C"
      nTotUnd     := NotCaja( ( uDbf )->nCanEnt )
      nTotUnd     *= ( uDbf )->nUniCaja
      nTotUnd     *= NotCero( ( uDbf )->nUndKit )
      nTotUnd     *= NotCero( ( uDbf )->nMedUno )
      nTotUnd     *= NotCero( ( uDbf )->nMedDos )
      nTotUnd     *= NotCero( ( uDbf )->nMedTre )

   case ValType( uDbf ) == "A"
      nTotUnd     := NotCaja( uDbf[ 12 ] )
      nTotUnd     *= uDbf[ 18 ]
      nTotUnd     *= NotCero( uDbf[ 19 ] )
      nTotUnd     *= NotCero( uDbf[ 68 ] )
      nTotUnd     *= NotCero( uDbf[ 69 ] )
      nTotUnd     *= NotCero( uDbf[ 70 ] )

   otherwise
      nTotUnd     := NotCaja( uDbf:nCanEnt )
      nTotUnd     *= uDbf:nUniCaja
      nTotUnd     *= NotCero( uDbf:nUndKit )
      nTotUnd     *= NotCero( uDbf:nMedUno )
      nTotUnd     *= NotCero( uDbf:nMedDos )
      nTotUnd     *= NotCero( uDbf:nMedTre )

   end

RETURN ( nTotUnd )



Function nTotVFacRec( uDbf )

   local nTotUnd

   IIF( uDbf == nil, uDbf := dbfFacRecL, ) ;

   do case
      case ValType( uDbf ) == "A"

         nTotUnd  := nTotNFacRec( uDbf ) * NotCero( uDbf[ 31 ] )

      case ValType( uDbf ) == "C"

         nTotUnd  := nTotNFacRec( uDbf ) * NotCero( ( uDbf )->nFacCnv )

      otherwise

         nTotUnd  := nTotNFacRec( uDbf ) * NotCero( uDbf:nFacCnv )

   end

Return ( nTotUnd )



Static function lImpLin( dbfTmpLin, oBrwDet )

   ( dbfTmpLin )->lImpLin  := !( dbfTmpLin )->lImpLin

   oBrwDet:Refresh()

Return nil



STATIC FUNCTION aGetSelRec( oBrw, bAction, cTitle, lHide1, cTitle1, lHide2, cTitle2, bPreAction, bPostAction )

   local oDlg
   local oRad
   local nRad        := 1
   local aRet        := {}
   local oTree
   local oChk1
   local oChk2
   local lChk1       := .T.
   local lChk2       := .T.
   local nRecno      := ( dbfFacRecT )->( Recno() )
   local nOrdAnt     := ( dbfFacRecT )->( OrdSetFocus( 1 ) )
   local oSerIni
   local oSerFin
   local cSerIni     := ( dbfFacRecT )->cSerie
   local cSerFin     := ( dbfFacRecT )->cSerie
   local oDocIni
   local oDocFin
   local nDocIni     := ( dbfFacRecT )->nNumFac
   local nDocFin     := ( dbfFacRecT )->nNumFac
   local oSufIni
   local oSufFin
   local cSufIni     := ( dbfFacRecT )->cSufFac
   local cSufFin     := ( dbfFacRecT )->cSufFac
   local oMtrInf
   local nMtrInf
   local lFechas     := .T.
   local dDesde      := CtoD( "01/01/" + Str( Year( Date() ) ) )
   local dHasta      := Date()
   local oImageList
   local oBtnCancel

   IIF( cTitle == nil, cTitle := "", ) ;
   IIF( lHide1 == nil, lHide1 := .F., ) ;
   IIF( cTitle1 == nil, cTitle1 := "", ) ;
   IIF( lHide2 == nil, lHide2 := .F., ) ;
   IIF( cTitle2 == nil, cTitle2 := "", ) ;

   oImageList        := TImageList():New( 16, 16 )
   oImageList:AddMasked( TBitmap():Define( "Bullet_Square_Red_16" ),    ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )
   oImageList:AddMasked( TBitmap():Define( "Bullet_Square_Green_16" ),  ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )

   oDlg = TDialog():New(,,,, cTitle, "SelectRango",, .F.,,,,,, .F.,,,,,, .F., )



   oRad := TRadMenu():Redefine( { | u | If( PCount()==0, nRad, nRad:= u ) }, oDlg,, { 80, 81 },,,,, .F.,, )










   oSerIni := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, cSerIni, cSerIni:= u ) }, oDlg,, "@!", {||    ( cSerIni >= "A" .AND. cSerIni <= "Z" )},,,,,, .T., {||     ( oRad:nOption == 2 )},, .F., .T., {||    ( UpSerie( oSerIni ) )}, {||  ( DwSerie( oSerIni ) )},,,, nil,,, )






   TBtnBmp():ReDefine( 101, "Up16",,,,, {|Self|( dbFirst( dbfFacRecT, "nNumFac", oDocIni, cSerIni, "nNumFac" ) )}, oDlg, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F. )










   oSerFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cSerFin, cSerFin:= u ) }, oDlg,, "@!", {||    ( cSerFin >= "A" .AND. cSerFin <= "Z" )},,,,,, .T., {||     ( oRad:nOption == 2 )},, .F., .T., {||    ( UpSerie( oSerFin ) )}, {||  ( DwSerie( oSerFin ) )},,,, nil,,, )






   TBtnBmp():ReDefine( 111, "Down16",,,,, {|Self|( dbLast( dbfFacRecT, "nNumFac", oDocFin, cSerFin, "nNumFAc" ) )}, oDlg, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F. )






   oDocIni := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, nDocIni, nDocIni:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( nRad == 2 )},, .F., .T.,,,,,, nil,,, )






   oDocFin := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, nDocFin, nDocFin:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( nRad == 2 )},, .F., .T.,,,,,, nil,,, )





   oSufIni := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, cSufIni, cSufIni:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )





   oSufFin := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, cSufFin, cSufFin:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )



   oChk1 := TCheckBox():ReDefine( 160, { | u | If( PCount()==0, lChk1, lChk1:= u ) }, oDlg,,,,,,, .F.,, .F. )



   oChk2 := TCheckBox():ReDefine( 180, { | u | If( PCount()==0, lChk2, lChk2:= u ) }, oDlg,,,,,,, .F.,, .F. )







   TCheckBox():ReDefine( 300, { | u | If( PCount()==0, lFechas, lFechas:= u ) }, oDlg,,,,,,, .F.,, .F. )





   TGetHlp():ReDefine( 310, { | u | If( PCount()==0, dDesde, dDesde:= u ) }, oDlg,,,,,,,,, .F., {||     ( !lFechas )},, .F., .T.,,,,,, nil,,, )





    TGetHlp():ReDefine( 320, { | u | If( PCount()==0, dHasta, dHasta:= u ) }, oDlg,,,,,,,,, .F., {||     ( !lFechas )},, .F., .T.,,,,,, nil,,, )





   oTree             := TTreeView():Redefine( 170, oDlg )
   oTree:bLDblClick  := {|| TreeChanged( oTree ) }





   oMtrInf := TMeter():ReDefine( 200, { | u | If( PCount()==0, nMtrInf, nMtrInf:= u ) },, oDlg, .F.,, "Proceso", .F.,,,, )

   oMtrInf:SetTotal( ( dbfFacRecT )->( OrdKeyCount() ) )




   TButton():ReDefine( 1, {||( MakSelRec( bAction, bPreAction, bPostAction, cSerIni + Str( nDocIni, 9 ) + cSufIni, cSerFin + Str( nDocFin, 9 ) + cSufFin, nRad, lChk1, lChk2, lFechas, dDesde, dHasta, oDlg, oTree, oBrw, oMtrInf, oBtnCancel ) )}, oDlg,,, .F.,,,, .F. )





   oBtnCancel := TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   oDlg:bStart := {|| StartGetSelRec( oBrw, oRad, oChk1, oChk2, oSerIni, oSerFin, oDocIni, oDocFin, oSufIni, oSufFin, lHide1, lHide2, cTitle1, cTitle2 ) }

   oDlg:AddFastKey( 116, {|| MakSelRec( bAction, bPreAction, bPostAction, cSerIni + Str( nDocIni, 9 ) + cSufIni, cSerFin + Str( nDocFin, 9 ) + cSufFin, nRad, lChk1, lChk2, lFechas, dDesde, dHasta, oDlg, oTree, oBrw, oMtrInf, oBtnCancel ) } )



   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( oTree:SetImageList( oImageList ) )}, oDlg:bRClicked,,, )

   ( dbfFacRecT )->( ordSetFocus( nOrdAnt ) )
   ( dbfFacRecT )->( dbGoTo( nRecNo ) )

   oImageList:End()

   oTree:Destroy()

   oBrw:SetFocus()
   oBrw:Refresh()

RETURN ( aRet )



Static Function StartGetSelRec( oBrw, oRad, oChk1, oChk2, oSerIni, oSerFin, oDocIni, oDocFin, oSufIni, oSufFin, lHide1, lHide2, cTitle1, cTitle2 )

   if !Empty( oBrw ) .AND. ( len( oBrw:oBrw:aSelected ) > 1 )

      oRad:SetOption( 1 )

   else

      oRad:SetOption( 2 )

      oSerIni:Enable()
      oSerFin:Enable()
      oDocIni:Enable()
      oDocFin:Enable()
      oSufIni:Enable()
      oSufFin:Enable()

   end

   if lHide1
      oChk1:Hide()
   else
      SetWindowText( oChk1:hWnd, cTitle1 )
      oChk1:Refresh()
   end

   if lHide2
      oChk2:Hide()
   else
      SetWindowText( oChk2:hWnd, cTitle2 )
      oChk2:Refresh()
   end

Return ( nil )



Static Function TreeChanged( oTree )

   local oItemTree   := oTree:GetItem()

   if !Empty( oItemTree ) .AND. !Empty( oItemTree:bAction )
      Eval( oItemTree:bAction )
   end

RETURN NIL



Static Function MakSelRec( bAction, bPreAction, bPostAction, cDocIni, cDocFin, nRad, lChk1, lChk2, lFechas, dDesde, dHasta, oDlg, oTree, oBrw, oMtrInf, oBtnCancel )

   local n        := 0
   local nPos     := 0
   local nRec     := ( dbfFacRecT )->( Recno() )
   local aPos
   local lRet
   local lPre
   local lWhile   := .T.





   if lChk1
      aPos        := { 0, 0 }
      ClientToScreen( oDlg:hWnd, aPos )
      oDlg:Move( aPos[ 1 ] - 22, aPos[ 2 ] - 510 )
   end





   oDlg:Disable()

   oTree:Enable()
   oTree:DeleteAll()

   oBtnCancel:bAction   := {|| lWhile := .F. }
   oBtnCancel:Enable()

   if !Empty( bPreAction )
      lPre              := Eval( bPreAction )
   end

   if !IsLogic( lPre ) .OR. lPre

      if nRad == 1

         for each nPos in ( oBrw:oBrw:aSelected )

            ( dbfFacRecT )->( dbGoTo( nPos ) )

            if lFechas .OR.( ( dbfFacRecT )->dFecFac >= dDesde .AND. ( dbfFacRecT )->dFecFac <= dHasta )

               lRet  := Eval( bAction, lChk1, lChk2, oTree, dbfFacRecT, dbfFacRecL )

               if IsFalse( lRet )
                  exit
               end

            end

            oMtrInf:Set( ++n )

            SysRefresh()

            if !lWhile
               exit
            end

         next

      else

         ( dbfFacRecT )->( dbSeek( cDocIni, .T. ) )




         while ( lWhile )                                                                                      .AND.  ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac, 9 ) + ( dbfFacRecT )->cSufFac >= cDocIni .AND.  ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac, 9 ) + ( dbfFacRecT )->cSufFac <= cDocFin .AND.  !( dbfFacRecT )->( eof() )

            if lFechas .OR.( ( dbfFacRecT )->dFecFac >= dDesde .AND. ( dbfFacRecT )->dFecFac <= dHasta )

               lRet  := Eval( bAction, lChk1, lChk2, oTree, dbfFacRecT, dbfFacRecL )

               if IsFalse( lRet )
                  exit
               end

            end

            oMtrInf:Set( ++n )

            ( dbfFacRecT )->( dbSkip() )

            SysRefresh()

         end

      end

      if !Empty( bPostAction )
         Eval( bPostAction )
      end

   end

   oMtrInf:Set( ( dbfFacRecT )->( OrdKeyCount() ) )

   ( dbfFacRecT )->( dbGoTo( nRec ) )

   if lChk1
      WndCenter( oDlg:hWnd )
   end

   oBtnCancel:bAction   := {|| oDlg:End() }

   oDlg:Enable()

   if oBrw <> nil
      oBrw:Refresh()
   end

RETURN ( lRet )



STATIC FUNCTION DelSerie( oWndBrw )

    local oDlg
   local oSerIni
   local oSerFin
   local oTxtDel
   local nTxtDel     := 0
   local nRecno      := ( dbfFacRecT )->( Recno() )
   local nOrdAnt     := ( dbfFacRecT )->( OrdSetFocus( 1 ) )
   local oDesde      := TDesdeHasta():Init( ( dbfFacRecT )->cSerie, ( dbfFacRecT )->nNumFac, ( dbfFacRecT )->cSufFac, GetSysDate() )
   local lCancel     := .F.
   local oBtnAceptar
   local oBtnCancel




   oDlg = TDialog():New(,,,, "Eliminar series de facturas rectificativas", "DELSERDOC",, .F.,,,,, oWndBrw, .F.,,,,,, .F., )



   TRadMenu():Redefine( { | u | If( PCount()==0, oDesde:nRadio, oDesde:nRadio:= u ) }, oDlg,, { 90, 91 },,,,, .F.,, )










   oSerIni := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, oDesde:cSerieInicio, oDesde:cSerieInicio:= u ) }, oDlg,, "@!", {||    ( oDesde:cSerieInicio >= "A" .AND. oDesde:cSerieInicio <= "Z"  )},,,,,, .T., {||     ( oDesde:nRadio == 1 )},, .F., .T., {||    ( UpSerie( oSerIni ) )}, {||  ( DwSerie( oSerIni ) )},,,, nil,,, )










   oSerFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, oDesde:cSerieFin, oDesde:cSerieFin:= u ) }, oDlg,, "@!", {||    ( oDesde:cSerieFin >= "A" .AND. oDesde:cSerieFin <= "Z"  )},,,,,, .T., {||     ( oDesde:nRadio == 1 )},, .F., .T., {||    ( UpSerie( oSerFin ) )}, {||  ( DwSerie( oSerFin ) )},,,, nil,,, )






   TGetHlp():ReDefine( 120, { | u | If( PCount()==0, oDesde:nNumeroInicio, oDesde:nNumeroInicio:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( oDesde:nRadio == 1 )},, .F., .T.,,,,,, nil,,, )






   TGetHlp():ReDefine( 130, { | u | If( PCount()==0, oDesde:nNumeroFin, oDesde:nNumeroFin:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( oDesde:nRadio == 1 )},, .F., .T.,,,,,, nil,,, )





   TGetHlp():ReDefine( 140, { | u | If( PCount()==0, oDesde:cSufijoInicio, oDesde:cSufijoInicio:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( oDesde:nRadio == 1 )},, .F., .F.,,,,,, nil,,, )





   TGetHlp():ReDefine( 150, { | u | If( PCount()==0, oDesde:cSufijoFin, oDesde:cSufijoFin:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( oDesde:nRadio == 1 )},, .F., .F.,,,,,, nil,,, )





   TGetHlp():ReDefine( 170, { | u | If( PCount()==0, oDesde:dFechaInicio, oDesde:dFechaInicio:= u ) }, oDlg,,,,,,,,, .F., {||     ( oDesde:nRadio == 2 )},, .F., .T.,,,,,, nil,,, )





   TGetHlp():ReDefine( 180, { | u | If( PCount()==0, oDesde:dFechaFin, oDesde:dFechaFin:= u ) }, oDlg,,,,,,,,, .F., {||     ( oDesde:nRadio == 2 )},, .F., .T.,,,,,, nil,,, )




   oBtnAceptar := TButton():ReDefine( 1, {||( DelStart( oDesde, oDlg, oBtnAceptar, oBtnCancel, oTxtDel, @lCancel ) )}, oDlg,,, .F.,,,, .F. )





   oBtnCancel := TButton():ReDefine( 2, {||( lCancel := .T., oDlg:end() )}, oDlg,,, .F.,,,, .T. )





   oTxtDel := TMeter():ReDefine( 160, { | u | If( PCount()==0, nTxtDel, nTxtDel:= u ) }, ( dbfFacRecT )->( OrdKeyCount() ), oDlg, .F.,,, .T.,,,, )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T., {|Self|( lCancel )},,, oDlg:bRClicked,,, )

   ( dbfFacRecT )->( dbGoTo( nRecNo ) )
   ( dbfFacRecT )->( ordSetFocus( nOrdAnt ) )

   oWndBrw:SetFocus()
   oWndBrw:Refresh()

RETURN NIL



STATIC FUNCTION DelStart( oDesde, oDlg, oBtnAceptar, oBtnCancel, oTxtDel, lCancel )

   local nOrd
   local nDeleted       := 0
   local nProcesed      := 0

   oBtnAceptar:Hide()
   oBtnCancel:bAction   := {|| lCancel := .T. }

   if oDesde:nRadio == 1

      nOrd              := ( dbfFacRecT )->( OrdSetFocus( "nNumFac" ) )

      ( dbfFacRecT )->( dbSeek( oDesde:cNumeroInicio(), .T. ) )
      while !lCancel .AND. ( dbfFacRecT )->( !eof() )






         if ( dbfFacRecT )->cSerie  >= oDesde:cSerieInicio  .AND. ( dbfFacRecT )->cSerie  <= oDesde:cSerieFin     .AND. ( dbfFacRecT )->nNumFac >= oDesde:nNumeroInicio .AND. ( dbfFacRecT )->nNumFac <= oDesde:nNumeroFin    .AND. ( dbfFacRecT )->cSufFac >= oDesde:cSufijoInicio .AND. ( dbfFacRecT )->cSufFac <= oDesde:cSufijoFin

            ++nDeleted

            oTxtDel:cText  := "Eliminando : " + ( dbfFacRecT )->cSerie + "/" + Alltrim( Str( ( dbfFacRecT )->nNumFac ) ) + "/" + ( dbfFacRecT )->cSufFac

            WinDelRec( nil, dbfFacRecT, {|| QuiFacRec() } )

         else

            ( dbfFacRecT )->( dbSkip() )

         end

         ++nProcesed

         oTxtDel:Set( nProcesed )

      end

      ( dbfFacRecT )->( OrdSetFocus( nOrd ) )

   else

      nOrd              := ( dbfFacRecT )->( OrdSetFocus( "dFecFac" ) )

      ( dbfFacRecT )->( dbSeek( oDesde:dFechaInicio, .T. ) )
      while !lCancel .AND. ( dbfFacRecT )->( !eof() )


         if ( dbfFacRecT )->dFecFac >= oDesde:dFechaInicio  .AND. ( dbfFacRecT )->dFecFac <= oDesde:dFechaFin

            ++nDeleted

            oTxtDel:cText  := "Eliminando : " + ( dbfFacRecT )->cSerie + "/" + Alltrim( Str( ( dbfFacRecT )->nNumFac ) ) + "/" + ( dbfFacRecT )->cSufFac

            WinDelRec( nil, dbfFacRecT, {|| QuiFacRec() } )

         else

            ( dbfFacRecT )->( dbSkip() )

         end

         ++nProcesed

         oTxtDel:Set( nProcesed )

      end

      ( dbfFacRecT )->( OrdSetFocus( nOrd ) )

   end

   lCancel              := .T.

   oBtnAceptar:Show()

   if lCancel
      msgStop( "Total de registros borrados : " + Str( nDeleted ), "Proceso cancelado" )
   else
      msgInfo( "Total de registros borrados : " + Str( nDeleted ), "Proceso finalizado" )
   end

RETURN ( oDlg:End() )



static function RecFacRec( aTmpFac )

   local nDtoAge  := 0
   local nImpAtp  := 0
   local nImpOfe  := 0
   local cCodFam
   local nRecno




   if !ApoloMsgNoYes(  "¡Atención!,"                                      + Chr(13)+Chr(10) +  "todos los precios se recalcularán en función de"  + Chr(13)+Chr(10) +  "los valores en las bases de datos.", "¿Desea proceder?" )
      return nil
   end

   nRecno         := ( dbfTmpLin )->( RecNo() )

   ( dbfTmpLin )->( dbGotop() )
   ( dbfArticulo )->( ordSetFocus( "CODIGO" ) )

   while !( dbfTmpLin )->( eof() )





      if ( dbfArticulo )->( dbSeek( ( dbfTmpLin )->cRef ) )

         if aTmpFac[63] <= 1
            ( dbfTmpLin )->nIva     := nIva( dbfIva, ( dbfArticulo )->TipoIva )
            ( dbfTmpLin )->nReq     := nReq( dbfIva, ( dbfArticulo )->TipoIva )
         end





         if !Empty( ( dbfArticulo )->cCodImp )
            ( dbfTmpLin )->cCodImp  := ( dbfArticulo )->cCodImp
            ( dbfTmpLin )->nValImp  := oNewImp:nValImp( ( dbfArticulo )->cCodImp, aTmpFac[ 56 ], ( dbfTmpLin )->nIva )
         end





         ( dbfTmpLin )->nPreUnit    := nRetPreArt( ( dbfTmpLin )->nTarLin, aTmpFac[ 58 ], aTmpFac[ 56 ], dbfArticulo, dbfDiv, dbfKit, dbfIva )





         ( dbfTmpLin )->nPntVer  := ( dbfArticulo )->nPntVer1





         ( dbfTmpLin )->nCtlStk     := ( dbfArticulo )->nCtlStock
         ( dbfTmpLin )->nCosDiv     := nCosto( nil, dbfArticulo, dbfKit )
         ( dbfTmpLin )->nPvpRec     := ( dbfArticulo )->PvpRec





         ( dbfTmpLin )->nComAge     := aTmpFac[ 23 ]

         cCodFam                    := ( dbfArticulo )->Familia





         do case

         case lSeekAtpArt( aTmpFac[ 6 ] + ( dbfTmpLin )->cRef, ( dbfTmpLin )->cCodPr1 + ( dbfTmpLin )->cCodPr2, ( dbfTmpLin )->cValPr1 + ( dbfTmpLin )->cValPr2, aTmpFac[ 5 ], dbfClientAtp ) .AND.  ( dbfClientAtp )->lAplFac

            nImpAtp  := nImpAtp( ( dbfTmpLin )->nTarLin, dbfClientAtp )
            if nImpAtp <> 0
               ( dbfTmpLin )->nPreUnit := nImpAtp
            end

            nImpAtp  := nDtoAtp( ( dbfTmpLin )->nTarLin, dbfClientAtp )
            if nImpAtp <> 0
               ( dbfTmpLin )->nDto     := nImpAtp
            end

            if ( dbfClientAtp )->nDprArt <> 0
               ( dbfTmpLin )->nDtoPrm  := ( dbfClientAtp )->nDprArt
            end

            if ( dbfClientAtp )->nComAge <> 0
               ( dbfTmpLin )->nComAge  := ( dbfClientAtp )->nComAge
            end

            if ( dbfClientAtp )->nDtoDiv <> 0
               ( dbfTmpLin )->nDtoDiv  := ( dbfClientAtp )->nDtoDiv
            end




         case lSeekAtpFam( aTmpFac[6] + cCodFam, dbfClientAtp )                                      .AND.  ( dbfClientAtp )->lAplFac                                                                    .AND.  ( ( dbfClientAtp )->DFECINI <= aTmpFac[ 5 ] .OR. Empty( ( dbfClientAtp )->DFECINI ) ) .AND.  ( ( dbfClientAtp )->DFECFIN >= aTmpFac[ 5 ] .OR. Empty( ( dbfClientAtp )->DFECFIN ) )

            if ( dbfClientAtp )->nDtoArt <> 0
               ( dbfTmpLin )->nDto     := ( dbfClientAtp )->nDtoArt
            end

            if ( dbfClientAtp )->nDprArt <> 0
               ( dbfTmpLin )->nDtoPrm  := ( dbfClientAtp )->nDprArt
            end

            if ( dbfClientAtp )->nComAge <> 0
               ( dbfTmpLin )->nComAge  := ( dbfClientAtp )->nComAge
            end

            if ( dbfClientAtp )->nDtoDiv <> 0
               ( dbfTmpLin )->nDtoDiv  := ( dbfClientAtp )->nDtoDiv
            end





         case !Empty( aTmpFac[21] )

            nImpOfe     := RetPrcTar( ( dbfTmpLin )->cRef, aTmpFac[ 21 ], ( dbfTmpLin )->cCodPr1, ( dbfTmpLin )->cCodPr2, ( dbfTmpLin )->cValPr1, ( dbfTmpLin )->cValPr2, dbfTarPreL, ( dbfTmpLin )->nTarLin )
            if nImpOfe <> 0
               ( dbfTmpLin )->nPreUnit := nImpOfe
            end

            nImpOfe     := RetPctTar( ( dbfTmpLin )->cRef, cCodFam, aTmpFac[ 21 ], ( dbfTmpLin )->cCodPr1, ( dbfTmpLin )->cCodPr2, ( dbfTmpLin )->cValPr1, ( dbfTmpLin )->cValPr2, dbfTarPreL )
            if nImpOfe <> 0
               ( dbfTmpLin )->nDto     := nImpOfe
            end

            nImpOfe     := RetComTar( ( dbfTmpLin )->cRef, cCodFam, aTmpFac[ 21 ], ( dbfTmpLin )->cCodPr1, ( dbfTmpLin )->cCodPr2, ( dbfTmpLin )->cValPr1, ( dbfTmpLin )->cValPr2, aTmpFac[ 19 ], dbfTarPreL, dbfTarPreS )
            if nImpOfe  <> 0
               ( dbfTmpLin )->nComAge  := nImpOfe
            end






            nImpOfe     := RetDtoPrm( ( dbfTmpLin )->cRef, cCodFam, aTmpFac[ 21 ], ( dbfTmpLin )->cCodPr1, ( dbfTmpLin )->cCodPr2, ( dbfTmpLin )->cValPr1, ( dbfTmpLin )->cValPr2, aTmpFac[ 5 ], dbfTarPreL )
            if nImpOfe  <> 0
               ( dbfTmpLin )->nDtoPrm  := nImpOfe
            end





            nDtoAge     := RetDtoAge( ( dbfTmpLin )->cRef, cCodFam, aTmpFac[ 21 ], ( dbfTmpLin )->cCodPr1, ( dbfTmpLin )->cCodPr2, ( dbfTmpLin )->cValPr1, ( dbfTmpLin )->cValPr2, aTmpFac[ 5 ], aTmpFac[ 19 ], dbfTarPreL, dbfTarPreS )
            if nDtoAge  <> 0
               ( dbfTmpLin )->nComAge  := nDtoAge
            end

         end





         nImpOfe     := nImpOferta( ( dbfTmpLin )->cRef, aTmpFac[ 6 ], aTmpFac[ 79 ], ( dbfTmpLin )->nUniCaja, aTmpFac[ 5 ], dbfOferta, ( dbfTmpLin )->nTarLin, nil, ( dbfTmpLin )->cCodPr1, ( dbfTmpLin )->cCodPr2, ( dbfTmpLin )->cValPr1, ( dbfTmpLin )->cValPr2 )
         if nImpOfe  <> 0
            ( dbfTmpLin )->nPreUnit := nCnv2Div( nImpOfe, cDivEmp(), aTmpFac[ 58 ], dbfDiv )
         end





         nImpOfe     := nDtoOferta( ( dbfTmpLin )->cRef, aTmpFac[ 6 ], aTmpFac[ 79 ], ( dbfTmpLin )->nUniCaja, aTmpFac[ 5 ], dbfOferta, ( dbfTmpLin )->cCodPr1, ( dbfTmpLin )->cCodPr2, ( dbfTmpLin )->cValPr1, ( dbfTmpLin )->cValPr2 )
         if nImpOfe  <> 0
            ( dbfTmpLin )->nDtoPrm  := nImpOfe
         end

      end

      ( dbfTmpLin )->( dbSkip() )

   end

   ( dbfTmpLin )->( dbGoTo( nRecno ) )

return nil



FUNCTION aDocFacRec()

   local aDoc  := {}





   aAdd( aDoc, { "Empresa",         "EM" } )
   aAdd( aDoc, { "Factura Rec.",    "FR" } )
   aAdd( aDoc, { "Cliente",         "CL" } )
   aAdd( aDoc, { "Almacen",         "AL" } )
   aAdd( aDoc, { "Obras",           "OB" } )
   aAdd( aDoc, { "Rutas",           "RT" } )
   aAdd( aDoc, { "Agentes",         "AG" } )
   aAdd( aDoc, { "Divisas",         "DV" } )
   aAdd( aDoc, { "Formas de pago",  "PG" } )
   aAdd( aDoc, { "Transportistas",  "TR" } )

RETURN ( aDoc )



function aItmFacRec()

   local aItmFacRec  := {}

   aAdd( aItmFacRec, {"CSERIE"      ,"C",  1, 0, "Serie de la factura " ,                                "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NNUMFAC"     ,"N",  9, 0, "Número de la factura" ,                                "'999999999'",        "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CSUFFAC"     ,"C",  2, 0, "Sufijo de la factura" ,                                "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CTURFAC"     ,"C",  6, 0, "Sesión de la factura" ,                                "######",             "", "( cDbf )"} )
   aAdd( aItmFacRec, {"DFECFAC"     ,"D",  8, 0, "Fecha de la factura" ,                                 "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CCODCLI"     ,"C", 12, 0, "Código del cliente" ,                                  "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CCODALM"     ,"C",  3, 0, "Código de almacén" ,                                   "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CCODCAJ"     ,"C",  3, 0, "Código de caja" ,                                      "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CNOMCLI"     ,"C", 80, 0, "Nombre del cliente" ,                                  "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CDIRCLI"     ,"C",100, 0, "Domicilio del cliente" ,                               "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CPOBCLI"     ,"C", 25, 0, "Población del cliente" ,                               "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CPRVCLI"     ,"C", 20, 0, "Provincia del cliente" ,                               "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NCODPROV"    ,"N",  2, 0, "Número de provincia cliente" ,                         "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CPOSCLI"     ,"C", 15, 0, "Código postal del cliente" ,                           "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CDNICLI"     ,"C", 30, 0, "DNI/Cif del cliente" ,                                 "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"lModCli"     ,"L",  1, 0, "Lógico de modificar datos del cliente" ,               "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"LMAYOR"      ,"L",  1, 0, "Lógico de mayorista" ,                                 "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NTARIFA"     ,"N",  1, 0, "Tarifa de precio aplicada" ,                           "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CCODAGE"     ,"C",  3, 0, "Código del agente" ,                                   "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CCODRUT"     ,"C",  4, 0, "Código de la ruta" ,                                   "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CCODTAR"     ,"C",  5, 0, "Código de la tarifa" ,                                 "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CCODOBR"     ,"C", 10, 0, "Código de la obra" ,                                   "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NPCTCOMAGE"  ,"N",  6, 2, "Porcentaje de comisión del agente" ,                   "'@E 999,99'",        "", "( cDbf )"} )
   aAdd( aItmFacRec, {"LLIQUIDADA"  ,"L",  1, 0, "Lógico de la liquidación" ,                            "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"LCONTAB"     ,"L",  1, 0, "Lógico de la contabilización" ,                        "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"DFECENT"     ,"D",  8, 0, "Fecha de entrega" ,                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CSUFAC"      ,"C", 10, 0, "Su factura" ,                                          "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"LIMPALB"     ,"L",  1, 0, "Lógico si la factura se importó de albaranes" ,        "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CCONDENT"    ,"C",100, 0, "Condición de entrada" ,                                "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"MCOMENT"     ,"M", 10, 0, "Comentarios" ,                                         "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"MOBSERV"     ,"M", 10, 0, "Observaciones" ,                                       "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CCODPAGO"    ,"C",  2, 0, "Código del tipo de pago" ,                             "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NBULTOS"     ,"N",  3, 0, "Número de bultos" ,                                    "999,999",            "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NPORTES"     ,"N",  6, 0, "Valor del porte" ,                                     "cPorDivFac",         "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NIVAMAN"     ,"N",  6, 2, "Porcentaje de " + cImp() + " del gasto" ,              "'@EZ 999,99'",       "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NMANOBR"     ,"N", 16, 6, "Gastos" ,                                              "cPorDivFac",         "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CNUMFAC"     ,"C", 12, 0, "Número de factura" ,                                   "'@!'",               "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NTIPOFAC"    ,"N",  1, 0, "" ,                                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CDTOESP"     ,"C", 50, 0, "Descripción de porcentaje de descuento especial" ,     "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NDTOESP"     ,"N",  6, 2, "Porcentaje de descuento especial" ,                    "'@EZ 999,99'",       "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CDPP"        ,"C", 50, 0, "Descripción de porcentaje de descuento por pronto pago","",                  "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NDPP"        ,"N",  6, 2, "Porcentaje de descuento por pronto pago" ,             "'@EZ 999,99'",       "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CDTOUNO"     ,"C", 25, 0, "Descripción de porcentaje de descuento personalizado", "'@EZ 999,99'",       "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NDTOUNO"     ,"N",  6, 2, "Porcentaje de descuento por descuento personalizado" , "'@EZ 999,99'",       "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CDTODOS"     ,"C", 25, 0, "Descripción de porcentaje de descuento personalizado" ,"'@EZ 999,99'",       "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NDTODOS"     ,"N",  4, 1, "Porcentaje de descuento por descuento personalizado" , "'@EZ 999,99'",       "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NDTOCNT"     ,"N",  6, 2, "" ,                                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NDTORAP"     ,"N",  6, 2, "" ,                                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NDTOPUB"     ,"N",  6, 2, "" ,                                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NDTOPGO"     ,"N",  6, 2, "" ,                                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NDTOPTF"     ,"N",  7, 2, "" ,                                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NTIPOIVA"    ,"N",  1, 0, "" ,                                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NPORCIVA"    ,"N",  4, 1, "" ,                                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"LRECARGO"    ,"L",  1, 0, "Lógico para recargo" ,                                 "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CREMITIDO"   ,"C", 50, 0, "Campo de remitido" ,                                   "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"LIVAINC"     ,"L",  1, 0, cImp() + " incluido" ,                                  "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"LSNDDOC"     ,"L",  1, 0, "Lógico para documento enviado" ,                       "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CDIVFAC"     ,"C",  3, 0, "Código de la divisa" ,                                 "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NVDVFAC"     ,"N", 10, 4, "Cambio de la divisa" ,                                 "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CRETPOR"     ,"C",100, 0, "Retirado por" ,                                        "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CRETMAT"     ,"C", 20, 0, "Matrícula" ,                                           "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CNUMDOC"     ,"C", 13, 0, "" ,                                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NREGIVA"     ,"N",  1, 0, "Regimen de " + cImp() ,                                "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CCODPRO"     ,"C",  9, 0, "Código de proyecto en contabilidad" ,                  "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CDOCORG"     ,"C", 10, 0, "Número del documento origen" ,                         "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NNUMLIQ"     ,"N",  9, 0, "Número liquidación",                                   "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CSUFLIQ"     ,"C",  2, 0, "Sufijo de la liquidación",                             "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"NIMPLIQ"     ,"N", 16, 6, "Importe liquidación",                                  "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"DFECLIQ"     ,"D",  8, 0, "Fecha liquidación",                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cCodTrn"     ,"C",  9, 0, "Código del transportista" ,                            "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"nKgsTrn"     ,"N", 16, 6, "TARA del transportista" ,                              "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"lCloFac"     ,"L",  1, 0, "" ,                                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cAbnFac"     ,"C", 12, 0, "" ,                                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cAntFac"     ,"C", 12, 0, "Factura de anticipo" ,                                 "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"nPctRet"     ,"N",  6, 2, "Porcentaje de retención",                              "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cCodUsr"     ,"C",  3, 0, "Código de usuario",                                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"dFecCre"     ,"D",  8, 0, "Fecha de creación del documento",                      "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cTimCre"     ,"C",  5, 0, "Hora de creación del documento",                       "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cCodGrp"     ,"C",  4, 0, "Código de grupo de cliente" ,                          "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"lImprimido"  ,"L",  1, 0, "Lógico de imprimido" ,                                 "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"dFecImp"     ,"D",  8, 0, "Última fecha de impresión" ,                           "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cHorImp"     ,"C",  5, 0, "Hora de la última impresión" ,                         "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cCodDlg"     ,"C",  2, 0, "Código delegación" ,                                   "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cManObr"     ,"C",250, 0, "Literal de gastos" ,                                   "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cMotRec"     ,"C",250, 0, "Motivo de la factura rectificativa",                   "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cCauRec"     ,"C",250, 0, "Causa de la factura rectificativa",                    "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"CTLFCLI"     ,"C", 20, 0, "Teléfono del cliente" ,                                "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"nTotNet"     ,"N", 16, 6, "Total neto" ,                                          "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"nTotIva"     ,"N", 16, 6, "Total " + cImp() ,                                     "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"nTotReq"     ,"N", 16, 6, "Total recargo" ,                                       "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"nTotFac"     ,"N", 16, 6, "Total factura" ,                                       "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cBanco"      ,"C", 50, 0, "Nombre del banco del cliente" ,                        "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cEntBnc"     ,"C",  4, 0, "Entidad de la cuenta bancaria del cliente" ,           "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cSucBnc"     ,"C",  4, 0, "Sucursal de la cuenta bancaria del cliente" ,          "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cDigBnc"     ,"C",  2, 0, "Dígito de control de la cuenta bancaria del cliente" , "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"cCtaBnc"     ,"C", 10, 0, "Cuenta bancaria del cliente" ,                         "",                   "", "( cDbf )"} )
   aAdd( aItmFacRec, {"lOperPV"     ,"L",  1, 0, "Lógico para operar con punto verde" ,                  "",                   "", "( cDbf )", .T. } )

RETURN ( aItmFacRec )



function aCalFacRec()

   local aCalFacRec  := {}

   aAdd( aCalFacRec, { "nTotArt",                                                   "N", 16,  6, "Total artículos",             "cPicUndFac",  "" } )
   aAdd( aCalFacRec, { "nTotCaj",                                                   "N", 16,  6, "Total cajas",                 "cPicUndFac",  "" } )
   aAdd( aCalFacRec, { "aTotIva[1,1]",                                              "N", 16,  6, "Bruto primer tipo de " + cImp(),    "cPorDivFac",  "!Empty( aTotIva[1,1] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "aTotIva[2,1]",                                              "N", 16,  6, "Bruto segundo tipo de " + cImp(),   "cPorDivFac",  "!Empty( aTotIva[2,1] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "aTotIva[3,1]",                                              "N", 16,  6, "Bruto tercer tipo de " + cImp(),    "cPorDivFac",  "!Empty( aTotIva[3,1] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "aTotIva[1,2]",                                              "N", 16,  6, "Base primer tipo de " + cImp(),     "cPorDivFac",  "!Empty( aTotIva[1,2] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "aTotIva[2,2]",                                              "N", 16,  6, "Base segundo tipo de " + cImp(),    "cPorDivFac",  "!Empty( aTotIva[2,2] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "aTotIva[3,2]",                                              "N", 16,  6, "Base tercer tipo de " + cImp(),     "cPorDivFac",  "!Empty( aTotIva[3,2] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "aTotIva[1,3]",                                              "N",  5,  2, "Porcentaje primer tipo " + cImp(),  "'@R 99.99%'", "!Empty( aTotIva[1,3] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "aTotIva[2,3]",                                              "N",  5,  2, "Porcentaje segundo tipo " + cImp(), "'@R 99.99%'", "!Empty( aTotIva[2,3] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "aTotIva[3,3]",                                              "N",  5,  2, "Porcentaje tercer tipo " + cImp(),  "'@R 99.99%'", "!Empty( aTotIva[3,3] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "aTotIva[1,4]",                                              "N",  5,  2, "Porcentaje primer tipo RE",   "'@R 99.99%'", "!Empty( aTotIva[1,4] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "aTotIva[2,4]",                                              "N",  5,  2, "Porcentaje segundo tipo RE",  "'@R 99.99%'", "!Empty( aTotIva[2,4] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "aTotIva[3,4]",                                              "N",  5,  2, "Porcentaje tercer tipo RE",   "'@R 99.99%'", "!Empty( aTotIva[3,4] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "round( aTotIva[1,2] * aTotIva[1,3] / 100, nDouDivFac )",    "N", 16,  6, "Importe primer tipo " + cImp(),     "cPorDivFac",  "!Empty( aTotIva[1,2] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "round( aTotIva[2,2] * aTotIva[2,3] / 100, nDouDivFac )",    "N", 16,  6, "Importe segundo tipo " + cImp(),    "cPorDivFac",  "!Empty( aTotIva[2,2] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "round( aTotIva[3,2] * aTotIva[3,3] / 100, nDouDivFac )",    "N", 16,  6, "Importe tercer tipo " + cImp(),     "cPorDivFac",  "!Empty( aTotIva[3,2] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "round( aTotIva[1,2] * aTotIva[1,4] / 100, nDouDivFac )",    "N", 16,  6, "Importe primer RE",           "cPorDivFac",  "!Empty( aTotIva[1,2] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "round( aTotIva[2,2] * aTotIva[2,4] / 100, nDouDivFac )",    "N", 16,  6, "Importe segundo RE",          "cPorDivFac",  "!Empty( aTotIva[2,2] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "round( aTotIva[3,2] * aTotIva[3,4] / 100, nDouDivFac )",    "N", 16,  6, "Importe tercer RE",           "cPorDivFac",  "!Empty( aTotIva[3,2] ) .and. lEnd" } )
   aAdd( aCalFacRec, { "nTotBrt",                                                   "N", 16,  6, "Total bruto",                 "cPorDivFac",  "lEnd" }                              )
   aAdd( aCalFacRec, { "nTotDto",                                                   "N", 16,  6, "Total descuento",             "cPorDivFac",  "lEnd" }                              )
   aAdd( aCalFacRec, { "nTotDpp",                                                   "N", 16,  6, "Total descuento pronto pago", "cPorDivFac",  "lEnd" }                              )
   aAdd( aCalFacRec, { "nTotNet",                                                   "N", 16,  6, "Total neto",                  "cPorDivFac",  "lEnd" }                              )
   aAdd( aCalFacRec, { "nTotUno",                                                   "N", 16,  6, "Total primer descuento definible", "cPorDivFac",  "lEnd" }                         )
   aAdd( aCalFacRec, { "nTotDos",                                                   "N", 16,  6, "Total segundo descuento definible", "cPorDivFac",  "lEnd" }                        )
   aAdd( aCalFacRec, { "nTotIva",                                                   "N", 16,  6, "Total " + cImp(),                   "cPorDivFac",  "lEnd" }                              )
   aAdd( aCalFacRec, { "nTotReq",                                                   "N", 16,  6, "Total RE",                    "cPorDivFac",  "lEnd" }                              )
   aAdd( aCalFacRec, { "nTotFac",                                                   "N", 16,  6, "Total factura",               "cPorDivFac",  "lEnd" }                              )
   aAdd( aCalFacRec, { "nTotRet",                                                   "N", 16,  6, "Total retención",             "cPorDivFac",  "lEnd" }                              )
   aAdd( aCalFacRec, { "nTotPage",                                                  "N", 16,  6, "Total página",                "cPorDivFac",  "!lEnd" }                             )
   aAdd( aCalFacRec, { "nImpEuros( nTotFac, (cDbf)->cDivFac, cDbfDiv )",            "N", 16,  6, "Total factura (Euros)",       "",             "lEnd" }                             )
   aAdd( aCalFacRec, { "nImpPesetas( nTotFac, (cDbf)->cDivFac, cDbfDiv )",          "N", 16,  6, "Total factura (Pesetas)",     "",             "lEnd" }                             )
   aAdd( aCalFacRec, { "nTotCob",                                                   "N", 16,  6, "Total cobrado",               "cPorDivFac",   "lEnd" }                             )
   aAdd( aCalFacRec, { "nPagina",                                                   "N",  2,  0, "Número de página",            "'99'",         "" }                                 )
   aAdd( aCalFacRec, { "lEnd",                                                      "L",  1,  0, "Fin del documento",           "",             "" }                                 )
   aAdd( aCalFacRec, { "nTotPes",                                                   "N", 16,  6, "Total peso",                  "'@E 99,999.99'","lEnd" }                            )
   aAdd( aCalFacRec, { "aDatVto[ 1 ]",                                              "D",  8,  0, "Fecha del primer vencimiento","",             "!Empty( aDatVto ) .and. len( aDatVto ) >= 1 .and. lEnd" } )
   aAdd( aCalFacRec, { "aDatVto[ 2 ]",                                              "D",  8,  0, "Fecha del segundo vencimiento","",            "!Empty( aDatVto ) .and. len( aDatVto ) >= 2 .and. lEnd" } )
   aAdd( aCalFacRec, { "aDatVto[ 3 ]",                                              "D",  8,  0, "Fecha del tercer vencimiento","",             "!Empty( aDatVto ) .and. len( aDatVto ) >= 3 .and. lEnd" } )
   aAdd( aCalFacRec, { "aDatVto[ 4 ]",                                              "D",  8,  0, "Fecha del cuarto vencimiento","",             "!Empty( aDatVto ) .and. len( aDatVto ) >= 4 .and. lEnd" } )
   aAdd( aCalFacRec, { "aDatVto[ 5 ]",                                              "D",  8,  0, "Fecha del quinto vencimiento","",             "!Empty( aDatVto ) .and. len( aDatVto ) >= 5 .and. lEnd" } )
   aAdd( aCalFacRec, { "aImpVto[ 1 ]",                                              "N", 16,  6, "Importe del primer vencimiento","cPorDivFac", "!Empty( aImpVto ) .and. len( aImpVto ) >= 1 .and. lEnd" } )
   aAdd( aCalFacRec, { "aImpVto[ 2 ]",                                              "N", 16,  6, "Importe del segundo vencimiento","cPorDivFac","!Empty( aImpVto ) .and. len( aImpVto ) >= 2 .and. lEnd" } )
   aAdd( aCalFacRec, { "aImpVto[ 3 ]",                                              "N", 16,  6, "Importe del tercero vencimiento","cPorDivFac","!Empty( aImpVto ) .and. len( aImpVto ) >= 3 .and. lEnd" } )
   aAdd( aCalFacRec, { "aImpVto[ 4 ]",                                              "N", 16,  6, "Importe del cuarto vencimiento","cPorDivFac", "!Empty( aImpVto ) .and. len( aImpVto ) >= 4 .and. lEnd" } )
   aAdd( aCalFacRec, { "aImpVto[ 5 ]",                                              "N", 16,  6, "Importe del quinto vencimiento","cPorDivFac", "!Empty( aImpVto ) .and. len( aImpVto ) >= 5 .and. lEnd" } )
   aAdd( aCalFacRec, { "aImpVto[ 5 ]",                                              "N", 16,  6, "Importe del quinto vencimiento","cPorDivFac", "!Empty( aImpVto ) .and. len( aImpVto ) >= 5 .and. lEnd" } )

return ( aCalFacRec )



function aColFacRec()

   local aColFacRec  := {}

   aAdd( aColFacRec, { "CSERIE"      ,"C",  1, 0, ""                                      , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NNUMFAC"     ,"N",  9, 0, ""                                      , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CSUFFAC"     ,"C",  2, 0, ""                                      , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CREF"        ,"C", 18, 0, "Referencia del artículo"               , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CDETALLE"    ,"C",250, 0, "Detalle del artículo"                  , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NPREUNIT"    ,"N", 16, 6, ""                                      , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NPNTVER"     ,"N", 16, 6, "Importe punto verde"                   , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "nImpTrn"     ,"N", 16, 6, "Importe de portes"                     , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NDTO"        ,"N",  6, 2, "Descuento"                             , "'@E 99,99'" ,   "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NDTOPRM"     ,"N",  6, 2, "Descuento promocional"                 , "'@E 99,99'" ,   "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NIVA"        ,"N",  6, 2, "Porcentaje de " + cImp()                     , "'@E 99,9'"  ,   "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NCANENT"     ,"N", 16, 6, "Cajas"                                 , "cPicUndFac" ,   "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "LCONTROL"    ,"L",  1, 0, ""                                      , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NPESOKG"     ,"N", 16, 6, "Peso del producto"                     , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CPESOKG"     ,"C",  2, 0, "Unidad de peso del producto"           , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CUNIDAD"     ,"C",  2, 0, "Unidades de venta"                     , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NCOMAGE"     ,"N",  6, 2, "Comisión del agente"                   , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NUNICAJA"    ,"N", 16, 6, "Unidades por caja"                     , "cPicUndFac" ,   "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NUNDKIT"     ,"N", 16, 6, "Unidades del producto kit"             , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "DFECHA"      ,"D",  8, 0, "Fecha de detalle"                      , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CTIPMOV"     ,"C",  2, 0, "Tipo de movimiento"                    , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "MLNGDES"     ,"M", 10, 0, "Descripción de artículo sin codificar" , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CCODALB"     ,"C", 12, 0, "Código del albarán de procedencia"     , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "DFECALB"     ,"D",  8, 0, "Fecha del albarán de procedencia"      , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "LTOTLIN"     ,"L",  1, 0, "Valor lógico para línea de total"      , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "LIMPLIN"     ,"L",  1, 0, "Valor lógico línea no imprimible"      , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CCODPR1"     ,"C", 10, 0, "Código de primera propiedad"           , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CCODPR2"     ,"C", 10, 0, "Código de segunda propiedad"           , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CVALPR1"     ,"C", 10, 0, "Valor de primera propiedad"            , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CVALPR2"     ,"C", 10, 0, "Valor de segunda propiedad"            , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NFACCNV"     ,"N", 16, 6, "Factor de conversión de la compra"     , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NDTODIV"     ,"N", 16, 6, "Descuento lineal de la compra"         , "'@EZ 99,99'" ,  "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "LSEL"        ,"L",  1, 0, ""                                      , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NNUMLIN"     ,"N",  4, 0, "Número de la línea"                    , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NCTLSTK"     ,"N",  1, 0, "Tipo de stock de la linea"             , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NCOSDIV"     ,"N", 16, 6, "Costo del producto"                    , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NPVPREC"     ,"N", 16, 6, "Precio de venta recomendado"           , "cPorDivFac" ,   "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CALMLIN"     ,"C",  3, 0, "Código de almacén"                     , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "LIVALIN"     ,"L",  1, 0, cImp() + " incluido"                          , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CCODIMP"     ,"C",  3, 0, "Código del impuesto especial"          , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NVALIMP"     ,"N", 16, 6, "Importe del impuesto especial"         , "cPorDivFac" ,   "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "LLOTE"       ,"L",  1, 0, ""                                      , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NLOTE"       ,"N",  9, 0, ""                                      , "'999999999'" ,  "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CLOTE"       ,"C", 12, 0, "Número de lote"                        , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "dFecCad"     ,"D",  8, 0, "Fecha de caducidad"                    , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "LKITART"     ,"L",  1, 0, "Línea con escandallo"                  , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "LKITCHL"     ,"L",  1, 0, "Línea pertenciente a escandallo"       , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "LKITPRC"     ,"L",  1, 0, ""                                      , "" ,             "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NMESGRT"     ,"N",  2, 0, "Meses de garantía"                     , "'99'",          "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "LNOTVTA"     ,"L",  1, 0, "No permitir venta sin stocks"          , "",              "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CCODTIP"     ,"C",  3, 0, "Código del tipo de artículo"           , "",              "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "MNUMSER"     ,"M", 10, 0, ""                                      , "",              "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CCODFAM"     ,"C", 16, 0, "Código de familia"                     , "",              "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CGRPFAM"     ,"C",  3, 0, "Código del grupo de familia"           , "",              "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "NREQ"        ,"N", 16, 6, "Recargo de equivalencia"               , "",              "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "MOBSLIN"     ,"M", 10, 0, "Observaciones de linea"                , "",              "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CCODPRV"     ,"C", 12, 0, "Código del proveedor"                  , "",              "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "CNOMPRV"     ,"C", 30, 0, "Nombre del proveedor"                  , "",              "", "( cDbfCol )"} )
   aAdd( aColFacRec, { "cImagen"     ,"C",128, 0, "Fichero de imagen"                     , "",              "", "( cDbfCol )", .T. } )
   aAdd( aColFacRec, { "NPUNTOS"     ,"N", 15, 6, "Puntos del artículo"                   , "",              "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "NVALPNT"     ,"N", 16, 6, "Valor del punto"                       , "",              "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "NDTOPNT"     ,"N",  5, 2, "Descuento puntos"                      , "",              "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "NINCPNT"     ,"N",  5, 2, "Incremento porcentual"                 , "",              "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "CREFPRV"     ,"C", 18, 0, "Referencia proveedor"                  , "",              "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "NVOLUMEN"    ,"N", 16, 6, "Volumen del producto"                  , "'@E 9,999.99'", "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "CVOLUMEN"    ,"C",  2, 0, "Unidad del volumen"                    , "",              "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "nNumMed"     ,"N",  1, 0, "Número de mediciones"                  ,"MasUnd()",       "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "nMedUno"     ,"N", 16, 6, "Primera unidad de medición"            ,"MasUnd()",       "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "nMedDos"     ,"N", 16, 6, "Segunda unidad de medición"            ,"MasUnd()",       "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "nMedTre"     ,"N", 16, 6, "Tercera unidad de medición"            ,"MasUnd()",       "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "nTarLin"     ,"N",  1, 0, "Tarifa de precio aplicada"             ,"",               "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "Descrip"     ,"M", 10, 0, "Descripción larga del artículo"        ,"",               "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "lLinOfe"     ,"L",  1, 0, "Linea con oferta"                      ,"",               "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "lVolImp"     ,"L",  1, 0, "Aplicar volumen impuestos especiales " ,"",               "", "( cDbfCol )" } )
   aAdd( aColFacRec, { "dFecFac"     ,"D",  8, 0, "Fecha de la factura rectificativa"     ,"" ,              "", "( cDbfCol )" } )

return ( aColFacRec )



function aCocFacRec()

   local aCocFacRec  := {}

   aAdd( aCocFacRec, {"( Descrip( cDbfCol ) )",                                 "C", 50, 0, "Detalle del artículo",              "",            "Descripción", "" } )
   aAdd( aCocFacRec, {"( nTotNFacRec( cDbfCol ) )",                             "N", 16, 6, "Total unidades artículo",           "MasUnd()",    "Unidades",    "" } )
   aAdd( aCocFacRec, {"( nTotUFacRec( cDbfCol, nDouDivFac ) )",                 "N", 16, 6, "Precio unitario del artículo",      "cPouDivFac",  "Precio",      "" } )
   aAdd( aCocFacRec, {"( nTotPFacRec( cDbfCol, nDouDivFac, nVdvDivFac ) )",     "N", 16, 6, "Precio unitario con descuentos",    "cPouDivFac",  "Precio neto", "" } )
   aAdd( aCocFacRec, {"( nPntUFacRec( cDbfCol, nDpvDivFac ) )",                 "N", 16, 6, "Punto verde del artículo",          "cPpvDivFac",  "Punto verde", "" } )
   aAdd( aCocFacRec, {"( nTotLFacRec( cDbfCol, nDouDivFac, nRouDivFac ) )",     "N", 16, 6, "Total línea del factura",           "cPorDivFac",  "Total",       "" } )
   aAdd( aCocFacRec, {"( nTotFFacRec( cDbfCol, nDouDivFac, nRouDivFac ) )",     "N", 16, 6, "Total final línea del factura ",    "cPorDivFac",  "Total neto",  "" } )
   aAdd( aCocFacRec, {"( nDtoLFacRec( cDbfCol, nDouDivFac, nVdvDivFac ) )",     "N", 16, 6, "Importe descuento línea del factura","cPouDivFac", "Dto.",        "" } )
   aAdd( aCocFacRec, {"( nTotDtoLFacRec( cDbfCol, nDouDivFac, nVdvDivFac ) )",  "N", 16, 6, "Total descuento línea del factura ","cPouDivFac",  "Total dto.",  "" } )

return ( aCocFacRec )



function aIncFacRec()

   local aIncFacRec  := {}

   aAdd( aIncFacRec, { "cSerie",  "C",    1,  0, "Serie de factura" ,              "",                   "", "( cDbfCol )" } )
   aAdd( aIncFacRec, { "nNumFac", "N",    9,  0, "Número de factura" ,             "'999999999'",        "", "( cDbfCol )" } )
   aAdd( aIncFacRec, { "cSufFac", "C",    2,  0, "Sufijo de factura" ,             "",                   "", "( cDbfCol )" } )
   aAdd( aIncFacRec, { "cCodTip", "C",    3,  0, "Tipo de incidencia" ,            "",                   "", "( cDbfCol )" } )
   aAdd( aIncFacRec, { "dFecInc", "D",    8,  0, "Fecha de la incidencia" ,        "",                   "", "( cDbfCol )" } )
   aAdd( aIncFacRec, { "mDesInc", "M",   10,  0, "Descripción de la incidencia" ,  "",                   "", "( cDbfCol )" } )
   aAdd( aIncFacRec, { "lListo",  "L",    1,  0, "Lógico de listo" ,               "",                   "", "( cDbfCol )" } )
   aAdd( aIncFacRec, { "lAviso",  "L",    1,  0, "Lógico de Aviso" ,               "",                   "", "( cDbfCol )" } )

return ( aIncFacRec )



function aFacRecDoc()

   local aFacRecDoc  := {}

   aAdd( aFacRecDoc, { "cSerFac", "C",    1,  0, "Serie de factura" ,                "",                   "", "( cDbfCol )" } )
   aAdd( aFacRecDoc, { "nNumFac", "N",    9,  0, "Número de factura" ,               "'999999999'",        "", "( cDbfCol )" } )
   aAdd( aFacRecDoc, { "cSufFac", "C",    2,  0, "Sufijo de factura" ,               "",                   "", "( cDbfCol )" } )
   aAdd( aFacRecDoc, { "cNombre", "C",  250,  0, "Nombre del documento" ,            "",                   "", "( cDbfCol )" } )
   aAdd( aFacRecDoc, { "cRuta",   "C",  250,  0, "Ruta del documento" ,              "",                   "", "( cDbfCol )" } )
   aAdd( aFacRecDoc, { "mObsDoc", "M",   10,  0, "Observaciones del documento" ,     "",                   "", "( cDbfCol )" } )

return ( aFacRecDoc )



function aSerFacRec()

   local aColFacRec  := {}

   aAdd( aColFacRec,  { "cSerFac",     "C",  1,   0, "",                                 "",                  "", "( cDbfCol )" } )
   aAdd( aColFacRec,  { "nNumFac",     "N",  9,   0, "",                                 "",                  "", "( cDbfCol )" } )
   aAdd( aColFacRec,  { "cSufFac",     "C",  2,   0, "",                                 "",                  "", "( cDbfCol )" } )
   aAdd( aColFacRec,  { "dFecFac",     "D",  8,   0, "",                                 "",                  "", "( cDbfCol )" } )
   aAdd( aColFacRec,  { "nNumLin",     "N",  4,   0, "Número de la línea",               "'9999'",            "", "( cDbfCol )" } )
   aAdd( aColFacRec,  { "cRef",        "C", 18,   0, "Referencia del artículo",          "",                  "", "( cDbfCol )" } )
   aAdd( aColFacRec,  { "cAlmLin",     "C",  3,   0, "Almacen del artículo",             "",                  "", "( cDbfCol )" } )
   aAdd( aColFacRec,  { "lUndNeg",     "L",  1,   0, "Lógico de unidades negativas",     "",                  "", "( cDbfCol )" } )
   aAdd( aColFacRec,  { "cNumSer",     "C", 30,   0, "Número de serie",                  "",                  "", "( cDbfCol )" } )

return ( aColFacRec )














































































































































































































































































































































































































function nTotRFacRec( cNumFac, dFecRes, cCodArt, cValPr1, cValPr2, cLote, dbfFacRecT, dbfFacRecL )

   local nTot        := 0
   local aStaFac     := aGetStatus( dbfFacRecT, .T. )
   local aStaLin     := aGetStatus( dbfFacRecL, .F. )

   IIF( cValPr1 == nil, cValPr1 := Space( 10 ), ) ;
   IIF( cValPr2 == nil, cValPr2 := Space( 10 ), ) ;

   ( dbfFacRecL )->( dbGoTop() )

   if ( dbfFacRecL )->( dbSeek( cNumFac ) )
      while ( dbfFacRecL )->cSerie + str( ( dbfFacRecL )->nNumFac, 9 ) + ( dbfFacRecL )->cSufFac == cNumFac .AND. !( dbfFacRecL )->( eof() )
         if ( dbfFacRecL )->cRef + ( dbfFacRecL )->cValPr1 + ( dbfFacRecL )->cValPr2 == cCodArt + cValPr1 + cValPr2
            if Empty( dFecRes ) .OR. dFecRes <= dFecFacRec( ( dbfFacRecL )->cSerFac + Str( ( dbfFacRecL )->nNumFac ) + ( dbfFacRecL )->cSufFac, dbfFacRecT )
               if ( dbfFacRecL )->nLote == cLote
                  nTot  += nTotNFacRec( dbfFacRecL )
               end
            end
         end
         ( dbfFacRecL )->( dbSkip() )
      end
   end

   SetStatus( dbfFacRecT, aStaFac )
   SetStatus( dbfFacRecL, aStaLin )

return ( nTot )



Static Function EdtRecMenu( aTmp, oDlg )

   oMenu := MenuBegin( .F.,,, .F., .F. )

      MenuAddItem( "&1. Rotor",, .F.,,,,,,,,, .F.,,, .F. )

         MenuBegin( .F.,,, .F., .F. )




            MenuAddItem( "&1. Modificar cliente", "Modifica la ficha del cliente", .F.,, {|oMenuItem|( if( !Empty( aTmp[ 6 ] ), EdtCli( aTmp[ 6 ] ), MsgStop( "Código de cliente vacío" ) ) )},, "User1_16",,,,, .F.,,, .F. )





            MenuAddItem( "&2. Informe de cliente", "Informe de cliente", .F.,, {|oMenuItem|( if( !Empty( aTmp[ 6 ] ), InfCliente( aTmp[ 6 ] ), MsgStop( "Código de cliente vacío" ) ) )},, "Info16",,,,, .F.,,, .F. )




            MenuAddItem( "&3. Modificar obra", "Modifica ficha de la obra", .F.,, {|oMenuItem|( if( !Empty( aTmp[ 22 ] ), EdtObras( aTmp[ 6 ], aTmp[ 22 ], dbfObrasT ), MsgStop( "Código de obra vacío" ) ) )},, "Worker16",,,,, .F.,,, .F. )
         MenuEnd()

   MenuEnd()

   oDlg:SetMenu( oMenu )

RETURN ( oMenu )



Static Function EndEdtRecMenu()

Return( oMenu:End() )



Static Function nEstadoIncidencia( cNumFac )

   local nEstado  := 0

   if ( dbfFacRecI )->( dbSeek( cNumFac ) )

      while ( dbfFacRecI )->cSerie + Str( ( dbfFacRecI )->nNumFac ) + ( dbfFacRecI )->cSufFac == cNumFac .AND. !( dbfFacRecI )->( Eof() )

         if ( dbfFacRecI )->lListo
            do case
               case nEstado == 0 .OR. nEstado == 3
                    nEstado := 3
               case nEstado == 1
                    nEstado := 2
            end
         else
            do case
               case nEstado == 0
                    nEstado := 1
               case nEstado == 3
                    nEstado := 2
            end
         end

         ( dbfFacRecI )->( dbSkip() )

      end

   end

Return ( nEstado )



STATIC FUNCTION cFacCli( aGet, aTmp, oBrw, oBrwiva, nMode )

   local aFacCliT
   local aFacCliL
   local cFactura    := aGet[ 37 ]:varGet()
   local nOption     := 0

   if nMode <> 1 .OR. Empty( cFactura )
      return .T.
   end

   aFacCliT          := aGetStatus( dbfFacCliT, .T. )
   aFacCliL          := aGetStatus( dbfFacCliL, .T. )

   if ( dbfFacCliT )->( dbSeek( cFactura ) )

      aGet[6 ]:cText( (dbfFacCliT)->cCodCli )
      aGet[6 ]:bWhen    := {|| .F. }
      aGet[6 ]:lValid()

      aGet[9 ]:cText( (dbfFacCliT)->cNomCli )
      aGet[10 ]:cText( (dbfFacCliT)->cDirCli )
      aGet[11 ]:cText( (dbfFacCliT)->cPobCli )
      aGet[12 ]:cText( (dbfFacCliT)->cPrvCli )
      aGet[14 ]:cText( (dbfFacCliT)->cPosCli )
      aGet[15 ]:cText( (dbfFacCliT)->cDniCli )

      aGet[7 ]:cText( ( dbfFacCliT )->cCodAlm )
      aGet[7 ]:lValid()

      aGet[8 ]:cText( ( dbfFacCliT )->cCodCaj )
      aGet[8 ]:lValid()

      aGet[32]:cText( ( dbfFacCliT )->cCodPago )
      aGet[32]:lValid()

      aGet[19 ]:cText( ( dbfFacCliT )->cCodAge )
      aGet[19 ]:lValid()

      aGet[21 ]:cText( ( dbfFacCliT )->cCodTar )
      aGet[21 ]:lValid()

      aGet[20 ]:cText( ( dbfFacCliT )->cCodRut )
      aGet[20 ]:lValid()

      aGet[22 ]:cText( ( dbfFacCliT )->cCodObr )
      aGet[22 ]:lValid()

      aGet[70 ]:cText( ( dbfFacCliT )->cCodTrn )
      aGet[70 ]:lValid()

      aGet[ 54 ]:Click( ( dbfFacCliT )->lRecargo )
      aGet[ 97  ]:Click( ( dbfFacCliT )->lOperPv )

      aGet[ 56 ]:Click( ( dbfFacCliT )->lIvaInc )

      aGet[ 92 ]:cText( ( dbfFacCliT )->cBanco )
      aGet[ 92 ]:lValid()

      aGet[ 93 ]:cText( ( dbfFacCliT )->cEntBnc )
      aGet[ 93 ]:lValid()

      aGet[ 94 ]:cText( ( dbfFacCliT )->cSucBnc )
      aGet[ 94 ]:lValid()

      aGet[ 95 ]:cText( ( dbfFacCliT )->cDigBnc )
      aGet[ 95 ]:lValid()

      aGet[ 96 ]:cText( ( dbfFacCliT )->cCtaBnc )
      aGet[ 96 ]:lValid()





      aGet[ 30 ]:cText( ( dbfFacCliT )->mComEnt )
      aTmp[ 31 ]  := ( dbfFacCliT )->mObsErv





      if Empty( ( dbfFacCliT )->cDtoEsp )
         aGet[ 39 ]:cText( "General" )
      else
         aGet[ 39 ]:cText( ( dbfFacCliT )->cDtoEsp )
      end

      if Empty( ( dbfFacCliT )->cDpp )
         aGet[ 41    ]:cText( "Pronto pago" )
      else
         aGet[ 41    ]:cText( ( dbfFacCliT )->cDpp )
      end

      aGet[ 40 ]:cText( ( dbfFacCliT )->nDtoEsp )
      aGet[ 42    ]:cText( ( dbfFacCliT )->nDpp    )
      aGet[ 43 ]:cText( ( dbfFacCliT )->cDtoUno )
      aGet[ 44 ]:cText( ( dbfFacCliT )->nDtoUno )
      aGet[ 45 ]:cText( ( dbfFacCliT )->cDtoDos )
      aGet[ 46 ]:cText( ( dbfFacCliT )->nDtoDos )
      aGet[ 84 ]:cText( ( dbfFacCliT )->cManObr )
      aGet[ 35 ]:cText( ( dbfFacCliT )->nIvaMan )
      aGet[ 36 ]:cText( ( dbfFacCliT )->nManObr )

      aTmp[ 79 ] := ( dbfFacCliT )->cCodGrp
      aTmp[ 16 ] := ( dbfFacCliT )->lModCli

      aTmp[ 97 ] := ( dbfFacCliT )->lOperPv





      nOption           := nImportaLineas()

      if nOption >= 1

         CursorWait()

         if ( dbfFacCliL )->( dbSeek( cFactura ) )

            while ( ( dbfFacCliL )->cSerie + Str( ( dbfFacCliL )->nNumFac ) + ( dbfFacCliL )->cSufFac == cFactura )

               if !( dbfFacCliL )->lTotLin  .AND. !( dbfFacCliL )->lControl

                  ( dbfTmpLin )->( dbAppend() )
                  ( dbfTmpLin )->cSerie     := " "
                  ( dbfTmpLin )->nNumFac    := 0
                  ( dbfTmpLin )->nNumLin    := ( dbfFacCliL )->nNumLin
                  ( dbfTmpLin )->cRef       := ( dbfFacCliL )->cRef
                  ( dbfTmpLin )->cDetalle   := ( dbfFacCliL )->cDetalle
                  ( dbfTmpLin )->mLngDes    := ( dbfFacCliL )->mLngDes
                  ( dbfTmpLin )->mNumSer    := ( dbfFacCliL )->mNumSer
                  ( dbfTmpLin )->nPreUnit   := ( dbfFacCliL )->nPreUnit
                  ( dbfTmpLin )->nPntVer    := ( dbfFacCliL )->nPntVer
                  ( dbfTmpLin )->nImpTrn    := ( dbfFacCliL )->nImpTrn
                  ( dbfTmpLin )->nCanEnt    := ( dbfFacCliL )->nCanEnt
                  ( dbfTmpLin )->cUnidad    := ( dbfFacCliL )->cUnidad
                  ( dbfTmpLin )->nUniCaja   := if( nOption == 2, ( ( dbfFacCliL )->nUniCaja * -1 ), ( dbfFacCliL )->nUniCaja )
                  ( dbfTmpLin )->nDto       := ( dbfFacCliL )->nDto
                  ( dbfTmpLin )->nDtoPrm    := ( dbfFacCliL )->nDtoPrm
                  ( dbfTmpLin )->nIva       := ( dbfFacCliL )->nIva
                  ( dbfTmpLin )->nReq       := ( dbfFacCliL )->nReq
                  ( dbfTmpLin )->nPesoKg    := ( dbfFacCliL )->nPesoKg
                  ( dbfTmpLin )->cPesoKg    := ( dbfFacCliL )->cPesoKg
                  ( dbfTmpLin )->nComAge    := ( dbfFacCliL )->nComAge
                  ( dbfTmpLin )->dFecha     := ( dbfFacCliL )->dFecha
                  ( dbfTmpLin )->cTipMov    := ( dbfFacCliL )->cTipMov
                  ( dbfTmpLin )->cCodAlb    := ( dbfFacCliL )->cSerie + Str( ( dbfFacCliL )->nNumFac ) + ( dbfFacCliL )->cSufFac
                  ( dbfTmpLin )->lTotLin    := ( dbfFacCliL )->lTotLin
                  ( dbfTmpLin )->nDtoDiv    := ( dbfFacCliL )->nDtoDiv
                  ( dbfTmpLin )->nCtlStk    := ( dbfFacCliL )->nCtlStk
                  ( dbfTmpLin )->cAlmLin    := ( dbfFacCliL )->cAlmLin
                  ( dbfTmpLin )->cTipMov    := ( dbfFacCliL )->cTipMov
                  ( dbfTmpLin )->lIvaLin    := ( dbfFacCliL )->lIvaLin
                  ( dbfTmpLin )->lImpLin    := ( dbfFacCliL )->lImpLin
                  ( dbfTmpLin )->nValImp    := ( dbfFacCliL )->nValImp
                  ( dbfTmpLin )->cCodImp    := ( dbfFacCliL )->cCodImp
                  ( dbfTmpLin )->cCodPr1    := ( dbfFacCliL )->cCodPr1
                  ( dbfTmpLin )->cCodPr2    := ( dbfFacCliL )->cCodPr2
                  ( dbfTmpLin )->cValPr1    := ( dbfFacCliL )->cValPr1
                  ( dbfTmpLin )->cValPr2    := ( dbfFacCliL )->cValPr2
                  ( dbfTmpLin )->nCosDiv    := ( dbfFacCliL )->nCosDiv
                  ( dbfTmpLin )->lKitArt    := ( dbfFacCliL )->lKitArt
                  ( dbfTmpLin )->lKitChl    := ( dbfFacCliL )->lKitChl
                  ( dbfTmpLin )->lKitPrc    := ( dbfFacCliL )->lKitPrc
                  ( dbfTmpLin )->nMesGrt    := ( dbfFacCliL )->nMesGrt
                  ( dbfTmpLin )->lLote      := ( dbfFacCliL )->lLote
                  ( dbfTmpLin )->nLote      := ( dbfFacCliL )->nLote
                  ( dbfTmpLin )->cLote      := ( dbfFacCliL )->cLote
                  ( dbfTmpLin )->lControl   := ( dbfFacCliL )->lControl
                  ( dbfTmpLin )->lNotVta    := ( dbfFacCliL )->lNotVta
                  ( dbfTmpLin )->cCodTip    := ( dbfFacCliL )->cCodTip
                  ( dbfTmpLin )->mObsLin    := ( dbfFacCliL )->mObsLin
                  ( dbfTmpLin )->Descrip    := ( dbfFacCliL )->Descrip
                  ( dbfTmpLin )->cCodPrv    := ( dbfFacCliL )->cCodPrv
                  ( dbfTmpLin )->cNomPrv    := ( dbfFacCliL )->cNomPrv
                  ( dbfTmpLin )->cImagen    := ( dbfFacCliL )->cImagen
                  ( dbfTmpLin )->cCodFam    := ( dbfFacCliL )->cCodFam
                  ( dbfTmpLin )->cGrpFam    := ( dbfFacCliL )->cGrpFam
                  ( dbfTmpLin )->nNumMed    := ( dbfFacCliL )->nNumMed
                  ( dbfTmpLin )->nMedUno    := ( dbfFacCliL )->nMedUno
                  ( dbfTmpLin )->nMedDos    := ( dbfFacCliL )->nMedDos
                  ( dbfTmpLin )->nMedTre    := ( dbfFacCliL )->nMedTre
                  ( dbfTmpLin )->lVolImp    := ( dbfFacCliL )->lVolImp
                  ( dbfTmpLin )->nVolumen   := ( dbfFacCliL )->nVolumen
                  ( dbfTmpLin )->lLinOfe    := ( dbfFacCliL )->lLinOfe
                  ( dbfTmpLin )->dFecCad    := ( dbfFacCliL )->dFecCad

               end

               ( dbfFacCliL )->( dbSkip() )

            end

         else

            MsgStop( "La factura no contiene líneas de detalle." )

         end

         ( dbfTmpLin )->( dbGoTop() )





         if ( dbfFacCliS )->( dbSeek( cFactura ) )

            while ( dbfFacCliS )->cSerFac + Str( ( dbfFacCliS )->nNumFac ) + ( dbfFacCliS )->cSufFac == cFactura .AND. !( dbfFacCliS )->( Eof() )

               ( dbfTmpSer )->( dbAppend() )
               ( dbfTmpSer )->nNumLin  := ( dbfFacCliS )->nNumLin
               ( dbfTmpSer )->cRef     := ( dbfFacCliS )->cRef
               ( dbfTmpSer )->cAlmLin  := ( dbfFacCliS )->cAlmLin
               ( dbfTmpSer )->cNumSer  := ( dbfFacCliS )->cNumSer

               ( dbfFacCliS )->( dbSkip() )

            end

         end

         CursorWE()

      end

      oBrw:SetFocus()
      oBrw:Refresh()

      oBrwIva:SetFocus()

   else

      MsgStop( "Factura : " + cFactura + " no encontrada" )

   end

   SetStatus( dbfFacCliT, aFacCliT )
   SetStatus( dbfFacCliL, aFacCliL )

RETURN .T.



Static Function DesgPnt( cCodArt, aTmp, nTarifa, oPreDiv, oCosDiv, nMode )

   local oDlg
   local oPuntos
   local oValorPunto
   local oDtoPnt
   local oIncPnt
   local oImporte
   local nPuntos     := 0
   local nValorPunto := 0
   local nDtoPnt     := 0
   local nIncPnt     := 0



   if Empty( cCodArt )
      MsgInfo( "Debe seleccinar un artículo", "Código vacío" )
      return .F.
   end



   nPuntos           := aTmp[ 60 ]
   nValorPunto       := aTmp[ 61 ]
   nDtoPnt           := aTmp[ 62 ]
   nIncPnt           := aTmp[ 63 ]

   oDlg = TDialog():New(,,,, "Desglose de puntos", "DESGPUNTOS",, .F.,,,,,, .F.,,,,,, .F., )







   oPuntos := TGetHlp():ReDefine( 200, { | u | If( PCount()==0, nPuntos, nPuntos:= u ) }, oDlg,, cPouDiv,,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( oImporte:Refresh() ) }, .F., .T.,,,,,, nil,,, )







   oValorPunto := TGetHlp():ReDefine( 210, { | u | If( PCount()==0, nValorPunto, nValorPunto:= u ) }, oDlg,, cPouDiv,,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( oImporte:Refresh() ) }, .F., .T.,,,,,, nil,,, )









   oDtoPnt := TGetHlp():ReDefine( 220, { | u | If( PCount()==0, nDtoPnt, nDtoPnt:= u ) }, oDlg,, "999.99",,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( oImporte:Refresh() ) }, .F., .T.,,, {||      0}, {||      100},, nil,,, )









   oIncPnt := TGetHlp():ReDefine( 230, { | u | If( PCount()==0, nIncPnt, nIncPnt:= u ) }, oDlg,, "999.99",,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( oImporte:Refresh() ) }, .F., .T.,,, {||      0}, {||      100},, nil,,, )





   oImporte := TSay():ReDefine( 240, {|| nCalculoPuntos( nPuntos, nValorPunto, nDtoPnt, nIncPnt )}, oDlg, cPouDiv, "N/W*",, .F.,, .F., .F. )





   TButton():ReDefine( 500, {||( EndDesgPnt( cCodArt, nTarifa, oPreDiv, oImporte, dbfArticulo, nDouDiv ), oDlg:end( 1 ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )




   TButton():ReDefine( 550, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| EndDesgPnt( cCodArt, nTarifa, oPreDiv, oImporte, dbfArticulo, nDouDiv ), oDlg:end( 1 ) } )
   end

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult == 1

      aTmp[ 60 ]     := nPuntos
      aTmp[ 61 ]     := nValorPunto
      aTmp[ 62 ]     := nDtoPnt
      aTmp[ 63 ]     := nIncPnt
      oCosDiv:cText( oImporte:VarGet() )
      oCosDiv:Refresh()

   end

Return ( .T. )



Function AppFacRec( cCodCli, cCodArt, lOpenBrowse )

   local nLevel         := nLevelUsr( "01082" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 2 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if FacRec( nil, nil, cCodCli, cCodArt )
         oWndBrw:RecAdd()
      end

   else

      if OpenFiles( .T. )
         WinAppRec( nil, bEdtRec, dbfFacRecT, cCodCli, cCodArt )
         CloseFiles()
      end

   end

RETURN .T.



Function EdtFacRec( cNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01082" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 4 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if FacRec()
         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacRecT )
            oWndBrw:RecEdit()
         else
            MsgStop( "No se encuentra factura" )
         end
      end

   else

      if OpenFiles( .T. )

         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacRecT )
            WinEdtRec( nil, bEdtRec, dbfFacRecT )
         end

         CloseFiles()

      end

   end

Return .T.



FUNCTION ZooFacRec( cNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01082" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 8 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if FacRec()
         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacRecT )
            oWndBrw:RecZoom()
         else
            MsgStop( "No se encuentra factura" )
         end
      end

   else

      if OpenFiles( .T. )
         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacRecT )
            WinZooRec( nil, bEdtRec, dbfFacRecT )
         end
         CloseFiles()
      end

   end

Return .T.



FUNCTION DelFacRec( cNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01082" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 16 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if FacRec()
         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacRecT )
            WinDelRec( nil, dbfFacRecT, {|| QuiFacRec() } )
         else
            MsgStop( "No se encuentra factura" )
         end
      end

   else

      if OpenFiles( .T. )

         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacRecT )
            WinDelRec( nil, dbfFacRecT, {|| QuiFacRec() } )
         end

         CloseFiles()

      end

   end

Return .T.



FUNCTION PrnFacRec( cNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01082" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 32 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if FacRec()
         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacRecT )
            GenFacRec( 1 )
         else
            MsgStop( "No se encuentra factura" )
         end
      end

   else

      if OpenFiles( .T. )

         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacRecT )
            GenFacRec( 1 )
         end

         CloseFiles()

      end

   end

Return .T.



FUNCTION VisFacRec( cNumFac, lOpenBrowse )

   local nLevel         := nLevelUsr( "01082" )

   IIF( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) <> 0 .OR. nAnd( nLevel, 32 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if lOpenBrowse

      if FacRec()
         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacRecT )
            GenFacRec( 2 )
         else
            MsgStop( "No se encuentra factura" )
         end
      end

   else

      if OpenFiles( .T. )

         if dbSeekInOrd( cNumFac, "nNumFac", dbfFacRecT )
            GenFacRec( 2 )
         end

         CloseFiles()

      end

   end

Return .T.



function SynFacRec( cPath )

   local oBlock
   local oError
   local aTotFac
   local cCodImp
   local cNumSer
   local aNumSer

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPath + "FacRecT.DBF" ), ( cCheckArea( "FacRecT", @dbfFacRecT ) ), if(.F. .OR. .T., !.T., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPath + "FacRecT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPath + "FacRecL.DBF" ), ( cCheckArea( "FacRecL", @dbfFacRecL ) ), if(.F. .OR. .T., !.T., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPath + "FacRecL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPath + "FacRecS.Dbf" ), ( cCheckArea( "FacRecS", @dbfFacRecS ) ), if(.F. .OR. .T., !.T., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPath + "FacRecS.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPath + "FacRecI.DBF" ), ( cCheckArea( "FacRecI", @dbfFacRecI ) ), if(.F. .OR. .T., !.T., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPath + "FacRecI.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FacCliP.DBF" ), ( cCheckArea( "FacCliP", @dbfFacCliP ) ), if(.F. .OR. .T., !.T., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FacCliP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      ( dbfFacCliP )->( OrdSetFocus( "rNumFac" ) )

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "FAMILIAS.DBF" ), ( cCheckArea( "FAMILIAS", @dbfFamilia ) ), if(.F. .OR. .T., !.T., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "FAMILIAS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatArt() + "ARTICULO.DBF" ), ( cCheckArea( "ARTICULO", @dbfArticulo ) ), if(.F. .OR. .T., !.T., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatArt() + "ARTICULO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIVA.DBF" ), ( cCheckArea( "TIVA", @dbfIva ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TIVA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "DIVISAS.DBF" ), ( cCheckArea( "DIVISAS", @dbfDiv ) ), if(.T. .OR. .F., !.F., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatDat() + "DIVISAS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "AntCliT.DBF" ), ( cCheckArea( "AntCliT", @dbfAntCliT ) ), if(.F. .OR. .T., !.T., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "AntCliT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatCli() + "Client.DBF" ), ( cCheckArea( "Client", @dbfClient ) ), if(.F. .OR. .T., !.T., NIL), .F.,, )
      if !lAIS() ; ordListAdd( ( cPatCli() + "Client.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      oNewImp        := TNewImp():Create( cPatEmp() )
      oNewImp:OpenFiles()

      while !( dbfFacRecT )->( eof() )

         if Empty( ( dbfFacRecT )->cCodCaj )
            ( dbfFacRecT )->cCodCaj    := "000"
         end

         if !( ( dbfFacRecT )->cSerie >= "A" .AND. ( dbfFacRecT )->cSerie <= "Z" )
            ( dbfFacRecT )->( dbDelete() )
         end





         if ( dbfFacRecT )->nTotFac == 0
            aTotFac                 := aTotFacRec( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, dbfFacRecT, dbfFacRecL, dbfIva, dbfDiv, ( dbfFacRecT )->cDivFac )
            ( dbfFacRecT )->nTotNet := aTotFac[1]
            ( dbfFacRecT )->nTotIva := aTotFac[2]
            ( dbfFacRecT )->nTotReq := aTotFac[3]
            ( dbfFacRecT )->nTotFac := aTotFac[4]
         end

         ( dbfFacRecT )->( dbSkip() )

      end

      while !( dbfFacRecL )->( eof() )

         if ( dbfFacRecT )->( dbSeek( ( dbfFacRecL )->cSerie + Str( ( dbfFacRecL )->nNumFac ) + ( dbfFacRecL )->cSufFac ) )

            if Empty( ( dbfFacRecL )->cLote ) .AND. !Empty( ( dbfFacRecL )->nLote )
               ( dbfFacRecL )->cLote         := AllTrim( Str( ( dbfFacRecL )->nLote ) )
            end

            if Empty( ( dbfFacRecL )->nValImp )
               cCodImp                       :=  RetFld( ( dbfFacRecL )->cRef, dbfArticulo, "cCodImp" )
               if !Empty( cCodImp )
                  ( dbfFacRecL )->nValImp    := oNewImp:nValImp( cCodImp )
               end
            end

            if Empty( ( dbfFacRecL )->nVolumen )
               ( dbfFacRecL )->nVolumen      :=  RetFld( ( dbfFacRecL )->cRef, dbfArticulo, "nVolumen" )
            end

            if !Empty( ( dbfFacRecL )->mNumSer )
               aNumSer                       := hb_aTokens( ( dbfFacRecL )->mNumSer, "," )
               for each cNumSer in aNumSer
                  ( dbfFacRecS )->( dbAppend() )
                  ( dbfFacRecS )->cSerFac    := ( dbfFacRecL )->cSerie
                  ( dbfFacRecS )->nNumFac    := ( dbfFacRecL )->nNumFac
                  ( dbfFacRecS )->cSufFac    := ( dbfFacRecL )->cSufFac
                  ( dbfFacRecS )->cRef       := ( dbfFacRecL )->cRef
                  ( dbfFacRecS )->cAlmLin    := ( dbfFacRecL )->cAlmLin
                  ( dbfFacRecS )->nNumLin    := ( dbfFacRecL )->nNumLin
                  ( dbfFacRecS )->cNumSer    := cNumSer
               next

               ( dbfFacRecL )->mNumSer       := ""
            end

         else

            ( dbfFacRecL )->( dbDelete() )

         end

         ( dbfFacRecL )->( dbSkip() )

         SysRefresh()

      end



      while !( dbfFacRecS )->( eof() )

         if !( dbfFacRecT )->( dbSeek( ( dbfFacRecS )->cSerFac + Str( ( dbfFacRecS )->nNumFac ) + ( dbfFacRecS )->cSufFac ) )

            ( dbfFacRecS )->( dbDelete() )

         else

            if ( dbfFacRecS )->dFecFac <> ( dbfFacRecT )->dFecFac
               ( dbfFacRecS )->dFecFac    := ( dbfFacRecT )->dFecFac
            end

         end

         ( dbfFacRecS )->( dbSkip() )

         SysRefresh()

      end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos de facturas rectificativas de clientes." + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfFacRecT  )->( dbCloseArea() )
   ( dbfFacRecL  )->( dbCloseArea() )
   ( dbfFacRecS  )->( dbCloseArea() )
   ( dbfFacRecI  )->( dbCloseArea() )
   ( dbfFacCliP  )->( dbCloseArea() )
   ( dbfAntCliT  )->( dbCloseArea() )
   ( dbfFamilia  )->( dbCloseArea() )
   ( dbfIva      )->( dbCloseArea() )
   ( dbfArticulo )->( dbCloseArea() )
   ( dbfDiv      )->( dbCloseArea() )
   ( dbfClient   )->( dbCloseArea() )

   if !Empty( oNewImp )
      oNewImp:end()
   end

   oNewImp              := nil

Return nil







FUNCTION nPagFacRec( cFactura, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfIva, dbfDiv, cDivRet, lOnlyCob, lPic )

   local cPorDiv
   local nRouDiv        := 2
   local nTotalPagado   := 0
   local cCodDiv        := cDivEmp()
   local nOrd
   local nRec

   IIF( lOnlyCob == nil, lOnlyCob := .T., ) ;
   IIF( lPic == nil, lPic := .F., ) ;





   cCodDiv              := ( dbfFacCliP )->cDivPgo
   cPorDiv              := cPorDiv( cCodDiv, dbfDiv )
   nRouDiv              := nRouDiv( cCodDiv, dbfDiv )

   if Empty( cFactura )

      nRec              := ( dbfFacCliP )->( Recno() )

      ( dbfFacCliP )->( dbGoTop() )
      while !( dbfFacCliP )->( Eof() )

         if ( lOnlyCob .AND. ( dbfFacCliP )->lCobrado .AND. !( dbfFacCliP )->lDevuelto ) .OR. ( !lOnlyCob .AND. !( dbfFacCliP )->lDevuelto )
            nTotalPagado+= ( dbfFacCliP )->nImporte
         end

         ( dbfFacCliP )->( dbSkip() )

      end

      ( dbfFacCliP )->( dbGoTo( nRec ) )

   else

      nRec              := ( dbfFacCliP )->( Recno() )
      nOrd              := ( dbfFacCliP )->( OrdSetFocus( "rNumFac" ) )

      if ( dbfFacCliP )->( dbSeek( cFactura ) )
         while ( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == cFactura )

            if ( lOnlyCob .AND. ( dbfFacCliP )->lCobrado .AND. !( dbfFacCliP )->lDevuelto ) .OR. ( !lOnlyCob .AND. !( dbfFacCliP )->lDevuelto )
               nTotalPagado   += ( dbfFacCliP )->nImporte
            end

            ( dbfFacCliP )->( dbSkip() )

         end
      end

      ( dbfFacCliP )->( OrdSetFocus( nOrd ) )
      ( dbfFacCliP )->( dbGoTo( nRec ) )

   end

   if cDivRet <> nil .AND. cCodDiv <> cDivRet
      nTotalPagado      := nCnv2Div( nTotalPagado, cCodDiv, cDivRet, dbfDiv )
      cPorDiv           := cPorDiv( cDivRet, dbfDiv )
      nRouDiv           := nRouDiv( cDivRet, dbfDiv )
   end

   nTotalPagado         := Round( nTotalPagado, nRouDiv )

   if lPic
      nTotalPagado      := Trans( nTotalPagado, cPorDiv )
   end

RETURN ( nTotalPagado )



Static Function EdtPgo( aTmp, aGet, dbfTmpPgo, oBrw, dbfDiv, oCtaRem, nMode, oBandera )

    local oDlg
   local oBmpDiv
   local oGetCli
   local oGetAge
   local oGetCaj
   local oGetSubCta
   local cGetSubCta
   local oGetCtaRem
   local cGetCtaRem
   local oGetSubGas
   local cGetSubGas
   local lPgdOld
   local nImpOld
   local cGetCli     := RetClient( ( dbfTmpPgo )->cCodCli, dbfClient )
   local cGetAge     := cNbrAgent( ( dbfTmpPgo )->cCodAge, dbfAgent )
   local cGetCaj     := RetFld( ( dbfTmpPgo )->cCodCaj, dbfCajT, "cNomCaj" )
   local cPorDiv     := cPorDiv( aTmp[ ( dbfTmpPgo )->( FieldPos( "cDivPgo" ) ) ], dbfDiv )



   if nMode == 2   .AND. aTmp[ ( dbfTmpPgo )->( FieldPos( "LCONPGO" ) ) ]     .AND. !ApoloMsgNoYes( "La modificación de este recibo puede provocar descuadres contables." + Chr(13)+Chr(10) + "¿ Desea continuar ?", "Recibo ya contabilizado" )
      return .F.
   end

   if nMode == 2
      if aTmp[ ( dbfTmpPgo )->( FieldPos( "lCloPgo" ) ) ] .AND. !oUser():lAdministrador()
         msgStop( "Solo pueden modificar los recibos cerrados los administradores." )
         return .F.
      end
   end

   if Empty( aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODCAJ" ) ) ] )
      aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODCAJ" ) ) ]   := oUser():cCaja()
   end

   lPgdOld              := ( dbfTmpPgo )->lCobrado .OR. ( dbfTmpPgo )->lRecDto
   nImpOld              := ( dbfTmpPgo )->nImporte

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "recibos de clientes", "PAGOS",, .F.,,,,,, .F.,,,,,, .F., )









      aGet[ ( dbfTmpPgo )->( FieldPos( "DPRECOB" ) ) ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "DPRECOB" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "DPRECOB" ) ) ]:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,, {|Self|aGet[ ( dbfTmpPgo )->( FieldPos( "DPRECOB" ) ) ]:cText( Calendario( aTmp[ ( dbfTmpPgo )->( FieldPos( "DPRECOB" ) ) ] ) )}, nil, "LUPA",, )









      aGet[ ( dbfTmpPgo )->( FieldPos( "DFECVTO" ) ) ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "DFECVTO" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "DFECVTO" ) ) ]:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,, {|Self|aGet[ ( dbfTmpPgo )->( FieldPos( "DFECVTO" ) ) ]:cText( Calendario( aTmp[ ( dbfTmpPgo )->( FieldPos( "DFECVTO" ) ) ] ) )}, nil, "LUPA",, )








      aGet[ ( dbfTmpPgo )->( FieldPos( "CCODCLI" ) ) ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODCLI" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODCLI" ) ) ]:= u ) }, oDlg,,, {||    ( cClient( aGet[ ( dbfTmpPgo )->( FieldPos( "CCODCLI" ) ) ], dbfClient, oGetCli ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwClient( aGet[ ( dbfTmpPgo )->( FieldPos( "CCODCLI" ) ) ], oGetCli ) )}, nil, "LUPA",, )




      oGetCli := TGetHlp():ReDefine( 121, { | u | If( PCount()==0, cGetCli, cGetCli:= u ) }, oDlg,,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )








      aGet[ ( dbfTmpPgo )->( FieldPos( "CCODAGE" ) ) ] := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODAGE" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODAGE" ) ) ]:= u ) }, oDlg,,, {||    ( cAgentes( aGet[ ( dbfTmpPgo )->( FieldPos( "CCODAGE" ) ) ], dbfAgent, oGetAge ) )},,,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwAgentes( aGet[ ( dbfTmpPgo )->( FieldPos( "CCODAGE" ) ) ], oGetAge ) )}, nil, "LUPA",, )




      oGetAge := TGetHlp():ReDefine( 131, { | u | If( PCount()==0, cGetAge, cGetAge:= u ) }, oDlg,,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )





      aGet[ ( dbfTmpPgo )->( FieldPos( "CDESCRIP" ) ) ] := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CDESCRIP" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CDESCRIP" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ ( dbfTmpPgo )->( FieldPos( "CPGDOPOR" ) ) ] := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CPGDOPOR" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CPGDOPOR" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ ( dbfTmpPgo )->( FieldPos( "CDOCPGO" ) ) ] := TGetHlp():ReDefine( 155, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CDOCPGO" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CDOCPGO" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      aGet[ ( dbfTmpPgo )->( FieldPos( "LRECIMP" ) ) ] := TCheckBox():ReDefine( 160, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "LRECIMP" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "LRECIMP" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||         ( nMode <> 3 )}, .F. )










      aGet[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ] := TGetHlp():ReDefine( 170, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ]:= u ) }, oDlg,, "@!", {||    ( cDivOut( aGet[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ], oBmpDiv, aGet[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ], nil, nil, @cPorDiv, nil, nil, nil, nil, dbfDiv, oBandera ) )}, "N/W*",,,,, .F., {||     ( .F. )},, .F., .F.,,,,, {|Self|BrwDiv( aGet[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ], oBmpDiv, aGet[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ], dbfDiv, oBandera )}, nil, "LUPA",, )




        oBmpDiv := TBitmap():ReDefine( 171, "BAN_EURO",, oDlg,,, .F., .F.,,, .F.,,, .F. )








      aGet[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ] := TGetHlp():ReDefine( 172, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ]:= u ) }, oDlg,, "@E 999,999.9999", {||    ( aTmp[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ] > 0 )}, "N/W*",,,,, .F., {||        ( .F. )},, .F., .F.,,,,,, nil,,, )








      aGet[ ( dbfTmpPgo )->( FieldPos( "NIMPORTE" ) ) ] := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "NIMPORTE" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "NIMPORTE" ) ) ]:= u ) }, oDlg,, ( cPorDiv ), {||    ( aGet[ ( dbfTmpPgo )->( FieldPos( "NIMPCOB" ) ) ]:cText( aTmp[ ( dbfTmpPgo )->( FieldPos( "NIMPORTE" ) ) ] ), .T. )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )








      aGet[ ( dbfTmpPgo )->( FieldPos( "NIMPCOB" ) ) ] := TGetHlp():ReDefine( 190, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "NIMPCOB" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "NIMPCOB" ) ) ]:= u ) }, oDlg,, ( cPorDiv ), {||    ( ValCobro( aGet, aTmp ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )







      aGet[ ( dbfTmpPgo )->( FieldPos( "NIMPGAS" ) ) ] := TGetHlp():ReDefine( 260, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "NIMPGAS" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "NIMPGAS" ) ) ]:= u ) }, oDlg,, ( cPorDiv ),, "N/W*",,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )





      aGet[ ( dbfTmpPgo )->( FieldPos( "lNotArqueo" ) ) ] := TCheckBox():ReDefine( 200, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "lNotArqueo" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "lNotArqueo" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||         ( nMode <> 3 )}, .F. )






      aGet[ ( dbfTmpPgo )->( FieldPos( "LCOBRADO" ) ) ] := TCheckBox():ReDefine( 220, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "LCOBRADO" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "LCOBRADO" ) ) ]:= u ) }, oDlg,, {||( ValCheck( aGet, aTmp ) )},,,,, .F., {||         ( nMode <> 3 )}, .F. )









      aGet[ ( dbfTmpPgo )->( FieldPos( "DENTRADA" ) ) ] := TGetHlp():ReDefine( 230, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "DENTRADA" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "DENTRADA" ) ) ]:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,, {|Self|aGet[ ( dbfTmpPgo )->( FieldPos( "DENTRADA" ) ) ]:cText( Calendario( aTmp[ ( dbfTmpPgo )->( FieldPos( "DENTRADA" ) ) ] ) )}, nil, "LUPA",, )










      aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ] := TGetHlp():ReDefine( 240, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ]:= u ) }, oDlg,, ( Replicate( "X", nLenSubcuentaContaplus() ) ), {||    ( MkSubCta( aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ], nil, oGetSubCta ) )}, "N/W*",,,,, .F., {||     ( nLenCuentaContaplus() <> 0 .AND. nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwChkSubCta( aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ], oGetSubCta ) )}, nil, "LUPA",, )





        oGetSubCta := TGetHlp():ReDefine( 241, { | u | If( PCount()==0, cGetSubCta, cGetSubCta:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )










      aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAGAS" ) ) ] := TGetHlp():ReDefine( 270, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CCTAGAS" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CCTAGAS" ) ) ]:= u ) }, oDlg,, ( Replicate( "X", nLenSubcuentaContaplus() ) ), {||    ( MkSubCta( aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAGAS" ) ) ], nil, oGetSubGas ) )}, "N/W*",,,,, .F., {||     ( nLenCuentaContaplus() <> 0 .AND. nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwChkSubCta( aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAGAS" ) ) ], oGetSubGas ) )}, nil, "LUPA",, )





      oGetSubGas := TGetHlp():ReDefine( 271, { | u | If( PCount()==0, cGetSubGas, cGetSubGas:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )








      aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAREM" ) ) ] := TGetHlp():ReDefine( 250, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CCTAREM" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CCTAREM" ) ) ]:= u ) }, oDlg,,, {||    ( oGetCtaRem:cText( retFld( aTmp[ ( dbfTmpPgo )->( FieldPos( "CCTAREM" ) ) ], oCtaRem:GetAlias() ) ), .T. )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oCtaRem:Buscar( aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAREM" ) ) ] ) )}, nil, "LUPA",, )





      oGetCtaRem := TGetHlp():ReDefine( 251, { | u | If( PCount()==0, cGetCtaRem, cGetCtaRem:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||         .F.},, .F., .F.,,,,,, nil,,, )












      aGet[ ( dbfTmpPgo )->( FieldPos( "CCODCAJ" ) ) ] := TGetHlp():ReDefine( 280, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODCAJ" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODCAJ" ) ) ]:= u ) }, oDlg,,, {||    cCajas( aGet[ ( dbfTmpPgo )->( FieldPos( "CCODCAJ" ) ) ], dbfCajT, oGetCaj )},,,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwCajas( aGet[ ( dbfTmpPgo )->( FieldPos( "CCODCAJ" ) ) ], oGetCaj ) )}, nil, "LUPA",, )




      oGetCaj := TGetHlp():ReDefine( 281, { | u | If( PCount()==0, cGetCaj, cGetCaj:= u ) }, oDlg,,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )













      aGet[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ] := TGetHlp():ReDefine( 310, { | u | If( PCount()==0, aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ]:= u ) }, oDlg,,, {||    ( oBanco:Existe( aGet[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ], aGet[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ]:oHelpText, "cNomBnc", .T., .T., "0" ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oBanco:Buscar( aGet[ ( dbfTmpPgo )->( FieldPos( "CCODBNC" ) ) ] ) )}, nil, "LUPA",, 311 )









      TButton():ReDefine( 1, {||( EndPgo( aTmp, aGet, lPgdOld, nImpOld, dbfTmpPgo, oBrw, oDlg, nMode ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( oDlg:End() )}, oDlg,,, .F.,,,, .T. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| EndPgo( aTmp, aGet, lPgdOld, nImpOld, dbfTmpPgo, oBrw, oDlg, nMode ) } )
   end






   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|(  aGet[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ]:lValid(), aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAREC" ) ) ]:lValid(), aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAGAS" ) ) ]:lValid(), aGet[ ( dbfTmpPgo )->( FieldPos( "CCTAREM" ) ) ]:lValid(), aGet[ ( dbfTmpPgo )->( FieldPos( "DPRECOB" ) ) ]:SetFocus() )}, oDlg:bRClicked,,, )

   oBmpDiv:End()

RETURN ( oDlg:nResult == 1 )



Static Function EndPgo( aTmp, aGet, lPgdOld, nImpOld, dbfTmpPgo, oBrw, oDlg, nMode )

   local nImp
   local nCon
   local nRec        := ( dbfTmpPgo )->( Recno() )
   local lImpNeg     := ( dbfTmpPgo )->nImporte < 0
   local nImpTmp     := abs( aTmp[ ( dbfTmpPgo )->( FieldPos( "nImporte" ) ) ] )
   local nImpFld     := abs( ( dbfTmpPgo )->nImporte )

   if !aGet[ ( dbfTmpPgo )->( FieldPos( "nImpCob" ) ) ]:lValid()
      return .F.
   end





   if nImpTmp > nImpFld
      msgStop( "El importe no puede ser superior al actual." )
      return nil
   end

   oDlg:Disable()





   if lPgdOld
      AddRiesgo( nImpOld, aTmp[ ( dbfTmpPgo )->( FieldPos( "cCodCli" ) ) ], dbfClient )
   end





   if aTmp[ ( dbfTmpPgo )->( FieldPos( "lCobrado" ) ) ] .OR. aTmp[ ( dbfTmpPgo )->( FieldPos( "lRecDto" ) ) ]
      DelRiesgo( aTmp[ ( dbfTmpPgo )->( FieldPos( "nImporte" ) ) ], aTmp[ ( dbfTmpPgo )->( FieldPos( "cCodCli" ) ) ], dbfClient )
   end





   if nImpFld <> nImpTmp





      nImp                       := ( nImpFld - nImpTmp ) * if( lImpNeg, - 1 , 1 )





      ( dbfTmpPgo )->( dbAppend() )
      nCon                       := ( dbfTmpPgo )->( Recno() )
      ( dbfTmpPgo )->cSerie      := aTmp[ ( dbfTmpPgo )->( FieldPos( "CSERIE"  ) ) ]
      ( dbfTmpPgo )->nNumFac     := aTmp[ ( dbfTmpPgo )->( FieldPos( "NNUMFAC" ) ) ]
      ( dbfTmpPgo )->cSufFac     := aTmp[ ( dbfTmpPgo )->( FieldPos( "CSUFFAC" ) ) ]
      ( dbfTmpPgo )->nNumRec     := nCon
      ( dbfTmpPgo )->cTipRec     := "R"
      ( dbfTmpPgo )->cCodCaj     := aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODCAJ" ) ) ]
      ( dbfTmpPgo )->cCodCli     := aTmp[ ( dbfTmpPgo )->( FieldPos( "CCODCLI" ) ) ]
      ( dbfTmpPgo )->dEntrada    := Ctod( "" )
      ( dbfTmpPgo )->nImporte    := nImp
      ( dbfTmpPgo )->nImpGas     := 0
      ( dbfTmpPgo )->cDescrip    := "Recibo nº" + AllTrim( Str( nCon ) ) + " de factura " + aTmp[ ( dbfTmpPgo )->( FieldPos( "CSERIE" ) ) ] + "/" + AllTrim( Str( aTmp[ ( dbfTmpPgo )->( FieldPos( "NNUMFAC" ) ) ] ) ) + "/" + aTmp[ ( dbfTmpPgo )->( FieldPos( "CSUFFAC" ) ) ]
      ( dbfTmpPgo )->dPreCob     := dFecFacRec( aTmp[ ( dbfTmpPgo )->( FieldPos( "CSERIE" ) ) ] + Str( aTmp[ ( dbfTmpPgo )->( FieldPos( "NNUMFAC" ) ) ] ) + aTmp[ ( dbfTmpPgo )->( FieldPos( "CSUFFAC" ) ) ], dbfFacRecT )
      ( dbfTmpPgo )->dFecVto     := dFecFacRec( aTmp[ ( dbfTmpPgo )->( FieldPos( "CSERIE" ) ) ] + Str( aTmp[ ( dbfTmpPgo )->( FieldPos( "NNUMFAC" ) ) ] ) + aTmp[ ( dbfTmpPgo )->( FieldPos( "CSUFFAC" ) ) ], dbfFacRecT )
      ( dbfTmpPgo )->cPgdoPor    := ""
      ( dbfTmpPgo )->lCobrado    := .F.
      ( dbfTmpPgo )->cTurRec     := cCurSesion()
      ( dbfTmpPgo )->cDivPgo     := aTmp[ ( dbfTmpPgo )->( FieldPos( "CDIVPGO" ) ) ]
      ( dbfTmpPgo )->nVdvPgo     := aTmp[ ( dbfTmpPgo )->( FieldPos( "NVDVPGO" ) ) ]
      ( dbfTmpPgo )->lConPgo     := .F.
      ( dbfTmpPgo )->( dbUnLock() )

   end

   ( dbfTmpPgo )->( dbGoTo( nRec ) )





   WinGather( aTmp, aGet, dbfTmpPgo, oBrw, nMode )





   dbCommitAll()

   oDlg:Enable()

   oDlg:End( 1 )

return .T.



FUNCTION nChkPagFacRec( cFacRec, dbfFacRecT, dbfFacCliP )

   local nBitmap        := 3

   if ( dbfFacRecT )->lLiquidada

      nBitmap           := 1

   elseif ( dbfFacCliP )->( dbSeek( cFacRec ) )

      while ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == cFacRec .AND. !( dbfFacCliP )->( eof() )

         if ( dbfFacCliP )->lCobrado

            nBitmap     := 2
            exit

         end

         ( dbfFacCliP )->( dbSkip() )

      end

   end

RETURN nBitmap



FUNCTION ChkLqdFacRec( aTmp, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfIva, dbfDiv )

   local lChkLqd
   local cFactura
   local nPagFacCli
    local nTotal
   local cDivFac
   local nRec     := ( dbfFacCliP )->( RecNo() )

   if aTmp <> nil
      cFactura    := aTmp[1 ] + Str( aTmp[2] ) + aTmp[3]
      cDivFac     := aTmp[58]
   else
      cFactura    := ( dbfFacRecT )->CSERIE + Str( ( dbfFacRecT )->NNUMFAC ) + ( dbfFacRecT )->CSUFFAC
      cDivFac     := ( dbfFacRecT )->CDIVFAC
   end

   nTotal         := abs( nTotFacRec( cFactura, dbfFacRecT, dbfFacRecL, dbfIva, dbfDiv, nil, nil, .F. ) )
   nPagFacCli     := abs( nPagFacRec( cFactura, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfIva, dbfDiv, nil, .T. ) )

   lChkLqd        := !lMayorIgual( nTotal, nPagFacCli, 0.1 )

   if aTmp <> nil
      aTmp[ 24 ]        := lChkLqd
   end

   if dbLock( dbfFacRecT )
      ( dbfFacRecT )->lLiquidada := lChkLqd
      ( dbfFacRecT )->( dbUnLock() )
   end

   ( dbfFacCliP )->( dbGoTo( nRec ) )

RETURN ( lChkLqd )



FUNCTION nPesLFacRec( cFacRecL )

   local nCalculo    := 0

   IIF( cFacRecL == nil, cFacRecL := dbfFacRecL, ) ;

   if !( cFacRecL )->lTotLin
      nCalculo       := Abs( nTotNFacRec( cFacRecL ) ) * ( cFacRecL )->nPesoKg
   end

RETURN ( nCalculo )



STATIC FUNCTION DupSerie( oWndBrw )

   local oDlg
   local oSerIni
   local oSerFin
   local oTxtDup
   local nTxtDup     := 0
   local nRecno      := ( dbfFacRecT )->( Recno() )
   local nOrdAnt     := ( dbfFacRecT )->( OrdSetFocus( 1 ) )
   local oDesde      := TDesdeHasta():Init( ( dbfFacRecT )->cSerie, ( dbfFacRecT )->nNumFac, ( dbfFacRecT )->cSufFac, GetSysDate() )
   local lCancel     := .F.
   local oBtnAceptar
   local oBtnCancel
   local oFecDoc
   local cFecDoc     := GetSysDate()




   oDlg = TDialog():New(,,,, "Duplicar series de facturas rectificativas", "DUPSERDOC",, .F.,,,,, oWndBrw, .F.,,,,,, .F., )



   TRadMenu():Redefine( { | u | If( PCount()==0, oDesde:nRadio, oDesde:nRadio:= u ) }, oDlg,, { 90, 91 },,,,, .F.,, )










   oSerIni := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, oDesde:cSerieInicio, oDesde:cSerieInicio:= u ) }, oDlg,, "@!", {||    ( oDesde:cSerieInicio >= "A" .AND. oDesde:cSerieInicio <= "Z"  )},,,,,, .T., {||     ( oDesde:nRadio == 1 )},, .F., .T., {||    ( UpSerie( oSerIni ) )}, {||  ( DwSerie( oSerIni ) )},,,, nil,,, )










   oSerFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, oDesde:cSerieFin, oDesde:cSerieFin:= u ) }, oDlg,, "@!", {||    ( oDesde:cSerieFin >= "A" .AND. oDesde:cSerieFin <= "Z"  )},,,,,, .T., {||     ( oDesde:nRadio == 1 )},, .F., .T., {||    ( UpSerie( oSerFin ) )}, {||  ( DwSerie( oSerFin ) )},,,, nil,,, )






   TGetHlp():ReDefine( 120, { | u | If( PCount()==0, oDesde:nNumeroInicio, oDesde:nNumeroInicio:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( oDesde:nRadio == 1 )},, .F., .T.,,,,,, nil,,, )






   TGetHlp():ReDefine( 130, { | u | If( PCount()==0, oDesde:nNumeroFin, oDesde:nNumeroFin:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( oDesde:nRadio == 1 )},, .F., .T.,,,,,, nil,,, )





   TGetHlp():ReDefine( 140, { | u | If( PCount()==0, oDesde:cSufijoInicio, oDesde:cSufijoInicio:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( oDesde:nRadio == 1 )},, .F., .F.,,,,,, nil,,, )





   TGetHlp():ReDefine( 150, { | u | If( PCount()==0, oDesde:cSufijoFin, oDesde:cSufijoFin:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( oDesde:nRadio == 1 )},, .F., .F.,,,,,, nil,,, )





   TGetHlp():ReDefine( 170, { | u | If( PCount()==0, oDesde:dFechaInicio, oDesde:dFechaInicio:= u ) }, oDlg,,,,,,,,, .F., {||     ( oDesde:nRadio == 2 )},, .F., .T.,,,,,, nil,,, )





   TGetHlp():ReDefine( 180, { | u | If( PCount()==0, oDesde:dFechaFin, oDesde:dFechaFin:= u ) }, oDlg,,,,,,,,, .F., {||     ( oDesde:nRadio == 2 )},, .F., .T.,,,,,, nil,,, )




   oFecDoc := TGetHlp():ReDefine( 200, { | u | If( PCount()==0, cFecDoc, cFecDoc:= u ) }, oDlg,,,,,,,,, .F.,,, .F., .T.,,,,,, nil,,, )




   oBtnAceptar := TButton():ReDefine( 1, {||( DupStart( oDesde, oDlg, oBtnAceptar, oBtnCancel, oTxtDup, @lCancel, cFecDoc ) )}, oDlg,,, .F.,,,, .F. )





   oBtnCancel := TButton():ReDefine( 2, {||( lCancel := .T., oDlg:end() )}, oDlg,,, .F.,,,, .T. )





   oTxtDup := TMeter():ReDefine( 160, { | u | If( PCount()==0, nTxtDup, nTxtDup:= u ) }, ( dbfFacRecT )->( OrdKeyCount() ), oDlg, .F.,,, .T.,,,, )

      oDlg:AddFastKey( 116, {|| DupStart( oDesde, oDlg, oBtnAceptar, oBtnCancel, oTxtDup, @lCancel, cFecDoc ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T., {|Self|( lCancel )},,, oDlg:bRClicked,,, )

   ( dbfFacRecT )->( dbGoTo( nRecNo ) )
   ( dbfFacRecT )->( ordSetFocus( nOrdAnt ) )

   oWndBrw:SetFocus()
   oWndBrw:Refresh()

RETURN NIL



STATIC FUNCTION DupStart( oDesde, oDlg, oBtnAceptar, oBtnCancel, oTxtDup, lCancel, cFecDoc )

   local nOrd
   local nDuplicados    := 0
   local nProcesed      := 0

   oBtnAceptar:Hide()
   oBtnCancel:bAction   := {|| lCancel := .T. }

   if oDesde:nRadio == 1

      nOrd              := ( dbfFacRecT )->( OrdSetFocus( "nNumFac" ) )

      ( dbfFacRecT )->( dbSeek( oDesde:cNumeroInicio(), .T. ) )

      while !lCancel .AND. ( dbfFacRecT )->( !eof() )






         if ( dbfFacRecT )->cSerie  >= oDesde:cSerieInicio  .AND. ( dbfFacRecT )->cSerie  <= oDesde:cSerieFin     .AND. ( dbfFacRecT )->nNumFac >= oDesde:nNumeroInicio .AND. ( dbfFacRecT )->nNumFac <= oDesde:nNumeroFin    .AND. ( dbfFacRecT )->cSufFac >= oDesde:cSufijoInicio .AND. ( dbfFacRecT )->cSufFac <= oDesde:cSufijoFin

            ++nDuplicados

            oTxtDup:cText  := "Duplicando : " + ( dbfFacRecT )->cSerie + "/" + Alltrim( Str( ( dbfFacRecT )->nNumFac ) ) + "/" + ( dbfFacRecT )->cSufFac

            DupFactura( cFecDoc )

         end

         ( dbfFacRecT )->( dbSkip() )

         ++nProcesed

         oTxtDup:Set( nProcesed )

      end

      ( dbfFacRecT )->( OrdSetFocus( nOrd ) )

   else

      nOrd              := ( dbfFacRecT )->( OrdSetFocus( "dFecFac" ) )

      ( dbfFacRecT )->( dbSeek( oDesde:dFechaInicio, .T. ) )

      while !lCancel .AND. ( dbfFacRecT )->( !eof() )


         if ( dbfFacRecT )->dFecFac >= oDesde:dFechaInicio  .AND. ( dbfFacRecT )->dFecFac <= oDesde:dFechaFin

            ++nDuplicados

            oTxtDup:cText  := "Duplicando : " + ( dbfFacRecT )->cSerie + "/" + Alltrim( Str( ( dbfFacRecT )->nNumFac ) ) + "/" + ( dbfFacRecT )->cSufFac

            DupFactura( cFecDoc )

         end

         ( dbfFacRecT )->( dbSkip() )

         ++nProcesed

         oTxtDup:Set( nProcesed )

      end

      ( dbfFacRecT )->( OrdSetFocus( nOrd ) )

   end

   lCancel              := .T.

   oBtnAceptar:Show()

   if lCancel
      msgStop( "Total de registros duplicados : " + Str( nDuplicados ), "Proceso cancelado" )
   else
      msgInfo( "Total de registros duplicados : " + Str( nDuplicados ), "Proceso finalizado" )
   end

RETURN ( oDlg:End() )



STATIC FUNCTION FacRecDup( cDbf, xField1, xField2, xField3, lCab, cFecDoc, lPag )

   local nRec                 := ( cDbf )->( Recno() )
   local aTabla               := {}
   local nOrdAnt

   IIF( lCab == nil, lCab := .F., ) ;
   IIF( lPag == nil, lPag := .F., ) ;

   aTabla                     := DBScatter( cDbf )
   aTabla[ 1  ]         := xField1
   aTabla[ 2 ]         := xField2
   aTabla[ 3 ]         := xField3

   if lCab

      aTabla[ 4     ]  := cCurSesion()
      if !Empty( cFecDoc )
         aTabla[ 5  ]  := cFecDoc
      end
      aTabla[ 8     ]  := oUser():cCaja()
      aTabla[ 25     ]  := .F.
      aTabla[ 26     ]  := Ctod("")
      aTabla[ 28     ]  := .F.
      aTabla[ 37     ]  := Space( 12 )
      aTabla[ 57     ]  := .T.
      aTabla[ 72     ]  := .F.
      aTabla[ 73     ]  := Space( 12 )
      aTabla[ 74     ]  := Space( 12 )
      aTabla[ 76     ]  := cCurUsr()
      aTabla[ 77     ]  := GetSysDate()
      aTabla[ 78     ]  := Time()
      aTabla[ 80  ]  := .F.
      aTabla[ 81     ]  := Ctod("")
      aTabla[ 82     ]  := Space( 5 )
      aTabla[ 83     ]  := oUser():cDelegacion()

      nOrdAnt                 := ( cDbf )->( OrdSetFocus( "NNUMFAC" ) )

   end

   if lPag

      aTabla[ ( dbfFacCliP )->( FieldPos( "lConPgo" ) ) ]      := .F.
      aTabla[ ( dbfFacCliP )->( FieldPos( "lRecImp" ) ) ]      := .F.
      aTabla[ ( dbfFacCliP )->( FieldPos( "lRecDto" ) ) ]      := .F.
      aTabla[ ( dbfFacCliP )->( FieldPos( "lCloPgo" ) ) ]      := .F.
      aTabla[ ( dbfFacCliP )->( FieldPos( "dPreCob" ) ) ]      := cFecDoc
      aTabla[ ( dbfFacCliP )->( FieldPos( "dFecDto" ) ) ]      := Ctod("")
      aTabla[ ( dbfFacCliP )->( FieldPos( "dFecImp" ) ) ]      := Ctod("")
      aTabla[ ( dbfFacCliP )->( FieldPos( "cHorImp" ) ) ]      := Space( 5 )
      aTabla[ ( dbfFacCliP )->( FieldPos( "dFecVto" ) ) ]      := cFecDoc
      aTabla[ ( dbfFacCliP )->( FieldPos( "cTurRec" ) ) ]      := cCurSesion()
      aTabla[ ( dbfFacCliP )->( FieldPos( "cCodCaj" ) ) ]      := oUser():cCaja()

      if aTabla[ ( dbfFacCliP )->( FieldPos( "lCobrado" ) ) ]
         aTabla[ ( dbfFacCliP )->( FieldPos( "dEntrada" ) ) ]  := cFecDoc
      else
         aTabla[ ( dbfFacCliP )->( FieldPos( "dEntrada" ) ) ]  := Ctod("")
      end

   end

   if dbDialogLock( cDbf, .T. )
      aEval( aTabla, { | uTmp, n | ( cDbf )->( fieldPut( n, uTmp ) ) } )
      ( cDbf )->( dbUnLock() )
   end

   if lCab
      ( cDbf )->( OrdSetFocus( nOrdAnt ) )
   end

   ( cDbf )->( dbGoTo( nRec ) )

RETURN ( .T. )



STATIC FUNCTION DupFactura( cFecDoc )

   local nNewNumFac  := 0



   nNewNumFac  := nNewDoc( ( dbfFacRecT )->cSerie, dbfFacRecT, "NFACREC", , dbfCount )



   FacRecDup( dbfFacRecT, ( dbfFacRecT )->cSerie, nNewNumFac, ( dbfFacRecT )->cSufFac, .T., cFecDoc )



   if ( dbfFacRecL )->( dbSeek( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac ) )


      while ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac == ( dbfFacRecL )->cSerie + Str( ( dbfFacRecL )->nNumFac ) + ( dbfFacRecL )->cSufFac .AND.  !( dbfFacRecL )->( Eof() )

            FacRecDup( dbfFacRecL, ( dbfFacRecT )->cSerie, nNewNumFac, ( dbfFacRecT )->cSufFac, .F. )

         ( dbfFacRecL )->( dbSkip() )

      end

   end



   if ( dbfFacCliP )->( dbSeek( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac ) )



      while ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac == ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac .AND.  !Empty( ( dbfFacCliP )->cTipRec ) .AND. !( dbfFacCliP )->( Eof() )

            FacRecDup( dbfFacCliP, ( dbfFacRecT )->cSerie, nNewNumFac, ( dbfFacCliT )->cSufFac, .F., cFecDoc, .T. )

         ( dbfFacCliP )->( dbSkip() )

      end

   end



   if ( dbfFacRecD )->( dbSeek( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac ) )


      while ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac == ( dbfFacRecD )->cSerie + Str( ( dbfFacRecD )->nNumFac ) + ( dbfFacRecD )->cSufFac .AND.  !( dbfFacRecD )->( Eof() )

            FacRecDup( dbfFacRecD, ( dbfFacRecT )->cSerie, nNewNumFac, ( dbfFacRecT )->cSufFac, .F. )

         ( dbfFacRecD )->( dbSkip() )

      end

   end

RETURN ( .T. )



STATIC FUNCTION ValidaMedicion( aTmp, aGet )

   local cNewUndMed  := aGet[ 16 ]:VarGet





   if ( Empty( cOldUndMed ) .OR. cOldUndMed <> cNewUndMed )

      if oUndMedicion:oDbf:Seek( aTmp[ 16 ] )

         if oUndMedicion:oDbf:nDimension >= 1 .AND. !Empty( oUndMedicion:oDbf:cTextoDim1 )
            if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ] )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim1 )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:cText( ( dbfArticulo )->nLngArt )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:Show()
            else
               aTmp[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]  := ( dbfArticulo )->nLngArt
            end
         else
            if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ] )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:cText( 0 )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:Hide()
            else
               aTmp[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]  := 0
            end
         end

         if oUndMedicion:oDbf:nDimension >= 2 .AND. !Empty( oUndMedicion:oDbf:cTextoDim2 )
            if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ] )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim2 )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:cText( ( dbfArticulo )->nAltArt )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:Show()
            else
               aTmp[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]  := ( dbfArticulo )->nAltArt
            end

         else
            if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ] )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:cText( 0 )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:Hide()
            else
                 aTmp[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]  := 0
            end
         end

         if oUndMedicion:oDbf:nDimension >= 3 .AND. !Empty( oUndMedicion:oDbf:cTextoDim3 )

            if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ] )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:oSay:SetText( oUndMedicion:oDbf:cTextoDim3 )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:cText( ( dbfArticulo ) ->nAncArt )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:Show()
            else
               aTmp[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]  := ( dbfArticulo )->nAncArt
            end

         else

            if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ] )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:cText( 0 )
               aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:Hide()
            else
               aTmp[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]  := 0
            end

         end

      else

         if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ] )
            aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:Hide()
            aGet[ ( dbfFacRecL )->( fieldpos( "nMedUno" ) ) ]:cText( 0 )
         end

         if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ] )
            aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:Hide()
            aGet[ ( dbfFacRecL )->( fieldpos( "nMedDos" ) ) ]:cText( 0 )
         end

         if !Empty( aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ] )
            aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:Hide()
            aGet[ ( dbfFacRecL )->( fieldpos( "nMedTre" ) ) ]:cText( 0 )
         end

      end

      cOldUndMed := cNewUndMed

   end

RETURN .T.



Static Function ChangeTarifa( aTmp, aGet, aTmpFac )

   local nPrePro

   nPrePro        := nPrePro( aTmp[ 4 ], aTmp[ 27 ], aTmp[ 29 ], aTmp[ 28 ], aTmp[ 30 ], aTmp[ 71 ], aTmpFac[ 56 ], dbfArtDiv, aTmpFac[ 21 ] )

   if nPrePro == 0
      nPrePro     := nRetPreArt( aTmp[ 71 ], aTmpFac[ 58 ], aTmpFac[ 56 ], dbfArticulo, dbfDiv, dbfKit, dbfIva )
   end

   if nPrePro <> 0
      aGet[ 6 ]:cText( nPrePro )
   end

return .T.



Static Function LoadTrans( aTmp, oGetCod, oGetKgs, oSayTrn )

   local uValor   := oGetCod:VarGet()

   if Empty( uValor )

      oSayTrn:cText( "" )
      oGetKgs:cText( 0 )

   else

      if oTrans:oDbf:SeekInOrd( uValor, "cCodTrn" )
         oGetCod:cText( uValor )
         oSayTrn:cText( oTrans:oDbf:cNomTrn )
         oGetKgs:cText( oTrans:oDbf:nKgsTrn )
      else
         msgStop( "Código de transportista no encontrado." )
         Return .F.
      end

   end

   RecalculaTotal( aTmp )

Return .T.



FUNCTION IsFacRec( cPath )

   IIF( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "FacRecT.Dbf" )
      dbCreate( cPath + "FacRecT.Dbf", aSqlStruct( aItmFacRec() ), cDriver() )
   end

   if !lExistTable( cPath + "FacRecL.Dbf" )
      dbCreate( cPath + "FacRecL.Dbf", aSqlStruct( aColFacRec() ), cDriver() )
   end

   if !lExistTable( cPath + "FacRecI.Dbf" )
      dbCreate( cPath + "FacRecI.Dbf", aSqlStruct( aIncFacRec() ), cDriver() )
   end

   if !lExistTable( cPath + "FacRecD.Dbf" )
      dbCreate( cPath + "FacRecD.Dbf", aSqlStruct( aFacRecDoc() ), cDriver() )
   end




   if !lExistIndex( cPath + "FacRecT.Cdx" ) .OR.  !lExistIndex( cPath + "FacRecL.Cdx" ) .OR.  !lExistIndex( cPath + "FacRecI.Cdx" ) .OR.  !lExistTable( cPath + "FacRecD.Cdx" )

      rxFacRec( cPath )

   end

Return ( nil )
#line 12556 ".\Prg\Facrec.prg"
Static Function DataReport( oFr )





   oFr:ClearDataSets()

   oFr:SetWorkArea(     "Facturas rectificativas", ( dbfFacRecT )->( Select() ), .F., { 1, 1, 0 } )
   oFr:SetFieldAliases( "Facturas rectificativas", cItemsToReport( aItmFacRec() ) )

   oFr:SetWorkArea(     "Lineas de facturas rectificativas", ( dbfFacRecL )->( Select() ) )
   oFr:SetFieldAliases( "Lineas de facturas rectificativas", cItemsToReport( aColFacRec() ) )

   oFr:SetWorkArea(     "Series de lineas de facturas rectificativas", ( dbfFacRecS )->( Select() ) )
   oFr:SetFieldAliases( "Series de lineas de facturas rectificativas", cItemsToReport( aSerFacRec() ) )

   oFr:SetWorkArea(     "Incidencias de facturas rectificativas", ( dbfFacRecI )->( Select() ) )
   oFr:SetFieldAliases( "Incidencias de facturas rectificativas", cItemsToReport( aIncFacRec() ) )

   oFr:SetWorkArea(     "Documentos de facturas rectificativas", ( dbfFacRecD )->( Select() ) )
   oFr:SetFieldAliases( "Documentos de facturas rectificativas", cItemsToReport( aFacRecDoc() ) )

   oFr:SetWorkArea(     "Empresa", ( dbfEmp )->( Select() ) )
   oFr:SetFieldAliases( "Empresa", cItemsToReport( aItmEmp() ) )

   oFr:SetWorkArea(     "Clientes", ( dbfClient )->( Select() ) )
   oFr:SetFieldAliases( "Clientes", cItemsToReport( aItmCli() ) )

   oFr:SetWorkArea(     "Obras", ( dbfObrasT )->( Select() ) )
   oFr:SetFieldAliases( "Obras",  cItemsToReport( aItmObr() ) )

   oFr:SetWorkArea(     "Almacenes", ( dbfAlm )->( Select() ) )
   oFr:SetFieldAliases( "Almacenes", cItemsToReport( aItmAlm() ) )

   oFr:SetWorkArea(     "Rutas", ( dbfRuta )->( Select() ) )
   oFr:SetFieldAliases( "Rutas", cItemsToReport( aItmRut() ) )

   oFr:SetWorkArea(     "Agentes", ( dbfAgent )->( Select() ) )
   oFr:SetFieldAliases( "Agentes", cItemsToReport( aItmAge() ) )

   oFr:SetWorkArea(     "Formas de pago", ( dbfFpago )->( Select() ) )
   oFr:SetFieldAliases( "Formas de pago", cItemsToReport( aItmFPago() ) )

   oFr:SetWorkArea(     "Transportistas", oTrans:Select() )
   oFr:SetFieldAliases( "Transportistas", cObjectsToReport( oTrans:oDbf ) )

   oFr:SetWorkArea(     "Artículos", ( dbfArticulo )->( Select() ) )
   oFr:SetFieldAliases( "Artículos", cItemsToReport( aItmArt() ) )

   oFr:SetWorkArea(     "Tipo de artículo",  oTipArt:Select() )
   oFr:SetFieldAliases( "Tipo de artículo",  cObjectsToReport( oTipArt:oDbf ) )

   oFr:SetWorkArea(     "Ofertas", ( dbfOferta )->( Select() ) )
   oFr:SetFieldAliases( "Ofertas", cItemsToReport( aItmOfe() ) )

   oFr:SetWorkArea(     "Bancos", ( dbfCliBnc )->( Select() ) )
   oFr:SetFieldAliases( "Bancos", cItemsToReport( aCliBnc() ) )

   oFr:SetWorkArea(     "Unidades de medición",  oUndMedicion:Select() )
   oFr:SetFieldAliases( "Unidades de medición",  cObjectsToReport( oUndMedicion:oDbf ) )

   oFr:SetMasterDetail( "Facturas rectificativas", "Lineas de facturas rectificativas",            {|| ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Series de lineas de facturas rectificativas",  {|| ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Incidencias de facturas rectificativas",       {|| ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Documentos de facturas rectificativas",        {|| ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Empresa",                                      {|| cCodigoEmpresaEnUso() } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Clientes",                                     {|| ( dbfFacRecT )->cCodCli } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Obras",                                        {|| ( dbfFacRecT )->cCodCli + ( dbfFacRecT )->cCodObr } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Almacen",                                      {|| ( dbfFacRecT )->cCodAlm } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Rutas",                                        {|| ( dbfFacRecT )->cCodRut } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Agentes",                                      {|| ( dbfFacRecT )->cCodAge } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Formas de pago",                               {|| ( dbfFacRecT )->cCodPago } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Transportistas",                               {|| ( dbfFacRecT )->cCodTrn } )
   oFr:SetMasterDetail( "Facturas rectificativas", "Bancos",                                       {|| ( dbfFacRecT )->cCodCli } )

   oFr:SetMasterDetail( "Lineas de facturas rectificativas", "Artículos",                          {|| ( dbfFacRecL )->cRef } )
   oFr:SetMasterDetail( "Lineas de facturas rectificativas", "Tipo de artículo",                   {|| ( dbfFacRecL )->cCodTip } )
   oFr:SetMasterDetail( "Lineas de facturas rectificativas", "Ofertas",                            {|| ( dbfFacRecL )->cRef } )
   oFr:SetMasterDetail( "Lineas de facturas rectificativas", "Unidades de medición",               {|| ( dbfFacRecL )->cUnidad } )

   oFr:SetResyncPair(   "Facturas rectificativas", "Lineas de facturas rectificativas" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Series de lineas de facturas rectificativas" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Incidencias de facturas rectificativas" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Documentos de facturas rectificativas" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Empresa" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Clientes" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Obras" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Almacenes" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Rutas" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Agentes" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Formas de pago" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Transportistas" )
   oFr:SetResyncPair(   "Facturas rectificativas", "Bancos" )

   oFr:SetResyncPair(   "Lineas de facturas rectificativas", "Artículos" )
   oFr:SetResyncPair(   "Lineas de facturas rectificativas", "Tipo de artículo" )
   oFr:SetResyncPair(   "Lineas de facturas rectificativas", "Ofertas" )
   oFr:SetResyncPair(   "Lineas de facturas rectificativas", "Unidades de medición" )

Return nil



Static Function VariableReport( oFr )

   oFr:DeleteCategory(  "Facturas rectificativas" )
   oFr:DeleteCategory(  "Lineas de facturas rectificativas" )





   oFr:AddVariable(     "Facturas rectificativas",             "Total factura",                       "GetHbVar('nTotFac')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total descuento",                     "GetHbVar('nTotDto')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total descuento pronto pago",         "GetHbVar('nTotDpp')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total bruto",                         "GetHbVar('nTotBrt')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total descuentos",                    "GetHbVar('nTotalDto')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total neto",                          "GetHbVar('nTotNet')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total primer descuento definible",    "GetHbVar('nTotUno')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total segundo descuento definible",   "GetHbVar('nTotDos')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total " + cImp(),                           "GetHbVar('nTotIva')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total RE",                            "GetHbVar('nTotReq')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total página",                        "GetHbVar('nTotPag')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total retención",                     "GetHbVar('nTotRet')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total peso",                          "GetHbVar('nTotPes')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total costo",                         "GetHbVar('nTotCos')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total anticipado",                    "GetHbVar('nTotAnt')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total cobrado",                       "GetHbVar('nTotCob')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total artículos",                     "GetHbVar('nTotArt')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total cajas",                         "GetHbVar('nTotCaj')" )
   oFr:AddVariable(     "Facturas rectificativas",             "Cuenta por defecto del cliente",      "GetHbVar('cCtaCli')" )

   oFr:AddVariable(     "Facturas rectificativas",             "Bruto primer tipo de " + cImp(),            "GetHbArrayVar('aIvaUno',1)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Bruto segundo tipo de " + cImp(),           "GetHbArrayVar('aIvaDos',1)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Bruto tercer tipo de " + cImp(),            "GetHbArrayVar('aIvaTre',1)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Base primer tipo de " + cImp(),             "GetHbArrayVar('aIvaUno',2)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Base segundo tipo de " + cImp(),            "GetHbArrayVar('aIvaDos',2)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Base tercer tipo de " + cImp(),             "GetHbArrayVar('aIvaTre',2)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Porcentaje primer tipo " + cImp(),          "GetHbArrayVar('aIvaUno',3)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Porcentaje segundo tipo " + cImp(),         "GetHbArrayVar('aIvaDos',3)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Porcentaje tercer tipo " + cImp(),          "GetHbArrayVar('aIvaTre',3)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Porcentaje primer tipo RE",           "GetHbArrayVar('aIvaUno',4)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Porcentaje segundo tipo RE",          "GetHbArrayVar('aIvaDos',4)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Porcentaje tercer tipo RE",           "GetHbArrayVar('aIvaTre',4)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe primer tipo " + cImp(),             "GetHbArrayVar('aIvaUno',8)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe segundo tipo " + cImp(),            "GetHbArrayVar('aIvaDos',8)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe tercer tipo " + cImp(),             "GetHbArrayVar('aIvaTre',8)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe primer RE",                   "GetHbArrayVar('aIvaUno',9)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe segundo RE",                  "GetHbArrayVar('aIvaDos',9)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe tercer RE",                   "GetHbArrayVar('aIvaTre',9)" )

   oFr:AddVariable(     "Facturas rectificativas",             "Fecha del primer vencimiento",        "GetHbArrayVar('aDatVto',1)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Fecha del segundo vencimiento",       "GetHbArrayVar('aDatVto',2)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Fecha del tercer vencimiento",        "GetHbArrayVar('aDatVto',3)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Fecha del cuarto vencimiento",        "GetHbArrayVar('aDatVto',4)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Fecha del quinto vencimiento",        "GetHbArrayVar('aDatVto',5)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe del primer vencimiento",      "GetHbArrayVar('aImpVto',1)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe del segundo vencimiento",     "GetHbArrayVar('aImpVto',2)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe del tercero vencimiento",     "GetHbArrayVar('aImpVto',3)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe del cuarto vencimiento",      "GetHbArrayVar('aImpVto',4)" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe del quinto vencimiento",      "GetHbArrayVar('aImpVto',5)" )

   oFr:AddVariable(     "Facturas rectificativas",             "Total unidades primer tipo de impuestos especiales",            "GetHbArrayVar('aIvmUno',1 )" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total unidades segundo tipo de impuestos especiales",           "GetHbArrayVar('aIvmDos',1 )" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total unidades tercer tipo de impuestos especiales",            "GetHbArrayVar('aIvmTre',1 )" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe del primer tipo de impuestos especiales",               "GetHbArrayVar('aIvmUno',2 )" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe del segundo tipo de impuestos especiales",              "GetHbArrayVar('aIvmDos',2 )" )
   oFr:AddVariable(     "Facturas rectificativas",             "Importe del tercer tipo de impuestos especiales",               "GetHbArrayVar('aIvmTre',2 )" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total importe primer tipo de impuestos especiales",             "GetHbArrayVar('aIvmUno',3 )" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total importe segundo tipo de impuestos especiales",            "GetHbArrayVar('aIvmDos',3 )" )
   oFr:AddVariable(     "Facturas rectificativas",             "Total importe tercer tipo de impuestos especiales",             "GetHbArrayVar('aIvmTre',3 )" )

   oFr:AddVariable(     "Facturas rectificativas",             "Cuenta bancaria cliente",             "CallHbFunc('cCtaFacRec')" )

   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Detalle del artículo",                "CallHbFunc('cDesFacRec')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Total unidades artículo",             "CallHbFunc('nTotNFacRec')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Precio unitario del artículo",        "CallHbFunc('nTotUFacRec')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Precio unitario con descuentos",      "CallHbFunc('nTotPFacRec')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Punto verde del artículo",            "CallHbFunc('nPntUFacRec')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Total línea de factura",              "CallHbFunc('nTotLFacRec')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Total peso por línea",                "CallHbFunc('nPesLFacRec')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Total final línea del factura",       "CallHbFunc('nTotFFacRec')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Importe descuento línea del factura", "CallHbFunc('nDtoLFacRec')" )
   oFr:AddVariable(     "Lineas de facturas rectificativas",   "Total descuento línea del factura",   "CallHbFunc('nTotDtoLFacRec')" )

Return nil



Function DesignReportFacRec( oFr, dbfDoc )

   local lOpen    := .F.
   local lFlag    := .F.





   if lOpenFiles
      lFlag       := .T.
   else
      if Openfiles()
         lFlag    := .T.
         lOpen    := .T.
      else
         lFlag    := .F.
      end
   end

   if lFlag





      DataReport( oFr )





      if !Empty( ( dbfDoc )->mReport )

         oFr:LoadFromBlob( ( dbfDoc )->( Select() ), "mReport")

      else

         oFr:SetProperty(     "Report",            "ScriptLanguage", "PascalScript" )







         oFr:SetProperty(     "Report.ScriptText", "Text", +  "procedure DetalleOnMasterDetail(Sender: TfrxComponent);"   + Chr(13) + Chr(10) +  "begin"                                                     + Chr(13) + Chr(10) +  "CallHbFunc('nTotFacRec');"                                 + Chr(13) + Chr(10) +  "end;"                                                      + Chr(13) + Chr(10) +  "begin"                                                     + Chr(13) + Chr(10) +  "end." )

         oFr:AddPage(         "MainPage" )

         oFr:AddBand(         "CabeceraDocumento", "MainPage", 2 )
         oFr:SetProperty(     "CabeceraDocumento", "Top", 0 )
         oFr:SetProperty(     "CabeceraDocumento", "Height", 200 )

         oFr:AddBand(         "CabeceraColumnas",  "MainPage", 6 )
         oFr:SetProperty(     "CabeceraColumnas",  "Top", 200 )
         oFr:SetProperty(     "CabeceraColumnas",  "Height", 0 )
         oFr:SetProperty(     "CabeceraColumnas",  "StartNewPage", .T. )
         oFr:SetObjProperty(  "CabeceraColumnas",  "DataSet", "Facturas rectificativas" )

         oFr:AddBand(         "DetalleColumnas",   "MainPage", 7  )
         oFr:SetProperty(     "DetalleColumnas",   "Top", 230 )
         oFr:SetProperty(     "DetalleColumnas",   "Height", 28 )
         oFr:SetObjProperty(  "DetalleColumnas",   "DataSet", "Lineas de facturas rectificativas" )
         oFr:SetProperty(     "DetalleColumnas",   "OnMasterDetail", "DetalleOnMasterDetail" )

         oFr:AddBand(         "PieDocumento",      "MainPage", 3 )
         oFr:SetProperty(     "PieDocumento",      "Top", 930 )
         oFr:SetProperty(     "PieDocumento",      "Height", 110 )

      end





      VariableReport( oFr )





      oFr:DesignReport()





      oFr:DestroyFr()





      if lOpen
         CloseFiles()
      end

   else

      Return .F.

   end

Return .T.



Function PrintReportFacRec( nDevice, nCopies, cPrinter, dbfDoc )

   local oFr
   local cFilePdf       := cPatTmp() + "FacturasRectificativasCliente" + StrTran( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, " ", "" ) + ".Pdf"

   IIF( nDevice == nil, nDevice := 2, ) ;
   IIF( nCopies == nil, nCopies := 1, ) ;
   IIF( cPrinter == nil, cPrinter := PrnGetName(), ) ;

   SysRefresh()

   oFr                  := frReportManager():New()

   oFr:LoadLangRes(     "Spanish.Xml" )

   oFr:SetIcon( 1 )

   oFr:SetTitle(        "Diseñador de documentos" )





   oFr:SetEventHandler( "Designer", "OnSaveReport", {|| oFr:SaveToBlob( ( dbfDoc )->( Select() ), "mReport" ) } )





   DataReport( oFr )





   if !Empty( ( dbfDoc )->mReport )

      oFr:LoadFromBlob( ( dbfDoc )->( Select() ), "mReport")





      VariableReport( oFr )





      oFr:PrepareReport()





      do case
         case nDevice == 2

            oFr:ShowPreparedReport()

         case nDevice == 1

            oFr:PrintOptions:SetPrinter( cPrinter )
            oFr:PrintOptions:SetCopies( nCopies )
            oFr:PrintOptions:SetShowDialog( .F. )
            oFr:Print()

         case nDevice == 3

            oFr:SetProperty(  "PDFExport", "ShowDialog",       .F. )
            oFr:SetProperty(  "PDFExport", "DefaultPath",      cPatTmp() )
            oFr:SetProperty(  "PDFExport", "FileName",         cFilePdf )
            oFr:SetProperty(  "PDFExport", "EmbeddedFonts",    .T. )
            oFr:SetProperty(  "PDFExport", "PrintOptimized",   .T. )
            oFr:SetProperty(  "PDFExport", "Outline",          .T. )
            oFr:SetProperty(  "PDFExport", "OpenAfterExport",  .T. )
            oFr:DoExport(     "PDFExport" )

         case nDevice == 6

            oFr:SetProperty(  "PDFExport", "ShowDialog",       .F. )
            oFr:SetProperty(  "PDFExport", "DefaultPath",      cPatTmp() )
            oFr:SetProperty(  "PDFExport", "FileName",         cFilePdf )
            oFr:SetProperty(  "PDFExport", "EmbeddedFonts",    .T. )
            oFr:SetProperty(  "PDFExport", "PrintOptimized",   .T. )
            oFr:SetProperty(  "PDFExport", "Outline",          .T. )
            oFr:SetProperty(  "PDFExport", "OpenAfterExport",  .F. )
            oFr:DoExport(     "PDFExport" )

            if file( cFilePdf )

               with object ( TGenMailing():New() )

                  :SetTypeDocument( "nFacCli" )

                  :SetDe(           uFieldEmpresa( "cNombre" ) )
                  :SetCopia(        uFieldEmpresa( "cCcpMai" ) )
                  :SetAdjunto(      cFilePdf )
                  :SetPara(         RetFld( ( dbfFacRecT )->cCodCli, dbfClient, "cMeiInt" ) )
                  :SetAsunto(       "Envio de factura rectificativa de cliente número " + ( dbfFacRecT )->cSerie + "/" + Alltrim( Str( ( dbfFacRecT )->nNumFac ) ) )
                  :SetMensaje(      "Adjunto le remito nuestro factura rectificativa de cliente " + ( dbfFacRecT )->cSerie + "/" + Alltrim( Str( ( dbfFacRecT )->nNumFac ) ) + Space( 1 ) )
                  :SetMensaje(      "de fecha " + Dtoc( ( dbfFacRecT )->dFecFac ) + Space( 1 ) )
                  :SetMensaje(      Chr(13)+Chr(10) )
                  :SetMensaje(      Chr(13)+Chr(10) )
                  :SetMensaje(      "Reciba un cordial saludo." )

                  :GeneralResource( dbfFacRecT, aItmFacRec() )

               end

            end

      end

   end





   oFr:DestroyFr()

Return .T.







FUNCTION cDesFacRec( cFacRecL, cFacRecS )

   IIF( cFacRecL == nil, cFacRecL := dbfFacRecL, ) ;
   IIF( cFacRecS == nil, cFacRecS := dbfFacRecS, ) ;

RETURN ( Descrip( cFacRecL, cFacRecS ) )



Function cCtaFacRec( cFacRecT, cFacCliP, cBncCli )

   local cCtaFacRec  := ""

   IIF( cFacRecT == nil, cFacRecT := dbfFacRecT, ) ;
   IIF( cFacCliP == nil, cFacCliP := dbfFacCliP, ) ;
   IIF( cBncCli == nil, cBncCli := dbfCliBnc, ) ;

   cCtaFacRec        := Rtrim( ( cFacRecT )->cEntBnc + ( cFacRecT )->cSucBnc + ( cFacRecT )->cDigBnc + ( cFacRecT )->cCtaBnc )

   if Empty( cCtaFacRec )
      if dbSeekInOrd( ( cFacRecT )->cSerie + Str( ( cFacRecT )->nNumFac ) + ( cFacRecT )->cSufFac, "nNumFac", cFacCliP )
         cCtaFacRec  := cClientCuenta( ( cFacCliP )->cCodCli, cBncCli )
      end
   end

Return ( cCtaFacRec )













FUNCTION nTotLFacRec( cFacRecL, nDec, nRou, nVdv, lDto, lPntVer, lImpTrn, cPorDiv )

   local nCalculo

   IIF( cFacRecL == nil, cFacRecL := dbfFacRecL, ) ;
   IIF( nDec == nil, nDec := nDouDiv(), ) ;
   IIF( nRou == nil, nRou := nRouDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;
   IIF( lDto == nil, lDto := .T., ) ;
   IIF( lPntVer == nil, lPntVer := .T., ) ;
   IIF( lImpTrn == nil, lImpTrn := .T., ) ;

   if ( cFacRecL )->lTotLin

      nCalculo       := nTotUFacRec( cFacRecL, nDec, nVdv )

   else



      nCalculo       := nTotUFacRec( cFacRecL, nDec )



      nCalculo       -= Round( ( cFacRecL )->nDtoDiv / nVdv , nDec )

      if lDto

         if ( cFacRecL )->nDto <> 0
            nCalculo -= nCalculo * ( cFacRecL )->nDto / 100
         end

         if ( cFacRecL )->nDtoPrm <> 0
            nCalculo -= nCalculo * ( cFacRecL )->nDtoPrm / 100
         end

      end



      if lPntVer
         nCalculo    += Round( ( cFacRecL )->nPntVer , nDec )
      end





      if lImpTrn .AND. ( cFacRecL )->nImpTrn <> 0
         nCalculo    += ( cFacRecL )->nImpTrn * nTotNFacRec( cFacRecL )
      end



      nCalculo       *= nTotNFacRec( cFacRecL )

   end

   if nRou <> nil
      nCalculo       := Round( nCalculo / nVdv, nRou )
   end

RETURN ( if( cPorDiv <> nil, Trans( nCalculo, cPorDiv ), nCalculo ) )







FUNCTION nTotUFacRec( cFacRecL, nDec, nVdv )

   local nCalculo    := 0

   IIF( cFacRecL == nil, cFacRecL := dbfFacRecL, ) ;
   IIF( nDec == nil, nDec := nDouDiv(), ) ;
   IIF( nVdv == nil, nVdv := 1, ) ;

   if ValType( cFacRecL ) == "C"
      nCalculo       := ( cFacRecL )->nPreUnit
   else
      nCalculo       := cFacRecL:nPreUnit
   end

   nCalculo          := nCalculo / nVdv

RETURN ( Round( nCalculo, nDec ) )



Static Function YearComboBoxChange()

     if oWndBrw:oWndBar:lAllYearComboBox()
        DestroyFastFilter( dbfFacRecT )
      CreateUserFilter( "", dbfFacRecT, .F., , , "all" )
     else
        DestroyFastFilter( dbfFacRecT )
      CreateUserFilter( "Year( Field->dFecFac ) == " + oWndBrw:oWndBar:cYearComboBox(), dbfFacRecT, .F., , , "Year( Field->dFecFac ) == " + oWndBrw:oWndBar:cYearComboBox() )
     end

     ( dbfFacRecT )->( dbGoTop() )

     oWndBrw:Refresh()

  Return nil



FUNCTION BrwFacRec( oGet, oIva )

    local oDlg
    local oBrw
   local oGet1
   local cGet1
   local oCbxOrd
   local cCbxOrd
   local nOrd
   local aCbxOrd

   if !OpenFiles()
      Return .F.
   end

   aCbxOrd        := { "Número", "Fecha", "Cliente", "Nombre" }
   nOrd           := GetBrwOpt( "BrwFacRec" )
   nOrd           := Min( Max( nOrd, 1 ), len( aCbxOrd ) )
   cCbxOrd        := aCbxOrd[ nOrd ]

   oDlg = TDialog():New(,,,, "Facturas rectificativas de clientes", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F., )






        oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, dbfFacRecT ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfFacRecT, nil, nil, .F. ) ) }, .F., .F.,,,,,, nil, "FIND",, )






        oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( dbfFacRecT )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:refresh(), oGet1:SetFocus() )},,,, .F.,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfFacRecT
      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Factura de cliente.Browse"

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }

      oBrw:CreateFromResource( 105 )

      with object ( oBrw:AddCol() )
         :cHeader          := "Número"
         :cSortOrder       := "nNumFac"
         :bEditValue       := {|| ( dbfFacRecT )->cSerie + "/" + RTrim( Str( ( dbfFacRecT )->nNumFac ) ) + "/" + ( dbfFacRecT )->cSufFac }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Fecha"
         :cSortOrder       := "dFecFac"
         :bEditValue       := {|| Dtoc( ( dbfFacRecT )->dFecFac ) }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Cliente"
         :cSortOrder       := "cCodCli"
         :bEditValue       := {|| Rtrim( ( dbfFacRecT )->cCodCli ) }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cNomCli"
         :bEditValue       := {|| Rtrim( ( dbfFacRecT )->cNomCli ) }
         :nWidth           := 180
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Total"
         :bEditValue       := {|| ( dbfFacRecT )->nTotFac }
         :cEditPicture     := cPorDiv( ( dbfFacRecT )->cDivFac, dbfDiv )
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end





        TButton():ReDefine( 500, {||( nil )}, oDlg,,, .F., {||     ( .F. )},,, .F. )





        TButton():ReDefine( 501, {||( nil )}, oDlg,,, .F., {||     ( .F. )},,, .F. )




        TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   oDlg:AddFastKey( 116, {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( oBrw:Load() )}, oDlg:bRClicked,,, )

   if oDlg:nResult == 1

      oGet:cText( ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac )

      oGet:bWhen   := {|| .F. }

      if !Empty( oIva )
         oIva:Click( ( dbfFacRecT )->lIvaInc ):Refresh()
      end

   end

   SetBrwOpt( "BrwFacRec", ( dbfFacRecT )->( OrdNumber() ) )

   ( dbfFacRecT )->( dbClearFilter() )

   CloseFiles()





   oBrw:CloseData()

RETURN ( oDlg:nResult == 1 )



STATIC FUNCTION lLiquida( oBrw, cFactura )

   IIF( cFactura == nil, cFactura := ( dbfFacRecT )->cSerie + Str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, ) ;

   if ( dbfFacRecT )->lLiquidada
      msgStop( "Factura ya cobrada", "Imposible añadir cobros" )
      return .F.
   end





   ( dbfFacCliP )->( dbGoTop() )

   if ( dbfFacCliP )->( dbSeek( cFactura ) )

      while ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == cFactura .AND. !( dbfFacCliP )->( eof() )

         if !Empty( ( dbfFacCliP )->cTipRec ) .AND. !( dbfFacCliP )->lCobrado

            EdtRecCli( ( dbfFacCliP )->cSerie + Str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac + Str( ( dbfFacCliP )->nNumRec ) + ( dbfFacCliP )->cTipRec, .F. )

            exit

         end

         ( dbfFacCliP )->( dbSkip() )

      end

   end





   ChkLqdFacRec( nil, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfIva, dbfDiv )

   oBrw:Refresh()
   oBrw:SetFocus()

Return .T.



static function lBuscaOferta( cCodArt, aGet, aTmp, aTmpFac, dbfOferta, dbfArticulo, dbfDiv, dbfKit, dbfIva  )

   local sOfeArt
   local nTotalLinea    := 0


   if ( dbfArticulo )->Codigo == cCodArt .OR. ( dbfArticulo )->( dbSeek( cCodArt ) )





      nTotalLinea       := lCalcDeta( aTmp, aTmpFac, .T. )

      sOfeArt           := sOfertaArticulo( cCodArt, aTmpFac[ 6 ], aTmpFac[ 79 ], aTmp[ 18 ], aTmpFac[ 5 ], dbfOferta, aTmp[ 71 ], , aTmp[27], aTmp[28], aTmp[29], aTmp[30], aTmp[ 58 ], dbfArticulo, dbfDiv, dbfKit, dbfIva, aTmp[ 12 ], nTotalLinea )

      if !Empty( sOfeArt ) .AND. sOfeArt:nPrecio <> 0
         aGet[ 6 ]:cText( sOfeArt:nPrecio )
         aGet[ 9 ]:cText( sOfeArt:nDtoPorcentual )
         aGet[ 32 ]:cText( sOfeArt:nDtoLineal )
         aTmp[ 73 ]  := .T.
      end

      if !aTmp[ 73 ]





         sOfeArt     := sOfertaFamilia( ( dbfArticulo )->Familia, aTmpFac[ 6 ], aTmpFac[ 79 ], aTmpFac[ 5 ], dbfOferta, aTmp[ 71 ], dbfArticulo, aTmp[ 18 ], aTmp[ 12 ], nTotalLinea )

         if !Empty( sOfeArt ) .AND. ( sOfeArt:nDtoPorcentual <> 0 .OR. sOfeArt:nDtoLineal <> 0 )
            aGet[ 9 ]:cText( sOfeArt:nDtoPorcentual )
            aGet[ 32 ]:cText( sOfeArt:nDtoLineal )
            aTmp[ 73 ]  := .T.
         end

      end

      if !aTmp[ 73 ]





         sOfeArt     := sOfertaTipoArticulo( ( dbfArticulo )->cCodTip, aTmpFac[ 6 ], aTmpFac[ 79 ], aTmpFac[ 5 ], dbfOferta, aTmp[ 71 ], dbfArticulo, aTmp[ 18 ], aTmp[ 12 ], nTotalLinea )

         if !Empty( sOfeArt ) .AND. ( sOfeArt:nDtoPorcentual <> 0 .OR. sOfeArt:nDtoLineal <> 0 )
            aGet[ 9 ]:cText( sOfeArt:nDtoPorcentual )
            aGet[ 32 ]:cText( sOfeArt:nDtoLineal )
            aTmp[ 73 ]  := .T.
         end

      end

      if !aTmp[ 73 ]





         sOfeArt     := sOfertaCategoria( ( dbfArticulo )->cCodCate, aTmpFac[ 6 ], aTmpFac[ 79 ], aTmpFac[ 5 ], dbfOferta, aTmp[ 71 ], dbfArticulo, aTmp[ 18 ], aTmp[ 12 ], nTotalLinea )

         if !Empty( sOfeArt ) .AND. ( sOfeArt:nDtoPorcentual <> 0 .OR. sOfeArt:nDtoLineal <> 0 )
            aGet[ 9 ]:cText( sOfeArt:nDtoPorcentual )
            aGet[ 32 ]:cText( sOfeArt:nDtoLineal )
            aTmp[ 73 ]  := .T.
         end

      end

      if !aTmp[ 73 ]





         sOfeArt     := sOfertaTemporada( ( dbfArticulo )->cCodTemp, aTmpFac[ 6 ], aTmpFac[ 79 ], aTmpFac[ 5 ], dbfOferta, aTmp[ 71 ], dbfArticulo, aTmp[ 18 ], aTmp[ 12 ], nTotalLinea )

         if !Empty( sOfeArt ) .AND. ( sOfeArt:nDtoPorcentual <> 0 .OR. sOfeArt:nDtoLineal <> 0 )
            aGet[ 9 ]:cText( sOfeArt:nDtoPorcentual )
            aGet[ 32 ]:cText( sOfeArt:nDtoLineal )
            aTmp[ 73 ]  := .T.
         end

      end

      if !aTmp[ 73 ]





         sOfeArt     := sOfertaFabricante( ( dbfArticulo )->cCodFab, aTmpFac[ 6 ], aTmpFac[ 79 ], aTmpFac[ 5 ], dbfOferta, aTmp[ 71 ], dbfArticulo, aTmp[ 18 ], aTmp[ 12 ], nTotalLinea )

         if !Empty( sOfeArt ) .AND. ( sOfeArt:nDtoPorcentual <> 0 .OR. sOfeArt:nDtoLineal <> 0 )
            aGet[ 9 ]:cText( sOfeArt:nDtoPorcentual )
            aGet[ 32 ]:cText( sOfeArt:nDtoLineal )
            aTmp[ 73 ]  := .T.
         end

      end

   end

return .T.



Static Function lValidLote( aTmp, aGet, oStkAct )

   if !uFieldEmpresa( "lNStkAct" )
      oStock:nPutStockActual( aTmp[ 4 ], aTmp[ 38 ], aTmp[ 29 ], aTmp[ 30 ], aTmp[ 44 ], aTmp[ 46 ], aTmp[ 35 ], oStkAct )
   end

   if !Empty( aGet[ 45 ] )
      aGet[ 45 ]:cText( dFechaCaducidadLote( aTmp[ 4 ], aTmp[ 29 ], aTmp[ 30 ], aTmp[ 44 ], dbfAlbPrvL, dbfFacPrvL ) )
   end

Return ( .T. )



Static Function EditarNumeroSerie( aTmp, oStock, nMode )

   with object ( TNumerosSerie() )

      :nMode            := nMode

      :cCodArt          := aTmp[ 4    ]
      :cCodAlm          := aTmp[ 38 ]
      :nNumLin          := aTmp[ 34 ]

      :nTotalUnidades   := nTotNFacRec( aTmp )

      :oStock           := oStock

      :uTmpSer          := dbfTmpSer

      :Resource()

   end

Return ( nil )



Static Function OldEditarNumeroSerie( aTmp, oStock, nMode )

   local n
   local oDlg
   local nTotUnd
   local cCodArt
   local cCodAlm
   local oBrwSer
   local aNumSer
   local aValSer
   local cPreFix  := Space( 18 )
   local oSerIni
   local nSerIni  := 0
   local oSerFin
   local nSerFin  := 0
   local oNumGen
   local nNumGen  := 0
   local oSaySer
   local cSaySer  := ""
   local oProSer
   local nProSer

   IIF( nMode == nil, nMode := 1, ) ;

   nTotUnd        := Abs( nTotNFacRec( aTmp ) )

   if nTotUnd == 0
      MsgStop( "No hay unidades para asignar números de serie." )
      Return ( nil )
   end

   n              := 1

   cCodArt        := aTmp[ 4    ]
   cCodAlm        := aTmp[ 38 ]

   aNumSer        := Afill( Array( nTotUnd ), Space( 30 ) )
   aValSer        := Afill( Array( nTotUnd ), .F. )

   if ( dbfTmpSer )->( dbSeek( Str( aTmp[ 34 ], 4 ) + aTmp[ 4 ] ) )
      while ( Str( ( dbfTmpSer )->nNumLin, 4 ) + ( dbfTmpSer )->cRef == Str( aTmp[ 34 ], 4 ) + aTmp[ 4 ] ) .AND. !( dbfTmpSer )->( Eof() )
         if ( n <= nTotUnd )
            aNumSer[ n ]   := ( dbfTmpSer )->cNumSer
         end
         ( dbfTmpSer )->( dbSkip() )
         n++
      end
   end

   oDlg = TDialog():New(,,,,, "VTANUMSER",, .F.,,,,,, .F.,,,,,, .F., )





      TGetHlp():ReDefine( 100, { | u | If( PCount()==0, nTotUnd, nTotUnd:= u ) }, oDlg,, MasUnd(),,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )




      TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cPreFix, cPreFix:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )







      oSerIni := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, nSerIni, nSerIni:= u ) }, oDlg,, "99999999999999999999", {||    ( oSerFin:cText( nSerIni + nTotUnd ), .T. )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





      oSerFin := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, nSerFin, nSerFin:= u ) }, oDlg,, "99999999999999999999",,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )






      oNumGen := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, nNumGen, nNumGen:= u ) }, oDlg,, "99999999999999999999",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )





      TButton():ReDefine( 500, {||( oDlg:Disable(), GenNumSer( cPreFix, aNumSer, nSerIni, nNumGen, oBrwSer, oProSer ), lValSer( cCodArt, cCodAlm, aNumSer, aValSer, nTotUnd, oStock, oBrwSer, oProSer, oSaySer ), oDlg:Enable() )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )

      oBrwSer                 := TXBrowse():New( oDlg )

      oBrwSer:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwSer:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwSer:lHScroll        := .F.
      oBrwSer:lRecordSelector := .T.
      oBrwSer:lFastEdit       := .T.

      oBrwSer:nMarqueeStyle   := 3

      oBrwSer:SetArray( aNumSer, , , .F. )

      oBrwSer:nColSel         := 2

      with object ( oBrwSer:addCol() )
         :cHeader             := "N."
         :bStrData            := {|| Trans( oBrwSer:nArrayAt, "999999" ) }
         :nWidth              := 60
         :nDataStrAlign       := 1
         :nHeadStrAlign       := 1
      end

      with object ( oBrwSer:addCol() )
         :cHeader             := "Serie"
         :bEditValue          := {|| aNumSer[ oBrwSer:nArrayAt ] }
         :nWidth              := 220
         if nMode <> 3
            :nEditType        := 1
         end
         :bOnPostEdit         := {|o,x| aNumSer[ oBrwSer:nArrayAt ] := x, aValSer[ oBrwSer:nArrayAt ] := oStock:lValidNumeroSerie( cCodArt, cCodAlm, x ) }
      end

      with object ( oBrwSer:addCol() )
         :cHeader             := "Es."
         :nHeadBmpNo          := 4
         :bStrData            := {|| "" }
         :bBmpData            := {|| if( aValSer[ oBrwSer:nArrayAt ], 3, 1 ) }
         :nWidth              := 20
         :AddResource( "Bullet_Square_Red_16" )
         :AddResource( "Bullet_Square_Yellow_16" )
         :AddResource( "Bullet_Square_Green_16" )
         :AddResource( "Informacion_16" )
      end

      oBrwSer:CreateFromResource( 150 )



      oSaySer := TSay():ReDefine( 230, {|| cSaySer}, oDlg,,,, .F.,, .F., .F. )

      oProSer     := TMeter():ReDefine( 240, { | u | if( pCount() == 0, nProSer, nProSer := u ) }, 10, oDlg, .F., , , .T., ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ), , ( 128 + ( 255 * 256 ) + ( 0 * 65536 ) ) )





      TButton():ReDefine( 510, {||( if( lChkSer( aValSer, nTotUnd, oProSer, oBrwSer ), SalvarNumeroSerie( aNumSer, aTmp, oProSer, oDlg ), ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )




      TButton():ReDefine( 520, {||( oDlg:End() )}, oDlg,,, .F.,,,, .F. )

      oDlg:bStart := {|| oDlg:Disable(), lValSer( cCodArt, cCodAlm, aNumSer, aValSer, nTotUnd, oStock, oBrwSer, oProSer, oSaySer ), oDlg:Enable() }

      oDlg:AddFastKey( 116, {|| if( lChkSer( aValSer, nTotUnd, oProSer, oBrwSer ), SalvarNumeroSerie( aNumSer, aTmp, oProSer, oDlg ),  ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

Return ( nil )



Static Function lValSer( cCodArt, cCodAlm, aNumSer, aValSer, nTotUnd, oStock, oBrwSer, oProSer, oSaySer )

   local n
   local lValid         := .T.

   CursorWait()

   if !Empty( oProSer )
      oProSer:Show()
      oProSer:SetTotal( nTotUnd )
   end

   if !Empty( oSaySer )
      oSaySer:SetText( "Calculando disponibilidad del stock..." )
   end

   for n := 1 to nTotUnd

      if !Empty( aNumSer[ n ] )

         aValSer[ n ]   := oStock:lValidNumeroSerie( cCodArt, cCodAlm, aNumSer[ n ] )

         if !aValSer[ n ]
            lValid      := .F.
         end

      else

         lValid         := .F.

      end

      if !Empty( oProSer ) .AND. ( Mod( n, int( nTotUnd / 100 ) ) == 0 )
         oProSer:Set( n )
      end

   next

   if !Empty( oBrwSer )
      oBrwSer:Refresh()
   end

   if !Empty( oProSer )
      oProSer:Set( 0 )
      oProSer:Hide()
   end

   if !Empty( oSaySer )
      oSaySer:SetText( "" )
   end

   CursorWE()

Return ( lValid )



Static Function lChkSer( aValSer, nTotUnd, oProSer, oBrwSer )

   local l
   local n
   local lValid            := .T.

   CursorWait()

   if !Empty( oProSer )
      oProSer:Show()
      oProSer:SetTotal( nTotUnd )
   end

   for each l in aValSer

      if IsFalse( l )

         lValid            := .F.
         n                 := hb_EnumIndex()
         exit

      else

         if !Empty( oProSer )
            oProSer:Set( hb_EnumIndex() )
         end

      end

   next

   if !lValid

      if uFieldEmpresa( "lSerNoCom" )
         msgStop( "Hay números de serie sin stock para su venta." )
      else
         lValid            := ApoloMsgNoYes( "Hay números de serie sin stock para su venta.", "¿Desea continuar con la venta?" )
      end

      if !Empty( oBrwSer ) .AND. IsNum( n )
         oBrwSer:nArrayAt  := n
         oBrwSer:Refresh()
      end

   end

   if !Empty( oProSer )
      oProSer:Hide()
   end

   CursorWE()

Return ( lValid )



Static Function SalvarNumeroSerie( aNumSer, aTmp, oProSer, oDlg )

   local cNumSer
   local nTotUnd              := len( aNumSer )

   oDlg:Disable()

   EliminarNumeroSerie( aTmp )

   if !Empty( oProSer )
      oProSer:SetTotal( nTotUnd )
   end

   for each cNumSer in aNumSer

      ( dbfTmpSer )->( dbAppend() )
      ( dbfTmpSer )->cRef        := aTmp[ 4        ]
      ( dbfTmpSer )->cAlmLin     := aTmp[ 38     ]
      ( dbfTmpSer )->nNumLin     := aTmp[ 34     ]
      ( dbfTmpSer )->cNumSer     := cNumSer

      if !Empty( oProSer ) .AND. ( Mod( hb_enumindex(), int( nTotUnd / 100 ) ) == 0 )
         oProSer:Set( hb_enumindex() )
      end

   next

   oDlg:Enable()
   oDlg:End()

Return ( nil )



Static Function EliminarNumeroSerie( aTmp )

   while ( ( dbfTmpSer )->( dbSeek( Str( aTmp[ 34 ], 4 ) + aTmp[ 4 ] ) ) ) .AND. !( dbfTmpSer )->( Eof() )
      ( dbfTmpSer )->( dbDelete() )
   end

Return ( nil )



Function nImportaLineas()

   local oDlg
   local oBmp
   local oBtnOk
   local oBtnCancel
   local oOption
   local nOption  := 1
   local cText    := "¿Desea importar las lineas de la factura?"

   oDlg = TDialog():New(,,,,, "IMPFACREC",, .F.,,,,,, .F.,,,,,, .F., )

   oBmp := TBitmap():ReDefine( 500, "Symbol_questionmark_48_Alpha",, oDlg,,, .F., .F.,,, .F.,,, .T. )

   TSay():ReDefine( 100, {|| cText}, oDlg,,,, .F.,, .F., .F. )



   oOption := TRadMenu():Redefine( { | u | If( PCount()==0, nOption, nOption:= u ) }, oDlg,, { 110, 120 },,,,, .F.,, )

   oBtnOk := TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )

   oBtnCancel := TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   oDlg:AddFastKey( 116, {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult <> 1
      nOption     := 0
   end

   if !Empty( oBmp )
      oBmp:End()
   end

RETURN ( nOption )
