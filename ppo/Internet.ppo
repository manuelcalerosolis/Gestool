#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 11 ".\Prg\Internet.prg"
_HB_CLASS TSndRecInf ; UTILITY FUNCTION TSndRecInf(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TSndRecInf" , { HBObject():Classh } ) ) ;

   _HB_MEMBER { lFtpValido} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lFtpValido" }, .F., .F. ), )

   _HB_MEMBER { lConnect} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lConnect" }, .F., .F. ), )
   _HB_MEMBER { lServer} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "lServer" }, .F., .F. ), )
   _HB_MEMBER { aSend} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aSend" }, .F., .F. ), )
   _HB_MEMBER { aReciver} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aReciver" }, .F., .F. ), )
   _HB_MEMBER { acSay} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "acSay" }, .F., .F. ), )
   _HB_MEMBER { oMtr} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oMtr" }, .F., .F. ), )
   _HB_MEMBER { nMtr} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nMtr" }, .F., .F. ), )
   _HB_MEMBER { oPro} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oPro" }, .F., .F. ), )
   _HB_MEMBER { cPro} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPro" }, .F., .F. ), )
   _HB_MEMBER { oSay} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oSay" }, .F., .F. ), )
   _HB_MEMBER { cSay} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSay" }, .F., .F. ), )
   _HB_MEMBER { oFtp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFtp" }, .F., .F. ), )
   _HB_MEMBER { oInt} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oInt" }, .F., .F. ), )

   _HB_MEMBER { oTimer} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTimer" }, .F., .F. ), )
   _HB_MEMBER { oSubItem} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oSubItem" }, .F., .F. ), )
   _HB_MEMBER { oSubItem2} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oSubItem2" }, .F., .F. ), )

   _HB_MEMBER { cIniFile} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cIniFile" }, .F., .F. ), )

   _HB_MEMBER { lPlanificarEnvio} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lPlanificarEnvio" }, .F., .F. ), )
   _HB_MEMBER { cHoraEnvio} ; IIF( !.F., s_oClass:AddMultiData(, "0000", nScope + IIF( .F., 32, 0 ), { "cHoraEnvio" }, .F., .F. ), )
   _HB_MEMBER { lPlanificarRecepcion} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lPlanificarRecepcion" }, .F., .F. ), )
   _HB_MEMBER { cHoraRecepcion} ; IIF( !.F., s_oClass:AddMultiData(, "0000", nScope + IIF( .F., 32, 0 ), { "cHoraRecepcion" }, .F., .F. ), )
   _HB_MEMBER { lEnviado} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lEnviado" }, .F., .F. ), )
   _HB_MEMBER { lRecibido} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lRecibido" }, .F., .F. ), )
   _HB_MEMBER { lInProcess} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lInProcess" }, .F., .F. ), )
   _HB_MEMBER { lGetProcesados} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lGetProcesados" }, .F., .F. ), )
   _HB_MEMBER { lGetFueraSecuencia} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lGetFueraSecuencia" }, .F., .F. ), )
   _HB_MEMBER { lGetEliminarFicheros} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lGetEliminarFicheros" }, .F., .F. ), )
   _HB_MEMBER { lImprimirEnvio} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lImprimirEnvio" }, .F., .F. ), )

   _HB_MEMBER { nTipoEnvio} ; IIF( !.F., s_oClass:AddMultiData(, 1, nScope + IIF( .F., 32, 0 ), { "nTipoEnvio" }, .F., .F. ), )

   _HB_MEMBER { nLevel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nLevel" }, .F., .F. ), )

   _HB_MEMBER { oDbfSenderReciver} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDbfSenderReciver" }, .F., .F. ), )
   _HB_MEMBER { oDbfFilesReciver} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDbfFilesReciver" }, .F., .F. ), )

   _HB_MEMBER { aFilesProcessed} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "aFilesProcessed" }, .F., .F. ), )

   _HB_MEMBER { oBrwHistorial} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBrwHistorial" }, .F., .F. ), )
   _HB_MEMBER { oBrwFiles} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBrwFiles" }, .F., .F. ), )

   _HB_MEMBER { oBmpSel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBmpSel" }, .F., .F. ), )
   _HB_MEMBER { oDlg} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDlg" }, .F., .F. ), )
   _HB_MEMBER { oFld} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFld" }, .F., .F. ), )

   _HB_MEMBER { oBotonAnterior} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBotonAnterior" }, .F., .F. ), )
   _HB_MEMBER { oBotonSiguiente} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBotonSiguiente" }, .F., .F. ), )
   _HB_MEMBER { oBotonTerminar} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBotonTerminar" }, .F., .F. ), )

   _HB_MEMBER { cFilTxt} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cFilTxt" }, .F., .F. ), )
   _HB_MEMBER { oFilTxt} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oFilTxt" }, .F., .F. ), )
   _HB_MEMBER { hFilTxt} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "hFilTxt" }, .F., .F. ), )

   _HB_MEMBER { oBtnOk} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBtnOk" }, .F., .F. ), )
   _HB_MEMBER { oBtnCancel} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oBtnCancel" }, .F., .F. ), )

   _HB_MEMBER { oTree} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oTree" }, .F., .F. ), )
   _HB_MEMBER { oImageList} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oImageList" }, .F., .F. ), )

   _HB_MEMBER { cPath} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cPath" }, .F., .F. ), )

   _HB_MEMBER New(); IIF( .F., s_oClass:ModMethod( "New", @TSndRecInf_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TSndRecInf_New(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Create(); IIF( .F., s_oClass:ModInline( "Create", {|Self | Self, ( Self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Create", {|Self | Self, ( Self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER LoadFromIni(); IIF( .F., s_oClass:ModMethod( "LoadFromIni", @TSndRecInf_LoadFromIni(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "LoadFromIni", @TSndRecInf_LoadFromIni(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SaveToIni(); IIF( .F., s_oClass:ModMethod( "SaveToIni", @TSndRecInf_SaveToIni(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SaveToIni", @TSndRecInf_SaveToIni(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SaveMessageToFile(); IIF( .F., s_oClass:ModMethod( "SaveMessageToFile", @TSndRecInf_SaveMessageToFile(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SaveMessageToFile", @TSndRecInf_SaveMessageToFile(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Activate( oWnd); IIF( .F., s_oClass:ModMethod( "Activate", @TSndRecInf_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Activate", @TSndRecInf_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER CatalogarTrasmision(); IIF( .F., s_oClass:ModMethod( "CatalogarTrasmision", @TSndRecInf_CatalogarTrasmision(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CatalogarTrasmision", @TSndRecInf_CatalogarTrasmision(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DefineFiles(); IIF( .F., s_oClass:ModMethod( "DefineFiles", @TSndRecInf_DefineFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DefineFiles", @TSndRecInf_DefineFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER OpenFiles(); IIF( .F., s_oClass:ModMethod( "OpenFiles", @TSndRecInf_OpenFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "OpenFiles", @TSndRecInf_OpenFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CloseFiles(); IIF( .F., s_oClass:ModMethod( "CloseFiles", @TSndRecInf_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CloseFiles", @TSndRecInf_CloseFiles(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER BotonSiguiente(); IIF( .F., s_oClass:ModMethod( "BotonSiguiente", @TSndRecInf_BotonSiguiente(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "BotonSiguiente", @TSndRecInf_BotonSiguiente(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER BotonAnterior(); IIF( .F., s_oClass:ModMethod( "BotonAnterior", @TSndRecInf_BotonAnterior(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "BotonAnterior", @TSndRecInf_BotonAnterior(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Execute(); IIF( .F., s_oClass:ModMethod( "Execute", @TSndRecInf_Execute(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Execute", @TSndRecInf_Execute(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Reindexa( cPath); IIF( .F., s_oClass:ModMethod( "Reindexa", @TSndRecInf_Reindexa(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Reindexa", @TSndRecInf_Reindexa(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SetText( cText); IIF( .F., s_oClass:ModMethod( "SetText", @TSndRecInf_SetText(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetText", @TSndRecInf_SetText(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER StartTimer(); IIF( .F., s_oClass:ModMethod( "StartTimer", @TSndRecInf_StartTimer(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "StartTimer", @TSndRecInf_StartTimer(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER StopTimer(); IIF( .F., s_oClass:ModMethod( "StopTimer", @TSndRecInf_StopTimer(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "StopTimer", @TSndRecInf_StopTimer(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lPriorFileRecive( cFile); IIF( .F., s_oClass:ModMethod( "lPriorFileRecive", @TSndRecInf_lPriorFileRecive(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lPriorFileRecive", @TSndRecInf_lPriorFileRecive(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER AppendFileRecive( cFile); IIF( .F., s_oClass:ModMethod( "AppendFileRecive", @TSndRecInf_AppendFileRecive(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "AppendFileRecive", @TSndRecInf_AppendFileRecive(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetProcedFileRecive( cFile, lProced); IIF( .F., s_oClass:ModMethod( "SetProcedFileRecive", @TSndRecInf_SetProcedFileRecive(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetProcedFileRecive", @TSndRecInf_SetProcedFileRecive(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ZoomHistorial(); IIF( .F., s_oClass:ModMethod( "ZoomHistorial", @TSndRecInf_ZoomHistorial(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "ZoomHistorial", @TSndRecInf_ZoomHistorial(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER FtpConexion(); IIF( .F., s_oClass:ModMethod( "FtpConexion", @TSndRecInf_FtpConexion(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "FtpConexion", @TSndRecInf_FtpConexion(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CloseConexion(); IIF( .F., s_oClass:ModMethod( "CloseConexion", @TSndRecInf_CloseConexion(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CloseConexion", @TSndRecInf_CloseConexion(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER PrintLog( cTextFile); IIF( .F., s_oClass:ModMethod( "PrintLog", @TSndRecInf_PrintLog(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "PrintLog", @TSndRecInf_PrintLog(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER SayMemo( cTextfile); IIF( .F., s_oClass:ModMethod( "SayMemo", @TSndRecInf_SayMemo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SayMemo", @TSndRecInf_SayMemo(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lZipData( cFileName); IIF( .F., s_oClass:ModMethod( "lZipData", @TSndRecInf_lZipData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lZipData", @TSndRecInf_lZipData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER lUnZipData( cFileName); IIF( .F., s_oClass:ModMethod( "lUnZipData", @TSndRecInf_lUnZipData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lUnZipData", @TSndRecInf_lUnZipData(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));



   WITH OBJECT <|Self, cFile|;

      local lFileRecive    := .F.

         if !Empty( cFile ) .AND. IsChar( cFile )
            lFileRecive    := ::oDbfFilesReciver:Seek( Rtrim( cFile ) )
         end

      Return ( lFileRecive )

   >; _HB_MEMBER lFileRecive(); IIF( .F., s_oClass:ModInline( "lFileRecive", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lFileRecive", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END



   WITH OBJECT <|Self, cFile|;

      local lFileProcesed  := .F.

      if !Empty( cFile ) .AND. IsChar( cFile )
         lFileProcesed     := ::oDbfFilesReciver:Seek( Rtrim( cFile ) ) .AND. ::oDbfFilesReciver:lProced
      end

      Return ( lFileProcesed )

   >; _HB_MEMBER lFileProcesed(); IIF( .F., s_oClass:ModInline( "lFileProcesed", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "lFileProcesed", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END



   WITH OBJECT <|Self|;

      if Empty( ::oDbfSenderReciver ) .OR. Empty( ::oDbfFilesReciver )
         ::DefineFiles()
      end

      lCheckDbf( ::oDbfSenderReciver )
      lCheckDbf( ::oDbfFilesReciver )

      Return ( Self )

   >; _HB_MEMBER SyncAllDbf(); IIF( .F., s_oClass:ModInline( "SyncAllDbf", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "SyncAllDbf", HB_QWith(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) ); END



; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TSndRecInf ;



UTILITY STATIC function TSndRecInf_New( oMenuItem, oWnd) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   IIF( oMenuItem == nil, oMenuItem := "01073", ) ;

   ::nLevel             := nLevelUsr( oMenuItem )





   if oWnd <> nil
      SysRefresh(); oWnd:CloseAll(); SysRefresh()
   end

   ::cPro               := ""
   ::cSay               := ""
   ::nMtr               := 0
   ::aSend              := {}
   ::aFilesProcessed    := {}
   ::lFtpValido         := .F.
   ::cIniFile           := cPatEmp() + "Empresa.Ini"

   aAdd( ::aSend, TArticuloSenderReciver():New(             "Artículos",                Self ) )
   aAdd( ::aSend, TFamiliaSenderReciver():New(              "Familias",                 Self ) )
   aAdd( ::aSend, TClienteSenderReciver():New(              "Clientes",                 Self ) )
   aAdd( ::aSend, TProveedorSenderReciver():New(            "Proveedor",                Self ) )
   aAdd( ::aSend, TPedidosProveedorSenderReciver():New(     "Pedidos de proveedor",     Self ) )
   aAdd( ::aSend, TAlbaranesProveedorSenderReciver():New(   "Albaranes de proveedor",   Self ) )
   aAdd( ::aSend, TFacturasProveedorSenderReciver():New(    "Facturas de proveedor",    Self ) )
   aAdd( ::aSend, TPresupuestosClientesSenderReciver():New( "Presupuestos clientes",    Self ) )
   aAdd( ::aSend, TPedidosClientesSenderReciver():New(      "Pedidos clientes",         Self ) )
   aAdd( ::aSend, TAlbaranesClientesSenderReciver():New(    "Albaranes clientes",       Self ) )
   aAdd( ::aSend, TFacturasClientesSenderReciver():New(     "Facturas clientes",        Self ) )
   aAdd( ::aSend, TTiketsClientesSenderReciver():New(       "Tickets clientes",         Self ) )
   aAdd( ::aSend, TTurno():Initiate(                        "Sesiones",                 Self ) )
   aAdd( ::aSend, TRemMovAlm():Initiate(                    "Movimientos de almacen",   Self ) )
   aAdd( ::aSend, THisMovSenderReciver():New(               "Historico de movimientos", Self ) )
   aAdd( ::aSend, TUsuarioSenderReciver():New(              "Usuarios",                 Self ) )

   ::DefineFiles()

RETURN ( Self )



UTILITY STATIC function TSndRecInf_LoadFromIni() ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   if !Empty( ::aSend )
      aSend( ::aSend, "Load" )
   end

   ::lServer               := ( "Servidor" $ cCodEnvUsr() )

   ::lPlanificarEnvio      := GetPvProfString( "Envioyrecepcion", "lPlanificarEnvio", cValToChar( ::lPlanificarEnvio ), ::cIniFile )
   ::lPlanificarEnvio      := Upper( ::lPlanificarEnvio ) == ".T."

   ::cHoraEnvio            := GetPvProfString( "Envioyrecepcion", "cHoraEnvio", cValToChar( ::cHoraEnvio ), ::cIniFile )

   ::lPlanificarRecepcion  := GetPvProfString( "Envioyrecepcion", "lPlanificarRecepcion", cValToChar( ::lPlanificarRecepcion ), ::cIniFile )
   ::lPlanificarRecepcion  := Upper( ::lPlanificarRecepcion ) == ".T."

   ::cHoraRecepcion        := GetPvProfString( "Envioyrecepcion", "cHoraRecepcion", cValToChar( ::cHoraRecepcion ), ::cIniFile )

   ::lGetProcesados        := GetPvProfString( "Envioyrecepcion", "lAceptarProcesados", cValToChar( ::lGetProcesados ), ::cIniFile )
   ::lGetProcesados        := Upper( ::lGetProcesados ) == ".T."

   ::lGetFueraSecuencia    := GetPvProfString( "Envioyrecepcion", "lAceptarFueraSecuencia", cValToChar( ::lGetFueraSecuencia ), ::cIniFile )
   ::lGetFueraSecuencia    := Upper( ::lGetFueraSecuencia ) == ".T."

   ::lGetEliminarFicheros  := GetPvProfString( "Envioyrecepcion", "lEliminarFicheros", cValToChar( ::lGetEliminarFicheros ), ::cIniFile )
   ::lGetEliminarFicheros  := Upper( ::lGetEliminarFicheros ) == ".T."

   ::lImprimirEnvio        := GetPvProfString( "Envioyrecepcion", "lImprimirEnvio", cValToChar( ::lImprimirEnvio ), ::cIniFile )
   ::lImprimirEnvio        := Upper( ::lImprimirEnvio ) == ".T."

RETURN ( Self )



UTILITY STATIC function TSndRecInf_StartTimer() ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   if ::lPlanificarEnvio .OR. ::lPlanificarRecepcion
      ::oTimer             := TTimer():New( 60000, {|| ::AutoExecute() }, oWnd() )
      ::oTimer:Activate()
   end

RETURN ( Self )



UTILITY STATIC function TSndRecInf_StopTimer() ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   if ::oTimer <> nil .AND. ::oTimer:lActive
      ::oTimer:DeActivate()
   end

RETURN ( Self )



UTILITY STATIC function TSndRecInf_SaveToIni( lMessage) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   IIF( lMessage == nil, lMessage := .F., ) ;

   if !Empty( ::aSend )
      aSend( ::aSend, "Save" )
   end

   WritePProString( "Envioyrecepcion", "lPlanificarEnvio",        cValToChar( ::lPlanificarEnvio ),      ::cIniFile )
   WritePProString( "Envioyrecepcion", "cHoraEnvio",              cValToChar( ::cHoraEnvio ),            ::cIniFile )
   WritePProString( "Envioyrecepcion", "lPlanificarRecepcion",    cValToChar( ::lPlanificarRecepcion ),  ::cIniFile )
   WritePProString( "Envioyrecepcion", "cHoraRecepcion",          cValToChar( ::cHoraRecepcion ),        ::cIniFile )
   WritePProString( "Envioyrecepcion", "lAceptarFueraSecuencia",  cValToChar( ::lGetFueraSecuencia ),    ::cIniFile )
   WritePProString( "Envioyrecepcion", "lAceptarProcesados",      cValToChar( ::lGetProcesados ),        ::cIniFile )
   WritePProString( "Envioyrecepcion", "lEliminarFicheros",       cValToChar( ::lGetEliminarFicheros ),  ::cIniFile )
   WritePProString( "Envioyrecepcion", "lImprimirEnvio",          cValToChar( ::lImprimirEnvio ),        ::cIniFile )

   if lMessage
      MsgInfo( "Configuración de envio guardada" )
   end

RETURN ( Self )



UTILITY STATIC function TSndRecInf_SaveMessageToFile() ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   if !Empty( ::hFilTxt )
      fClose( ::hFilTxt )
   end

   ::cFilTxt      := ""

RETURN ( Self )



UTILITY STATIC function TSndRecInf_DefineFiles( cPath, cDriver) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   IIF( cPath == nil, cPath := cPatEmp(), ) ;
   IIF( cDriver == nil, cDriver := cDriver(), ) ;

   ::cPath              := cPath

   ::oDbfSenderReciver  := nil
   ::oDbfFilesReciver   := nil

   ::oDbfSenderReciver := DbfServer( "SndLog.Dbf", "SndLog" ):New( "SndLog.Dbf", "SndLog", ( cDriver ), "Registro de los envios", ( ::cPath ) )

      ::oDbfSenderReciver:AddField( "lSelect", "L", 1, 0,,,,, "Seleccionado para envío", .F.,, .F., {} )
      ::oDbfSenderReciver:AddField( "lTipo", "L", 1, 0,,,,, "Tipo envío o recepción", .F.,, .F., {} )
      ::oDbfSenderReciver:AddField( "nEnvio", "N", 9, 0,,,,, "Número del envío", .F.,, .F., {} )
      ::oDbfSenderReciver:AddField( "dFecha", "D", 8, 0,,,,, "Fecha del envío", .F.,, .F., {} )
      ::oDbfSenderReciver:AddField( "cArchivo", "C", 80, 0,,,,, "Nombre fichero de datos", .F.,, .F., {} )
      ::oDbfSenderReciver:AddField( "cLog", "C", 80, 0,,,,, "Nombre fichero del log", .F.,, .F., {} )

      ::oDbfSenderReciver:AddIndex( "nEnvio", "SndLog.Cdx", "Str( nEnvio )",,, .F., .F.,,,, .T., .F. )



   ::oDbfFilesReciver := DbfServer( "SndFil.Dbf", "SndFil" ):New( "SndFil.Dbf", "SndFil", ( cDriver ), "Registro de ficheros recibidos", ( ::cPath ) )

      ::oDbfFilesReciver:AddField( "cArchivo", "C", 80, 0,,,,, "Nombre del fichero", .F.,, .F., {} )
      ::oDbfFilesReciver:AddField( "dFecha", "D", 8, 0,,,,, "Fecha del envío", .F.,, .F., {} )
      ::oDbfFilesReciver:AddField( "lProced", "L", 1, 0,,,,, "Procesado", .F.,, .F., {} )

      ::oDbfFilesReciver:AddIndex( "cArchivo", "SndFil.Cdx", "cArchivo",,, .F., .F.,,,, .T., .F. )



RETURN ( Self )



UTILITY STATIC function TSndRecInf_OpenFiles( lExclusive) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local lOpen          := .T.
   local oError
   local oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   IIF( lExclusive == nil, lExclusive := .F., ) ;

   BEGIN SEQUENCE

      ::oDbfSenderReciver:Activate( .F., !( lExclusive ) )
      ::oDbfFilesReciver:Activate(  .F., !( lExclusive ) )

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Imposible abrir las bases de datos de envios y recepciones" )

      lOpen             := .F.

   end

   ErrorBlock( oBlock )

Return ( lOpen )



UTILITY STATIC function TSndRecInf_CloseFiles() ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local oBlock   := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   local lOpen    := .T.

   BEGIN SEQUENCE

      ::oDbfSenderReciver:End()
      ::oDbfFilesReciver:End()

   RECOVER

      msgStop( "Imposible cerrar todas las bases de datos.", "Atención" )
      lOpen       := .F.

   end

   ErrorBlock( oBlock )

   ::oDbfSenderReciver  := nil
   ::oDbfFilesReciver   := nil

RETURN ( lOpen )



UTILITY STATIC function TSndRecInf_Activate( oWnd, lAuto) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local oBmp
   local oBrwSnd
   local oBrwRec
   local cTipEnv     := if( nTipConInt() == 2, "Por internet", "Por medio fisico" )

   IIF( lAuto == nil, lAuto := .F., ) ;

   if nAnd( ::nLevel, 1 ) <> 0
      msgStop( "Acceso no permitido." )
      return ( Self )
   end

   if oWnd <> nil
      SysRefresh(); oWnd:CloseAll(); SysRefresh()
   end

   if !::OpenFiles()
      return ( Self )
   end

   ::lInProcess   := .T.

   ::LoadFromIni()





   ::oDlg = TDialog():New(,,,,, "Internet_0",, .F.,,,,, oWnd(), .F.,,,,,, .F., )









      ::oFld := TPages():Redefine( 10, ::oDlg, {"Internet_1", "Internet_2", "Internet_3", "Internet_4", "Internet_5", "Internet_6"},,,, )








      oBmp := TBitmap():ReDefine( 500, "Satellite_dish_48_alpha",, ::oFld:aDialogs[ 1 ],,, .F., .F.,,, .F.,,, .F. )



      TSay():ReDefine( 100, {|| cCodEnvUsr()}, ::oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )



      TSay():ReDefine( 110, {|| cTipEnv}, ::oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )



      TSay():ReDefine( 120, {|| cNomConInt()}, ::oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )



      TSay():ReDefine( 130, {|| cUsrConInt()}, ::oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )



      TSay():ReDefine( 140, {|| cSitFtp()}, ::oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )



      TSay():ReDefine( 150, {|| cUsrFtp()}, ::oFld:aDialogs[ 1 ],,,, .F.,, .F., .F. )



      TRadMenu():Redefine( { | u | If( PCount()==0, ::nTipoEnvio, ::nTipoEnvio:= u ) }, ::oFld:aDialogs[ 1 ],, { 160, 161, 162 },,,,, .F.,, )




      TCheckBox():ReDefine( 170, { | u | If( PCount()==0, ::lGetProcesados, ::lGetProcesados:= u ) }, ::oFld:aDialogs[1],,,,,,, .F., {||     ( lUsrMaster() )}, .F. )




      TCheckBox():ReDefine( 180, { | u | If( PCount()==0, ::lGetFueraSecuencia, ::lGetFueraSecuencia:= u ) }, ::oFld:aDialogs[1],,,,,,, .F., {||     ( lUsrMaster() )}, .F. )




      TCheckBox():ReDefine( 190, { | u | If( PCount()==0, ::lGetEliminarFicheros, ::lGetEliminarFicheros:= u ) }, ::oFld:aDialogs[1],,,,,,, .F., {||     ( lUsrMaster() )}, .F. )



      TCheckBox():ReDefine( 710, { | u | If( PCount()==0, ::lImprimirEnvio, ::lImprimirEnvio:= u ) }, ::oFld:aDialogs[1],,,,,,, .F.,, .F. )





      oBrwSnd                        := TXBrowse():New( ::oFld:aDialogs[ 2 ] )

      oBrwSnd:bClrSel                := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwSnd:bClrSelFocus           := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwSnd:SetArray( ::aSend, , , .F. )

      oBrwSnd:lHScroll               := .F.
      oBrwSnd:nMarqueeStyle          := 5

      oBrwSnd:CreateFromResource( 100 )

      with object ( oBrwSnd:addCol() )
         :cHeader       := "Se. Seleccionada"
         :bEditValue    := {|| ::aSend[ oBrwSnd:nArrayAt ]:lSelectSend }
         :nWidth        := 20
         :SetCheck( { "Sel16", "Nil16" } )
      end

      with object ( oBrwSnd:addCol() )
         :cHeader       := "Documento"
         :bEditValue    := {|| ::aSend[ oBrwSnd:nArrayAt ]:cText + " envio" }
         :nWidth        := 300
      end

      oBrwSnd:bLDblClick   := {|| ::aSend[ oBrwSnd:nArrayAt ]:lSelectSend := !::aSend[ oBrwSnd:nArrayAt ]:lSelectSend, oBrwSnd:Refresh() }




      TButton():ReDefine( 501, {||( ::aSend[ oBrwSnd:nArrayAt ]:lSelectSend := !::aSend[ oBrwSnd:nArrayAt ]:lSelectSend, oBrwSnd:Refresh() )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )




      TButton():ReDefine( 502, {||( aEval( ::aSend, {|o| o:lSelectSend := .T. }, oBrwSnd:Refresh() ) )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )




      TButton():ReDefine( 503, {||( aEval( ::aSend, {|o| o:lSelectSend := .F. }, oBrwSnd:Refresh() ) )}, ::oFld:aDialogs[ 2 ],,, .F.,,,, .F. )





      oBrwRec                        := TXBrowse():New( ::oFld:aDialogs[ 3 ] )

      oBrwRec:bClrSel                := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrwRec:bClrSelFocus           := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrwRec:SetArray( ::aSend, , , .F. )

      oBrwRec:lHScroll               := .F.
      oBrwRec:nMarqueeStyle          := 5

      oBrwRec:CreateFromResource( 100 )

      with object ( oBrwRec:addCol() )
         :cHeader       := "Se. Seleccionada"
         :bEditValue    := {|| ::aSend[ oBrwRec:nArrayAt ]:lSelectRecive }
         :nWidth        := 20
         :SetCheck( { "Sel16", "Nil16" } )
      end

      with object ( oBrwRec:addCol() )
         :cHeader       := "Documento"
         :bEditValue    := {|| ::aSend[ oBrwRec:nArrayAt ]:cText + " recepción" }
         :nWidth        := 300
      end

      oBrwRec:bLDblClick   := {|| ::aSend[ oBrwRec:nArrayAt ]:lSelectRecive := !::aSend[ oBrwRec:nArrayAt ]:lSelectRecive, oBrwRec:Refresh() }




      TButton():ReDefine( 501, {||( ::aSend[ oBrwRec:nArrayAt ]:lSelectRecive := !::aSend[ oBrwRec:nArrayAt ]:lSelectRecive, oBrwRec:Refresh() )}, ::oFld:aDialogs[ 3 ],,, .F.,,,, .F. )




      TButton():ReDefine( 502, {||( aEval( ::aSend, {|o| o:lSelectRecive := .T. }, oBrwRec:Refresh() ) )}, ::oFld:aDialogs[ 3 ],,, .F.,,,, .F. )




      TButton():ReDefine( 503, {||( aEval( ::aSend, {|o| o:lSelectRecive := .F. }, oBrwRec:Refresh() ) )}, ::oFld:aDialogs[ 3 ],,, .F.,,,, .F. )





      ::oTree     := TTreeView():Redefine( 100, ::oFld:aDialogs[ 4 ] )




      ::oPro := TSay():ReDefine( 110, {||   ::cPro}, ::oFld:aDialogs[ 4 ],,,, .F.,, .F., .F. )




      ::oMtr := TMeter():ReDefine( 120, { | u | If( PCount()==0, ::nMtr, ::nMtr:= u ) },, ::oFld:aDialogs[ 4 ], .F.,,, .F.,,,, )








      TButton():ReDefine( 501, {||( ::oDbfSenderReciver:FieldPutByName( "lSelect", ! ::oDbfSenderReciver:lSelect ), ::oBrwHistorial:Refresh() )}, ::oFld:aDialogs[ 5 ],,, .F.,,,, .F. )




      TButton():ReDefine( 502, {||( ::ZoomHistorial() )}, ::oFld:aDialogs[ 5 ],,, .F.,,,, .F. )

      ::oBrwHistorial                 := TXBrowse():New( ::oFld:aDialogs[ 5 ] )

      ::oDbfSenderReciver:SetBrowse( ::oBrwHistorial, .F. )

      ::oBrwHistorial:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      ::oBrwHistorial:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      ::oBrwHistorial:nMarqueeStyle   := 5

      ::oBrwHistorial:CreateFromResource( 100 )

      with object ( ::oBrwHistorial:addCol() )
         :cHeader       := "Se. Seleccionada"
         :bStrData      := {|| "" }
         :bEditValue    := {|| ::oDbfSenderReciver:lSelect }
         :nWidth        := 20
         :SetCheck( { "Sel16", "Nil16" } )
      end

      with object ( ::oBrwHistorial:addCol() )
         :cHeader       := "Envio"
         :bEditValue    := {|| ::oDbfSenderReciver:nEnvio }
         :nWidth        := 70
         :cEditPicture  := "999999999"
         :nDataStrAlign := 1
         :nHeadStrAlign := 1
      end

      with object ( ::oBrwHistorial:addCol() )
         :cHeader       := "Fecha"
         :bEditValue    := {|| Dtoc( ::oDbfSenderReciver:dFecha ) }
         :nWidth        := 70
      end

      with object ( ::oBrwHistorial:addCol() )
         :cHeader       := "Fichero"
         :bEditValue    := {|| ::oDbfSenderReciver:cLog }
         :nWidth        := 300
      end

      ::oBrwHistorial:bLDblClick := {|| ::ZoomHistorial() }








      TButton():ReDefine( 500, {||(  ::oDbfFilesReciver:FieldPutByName( "lProced", !::oDbfFilesReciver:lProced ), ::oBrwFiles:Refresh() )}, ::oFld:aDialogs[ 6 ],,, .F.,,,, .F. )




      TButton():ReDefine( 510, {||(  ::oDbfFilesReciver:Delete(), ::oBrwFiles:Refresh() )}, ::oFld:aDialogs[ 6 ],,, .F.,,,, .F. )

      ::oBrwFiles                 := TXBrowse():New( ::oFld:aDialogs[ 6 ] )

      ::oDbfFilesReciver:SetBrowse( ::oBrwFiles, .F. )

      ::oBrwFiles:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      ::oBrwFiles:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      ::oBrwFiles:nMarqueeStyle   := 5

      ::oBrwFiles:CreateFromResource( 100 )

      with object ( ::oBrwFiles:addCol() )
         :cHeader       := "Se. Seleccionada"
         :bStrData      := {|| "" }
         :bEditValue    := {|| ::oDbfFilesReciver:lProced }
         :nWidth        := 20
         :SetCheck( { "Sel16", "Nil16" } )
      end

      with object ( ::oBrwFiles:addCol() )
         :cHeader       := "Fecha"
         :bEditValue    := {|| Dtoc( ::oDbfFilesReciver:dFecha ) }
         :nWidth        := 70
      end

      with object ( ::oBrwFiles:addCol() )
         :cHeader       := "Fichero"
         :bEditValue    := {|| ::oDbfFilesReciver:cArchivo }
         :nWidth        := 300
      end

























      TButton():ReDefine( 40, {||( ::SaveToIni( .T. ) )}, ::oDlg,,, .F.,,,, .F. )




      ::oBotonAnterior := TButton():ReDefine( 20, {||( ::BotonAnterior() )}, ::oDlg,,, .F.,,,, .F. )




      ::oBotonSiguiente := TButton():ReDefine( 30, {||( ::BotonSiguiente() )}, ::oDlg,,, .F.,,,, .F. )




      ::oBtnOk := TButton():ReDefine( 1, {||( ::Execute( .T., .T., ::lImprimirEnvio) )}, ::oDlg,,, .F.,,,, .F. )




      ::oBtnCancel := TButton():ReDefine( 2, {||( ::oDlg:end() )}, ::oDlg,,, .F.,,,, .F. )

   if lAuto
      ::oDlg:bStart  := {|| ::Execute( .T., .T., .F. ), ::oDlg:End() }
   end

   ::oDlg:Activate( ::oDlg:bLClicked, ::oDlg:bMoved, ::oDlg:bPainted, .T.,,,, ::oDlg:bRClicked,,, )





   ::SaveMessageToFile()





   oBmp:End()

   ::CloseFiles()

   ::lInProcess   := .F.

Return nil



UTILITY STATIC function TSndRecInf_BotonSiguiente() ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf


   do case
      case ::oFld:nOption == 1 .AND. ::nTipoEnvio == 1
         ::oFld:GoNext()
         ::oBotonAnterior:Show()

      case ::oFld:nOption == 2 .AND. ::nTipoEnvio == 1
         ::oFld:GoNext()
         ::oBotonSiguiente:Hide()
         ::oBtnOk:Show()

      case ::oFld:nOption == 1 .AND. ::nTipoEnvio == 2
         ::oFld:SetOption( 5 )
         ::oBotonAnterior:Show()
         ::oBotonSiguiente:Hide()
         ::oBtnOk:Hide()

      case ::oFld:nOption == 1 .AND. ::nTipoEnvio == 3
         ::oFld:SetOption( 6 )
         ::oBotonAnterior:Show()
         ::oBotonSiguiente:Hide()
         ::oBtnOk:Hide()

   end

return ( Self )






UTILITY STATIC function TSndRecInf_BotonAnterior() ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   do case
      case ::oFld:nOption == 2
         ::oBotonAnterior:Hide()
         ::oFld:GoPrev()
         ::oBtnOk:Show()

      case ::oFld:nOption == 5 .OR. ::oFld:nOption == 6
         ::oFld:SetOption( 1 )
         ::oBotonAnterior:Hide()
         ::oBotonSiguiente:Show()
         ::oBtnOk:Show()

      otherwise
         ::oBotonSiguiente:Show()
         ::oFld:GoPrev()
         ::oBtnOk:Show()

   end

return ( Self )



UTILITY STATIC function TSndRecInf_Execute( lSend, lRecive, lImprimirEnvio) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local n
   local nZip
   local aFiles
   local cFileCatalog
   local nUltimoEnvio      := nUltimoEnvioInformacion()

   IIF( lSend == nil, lSend := .T., ) ;
   IIF( lRecive == nil, lRecive := .T., ) ;
   IIF( lImprimirEnvio == nil, lImprimirEnvio := .F., ) ;

   if ::oDlg <> nil
      ::oDlg:Disable()
   end

   if !Empty( ::oBotonAnterior )
      ::oBotonAnterior:Hide()
   end

   if !Empty( ::oBotonSiguiente )
      ::oBotonSiguiente:Hide()
   end

   if !Empty( ::oBtnOk )
      ::oBtnOk:Hide()
   end

   ::SaveToIni()





   if !Empty( ::oFld )
      ::oFld:SetOption( 4 )
   end



   if ::oTree <> nil
      ::oTree:DeleteAll()
   end





   lRdDir( cPatIn(),  "*.*" )
   lRdDir( cPatOut(), "*.*" )
   lRdDir( cPatSnd(), "*.*" )





   if ::nTipoEnvio == 1





      ::SetText( "Seleccionando datos", 1 )

      if lSend
         aEval( ::aSend, {|o| if( o:lSelectSend, ( ::SetText( o:cText, 2 ), o:CreateData(), lRdDir( cPatSnd(), "*.*" ), Self ), ) } )
      end





      ::FtpConexion()

      if ::lFtpValido





         ::SetText( "Enviando datos", 1 )

         if lSend
            aEval( ::aSend, {|o| if( o:lSelectSend, ( ::SetText( o:cText, 2 ), o:SendData(), Self ), ) } )
         end





         ::SetText( "Recibiendo datos", 1 )

         if lRecive
            aEval( ::aSend, {|o| if( o:lSelectRecive, ( ::SetText( o:cText, 2 ), o:ReciveData(), Self ), ) } )
         end





         ::SetText( "Procesando datos", 1 )

         if lRecive
            aEval( ::aSend, {|o| if( o:lSelectRecive, ( ::SetText( o:cText, 2 ), o:Process(), Self ), ) } )
         end





         ::SetText( "Borrando de recepciones", 1 )

         if lRecive .AND. ::lServer .AND. !::lGetEliminarFicheros
            aEval( ::aFilesProcessed, {| cFile | ::SetText( "Borrando fichero " + cFile, 2 ), ftpEraseFile( cFile, Self ) } )
         end





         ::CloseConexion()





         ::SetText( "Restaurando datos", 1 )

         if lSend
            aEval( ::aSend, {|o| if( o:lSelectSend, ( ::SetText( o:cText, 2 ), o:RestoreData(), Self ), ) } )
         end





         if lSend .OR. lRecive

            ::oDbfSenderReciver:Append()

            cFileCatalog                        := cPatLog() + "Snd" + StrZero( nUltimoEnvio, 6 ) + ".Zip"
            ::oDbfSenderReciver:nEnvio          := nUltimoEnvio
            ::oDbfSenderReciver:lTipo           := .T.
            ::oDbfSenderReciver:dFecha          := GetSysDate()
            ::oDbfSenderReciver:cLog            := ::cFilTxt

            ::SetText( "Comprimiendo información para el catalogo", 1 )

            hb_SetDiskZip( {|| nil } )
            aEval( Directory( cPatOut() + "*.*" ), { | cName, nIndex | hb_ZipFile( cFileCatalog, cPatOut() + "\" + cName[ 1 ], 9 ) } )
            hb_gcAll()

            ::oDbfSenderReciver:Save()

            nUltimoEnvioInformacion( ++nUltimoEnvio )

         end

      else

         ::SetText( "Conexion invalida", 1 )

      end

   else

      ::oDbfSenderReciver:GoTop()
      while !::oDbfSenderReciver:Eof()

         if ::oDbfSenderReciver:lSelect

            if file( Rtrim( ::oDbfSenderReciver:cArchivo ) )

               aFiles      := Hb_GetFilesInZip( Rtrim( ::oDbfSenderReciver:cArchivo ) )
               if !Hb_UnZipFile( Rtrim( ::oDbfSenderReciver:cArchivo ), , , , cPatOut(), aFiles )
                  MsgStop( "No se ha descomprimido el fichero " + Rtrim( ::oDbfSenderReciver:cArchivo ), "Error" )
               end
               hb_gcAll()

               ::oDbfSenderReciver:FieldPutByName( "lSelect", .F. )





               ::FtpConexion()

               if ::lFtpValido

                  ::SetText( "Reenviando envio número " + Trans( ::oDbfSenderReciver:nEnvio, "999999999" ), 1 )

                  aFiles   := Directory( cPatOut() + "*.*" )

                  for n := 1 to len( aFiles )

                     if ftpSndFile( cPatOut() + aFiles[ n, 1 ], aFiles[ n, 1 ], 2000, Self )
                        ::SetText( "Fichero reenviados " + cValToChar( aFiles[ n, 1 ] ), 2 )
                     else
                        ::SetText( "ERROR reenviando fichero " + cValToChar( aFiles[ n, 1 ] ), 2 )
                     end

                  next

               end

            else

               ::SetText( "ERROR el fichero comprimido " + Rtrim( ::oDbfSenderReciver:cArchivo ) + " no existe", 2 )

            end

         end

         ::oDbfSenderReciver:Skip()

      end

   end





   lRdDir( cPatIn(),  "*.*" )
   lRdDir( cPatOut(), "*.*" )
   lRdDir( cPatSnd(), "*.*" )





   ::SetText( "Proceso finalizado", 1 )

   if !Empty( ::oBtnCancel )
      ::oBtnCancel:bAction  := {|| ::oDlg:end() }
      SetWindowText( ::oBtnCancel:hWnd, "&Cerrar" )
   end

   if lImprimirEnvio
      ::PrintLog()
   end

   if ::oDlg <> nil
      ::oDlg:Enable()
   end

RETURN ( Self )












































































UTILITY STATIC function TSndRecInf_SetText( cText, nLevel) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   IIF( nLevel == nil, nLevel := 3, ) ;

   if nLevel < 3 .AND. ::oPro <> nil
      ::oPro:SetText( cText )
   end

   if Empty( ::cFilTxt )
      ::cFilTxt      := cGetNewFileName( cPatLog() + "Snd" + Dtos( Date() ) + StrTran( Time(), ":", "" ) ) + ".Txt"
      ::hFilTxt      := fCreate( ::cFilTxt )
   end

   if Empty( ::hFilTxt )
      ::hFilTxt      := fOpen( ::cFilTxt, 1 )
   endif





   do case
      case nLevel == 1
         fWrite( ::hFilTxt, cValToChar( cText ) + Chr(13)+Chr(10) )
      case nLevel == 2
         fWrite( ::hFilTxt, Space( 3 ) + cValToChar( cText ) + Chr(13)+Chr(10) )
      case nLevel == 3
         fWrite( ::hFilTxt, Space( 6 ) + cValToChar( cText ) + Chr(13)+Chr(10) )
   end

   if ::oTree <> nil
      do case
         case nLevel == 1
            ::oSubItem  := ::oTree:Add( cText )
            ::oTree:Select( ::oSubItem )
         case nLevel == 2
            ::oSubItem2 := ::oSubItem:Add( cText )
            ::oTree:Select( ::oSubItem2 )
            ::oSubItem:Expand()
         case nLevel == 3
            ::oTree:Select( ::oSubItem2:Add( cText ) )
            ::oSubItem2:Expand()
      end
   end

RETURN ( Self )



UTILITY STATIC function TSndRecInf_CatalogarTrasmision() ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local nUltimoEnvio            := nUltimoEnvioInformacion()

   ::oDbfSenderReciver:Append()
   ::oDbfSenderReciver:nEnvio    := ++nUltimoEnvio
   ::oDbfSenderReciver:dFecha    := GetSysDate()
   ::oDbfSenderReciver:cArchivo  := ::cFilTxt
   ::oDbfSenderReciver:Save()

   nUltimoEnvioInformacion( nUltimoEnvio )

Return ( Self )



UTILITY STATIC function TSndRecInf_AppendFileRecive( cFile) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local oBlock
   local oError

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   aAdd( ::aFilesProcessed, cFile )

   if !::oDbfFilesReciver:Seek( cFile )
      ::oDbfFilesReciver:Append()
   else
      ::oDbfFilesReciver:Load()
   end

   ::oDbfFilesReciver:cArchivo   := cFile
   ::oDbfFilesReciver:dFecha     := GetSysDate()
   ::oDbfFilesReciver:lProced    := .T.

   ::oDbfFilesReciver:Save()

   RECOVER USING oError

      msgStop( "Error al añadir registro " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

Return ( Self )



UTILITY STATIC function TSndRecInf_SetProcedFileRecive( cFile, lProced) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   IIF( lProced == nil, lProced := .T., ) ;

   if ::oDbfFilesReciver:Seek( cFile )
      ::oDbfFilesReciver:Load()
      ::oDbfFilesReciver:lProced := lProced
      ::oDbfFilesReciver:Save()
   end

Return ( Self )



UTILITY STATIC function TSndRecInf_lPriorFileRecive( cFile) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local lResult     := .F.
   local cFileExt    := GetFileExt( cFile )
   local cFileNoExt  := GetFileNoExt( cFile )
   local cTypeFile   := Left( cFileNoExt, At( "0", cFileNoExt ) - 1 )
   local nNumberFile := Val( Right( cFileNoExt, 6 ) ) - 1
   local cNumberFile := StrZero( nNumberFile, 6 )

   if nNumberFile < 0
      lResult        := .T.
   else
      lResult        := ::oDbfFilesReciver:Seek( cTypeFile + cNumberFile + "." + cFileExt )
   end

Return ( lResult )



UTILITY STATIC function TSndRecInf_ZoomHistorial() ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local oMemo
   local cMemo
   local oDlg

   cMemo          := Memoread( ::oDbfSenderReciver:cLog )

   oDlg = TDialog():New(,,,,, "InfoEnvio",, .F.,,,,,, .F.,,,,,, .F., )





   TGetHlp():ReDefine( 100, { | u | If( PCount()==0, ::oDbfSenderReciver:nEnvio, ::oDbfSenderReciver:nEnvio:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )





   TGetHlp():ReDefine( 110, { | u | If( PCount()==0, ::oDbfSenderReciver:dFecha, ::oDbfSenderReciver:dFecha:= u ) }, oDlg,,,,,,,,, .F., {||     ( .F. )},, .F., .T.,,,,,, nil,,, )





   oMemo := TMultiGet():ReDefine( 120, { | u | If( PCount()==0, cMemo, cMemo:= u ) }, oDlg,,,,,,, .F.,, .T.,, )




   TButton():ReDefine( 1, {||( oDlg:End() )}, oDlg,,, .F.,,,, .F. )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

Return ( Self )



UTILITY STATIC function TSndRecInf_FtpConexion() ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local nRetry            := 0
   local ftpSit            := cFirstPath( Rtrim( cSitFtp() ) )
   local ftpDir            := cNoPath( Rtrim( cSitFtp() ) )
   local nbrUsr            := Rtrim( cUsrFtp() )
   local accUsr            := Rtrim( cPswFtp() )
   local pasInt            := uFieldEmpresa( "lPasEnvio" )

   if nTipConInt() == 2

      while !::lFtpValido .AND. nRetry < 3

         ::SetText( "> Conectando con el sitio " + Rtrim( ftpSit ) + "...", 1 )

         ::oInt         := TInternet():New()
         ::oFtp         := TFtp():New( ftpSit, ::oInt, nbrUsr, accUsr, pasInt )

         if Empty( ::oFtp ) .OR. Empty( ::oFtp:hFtp )

            ::SetText( "Imposible conectar con el sitio ftp " + Alltrim( ftpSit ), 1 )

            ::lFtpValido   := .F.

            ++nRetry
            ::SetText( "Reintento " + Alltrim( Str( nRetry ) ) + " de 3, en 10 segundos", 1 )

            DlgWait( 10 )

         else

            if !Empty( ftpDir )
               ::oFtp:SetCurrentDirectory( ftpDir )
            end

            ::lFtpValido   := .T.

         end

      end

   else

      ::lFtpValido           := .T.

   end

Return ( Self )











































































UTILITY STATIC function TSndRecInf_CloseConexion() ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   if !Empty( ::oInt )
      ::oInt:end()
   end

   if !Empty( ::oFtp )
      ::oFtp:end()
   end

Return ( Self )



FUNCTION FtpSndFile( aSource, aTarget, nBufSize, oSender, lDisco )

   local n
   local oFile
   local hSource
   local hTarget
   local cBuffer
   local nBytes         := 0
   local nFile          := 0
   local nTotSize       := 0
   local lRet           := .F.

   IIF( aTarget == nil, aTarget := aSource, ) ;
   IIF( nBufSize == nil, nBufSize := 2000, ) ;
   IIF( lDisco == nil, lDisco := ( nTipConInt() == 1 ), ) ;

   IF ValType( aSource ) <> "A"
      aSource           := { aSource }
   end

   IF ValType( aTarget ) <> "A"
      aTarget           := { aTarget }
   end

   cBuffer              := Space( nBufSize )

   for n := 1 to Len( aSource )

      if File( aSource[ n ] )
         hSource        := fOpen( aSource[ n ] )
         nTotSize       += fSeek( hSource, 0, 2 )
         fClose( hSource )
      end

      SysRefresh()

   next





   if nTotSize == 0
      Return .F.
   end

   if !Empty( oSender )

      oSender:oMtr:nTotal     := nTotSize

      oSender:SetText( "Tamaño fichero " + Alltrim( Str( nTotSize ) ) )

   end





   if lDisco

      for n := 1 to Len( aSource )

         hSource        := fOpen( aSource[ n ] )
         hTarget        := fCreate( cRutConInt() + aTarget[ n ] )

         if !Empty( oSender )
            oSender:oMtr:Set( 0 )
            oSender:oMtr:nTotal := nTotSize
         end





         fSeek( hSource, 0, 0 )

         SysRefresh()

         while ( nBytes := fRead( hSource, @cBuffer, nBufSize ) ) > 0

            fWrite( hTarget, cBuffer, nBytes )

            if !Empty( oSender )
               oSender:oMtr:Set( nFile += nBytes )
            end

            SysRefresh()

         end

         fClose( hSource )
         fClose( hTarget )

      next

      lRet  := nTotSize == nFile

   else

      for n := 1 to Len( aSource )

         if !Empty( oSender )

            if Empty( oSender:oFtp )

               msgInfo( "No hay conexiones de internet disponibles." )

            else

               oFile             := TFtpFile():New( aSource[ n ], oSender:oFtp )

               lRet              := oFile:PutFile()

            end

            oSender:SetText( "Procesando fichero " + aTarget[ n ] )

         end

         if !lRet

            if !Empty( oSender )

               oSender:SetText( "Error procesando fichero " + aTarget[ n ] )
               oSender:SetText( GetErrMsg() )

            end

         end

         oFile:End()

      next

   end

   if !Empty( oSender )
      oSender:oMtr:Set( 0 )
   end

   SysRefresh()

return ( lRet )



function ftpGetFiles( aSource, cTarget, nBufSize, oSender, lDisco )

   local n
   local i
   local hTarget
   local cBuffer
   local nBytes
   local oFile
   local aFiles
   local nFile          := 0
   local nTotSize       := 0
   local oFtp           := oSender:oFtp
   local oMeter         := oSender:oMtr
   local lSuccess       := .F.

   IIF( nBufSize == nil, nBufSize := 2000, ) ;
   IIF( lDisco == nil, lDisco := ( nTipConInt() == 1 ), ) ;

   if ValType( aSource ) <> "A"
      aSource           := { aSource }
   end

   cBuffer              := Space( nBufSize )





   for n := 1 to Len( aSource )

      if lDisco
         aFiles         := Directory( cRutConInt() + aSource[ n ] )
      else
         aFiles         := oFTP:Directory( aSource[ n ] )
      end

      for i := 1 to Len( aFiles )

         oSender:SetText( "Ficheros en el servidor : " + cValToChar( aFiles[ i, 1 ] ) )

         if ( Len( aFiles ) > 0 ) .AND. isNum( aFiles[ i, 2 ] ) .AND. ( aFiles[ i, 2 ] <> 0 )
            nTotSize    += aFiles[ i , 2 ]
         endif

      next

      if oMeter <> nil
         oMeter:nTotal  := nTotSize
      end

      for i := 1 to Len( aFiles )

         if oSender:lFileProcesed( aFiles[ i, 1 ] )
            oSender:SetText( "INFORMACIÓN fichero " + cValToChar( aFiles[ i, 1 ] ) + " ya procesado." )
            if !oSender:lGetProcesados
               loop
            end
         end

         if !oSender:lFileRecive( aFiles[ i, 1 ] ) .AND. !oSender:lPriorFileRecive( aFiles[ i, 1 ] )
            oSender:SetText( "INFORMACIÓN fichero " + cValToChar( aFiles[ i, 1 ] ) + " fuera de secuencia." )
            if !oSender:lGetFueraSecuencia
               loop
            end
         end



         if aFiles[ i, 2 ] <> 0

            if IsChar( aFiles[ i, 1 ] )

               hTarget     := fCreate( cTarget + aFiles[ i, 1 ] )

               if lDisco
                  oFile    := TTxtFile():New( cRutConInt() + aFiles[ i, 1 ] )
               else
                  oFile    := TFtpFile():New( aFiles[ i, 1 ], oFTP )
                  oFile:OpenRead()
               end

               while ( nBytes := Len( cBuffer := if( lDisco, oFile:cGetStr( nBufSize ), oFile:Read( nBufSize ) ) ) ) > 0

                  fWrite( hTarget, cBuffer, nBytes )

                  if oMeter <> nil
                     oMeter:Set( nFile += nBytes )
                  end

                  SysRefresh()

               end

               fClose( hTarget )

               oFile:end()

               oSender:SetText( "Fichero recibido : " + cValToChar( aFiles[ i, 1 ] ) )

               oSender:AppendFileRecive( aFiles[ i, 1 ] )

            end

         else

            oSender:SetText( "INFORMACIÓN fichero " + cValToChar( aFiles[ i, 1 ] ) + " está vacio." )

         end

      next

      lSuccess          := ( nFile >= nTotSize )

   next

   if oMeter <> nil
      oMeter:Set( 0 )
   end

return ( lSuccess )



Function ftpDeleteMask( cMask, oSender, lDisco )

   local oFtp              := oSender:oFtp

   IIF( lDisco == nil, lDisco := ( nTipConInt() == 1 ), ) ;

   if lDisco
      lRdDir( cRutConInt(), cMask )
   else
      if oFtp <> nil
         oFtp:DeleteMask( cMask )
      end
   end

Return nil



Function ftpEraseFile( cFile, oSender, lDisco )

   local oFtp              := oSender:oFtp

   IIF( lDisco == nil, lDisco := ( nTipConInt() == 1 ), ) ;

   if lDisco
      fErase( cRutConInt() + cFile )
   else
      if oFtp <> nil
         oFtp:DeleteFile( cFile )
      end
   end

Return nil



Function nAreas()

   local n
   local nAreas   := 0

   for n := 1 to 255
      if !Empty( Alias( n ) )
         ++nAreas
      end
   next

return ( nAreas )



UTILITY STATIC function TSndRecInf_PrintLog() ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local oFont
   local oReport
   local oColumn

   oFont       := TFont():New("Courier New", 9, -12 )













   oReport     := TReport():New( {  { || AllTrim( cCodEmp() + " - " + cNbrEmp() ) }, { || "Informe de envío y recepción" } }, {  { || "Fecha: " + Dtoc( Date() ) + " - " + Time() } }, {  { || "Página: " + Str( oReport:nPage, 3 ) } }, { oFont }, {}, .F., , , .F., .T., , , "Imprimiendo Log" )

   if !Empty( oReport ) .AND. oReport:lCreated

      oColumn  := TRColumn():New( {}, 1, { {|| "" } }, 76, {}, , .F., , , .F., .F., , oReport )

      oReport:AddColumn( oColumn )

      oReport:nTitleUpLine := 0
      oReport:nTitleDnLine := 0

      oReport:Margin( .25, 1, 1)
      oReport:Margin( .25, 4, 1)
      oReport:Margin( .25, 5, 1)

   else

      msgStop( "No se ha podido crear informe, revise la configuración de sus impresoras." )

   end

   if !Empty( oReport )
      oReport:Activate( , , {|| ::SayMemo( oReport ) } )
   end

   oFont:End()

RETURN ( Self )



UTILITY STATIC function TSndRecInf_SayMemo( oReport) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local cText
   local cLine
   local nFor
   local nLines
   local nPageln

   cText    := MemoRead( ::cFilTxt )

   nLines   := MlCount( cText, 76 )
   nPageln  := 0

   for nFor := 1 to nLines

      cLine := MemoLine( cText, 76, nFor)

      oReport:StartLine()
      oReport:Say( 1, cLine )
      oReport:EndLine()

      nPageln     := nPageln + 1

      if nPageln == 60

         nFor     := GetTop( cText, nFor, nLines)
         nPageln  := 0

      endif

   next

return ( Self )



Static Function GetTop( cText, nFor, nLines )

   local cLine
   local lTest := .T.

   while lTest = .T. .AND. nFor <= nLines

      nFor  := nFor + 1

      cLine := MemoLine( cText, 76, nFor )

      lTest := Empty( cLine )

   end

   nFor -= 1

   SysRefresh()

Return nFor



UTILITY STATIC function TSndRecInf_lZipData( cFileName) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local lZip     := .T.
   local aDir     := Directory( cLastPath( cPatSnd() ) + "\*.*" )
   local aName

   hb_SetDiskZip( {|| nil } )
   for each aName in aDir
      lZip        := hb_ZipFile( cPatOut() + cFileName, cLastPath( cPatSnd() ) + aName[ 1 ], 9 )
      if !lZip
         exit
      end
   next
   hb_gcAll()

Return ( lZip )



UTILITY STATIC function TSndRecInf_lUnZipData( cFileName) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   local aDir
   local nZip
   local lUnZip   := .T.

   aDir           := Hb_GetFilesInZip( cFileName )
   lUnZip         := Hb_UnZipFile( cFileName, { | cName, nPos | ::SetText( "Descomprimiendo " + cName ) }, , , cPatSnd(), aDir )
   hb_gcAll()

Return ( lUnZip )



UTILITY STATIC function TSndRecInf_Reindexa( cPath) ; local Self AS CLASS TSndRecInf := QSelf() AS CLASS TSndRecInf

   ::DefineFiles( cPath )

   if !Empty( ::oDbfSenderReciver )
      ::oDbfSenderReciver:IdxFDel()
      ::oDbfSenderReciver:Activate( .F., .T., .F. )
      ::oDbfSenderReciver:Pack()
      ::oDbfSenderReciver:End()
   end

   if Empty( ::oDbfFilesReciver )
      ::oDbfFilesReciver:IdxFDel()
      ::oDbfFilesReciver:Activate( .F., .T., .F. )
      ::oDbfFilesReciver:Pack()
      ::oDbfFilesReciver:End()
   end

RETURN ( Self )
