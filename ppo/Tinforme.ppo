#line 112 "hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 85 "\Fwh1204\Include\FiveWin.Ch"
   EXTERNAL GetProcAdd
   EXTERNAL TActiveX




extern errorsys
#line 10 ".\Prg\Tinforme.prg"
_HB_CLASS TInforme ; UTILITY FUNCTION TInforme(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "TInforme" , { HBObject():Classh } ) ) ;

   _HB_MEMBER {AS NUMERIC nDevice} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC",, nScope + IIF( .F., 32, 0 ), { "nDevice" }, .F., .F. ), )
   _HB_MEMBER { cTitle} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cTitle" }, .F., .F. ), )
   _HB_MEMBER { cSubTitle} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cSubTitle" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aDbfTmp} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aDbfTmp" }, .F., .F. ), )
   _HB_MEMBER { cIndex} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cIndex" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aStru} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aStru" }, .F., .F. ), )
   _HB_MEMBER { bRedefine} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bRedefine" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aCols} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aCols" }, .F., .F. ), )
   _HB_MEMBER { bFilter} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bFilter" }, .F., .F. ), )
   _HB_MEMBER { uFrom} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "uFrom" }, .F., .F. ), )
   _HB_MEMBER { uTo} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "uTo" }, .F., .F. ), )
   _HB_MEMBER {AS NUMERIC nSize} ; IIF( !.F., s_oClass:AddMultiData( "NUMERIC", 12, nScope + IIF( .F., 32, 0 ), { "nSize" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aOrd} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aOrd" }, .F., .F. ), )
   _HB_MEMBER { cAlias} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cAlias" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lOpen} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .F., nScope + IIF( .F., 32, 0 ), { "lOpen" }, .F., .F. ), )
   _HB_MEMBER {AS ARRAY aoCols} ; IIF( !.F., s_oClass:AddMultiData( "ARRAY", {}, nScope + IIF( .F., 32, 0 ), { "aoCols" }, .F., .F. ), )
   _HB_MEMBER { bHelp} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "bHelp" }, .F., .F. ), )
   _HB_MEMBER {AS OBJECT oIni} ; IIF( !.F., s_oClass:AddMultiData( "OBJECT",, nScope + IIF( .F., 32, 0 ), { "oIni" }, .F., .F. ), )
   _HB_MEMBER {AS LOGIC lSave2Exit} ; IIF( !.F., s_oClass:AddMultiData( "LOGIC", .T., nScope + IIF( .F., 32, 0 ), { "lSave2Exit" }, .F., .F. ), )

   _HB_MEMBER New( aoCols, aOrd, bHelp, cTitle, cSubTitle, uAlias) AS CLASS TInforme; IIF( .F., s_oClass:ModMethod( "New", @TInforme_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @TInforme_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Activate(); IIF( .F., s_oClass:ModMethod( "Activate", @TInforme_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Activate", @TInforme_Activate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Generate( nDevice); IIF( .F., s_oClass:ModMethod( "Generate", @TInforme_Generate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Generate", @TInforme_Generate(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER lResources(); IIF( .F., s_oClass:ModMethod( "lResources", @TInforme_lResources(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "lResources", @TInforme_lResources(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER ChgIndex(oCmb); IIF( .F., s_oClass:ModInline( "ChgIndex", {|Self,oCmb | Self, ( ::cAlias )->( OrdSetFocus( oCmb:nAt ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "ChgIndex", {|Self,oCmb | Self, ( ::cAlias )->( OrdSetFocus( oCmb:nAt ) ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER Redefine(); IIF( .F., s_oClass:ModInline( "Redefine", {|Self | Self, Eval( ::bRedefine, self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Redefine", {|Self | Self, Eval( ::bRedefine, self ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER UpColumn( oBrw); IIF( .F., s_oClass:ModMethod( "UpColumn", @TInforme_UpColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "UpColumn", @TInforme_UpColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER DwColumn( oBrw); IIF( .F., s_oClass:ModMethod( "DwColumn", @TInforme_DwColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "DwColumn", @TInforme_DwColumn(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Default(); IIF( .F., s_oClass:ModMethod( "Default", @TInforme_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Default", @TInforme_Default(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Save(); IIF( .F., s_oClass:ModMethod( "Save", @TInforme_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Save", @TInforme_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

   _HB_MEMBER Filter(); IIF( .F., s_oClass:ModInline( "Filter", {|Self | Self, msgInfo( "Filter" ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddInline( "Filter", {|Self | Self, msgInfo( "Filter" ) }, nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ) )

   _HB_MEMBER End(); IIF( .F., s_oClass:ModMethod( "End", @TInforme_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @TInforme_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS TInforme ;



UTILITY STATIC function TInforme_New( aoCols, aOrd, bHelp, cTitle, cSubTitle, uAlias, uAliasDet) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

   IIF( aoCols == nil, aoCols := {}, ) ;
   IIF( cTitle == nil, cTitle := "Titulo del informe", ) ;
   IIF( cSubTitle == nil, cSubTitle := "Subtitulo del informe", ) ;
   IIF( aOrd == nil, aOrd := {""}, ) ;
   IIF( uAlias == nil, uAlias := Alias(), ) ;
   IIF( bHelp == nil, bHelp := {|| msginfo( "No definida ayuda." ) }, ) ;

   ::aoCols          := aoCols
   ::cAlias          := if( Valtype( uAlias ) == "O", uAlias:cAlias, uAlias )
   ::aOrd            := aOrd
   ::cTitle          := cTitle
   ::cSubTitle       := cSubTitle
   ::bHelp           := bHelp





   ::Default()






RETURN Self



UTILITY STATIC function TInforme_Activate() ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme









RETURN ::Resources()



UTILITY STATIC function TInforme_End() ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

   if ::lSave2Exit
      ::Save()
   end

RETURN .T.



UTILITY STATIC function TInforme_lResources() ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

   local oDlg
   local oOrdCmb
   local cOrdCmb
   local oFrom
   local oTo
   local oSayFrom
   local uSayFrom    := ""
   local oSayTo
   local uSayTo      := ""
   local oBmp        := LoadBitmap( 0, 32760 )
   local oBrwCol

   ( ::cAlias )->( dbGoTop() )
   ::uFrom           := ( ::cAlias )->( OrdKeyVal() )
   ( ::cAlias )->( dbGoBottom() )
   ::uTo             := ( ::cAlias )->( OrdKeyVal() )
   ( ::cAlias )->( dbGoTop() )

   oDlg = TDialog():New(,,,,, "REP_STD",, .F.,,,,,, .F.,,,,,, .F., )




   oOrdCmb := TComboBox():ReDefine( 100, { | u | If( PCount()==0, cOrdCmb, cOrdCmb:= u ) }, ::aOrd, oDlg,,,,,,, .F.,,,,,, )

      oOrdCmb:bChange := {|| ::ChgIndex( oOrdCmb ) }




   oFrom := TGet():ReDefine( 110, { | u | If( PCount()==0, ::uFrom, ::uFrom:= u ) }, oDlg,,, {||    lRetFld( ::uFrom, ::cAlias, oSayFrom )},,,,,, .F.,,, .F., .F.,,,,,,, "::uFrom", )

      oFrom:bHelp := ::bHelp




   oSayFrom := TGet():ReDefine( 120, { | u | If( PCount()==0, uSayFrom, uSayFrom:= u ) }, oDlg,,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,,, "uSayFrom", )




   oTo := TGet():ReDefine( 130, { | u | If( PCount()==0, ::uTo, ::uTo:= u ) }, oDlg,,, {||    lRetFld( ::uTo, ::cAlias, oSayTo )},,,,,, .F.,,, .F., .F.,,,,,,, "::uTo", )

      oTo:bHelp   := ::bHelp




   oSayTo := TGet():ReDefine( 140, { | u | If( PCount()==0, uSayTo, uSayTo:= u ) }, oDlg,,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,,, "uSayTo", )








   TGet():ReDefine( 160, { | u | If( PCount()==0, ::nSize, ::nSize:= u ) }, oDlg,, "@E 99", {||    ::nSize >= 6 .AND. ::nSize <= 72},,,,,, .F.,,, .F., .T.,,, {||      6}, {||      72},,, "::nSize", )



   TGet():ReDefine( 170, { | u | If( PCount()==0, ::cTitle, ::cTitle:= u ) }, oDlg,,,,,,,,, .F.,,, .F., .F.,,,,,,, "::cTitle", )



   TGet():ReDefine( 180, { | u | If( PCount()==0, ::cSubTitle, ::cSubTitle:= u ) }, oDlg,,,,,,,,, .F.,,, .F., .F.,,,,,,, "::cSubTitle", )




   TCheckBox():ReDefine( 190, { | u | If( PCount()==0, ::lOpen, ::lOpen:= u ) }, oDlg,, {||( setSize( oDlg, ::lOpen ) )},,,,, .F.,, )



   TCheckBox():ReDefine( 191, { | u | If( PCount()==0, ::lSave2Exit, ::lSave2Exit:= u ) }, oDlg,,,,,,, .F.,, )










   oBrwCol := TWBrowse():ReDefine( 200, {|| { if( ::aoCols[ oBrwCol:nAt ]:lSelect, oBmp, "" ), ::aoCols[ oBrwCol:nAt ]:cTitle } }, oDlg, {"S", "Columna"}, {14, 40},,,,,,,,,,,, .F.,,,,, )

      oBrwCol:SetArray( ::aoCols )




   TButton():ReDefine( 538, {||::UpColumn( oBrwCol )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 539, {||::DwColumn( oBrwCol )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 514, {||( ::aoCols[ oBrwCol:nAt ]:Select(), oBrwCol:SetFocus(), oBrwCol:Refresh() )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 540, {||( ::aoCols[ oBrwCol:nAt ]:UnSelect(), oBrwCol:SetFocus(), oBrwCol:Refresh() )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 501, {||( ::aoCols[ oBrwCol:nAt ]:lEditCol(), oBrwCol:Refresh() )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 531, {||( ::Filter() )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 508, {||( ::Generate( 1 ) )}, oDlg,,, .F.,,,, .F. )




    TButton():ReDefine( 505, {||( ::Generate( 2 ) )}, oDlg,,, .F.,,,, .F. )




    TButton():ReDefine( 510, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   oDlg:bStart := {|| SetSize( oDlg, ::lOpen ), oFrom:lValid(), oTo:lValid() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   DeleteObject( oBmp )

RETURN ( oDlg:nResult == 1 )



static function lRetFld( uSearch, Alias, oSay, nFld )

   local lReturn  := .T.

   IIF( nFld == nil, nFld := 2, ) ;

   if valtype( uSearch ) == "C"
      uSearch     := Upper( uSearch )
   end

   if ( Alias )->( dbSeek( uSearch ) )
      oSay:cText( ( Alias )->( fieldGet( nFld ) ) )
   else
      msgStop( "Registro no encontrado" )
      lReturn     := .F.
   end

return lReturn



static function setSize( oDlg, lOpen )

   local aRect := GetWndRect( oDlg:hWnd )

   if lOpen
      oDlg:Move( aRect[1], aRect[2], 675, oDlg:nHeight, .T. )
   else
      oDlg:Move( aRect[1], aRect[2], 390, oDlg:nHeight, .T. )
   end

return nil






UTILITY STATIC function TInforme_Generate( nDevice) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

   local nFor
   local oFnt1
   local oFnt2
   local oReport

   ( ::cAlias )->( DbGoTop() )

   oFnt1 := TFont():New( "Arial", 0, - ( ::nSize ),, .T.,,,,,,,,,,,, )
   oFnt2 := TFont():New( "Arial", 0, - ( ::nSize ),,,,,,,,,,,,,, )

   IF nDevice == 1








      oReport := RptBegin({{||    Rtrim( ::cTitle    )}, {|| Rtrim( ::cSubTitle )}}, {{||   "Fecha : " + dtoc(date())}}, {{||     "Página : " + str( oReport:nPage, 3 )}}, {oFnt1, oFnt2}, {}, .F.,,,, .T.,,, Rtrim( ::cTitle ),, UPPER("RIGHT"), UPPER("CENTERED") )

   ELSE








      oReport := RptBegin({{||    Rtrim( ::cTitle    )}, {|| Rtrim( ::cSubTitle )}}, {{||   "Fecha : " + dtoc(date())}}, {{||     "Página : " + str( oReport:nPage, 3 )}}, {oFnt1, oFnt2}, {}, .F.,,, .T., .F.,,, Rtrim( ::cTitle ),, UPPER("RIGHT"), UPPER("CENTERED") )

   end

   for nFor := 1 to len( ::aoCols )

      if ::aoCols[ nFor ]:lSelect












         RptAddColumn(  { bHeaders( nFor, Self ) } , , { bFlds( nFor, Self ) } , ::aoCols[ nFor ]:nSize , { ::aoCols[ nFor ]:bPict } , {|| 2 } , ::aoCols[ nFor ]:lTotal , nil , nil , ::aoCols[ nFor ]:lSombra , ::aoCols[ nFor ]:lSeparador , nil )

      end

   next

   RptEnd()

   IF !Empty( oReport ) .AND.  oReport:lCreated
      oReport:Margin( 0, 2, 2)
      oReport:bSkip  := {|| ( ::cAlias )->( DbSkip( 1 ) ) }
   end




   oReport:Activate({||   ( ::cAlias )->( fieldGet( 1 ) ) >= ::uFrom .AND.  ( ::cAlias )->( fieldGet( 1 ) ) <= ::uTo}, {|| !( ::cAlias )->( eof() )},,,,,,,,,,,, )

   oFnt1:end()
   oFnt2:end()

RETURN NIL



static function bHeaders( nFor, Self )
return {|| ::aoCols[ nFor ]:cTitle }



static function bFlds( nFor, Self )

   if valType( ::aoCols[ nFor ] ) == "B"
      return ::aoCols[ nFor ]
   end

return ( ::aoCols[ nFor ]:bFld )



UTILITY STATIC function TInforme_UpColumn( oBrw) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

   local nPos  := oBrw:nAt

   if nPos <= len( ::aoCols ) .AND. nPos > 1

      SwapUpArray( ::aoCols, nPos )

      oBrw:GoUp()
      oBrw:Refresh()
      oBrw:SetFocus()

   end

return nil



UTILITY STATIC function TInforme_DwColumn( oBrw) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

   local nPos  := oBrw:nAt

   if nPos < len( ::aoCols ) .AND. nPos > 0

      SwapDwArray( ::aoCols, nPos )

      oBrw:GoDown()
      oBrw:Refresh()
      oBrw:SetFocus()

   end

return nil






UTILITY STATIC function TInforme_Default() ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme




























RETURN ( SELF )



UTILITY STATIC function TInforme_Save() ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

















RETURN ( SELF )
